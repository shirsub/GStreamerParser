<MACRO>
<NAME>GST_TYPE_AASINK</NAME>
#define GST_TYPE_AASINK \
  (gst_aasink_get_type())
</MACRO>
<MACRO>
<NAME>GST_AASINK</NAME>
#define GST_AASINK(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_AASINK,GstAASink))
</MACRO>
<MACRO>
<NAME>GST_AASINK_CLASS</NAME>
#define GST_AASINK_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_AASINK,GstAASinkClass))
</MACRO>
<MACRO>
<NAME>GST_IS_AASINK</NAME>
#define GST_IS_AASINK(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_AASINK))
</MACRO>
<MACRO>
<NAME>GST_IS_AASINK_CLASS</NAME>
#define GST_IS_AASINK_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_AASINK))
</MACRO>
<STRUCT>
<NAME>GstAASink</NAME>
struct _GstAASink {
  GstVideoSink parent;

  GstVideoInfo info;

  gint frames_displayed;
  guint64 frame_time;

  aa_context *context;
  struct aa_hardware_params ascii_surf;
  struct aa_renderparams ascii_parms;
  aa_palette palette;
  gint aa_driver;
};
</STRUCT>
<STRUCT>
<NAME>GstAASinkClass</NAME>
struct _GstAASinkClass {
  GstVideoSinkClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_aasink_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_CAIRO_OVERLAY</NAME>
#define GST_TYPE_CAIRO_OVERLAY \
  (gst_cairo_overlay_get_type())
</MACRO>
<MACRO>
<NAME>GST_CAIRO_OVERLAY</NAME>
#define GST_CAIRO_OVERLAY(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_CAIRO_OVERLAY,GstCairoOverlay))
</MACRO>
<MACRO>
<NAME>GST_CAIRO_OVERLAY_CLASS</NAME>
#define GST_CAIRO_OVERLAY_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_CAIRO_OVERLAY,GstCairoOverlayClass))
</MACRO>
<MACRO>
<NAME>GST_IS_CAIRO_OVERLAY</NAME>
#define GST_IS_CAIRO_OVERLAY(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_CAIRO_OVERLAY))
</MACRO>
<MACRO>
<NAME>GST_IS_CAIRO_OVERLAY_CLASS</NAME>
#define GST_IS_CAIRO_OVERLAY_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_CAIRO_OVERLAY))
</MACRO>
<STRUCT>
<NAME>GstCairoOverlay</NAME>
struct _GstCairoOverlay {
  GstVideoFilter video_filter;
};
</STRUCT>
<STRUCT>
<NAME>GstCairoOverlayClass</NAME>
struct _GstCairoOverlayClass {
  GstVideoFilterClass video_filter_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_cairo_overlay_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_DVDEC</NAME>
#define GST_TYPE_DVDEC \
  (gst_dvdec_get_type())
</MACRO>
<MACRO>
<NAME>GST_DVDEC</NAME>
#define GST_DVDEC(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_DVDEC,GstDVDec))
</MACRO>
<MACRO>
<NAME>GST_DVDEC_CLASS</NAME>
#define GST_DVDEC_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_DVDEC,GstDVDecClass))
</MACRO>
<MACRO>
<NAME>GST_IS_DVDEC</NAME>
#define GST_IS_DVDEC(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_DVDEC))
</MACRO>
<MACRO>
<NAME>GST_IS_DVDEC_CLASS</NAME>
#define GST_IS_DVDEC_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_DVDEC))
</MACRO>
<STRUCT>
<NAME>GstDVDec</NAME>
struct _GstDVDec {
  GstElement     element;

  GstPad        *sinkpad;
  GstPad        *srcpad;

  dv_decoder_t  *decoder;
  gboolean       clamp_luma;
  gboolean       clamp_chroma;
  gint           quality;

  gboolean       PAL;
  gboolean       interlaced;
  gboolean       wide;

  /* input caps */
  gboolean       sink_negotiated;
  GstVideoInfo   vinfo;
  gint           framerate_numerator;
  gint           framerate_denominator;
  gint           height;
  gint           par_x;
  gint           par_y;
  gboolean       need_par;

  /* negotiated output */
  gint           bpp;
  gboolean       src_negotiated;
  
  gint           video_offset;
  gint           drop_factor;

  GstBufferPool *pool;
  GstSegment     segment;
  gboolean       need_segment;
};
</STRUCT>
<STRUCT>
<NAME>GstDVDecClass</NAME>
struct _GstDVDecClass {
  GstElementClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_dvdec_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_DVDEMUX</NAME>
#define GST_TYPE_DVDEMUX \
  (gst_dvdemux_get_type())
</MACRO>
<MACRO>
<NAME>GST_DVDEMUX</NAME>
#define GST_DVDEMUX(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_DVDEMUX,GstDVDemux))
</MACRO>
<MACRO>
<NAME>GST_DVDEMUX_CLASS</NAME>
#define GST_DVDEMUX_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_DVDEMUX,GstDVDemuxClass))
</MACRO>
<MACRO>
<NAME>GST_IS_DVDEMUX</NAME>
#define GST_IS_DVDEMUX(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_DVDEMUX))
</MACRO>
<MACRO>
<NAME>GST_IS_DVDEMUX_CLASS</NAME>
#define GST_IS_DVDEMUX_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_DVDEMUX))
</MACRO>
<USER_FUNCTION>
<NAME>GstDVDemuxSeekHandler</NAME>
<RETURNS>gboolean </RETURNS>
GstDVDemux *demux, GstPad * pad, GstEvent * event
</USER_FUNCTION>
<STRUCT>
<NAME>GstDVDemux</NAME>
struct _GstDVDemux {
  GstElement     element;

  GstPad        *sinkpad;
  GstPad        *videosrcpad;
  GstPad        *audiosrcpad;

  gboolean       have_group_id;
  guint          group_id;

  dv_decoder_t  *decoder;

  GstAdapter    *adapter;
  gint           frame_len;

  /* video params */
  gint           framerate_numerator;
  gint           framerate_denominator;
  gint           height;
  gboolean       wide;
  /* audio params */
  gint           frequency;
  gint           channels;

  gboolean       discont;
  gint64         frame_offset;
  gint64         audio_offset;
  gint64         video_offset;

  GstDVDemuxSeekHandler seek_handler;
  GstSegment     byte_segment;
  gboolean       upstream_time_segment;
  GstSegment     time_segment;
  gboolean       need_segment;
  guint32        segment_seqnum;
  gboolean       new_media;
  int            frames_since_new_media;
  
  gint           found_header; /* ATOMIC */
  GstEvent      *seek_event;
  GstEvent	*pending_segment;

  gint16        *audio_buffers[4];
};
</STRUCT>
<STRUCT>
<NAME>GstDVDemuxClass</NAME>
struct _GstDVDemuxClass {
  GstElementClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_dvdemux_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_FLAC_DEC</NAME>
#define GST_TYPE_FLAC_DEC gst_flac_dec_get_type()
</MACRO>
<MACRO>
<NAME>GST_FLAC_DEC</NAME>
#define GST_FLAC_DEC(obj) G_TYPE_CHECK_INSTANCE_CAST(obj, GST_TYPE_FLAC_DEC, GstFlacDec)
</MACRO>
<MACRO>
<NAME>GST_FLAC_DEC_CLASS</NAME>
#define GST_FLAC_DEC_CLASS(klass) G_TYPE_CHECK_CLASS_CAST(klass, GST_TYPE_FLAC_DEC, GstFlacDecClass)
</MACRO>
<MACRO>
<NAME>GST_IS_FLAC_DEC</NAME>
#define GST_IS_FLAC_DEC(obj) G_TYPE_CHECK_INSTANCE_TYPE(obj, GST_TYPE_FLAC_DEC)
</MACRO>
<MACRO>
<NAME>GST_IS_FLAC_DEC_CLASS</NAME>
#define GST_IS_FLAC_DEC_CLASS(klass) G_TYPE_CHECK_CLASS_TYPE(klass, GST_TYPE_FLAC_DEC)
</MACRO>
<STRUCT>
<NAME>GstFlacDec</NAME>
struct _GstFlacDec {
  GstAudioDecoder  audiodecoder;

  /*< private >*/
  FLAC__StreamDecoder         *decoder;
  GstAdapter                  *adapter;

  gboolean       got_headers; /* have we received all the header buffers yet? */

  GstFlowReturn  last_flow;   /* to marshal flow return from finis_frame to
                               * handle_frame via flac callbacks */

  GstAudioInfo   info;
  gint           channel_reorder_map[8];
  gint           depth;

  /* from the stream info, needed for scanning */
  guint16        min_blocksize;
  guint16        max_blocksize;

  gint           error_count;
};
</STRUCT>
<STRUCT>
<NAME>GstFlacDecClass</NAME>
struct _GstFlacDecClass {
  GstAudioDecoderClass  audiodecoder;
};
</STRUCT>
<FUNCTION>
<NAME>gst_flac_dec_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_FLAC_ENC</NAME>
#define GST_TYPE_FLAC_ENC (gst_flac_enc_get_type())
</MACRO>
<MACRO>
<NAME>GST_FLAC_ENC</NAME>
#define GST_FLAC_ENC(obj) G_TYPE_CHECK_INSTANCE_CAST(obj, GST_TYPE_FLAC_ENC, GstFlacEnc)
</MACRO>
<MACRO>
<NAME>GST_FLAC_ENC_CLASS</NAME>
#define GST_FLAC_ENC_CLASS(klass) G_TYPE_CHECK_CLASS_CAST(klass, GST_TYPE_FLAC_ENC, GstFlacEncClass)
</MACRO>
<MACRO>
<NAME>GST_IS_FLAC_ENC</NAME>
#define GST_IS_FLAC_ENC(obj) G_TYPE_CHECK_INSTANCE_TYPE(obj, GST_TYPE_FLAC_ENC)
</MACRO>
<MACRO>
<NAME>GST_IS_FLAC_ENC_CLASS</NAME>
#define GST_IS_FLAC_ENC_CLASS(klass) G_TYPE_CHECK_CLASS_TYPE(klass, GST_TYPE_FLAC_ENC)
</MACRO>
<STRUCT>
<NAME>GstFlacEnc</NAME>
struct _GstFlacEnc {
  GstAudioEncoder  element;

  /* < private > */

  GstFlowReturn  last_flow; /* save flow from last push so we can pass the
                             * correct flow return upstream in case the push
                             * fails for some reason */

  guint64        offset;
  gint           quality;
  gboolean       stopped;
  guint           padding;
  gint            seekpoints;

  FLAC__StreamEncoder *encoder;

  FLAC__StreamMetadata **meta;

  GstTagList *     tags;
  GstToc *         toc;

  guint64          samples_in;
  guint64          samples_out;
  gboolean         eos;
  /* queue headers until we have them all so we can add streamheaders to caps */
  gboolean         got_headers;
  GList           *headers;

  gint             channel_reorder_map[8];
};
</STRUCT>
<STRUCT>
<NAME>GstFlacEncClass</NAME>
struct _GstFlacEncClass {
  GstAudioEncoderClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_flac_enc_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_FLAC_TAG</NAME>
#define GST_TYPE_FLAC_TAG (gst_flac_tag_get_type())
</MACRO>
<MACRO>
<NAME>GST_FLAC_TAG</NAME>
#define GST_FLAC_TAG(obj) (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_FLAC_TAG, GstFlacTag))
</MACRO>
<MACRO>
<NAME>GST_FLAC_TAG_CLASS</NAME>
#define GST_FLAC_TAG_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_FLAC_TAG, GstFlacTag))
</MACRO>
<MACRO>
<NAME>GST_IS_FLAC_TAG</NAME>
#define GST_IS_FLAC_TAG(obj) (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_FLAC_TAG))
</MACRO>
<MACRO>
<NAME>GST_IS_FLAC_TAG_CLASS</NAME>
#define GST_IS_FLAC_TAG_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_FLAC_TAG))
</MACRO>
<ENUM>
<NAME>GstFlacTagState</NAME>
typedef enum
{
  GST_FLAC_TAG_STATE_INIT,
  GST_FLAC_TAG_STATE_METADATA_BLOCKS,
  GST_FLAC_TAG_STATE_METADATA_NEXT_BLOCK,
  GST_FLAC_TAG_STATE_WRITING_METADATA_BLOCK,
  GST_FLAC_TAG_STATE_VC_METADATA_BLOCK,
  GST_FLAC_TAG_STATE_ADD_VORBIS_COMMENT,
  GST_FLAC_TAG_STATE_AUDIO_DATA
}
GstFlacTagState;
</ENUM>
<STRUCT>
<NAME>GstFlacTag</NAME>
struct _GstFlacTag
{
  GstElement element;

  /* < private > */

  /* pads */
  GstPad *sinkpad;
  GstPad *srcpad;

  GstFlacTagState state;

  GstAdapter *adapter;
  GstBuffer *vorbiscomment;
  GstTagList *tags;

  guint metadata_block_size;
  gboolean metadata_last_block;
};
</STRUCT>
<STRUCT>
<NAME>GstFlacTagClass</NAME>
struct _GstFlacTagClass
{
  GstElementClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_flac_tag_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_GDK_PIXBUF_SINK</NAME>
#define GST_TYPE_GDK_PIXBUF_SINK            (gst_gdk_pixbuf_sink_get_type())
</MACRO>
<MACRO>
<NAME>GST_GDK_PIXBUF_SINK</NAME>
#define GST_GDK_PIXBUF_SINK(obj)            (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_GDK_PIXBUF_SINK,GstGdkPixbufSink))
</MACRO>
<MACRO>
<NAME>GST_GDK_PIXBUF_SINK_CLASS</NAME>
#define GST_GDK_PIXBUF_SINK_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_GDK_PIXBUF_SINK,GstGdkPixbufSinkClass))
</MACRO>
<MACRO>
<NAME>GST_IS_GDK_PIXBUF_SINK</NAME>
#define GST_IS_GDK_PIXBUF_SINK(obj)         (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_GDK_PIXBUF_SINK))
</MACRO>
<MACRO>
<NAME>GST_IS_GDK_PIXBUF_SINK_CLASS</NAME>
#define GST_IS_GDK_PIXBUF_SINK_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_GDK_PIXBUF_SINK))
</MACRO>
<STRUCT>
<NAME>GstGdkPixbufSink</NAME>
struct _GstGdkPixbufSink
{
  GstVideoSink  basesink;

  /*< private >*/

  /* current caps */
  GstVideoInfo info;
  gint         width;
  gint         height;
  gint         par_n;
  gint         par_d;
  gboolean     has_alpha;

  /* properties */
  gboolean     post_messages;
  GdkPixbuf  * last_pixbuf;
};
</STRUCT>
<STRUCT>
<NAME>GstGdkPixbufSinkClass</NAME>
struct _GstGdkPixbufSinkClass 
{
  GstVideoSinkClass  basesinkclass;
};
</STRUCT>
<FUNCTION>
<NAME>gst_gdk_pixbuf_sink_get_type</NAME>
<RETURNS>GType    </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_JACK_AUDIO_SRC</NAME>
#define GST_TYPE_JACK_AUDIO_SRC             (gst_jack_audio_src_get_type())
</MACRO>
<MACRO>
<NAME>GST_JACK_AUDIO_SRC</NAME>
#define GST_JACK_AUDIO_SRC(obj)             (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_JACK_AUDIO_SRC,GstJackAudioSrc))
</MACRO>
<MACRO>
<NAME>GST_JACK_AUDIO_SRC_CLASS</NAME>
#define GST_JACK_AUDIO_SRC_CLASS(klass)     (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_JACK_AUDIO_SRC,GstJackAudioSrcClass))
</MACRO>
<MACRO>
<NAME>GST_JACK_AUDIO_SRC_GET_CLASS</NAME>
#define GST_JACK_AUDIO_SRC_GET_CLASS(obj)   (G_TYPE_INSTANCE_GET_CLASS ((obj),GST_TYPE_JACK_AUDIO_SRC,GstJackAudioSrcClass))
</MACRO>
<MACRO>
<NAME>GST_IS_JACK_AUDIO_SRC</NAME>
#define GST_IS_JACK_AUDIO_SRC(obj)          (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_JACK_AUDIO_SRC))
</MACRO>
<MACRO>
<NAME>GST_IS_JACK_AUDIO_SRC_CLASS</NAME>
#define GST_IS_JACK_AUDIO_SRC_CLASS(klass)  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_JACK_AUDIO_SRC))
</MACRO>
<STRUCT>
<NAME>GstJackAudioSrc</NAME>
struct _GstJackAudioSrc
{
    GstAudioBaseSrc src;

    /*< private >*/
    /* cached caps */
    GstCaps         *caps;

    /* properties */
    GstJackConnect   connect;
    gchar           *server;
    jack_client_t   *jclient;
    gchar           *client_name;
    gchar           *port_pattern;
    guint            transport;

    /* our client */
    GstJackAudioClient *client;

    /* our ports */
    jack_port_t    **ports;
    int port_count;
    sample_t **buffers;
};
</STRUCT>
<STRUCT>
<NAME>GstJackAudioSrcClass</NAME>
struct _GstJackAudioSrcClass
{
    GstAudioBaseSrcClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_jack_audio_src_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_JACK_AUDIO_SINK</NAME>
#define GST_TYPE_JACK_AUDIO_SINK             (gst_jack_audio_sink_get_type())
</MACRO>
<MACRO>
<NAME>GST_JACK_AUDIO_SINK</NAME>
#define GST_JACK_AUDIO_SINK(obj)             (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_JACK_AUDIO_SINK,GstJackAudioSink))
</MACRO>
<MACRO>
<NAME>GST_JACK_AUDIO_SINK_CLASS</NAME>
#define GST_JACK_AUDIO_SINK_CLASS(klass)     (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_JACK_AUDIO_SINK,GstJackAudioSinkClass))
</MACRO>
<MACRO>
<NAME>GST_JACK_AUDIO_SINK_GET_CLASS</NAME>
#define GST_JACK_AUDIO_SINK_GET_CLASS(obj)   (G_TYPE_INSTANCE_GET_CLASS ((obj),GST_TYPE_JACK_AUDIO_SINK,GstJackAudioSinkClass))
</MACRO>
<MACRO>
<NAME>GST_IS_JACK_AUDIO_SINK</NAME>
#define GST_IS_JACK_AUDIO_SINK(obj)          (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_JACK_AUDIO_SINK))
</MACRO>
<MACRO>
<NAME>GST_IS_JACK_AUDIO_SINK_CLASS</NAME>
#define GST_IS_JACK_AUDIO_SINK_CLASS(klass)  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_JACK_AUDIO_SINK))
</MACRO>
<STRUCT>
<NAME>GstJackAudioSink</NAME>
struct _GstJackAudioSink {
  GstAudioBaseSink element;

  /*< private >*/
  /* cached caps */
  GstCaps         *caps;

  /* properties */
  GstJackConnect   connect;
  gchar           *server;
  jack_client_t   *jclient;
  gchar           *client_name;
  gchar           *port_pattern;
  guint            transport;

  /* our client */
  GstJackAudioClient *client;

  /* our ports */
  jack_port_t    **ports;
  int              port_count;
  sample_t       **buffers;
};
</STRUCT>
<STRUCT>
<NAME>GstJackAudioSinkClass</NAME>
struct _GstJackAudioSinkClass {
  GstAudioBaseSinkClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_jack_audio_sink_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_JPEG_DEC</NAME>
#define GST_TYPE_JPEG_DEC \
  (gst_jpeg_dec_get_type())
</MACRO>
<MACRO>
<NAME>GST_JPEG_DEC</NAME>
#define GST_JPEG_DEC(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_JPEG_DEC,GstJpegDec))
</MACRO>
<MACRO>
<NAME>GST_JPEG_DEC_CLASS</NAME>
#define GST_JPEG_DEC_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_JPEG_DEC,GstJpegDecClass))
</MACRO>
<MACRO>
<NAME>GST_IS_JPEG_DEC</NAME>
#define GST_IS_JPEG_DEC(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_JPEG_DEC))
</MACRO>
<MACRO>
<NAME>GST_IS_JPEG_DEC_CLASS</NAME>
#define GST_IS_JPEG_DEC_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_JPEG_DEC))
</MACRO>
<STRUCT>
<NAME>GstJpegDecErrorMgr</NAME>
struct GstJpegDecErrorMgr {
  struct jpeg_error_mgr    pub;   /* public fields */
  jmp_buf                  setjmp_buffer;
};
</STRUCT>
<STRUCT>
<NAME>GstJpegDecSourceMgr</NAME>
struct GstJpegDecSourceMgr {
  struct jpeg_source_mgr   pub;   /* public fields */
  GstJpegDec              *dec;
};
</STRUCT>
<STRUCT>
<NAME>GstJpegDec</NAME>
struct _GstJpegDec {
  GstVideoDecoder decoder;

  /* negotiated state */
  GstVideoCodecState *input_state;
  GstVideoCodecFrame *current_frame;
  GstMapInfo current_frame_map;

  /* parse state */
  gboolean saw_header;
  gint     parse_entropy_len;
  gint     parse_resync;

  /* properties */
  gint     idct_method;
  gint     max_errors;  /* ATOMIC */

  struct jpeg_decompress_struct cinfo;
  struct GstJpegDecErrorMgr     jerr;
  struct GstJpegDecSourceMgr    jsrc;

  /* arrays for indirect decoding */
  gboolean idr_width_allocated;
  guchar *idr_y[16],*idr_u[16],*idr_v[16];
  /* current (parsed) image size */
  guint    rem_img_len;
};
</STRUCT>
<STRUCT>
<NAME>GstJpegDecClass</NAME>
struct _GstJpegDecClass {
  GstVideoDecoderClass decoder_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_jpeg_dec_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_JPEGENC</NAME>
#define GST_TYPE_JPEGENC \
  (gst_jpegenc_get_type())
</MACRO>
<MACRO>
<NAME>GST_JPEGENC</NAME>
#define GST_JPEGENC(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_JPEGENC,GstJpegEnc))
</MACRO>
<MACRO>
<NAME>GST_JPEGENC_CLASS</NAME>
#define GST_JPEGENC_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_JPEGENC,GstJpegEncClass))
</MACRO>
<MACRO>
<NAME>GST_IS_JPEGENC</NAME>
#define GST_IS_JPEGENC(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_JPEGENC))
</MACRO>
<MACRO>
<NAME>GST_IS_JPEGENC_CLASS</NAME>
#define GST_IS_JPEGENC_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_JPEGENC))
</MACRO>
<STRUCT>
<NAME>GstJpegEnc</NAME>
struct _GstJpegEnc
{
  GstVideoEncoder encoder;

  GstVideoCodecState *input_state;
  GstVideoFrame current_vframe;
  GstVideoCodecFrame *current_frame;
  GstFlowReturn res;

  guint channels;

  gint inc[GST_VIDEO_MAX_COMPONENTS];
  gint cwidth[GST_VIDEO_MAX_COMPONENTS];
  gint cheight[GST_VIDEO_MAX_COMPONENTS];
  gint h_samp[GST_VIDEO_MAX_COMPONENTS];
  gint v_samp[GST_VIDEO_MAX_COMPONENTS];
  gint h_max_samp;
  gint v_max_samp;
  gboolean planar;
  gint sof_marker;
  /* the video buffer */
  gint bufsize;
  /* the jpeg line buffer */
  guchar **line[3];
  /* indirect encoding line buffers */
  guchar *row[3][4 * DCTSIZE];

  struct jpeg_compress_struct cinfo;
  struct jpeg_error_mgr jerr;
  struct jpeg_destination_mgr jdest;

  /* properties */
  gint quality;
  gint smoothing;
  gint idct_method;

  GstMemory *output_mem;
  GstMapInfo output_map;
};
</STRUCT>
<STRUCT>
<NAME>GstJpegEncClass</NAME>
struct _GstJpegEncClass
{
  GstVideoEncoderClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_jpegenc_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_CACASINK</NAME>
#define GST_TYPE_CACASINK \
  (gst_cacasink_get_type())
</MACRO>
<MACRO>
<NAME>GST_CACASINK</NAME>
#define GST_CACASINK(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_CACASINK,GstCACASink))
</MACRO>
<MACRO>
<NAME>GST_CACASINK_CLASS</NAME>
#define GST_CACASINK_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_CACASINK,GstCACASinkClass))
</MACRO>
<MACRO>
<NAME>GST_IS_CACASINK</NAME>
#define GST_IS_CACASINK(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_CACASINK))
</MACRO>
<MACRO>
<NAME>GST_IS_CACASINK_CLASS</NAME>
#define GST_IS_CACASINK_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_CACASINK))
</MACRO>
<STRUCT>
<NAME>GstCACASink</NAME>
struct _GstCACASink {
  GstBaseSink parent;

  GstVideoInfo info;
  gint screen_width, screen_height;

  guint dither;
  gboolean antialiasing;

  struct caca_bitmap *bitmap;
};
</STRUCT>
<STRUCT>
<NAME>GstCACASinkClass</NAME>
struct _GstCACASinkClass {
  GstBaseSinkClass parent_class;

  /* signals */
};
</STRUCT>
<FUNCTION>
<NAME>gst_cacasink_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_PNGDEC</NAME>
#define GST_TYPE_PNGDEC (gst_pngdec_get_type())
</MACRO>
<MACRO>
<NAME>GST_PNGDEC</NAME>
#define GST_PNGDEC(obj) (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_PNGDEC,GstPngDec))
</MACRO>
<MACRO>
<NAME>GST_PNGDEC_CLASS</NAME>
#define GST_PNGDEC_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_PNGDEC,GstPngDecClass))
</MACRO>
<MACRO>
<NAME>GST_IS_PNGDEC</NAME>
#define GST_IS_PNGDEC(obj) (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_PNGDEC))
</MACRO>
<MACRO>
<NAME>GST_IS_PNGDEC_CLASS</NAME>
#define GST_IS_PNGDEC_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_PNGDEC))
</MACRO>
<STRUCT>
<NAME>GstPngDec</NAME>
struct _GstPngDec
{
  GstVideoDecoder parent;

  GstVideoCodecState *input_state;
  GstVideoCodecState *output_state;
  GstMapInfo current_frame_map;
  GstVideoCodecFrame *current_frame;

  GstFlowReturn ret;

  png_structp png;
  png_infop info;
  png_infop endinfo;

  gint color_type;

  gboolean image_ready;
  gsize read_data;
};
</STRUCT>
<STRUCT>
<NAME>GstPngDecClass</NAME>
struct _GstPngDecClass
{
  GstVideoDecoderClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_pngdec_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_PNGENC</NAME>
#define GST_TYPE_PNGENC            (gst_pngenc_get_type())
</MACRO>
<MACRO>
<NAME>GST_PNGENC</NAME>
#define GST_PNGENC(obj)            (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_PNGENC,GstPngEnc))
</MACRO>
<MACRO>
<NAME>GST_PNGENC_CLASS</NAME>
#define GST_PNGENC_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_PNGENC,GstPngEncClass))
</MACRO>
<MACRO>
<NAME>GST_IS_PNGENC</NAME>
#define GST_IS_PNGENC(obj)         (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_PNGENC))
</MACRO>
<MACRO>
<NAME>GST_IS_PNGENC_CLASS</NAME>
#define GST_IS_PNGENC_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_PNGENC))
</MACRO>
<STRUCT>
<NAME>GstPngEnc</NAME>
struct _GstPngEnc
{
  GstVideoEncoder parent;

  GstVideoCodecState *input_state;
  GstBuffer *buffer_out;

  png_structp png_struct_ptr;
  png_infop png_info_ptr;

  gint png_color_type;
  gint depth;
  guint compression_level;

  gboolean snapshot;
  gboolean newmedia;
};
</STRUCT>
<STRUCT>
<NAME>GstPngEncClass</NAME>
struct _GstPngEncClass
{
  GstVideoEncoderClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_pngenc_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_DV1394SRC</NAME>
#define GST_TYPE_DV1394SRC \
  (gst_dv1394src_get_type())
</MACRO>
<MACRO>
<NAME>GST_DV1394SRC</NAME>
#define GST_DV1394SRC(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_DV1394SRC,GstDV1394Src))
</MACRO>
<MACRO>
<NAME>GST_DV1394SRC_CLASS</NAME>
#define GST_DV1394SRC_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_DV1394SRC,GstDV1394SrcClass))
</MACRO>
<MACRO>
<NAME>GST_IS_DV1394SRC</NAME>
#define GST_IS_DV1394SRC(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_DV1394SRC))
</MACRO>
<MACRO>
<NAME>GST_IS_DV1394SRC_CLASS</NAME>
#define GST_IS_DV1394SRC_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_DV1394SRC))
</MACRO>
<STRUCT>
<NAME>GstDV1394Src</NAME>
struct _GstDV1394Src {
  GstPushSrc element;

  // consecutive=2, skip=4 will skip 4 frames, then let 2 consecutive ones thru
  gint consecutive;
  gint skip;
  gboolean drop_incomplete;

  gint num_ports;
  gint port;
  gint channel;
  octlet_t guid;
  gint avc_node;
  gboolean use_avc;

  struct raw1394_portinfo pinfo[16];
  raw1394handle_t handle;

  GstBuffer *buf;
  
  GstBuffer *frame;
  guint frame_size;
  guint frame_rate;
  guint bytes_in_frame;
  guint frame_sequence;

  int control_sock[2];

  gchar *uri;

  gchar *device_name;

  gboolean connected;
  #ifdef HAVE_LIBIEC61883
  iec61883_dv_fb_t iec61883dv;
  #endif

  Gst1394Clock *provided_clock;
};
</STRUCT>
<STRUCT>
<NAME>GstDV1394SrcClass</NAME>
struct _GstDV1394SrcClass {
  GstPushSrcClass parent_class;

  /* signal */
  void (*frame_dropped)  (GstElement *elem);
};
</STRUCT>
<FUNCTION>
<NAME>gst_dv1394src_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_HDV1394SRC</NAME>
#define GST_TYPE_HDV1394SRC \
  (gst_hdv1394src_get_type())
</MACRO>
<MACRO>
<NAME>GST_HDV1394SRC</NAME>
#define GST_HDV1394SRC(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_HDV1394SRC,GstHDV1394Src))
</MACRO>
<MACRO>
<NAME>GST_HDV1394SRC_CLASS</NAME>
#define GST_HDV1394SRC_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_HDV1394SRC,GstHDV1394SrcClass))
</MACRO>
<MACRO>
<NAME>GST_IS_HDV1394SRC</NAME>
#define GST_IS_HDV1394SRC(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_HDV1394SRC))
</MACRO>
<MACRO>
<NAME>GST_IS_HDV1394SRC_CLASS</NAME>
#define GST_IS_HDV1394SRC_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_HDV1394SRC))
</MACRO>
<STRUCT>
<NAME>GstHDV1394Src</NAME>
struct _GstHDV1394Src {
  GstPushSrc element;

  gint num_ports;
  gint port;
  gint channel;
  octlet_t guid;
  gint avc_node;
  gboolean use_avc;

  struct raw1394_portinfo pinfo[16];
  raw1394handle_t handle;

  gpointer outdata;
  gsize outoffset;
  guint frame_size;
  guint frame_sequence;

  int control_sock[2];

  gchar *uri;

  gchar *device_name;

  gboolean connected;
  iec61883_mpeg2_t iec61883mpeg2;
};
</STRUCT>
<STRUCT>
<NAME>GstHDV1394SrcClass</NAME>
struct _GstHDV1394SrcClass {
  GstPushSrcClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_hdv1394src_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<ENUM>
<NAME>GstShout2SendProtocol</NAME>
typedef enum {
  SHOUT2SEND_PROTOCOL_XAUDIOCAST = 1,
  SHOUT2SEND_PROTOCOL_ICY,
  SHOUT2SEND_PROTOCOL_HTTP
} GstShout2SendProtocol;
</ENUM>
<STRUCT>
<NAME>GstShout2send</NAME>
struct _GstShout2send {
  GstBaseSink parent;

  GstShout2SendProtocol protocol;

  GstPoll *timer;

  shout_t *conn;

  gchar *ip;
  guint port;
  gchar *password;
  gchar *username;
  gchar *streamname;
  gchar *description;
  gchar *genre;
  gchar *mount;
  gchar *url;
  gboolean connected;
  gboolean ispublic;
  gchar *songmetadata;
  gchar *songartist;
  gchar *songtitle;
  int    format;

  GstTagList* tags;
};
</STRUCT>
<STRUCT>
<NAME>GstShout2sendClass</NAME>
struct _GstShout2sendClass {
  GstBaseSinkClass parent_class;

  /* signal callbacks */
  void (*connection_problem) (GstElement *element,guint errno);
};
</STRUCT>
<MACRO>
<NAME>GST_TYPE_SHOUT2SEND</NAME>
#define GST_TYPE_SHOUT2SEND \
  (gst_shout2send_get_type())
</MACRO>
<MACRO>
<NAME>GST_SHOUT2SEND</NAME>
#define GST_SHOUT2SEND(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_SHOUT2SEND,GstShout2send))
</MACRO>
<MACRO>
<NAME>GST_SHOUT2SEND_CLASS</NAME>
#define GST_SHOUT2SEND_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_SHOUT2SEND,GstShout2sendClass))
</MACRO>
<MACRO>
<NAME>GST_IS_SHOUT2SEND</NAME>
#define GST_IS_SHOUT2SEND(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_SHOUT2SEND))
</MACRO>
<MACRO>
<NAME>GST_IS_SHOUT2SEND_CLASS</NAME>
#define GST_IS_SHOUT2SEND_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_SHOUT2SEND))
</MACRO>
<FUNCTION>
<NAME>gst_shout2send_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_SOUP_HTTP_SRC</NAME>
#define GST_TYPE_SOUP_HTTP_SRC \
  (gst_soup_http_src_get_type())
</MACRO>
<MACRO>
<NAME>GST_SOUP_HTTP_SRC</NAME>
#define GST_SOUP_HTTP_SRC(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_SOUP_HTTP_SRC,GstSoupHTTPSrc))
</MACRO>
<MACRO>
<NAME>GST_SOUP_HTTP_SRC_CLASS</NAME>
#define GST_SOUP_HTTP_SRC_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass), \
      GST_TYPE_SOUP_HTTP_SRC,GstSoupHTTPSrcClass))
</MACRO>
<MACRO>
<NAME>GST_IS_SOUP_HTTP_SRC</NAME>
#define GST_IS_SOUP_HTTP_SRC(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_SOUP_HTTP_SRC))
</MACRO>
<MACRO>
<NAME>GST_IS_SOUP_HTTP_SRC_CLASS</NAME>
#define GST_IS_SOUP_HTTP_SRC_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_SOUP_HTTP_SRC))
</MACRO>
<ENUM>
<NAME>GstSoupHTTPSrcSessionIOStatus</NAME>
typedef enum {
  GST_SOUP_HTTP_SRC_SESSION_IO_STATUS_IDLE,
  GST_SOUP_HTTP_SRC_SESSION_IO_STATUS_QUEUED,
  GST_SOUP_HTTP_SRC_SESSION_IO_STATUS_RUNNING,
  GST_SOUP_HTTP_SRC_SESSION_IO_STATUS_CANCELLED,
} GstSoupHTTPSrcSessionIOStatus;
</ENUM>
<STRUCT>
<NAME>GstSoupHTTPSrc</NAME>
struct _GstSoupHTTPSrc {
  GstPushSrc element;

  gchar *location;             /* Full URI. */
  gchar *redirection_uri;      /* Full URI after redirections. */
  gboolean redirection_permanent; /* Permanent or temporary redirect? */
  gchar *user_agent;           /* User-Agent HTTP header. */
  gboolean automatic_redirect; /* Follow redirects. */
  SoupURI *proxy;              /* HTTP proxy URI. */
  gchar *user_id;              /* Authentication user id for location URI. */
  gchar *user_pw;              /* Authentication user password for location URI. */
  gchar *proxy_id;             /* Authentication user id for proxy URI. */
  gchar *proxy_pw;             /* Authentication user password for proxy URI. */
  gchar **cookies;             /* HTTP request cookies. */
  SoupSession *session;        /* Async context. */
  SoupMessage *msg;            /* Request message. */
  gint retry_count;            /* Number of retries since we received data */
  gint max_retries;            /* Maximum number of retries */
  gchar *method;               /* HTTP method */

  gboolean got_headers;        /* Already received headers from the server */
  gboolean have_size;          /* Received and parsed Content-Length
                                  header. */
  guint64 content_size;        /* Value of Content-Length header. */
  guint64 read_position;       /* Current position. */
  gboolean seekable;           /* FALSE if the server does not support
                                  Range. */
  guint64 request_position;    /* Seek to this position. */
  guint64 stop_position;       /* Stop at this position. */
  gboolean have_body;          /* Indicates if it has just been signaled the
                                * end of the message body. This is used to
                                * decide if an out of range request should be
                                * handled as an error or EOS when the content
                                * size is unknown */
  gboolean keep_alive;         /* Use keep-alive sessions */
  gboolean ssl_strict;
  gchar *ssl_ca_file;
  gboolean ssl_use_system_ca_file;
  GTlsDatabase *tls_database;
  GTlsInteraction *tls_interaction;

  GCancellable *cancellable;
  GInputStream *input_stream;

  gint reduce_blocksize_count;
  gint increase_blocksize_count;
  guint minimum_blocksize;

  /* Shoutcast/icecast metadata extraction handling. */
  gboolean iradio_mode;
  GstCaps *src_caps;
  gchar *iradio_name;
  gchar *iradio_genre;
  gchar *iradio_url;

  GstStructure *extra_headers;

  SoupLoggerLogLevel log_level;/* Soup HTTP session logger level */

  gboolean compress;

  guint timeout;

  GMutex mutex;
  GCond have_headers_cond;

  GstEvent *http_headers_event;
};
</STRUCT>
<STRUCT>
<NAME>GstSoupHTTPSrcClass</NAME>
struct _GstSoupHTTPSrcClass {
  GstPushSrcClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_soup_http_src_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<STRUCT>
<NAME>GstApev2Mux</NAME>
struct _GstApev2Mux {
  GstTagMux  tagmux;
};
</STRUCT>
<STRUCT>
<NAME>GstApev2MuxClass</NAME>
struct _GstApev2MuxClass {
  GstTagMuxClass  tagmux_class;
};
</STRUCT>
<MACRO>
<NAME>GST_TYPE_APEV2_MUX</NAME>
#define GST_TYPE_APEV2_MUX \
  (gst_apev2_mux_get_type())
</MACRO>
<MACRO>
<NAME>GST_APEV2_MUX</NAME>
#define GST_APEV2_MUX(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_APEV2_MUX,GstApev2Mux))
</MACRO>
<MACRO>
<NAME>GST_APEV2_MUX_CLASS</NAME>
#define GST_APEV2_MUX_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_APEV2_MUX,GstApev2MuxClass))
</MACRO>
<MACRO>
<NAME>GST_IS_APEV2_MUX</NAME>
#define GST_IS_APEV2_MUX(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_APEV2_MUX))
</MACRO>
<MACRO>
<NAME>GST_IS_APEV2_MUX_CLASS</NAME>
#define GST_IS_APEV2_MUX_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_APEV2_MUX))
</MACRO>
<FUNCTION>
<NAME>gst_apev2_mux_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<STRUCT>
<NAME>GstId3v2Mux</NAME>
struct _GstId3v2Mux {
  GstTagMux  tagmux;
};
</STRUCT>
<STRUCT>
<NAME>GstId3v2MuxClass</NAME>
struct _GstId3v2MuxClass {
  GstTagMuxClass  tagmux_class;
};
</STRUCT>
<MACRO>
<NAME>GST_TYPE_ID3V2_MUX</NAME>
#define GST_TYPE_ID3V2_MUX \
  (gst_id3v2_mux_get_type())
</MACRO>
<MACRO>
<NAME>GST_ID3V2_MUX</NAME>
#define GST_ID3V2_MUX(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_ID3V2_MUX,GstId3v2Mux))
</MACRO>
<MACRO>
<NAME>GST_ID3V2_MUX_CLASS</NAME>
#define GST_ID3V2_MUX_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_ID3V2_MUX,GstId3v2MuxClass))
</MACRO>
<MACRO>
<NAME>GST_IS_ID3V2_MUX</NAME>
#define GST_IS_ID3V2_MUX(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_ID3V2_MUX))
</MACRO>
<MACRO>
<NAME>GST_IS_ID3V2_MUX_CLASS</NAME>
#define GST_IS_ID3V2_MUX_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_ID3V2_MUX))
</MACRO>
<FUNCTION>
<NAME>gst_id3v2_mux_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_PULSESINK</NAME>
#define GST_TYPE_PULSESINK \
  (gst_pulsesink_get_type())
</MACRO>
<MACRO>
<NAME>GST_PULSESINK</NAME>
#define GST_PULSESINK(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_PULSESINK,GstPulseSink))
</MACRO>
<MACRO>
<NAME>GST_PULSESINK_CLASS</NAME>
#define GST_PULSESINK_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_PULSESINK,GstPulseSinkClass))
</MACRO>
<MACRO>
<NAME>GST_IS_PULSESINK</NAME>
#define GST_IS_PULSESINK(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_PULSESINK))
</MACRO>
<MACRO>
<NAME>GST_IS_PULSESINK_CLASS</NAME>
#define GST_IS_PULSESINK_CLASS(obj) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_PULSESINK))
</MACRO>
<MACRO>
<NAME>GST_PULSESINK_CAST</NAME>
#define GST_PULSESINK_CAST(obj) \
  ((GstPulseSink *)(obj))
</MACRO>
<STRUCT>
<NAME>GstPulseDeviceInfo</NAME>
typedef struct _GstPulseDeviceInfo {
  gchar *description;
  GList *formats;
} GstPulseDeviceInfo;
</STRUCT>
<STRUCT>
<NAME>GstPulseSink</NAME>
struct _GstPulseSink
{
  GstAudioBaseSink sink;

  gchar *server, *device, *stream_name, *client_name;
  GstPulseDeviceInfo device_info;

  gdouble volume;
  gboolean volume_set:1;
  gboolean mute:1;
  gboolean mute_set:1;
  guint32 current_sink_idx;
  gchar *current_sink_name;

  guint defer_pending;

  gint notify; /* atomic */

  const gchar *pa_version;

  GstStructure *properties;
  pa_proplist *proplist;

  volatile gint format_lost;
  GstClockTime format_lost_time;
};
</STRUCT>
<STRUCT>
<NAME>GstPulseSinkClass</NAME>
struct _GstPulseSinkClass
{
  GstAudioBaseSinkClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_pulsesink_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>PULSE_SINK_TEMPLATE_CAPS</NAME>
#define PULSE_SINK_TEMPLATE_CAPS \
  _PULSE_CAPS_PCM \
  _PULSE_CAPS_AC3 \
  _PULSE_CAPS_EAC3 \
  _PULSE_CAPS_DTS \
  _PULSE_CAPS_MP3 \
  _PULSE_CAPS_AAC
</MACRO>
<MACRO>
<NAME>GST_TYPE_PULSESRC</NAME>
#define GST_TYPE_PULSESRC \
  (gst_pulsesrc_get_type())
</MACRO>
<MACRO>
<NAME>GST_PULSESRC</NAME>
#define GST_PULSESRC(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_PULSESRC,GstPulseSrc))
</MACRO>
<MACRO>
<NAME>GST_PULSESRC_CLASS</NAME>
#define GST_PULSESRC_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_PULSESRC,GstPulseSrcClass))
</MACRO>
<MACRO>
<NAME>GST_IS_PULSESRC</NAME>
#define GST_IS_PULSESRC(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_PULSESRC))
</MACRO>
<MACRO>
<NAME>GST_IS_PULSESRC_CLASS</NAME>
#define GST_IS_PULSESRC_CLASS(obj) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_PULSESRC))
</MACRO>
<MACRO>
<NAME>GST_PULSESRC_CAST</NAME>
#define GST_PULSESRC_CAST(obj) \
  ((GstPulseSrc *)(obj))
</MACRO>
<STRUCT>
<NAME>GstPulseSrc</NAME>
struct _GstPulseSrc
{
  GstAudioSrc src;

  gchar *server, *device, *client_name;

  pa_threaded_mainloop *mainloop;

  pa_context *context;
  pa_stream *stream;
  guint32 source_output_idx;

  pa_sample_spec sample_spec;

  const void *read_buffer;
  size_t read_buffer_length;

  gchar *device_description;

  gdouble volume;
  gboolean volume_set:1;
  gboolean mute:1;
  gboolean mute_set:1;
  guint32 current_source_idx;
  gchar *current_source_name;

  gint notify; /* atomic */

  gboolean corked:1;
  gboolean stream_connected:1;
  gboolean operation_success:1;
  gboolean paused:1;
  gboolean in_read:1;

  GstStructure *properties;
  pa_proplist *proplist;
};
</STRUCT>
<STRUCT>
<NAME>GstPulseSrcClass</NAME>
struct _GstPulseSrcClass
{
  GstAudioSrcClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_pulsesrc_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_SPEEX_ENC</NAME>
#define GST_TYPE_SPEEX_ENC \
  (gst_speex_enc_get_type())
</MACRO>
<MACRO>
<NAME>GST_SPEEX_ENC</NAME>
#define GST_SPEEX_ENC(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_SPEEX_ENC,GstSpeexEnc))
</MACRO>
<MACRO>
<NAME>GST_SPEEX_ENC_CLASS</NAME>
#define GST_SPEEX_ENC_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_SPEEX_ENC,GstSpeexEncClass))
</MACRO>
<MACRO>
<NAME>GST_IS_SPEEX_ENC</NAME>
#define GST_IS_SPEEX_ENC(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_SPEEX_ENC))
</MACRO>
<MACRO>
<NAME>GST_IS_SPEEX_ENC_CLASS</NAME>
#define GST_IS_SPEEX_ENC_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_SPEEX_ENC))
</MACRO>
<ENUM>
<NAME>GstSpeexMode</NAME>
typedef enum
{
  GST_SPEEX_ENC_MODE_AUTO,
  GST_SPEEX_ENC_MODE_UWB,
  GST_SPEEX_ENC_MODE_WB,
  GST_SPEEX_ENC_MODE_NB
} GstSpeexMode;
</ENUM>
<STRUCT>
<NAME>GstSpeexEnc</NAME>
struct _GstSpeexEnc {
  GstAudioEncoder   element;

  SpeexBits             bits;
  SpeexHeader           header;
  const SpeexMode       *speex_mode;
  void                  *state;

  /* properties */
  GstSpeexMode          mode;
  gfloat                quality;
  gint                  bitrate;
  gboolean              vbr;
  gint                  abr;
  gboolean              vad;
  gboolean              dtx;
  gint                  complexity;
  gint                  nframes;
  gchar                 *last_message;

  gint                  channels;
  gint                  rate;

  gboolean              header_sent;
  guint64               encoded_samples;

  GstTagList            *tags;

  gint                  frame_size;
  gint                  lookahead;

  guint8                *comments;
  gint                  comment_len;
};
</STRUCT>
<STRUCT>
<NAME>GstSpeexEncClass</NAME>
struct _GstSpeexEncClass {
  GstAudioEncoderClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_speex_enc_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_SPEEX_DEC</NAME>
#define GST_TYPE_SPEEX_DEC \
  (gst_speex_dec_get_type())
</MACRO>
<MACRO>
<NAME>GST_SPEEX_DEC</NAME>
#define GST_SPEEX_DEC(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_SPEEX_DEC,GstSpeexDec))
</MACRO>
<MACRO>
<NAME>GST_SPEEX_DEC_CLASS</NAME>
#define GST_SPEEX_DEC_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_SPEEX_DEC,GstSpeexDecClass))
</MACRO>
<MACRO>
<NAME>GST_IS_SPEEX_DEC</NAME>
#define GST_IS_SPEEX_DEC(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_SPEEX_DEC))
</MACRO>
<MACRO>
<NAME>GST_IS_SPEEX_DEC_CLASS</NAME>
#define GST_IS_SPEEX_DEC_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_SPEEX_DEC))
</MACRO>
<STRUCT>
<NAME>GstSpeexDec</NAME>
struct _GstSpeexDec {
  GstAudioDecoder   element;

  void                  *state;
  SpeexStereoState      *stereo;
  const SpeexMode       *mode;
  SpeexHeader           *header;
  SpeexCallback         callback;
  SpeexBits             bits;

  gboolean              enh;

  gint                  frame_size;
  GstClockTime          frame_duration;
  guint64               packetno;

  GstBuffer             *streamheader;
  GstBuffer             *vorbiscomment;
};
</STRUCT>
<STRUCT>
<NAME>GstSpeexDecClass</NAME>
struct _GstSpeexDecClass {
  GstAudioDecoderClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_speex_dec_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_VP8_DEC</NAME>
#define GST_TYPE_VP8_DEC \
  (gst_vp8_dec_get_type())
</MACRO>
<MACRO>
<NAME>GST_VP8_DEC</NAME>
#define GST_VP8_DEC(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_VP8_DEC,GstVP8Dec))
</MACRO>
<MACRO>
<NAME>GST_VP8_DEC_CLASS</NAME>
#define GST_VP8_DEC_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_VP8_DEC,GstVP8DecClass))
</MACRO>
<MACRO>
<NAME>GST_IS_VP8_DEC</NAME>
#define GST_IS_VP8_DEC(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_VP8_DEC))
</MACRO>
<MACRO>
<NAME>GST_IS_VP8_DEC_CLASS</NAME>
#define GST_IS_VP8_DEC_CLASS(obj) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_VP8_DEC))
</MACRO>
<STRUCT>
<NAME>GstVP8Dec</NAME>
struct _GstVP8Dec
{
  GstVPXDec base_vpx_decoder;
};
</STRUCT>
<STRUCT>
<NAME>GstVP8DecClass</NAME>
struct _GstVP8DecClass
{
  GstVPXDecClass base_vpx_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_vp8_dec_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_VP8_ENC</NAME>
#define GST_TYPE_VP8_ENC \
  (gst_vp8_enc_get_type())
</MACRO>
<MACRO>
<NAME>GST_VP8_ENC</NAME>
#define GST_VP8_ENC(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_VP8_ENC,GstVP8Enc))
</MACRO>
<MACRO>
<NAME>GST_VP8_ENC_CLASS</NAME>
#define GST_VP8_ENC_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_VP8_ENC,GstVP8EncClass))
</MACRO>
<MACRO>
<NAME>GST_IS_VP8_ENC</NAME>
#define GST_IS_VP8_ENC(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_VP8_ENC))
</MACRO>
<MACRO>
<NAME>GST_IS_VP8_ENC_CLASS</NAME>
#define GST_IS_VP8_ENC_CLASS(obj) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_VP8_ENC))
</MACRO>
<STRUCT>
<NAME>GstVP8Enc</NAME>
struct _GstVP8Enc
{
  GstVPXEnc base_vpx_encoder;

  int keyframe_distance;
};
</STRUCT>
<STRUCT>
<NAME>GstVP8EncClass</NAME>
struct _GstVP8EncClass
{
  GstVPXEncClass  base_vpxenc_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_vp8_enc_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_WAVPACK_DEC</NAME>
#define GST_TYPE_WAVPACK_DEC \
  (gst_wavpack_dec_get_type())
</MACRO>
<MACRO>
<NAME>GST_WAVPACK_DEC</NAME>
#define GST_WAVPACK_DEC(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_WAVPACK_DEC,GstWavpackDec))
</MACRO>
<MACRO>
<NAME>GST_WAVPACK_DEC_CLASS</NAME>
#define GST_WAVPACK_DEC_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_WAVPACK_DEC,GstWavpackDecClass))
</MACRO>
<MACRO>
<NAME>GST_IS_WAVPACK_DEC</NAME>
#define GST_IS_WAVPACK_DEC(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_WAVPACK_DEC))
</MACRO>
<MACRO>
<NAME>GST_IS_WAVPACK_DEC_CLASS</NAME>
#define GST_IS_WAVPACK_DEC_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_WAVPACK_DEC))
</MACRO>
<STRUCT>
<NAME>GstWavpackDec</NAME>
struct _GstWavpackDec
{
  GstAudioDecoder element;

  /*< private > */

  WavpackContext *context;
  WavpackStreamReader *stream_reader;

  read_id wv_id;

  gint sample_rate;
  gint depth;
  gint width;
  gint channels;
  gint channel_mask;

  gint channel_reorder_map[64];

};
</STRUCT>
<STRUCT>
<NAME>GstWavpackDecClass</NAME>
struct _GstWavpackDecClass
{
  GstAudioDecoderClass parent;
};
</STRUCT>
<FUNCTION>
<NAME>gst_wavpack_dec_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_wavpack_dec_plugin_init</NAME>
<RETURNS>gboolean  </RETURNS>
GstPlugin * plugin
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_WAVPACK_ENC</NAME>
#define GST_TYPE_WAVPACK_ENC \
  (gst_wavpack_enc_get_type())
</MACRO>
<MACRO>
<NAME>GST_WAVPACK_ENC</NAME>
#define GST_WAVPACK_ENC(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_WAVPACK_ENC,GstWavpackEnc))
</MACRO>
<MACRO>
<NAME>GST_WAVPACK_ENC_CLASS</NAME>
#define GST_WAVPACK_ENC_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_WAVPACK_ENC,GstWavpackEnc))
</MACRO>
<MACRO>
<NAME>GST_IS_WAVPACK_ENC</NAME>
#define GST_IS_WAVPACK_ENC(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_WAVPACK_ENC))
</MACRO>
<MACRO>
<NAME>GST_IS_WAVPACK_ENC_CLASS</NAME>
#define GST_IS_WAVPACK_ENC_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_WAVPACK_ENC))
</MACRO>
<STRUCT>
<NAME>GstWavpackEnc</NAME>
struct _GstWavpackEnc
{
  GstAudioEncoder element;

  /*< private > */
  GstPad *wvcsrcpad;

  GstFlowReturn srcpad_last_return;
  GstFlowReturn wvcsrcpad_last_return;

  WavpackConfig *wp_config;
  WavpackContext *wp_context;

  gint samplerate;
  gint channels;
  gint channel_mask;
  gint8 channel_mapping[8];
  gboolean need_channel_remap;
  gint depth;

  GstWavpackEncWriteID wv_id;
  GstWavpackEncWriteID wvc_id;

  guint mode;
  guint bitrate;
  gdouble bps;
  guint correction_mode;
  gboolean md5;
  GChecksum *md5_context;
  guint extra_processing;
  guint joint_stereo_mode;

  void *first_block;
  int32_t first_block_size;

  GstBuffer *pending_buffer;
  gint32 pending_offset;
  GstEvent *pending_segment;

  GstClockTime timestamp_offset;
  GstClockTime next_ts;
};
</STRUCT>
<STRUCT>
<NAME>GstWavpackEncClass</NAME>
struct _GstWavpackEncClass
{
  GstAudioEncoderClass parent;
};
</STRUCT>
<FUNCTION>
<NAME>gst_wavpack_enc_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_wavpack_enc_plugin_init</NAME>
<RETURNS>gboolean  </RETURNS>
GstPlugin * plugin
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_ALPHA</NAME>
#define GST_TYPE_ALPHA \
  (gst_alpha_get_type())
</MACRO>
<MACRO>
<NAME>GST_ALPHA</NAME>
#define GST_ALPHA(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_ALPHA,GstAlpha))
</MACRO>
<MACRO>
<NAME>GST_ALPHA_CLASS</NAME>
#define GST_ALPHA_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_ALPHA,GstAlphaClass))
</MACRO>
<MACRO>
<NAME>GST_IS_ALPHA</NAME>
#define GST_IS_ALPHA(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_ALPHA))
</MACRO>
<MACRO>
<NAME>GST_IS_ALPHA_CLASS</NAME>
#define GST_IS_ALPHA_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_ALPHA))
</MACRO>
<ENUM>
<NAME>GstAlphaMethod</NAME>
typedef enum
{
  ALPHA_METHOD_SET,
  ALPHA_METHOD_GREEN,
  ALPHA_METHOD_BLUE,
  ALPHA_METHOD_CUSTOM,
}
GstAlphaMethod;
</ENUM>
<MACRO>
<NAME>GST_CAT_DEFAULT</NAME>
#define GST_CAT_DEFAULT gst_alpha_debug
</MACRO>
<STRUCT>
<NAME>GstAlpha</NAME>
struct _GstAlpha
{
  GstVideoFilter parent;

  /* <private> */

  /* caps */
  GMutex lock;

  gboolean in_sdtv, out_sdtv;

  /* properties */
  gdouble alpha;

  guint target_r;
  guint target_g;
  guint target_b;

  GstAlphaMethod method;

  gfloat angle;
  gfloat noise_level;
  guint black_sensitivity;
  guint white_sensitivity;

  gboolean prefer_passthrough;

  /* processing function */
  void (*process) (const GstVideoFrame *in_frame, GstVideoFrame *out_frame, GstAlpha *alpha);

  /* precalculated values for chroma keying */
  gint8 cb, cr;
  gint8 kg;
  guint8 accept_angle_tg;
  guint8 accept_angle_ctg;
  guint8 one_over_kc;
  guint8 kfgy_scale;
  guint noise_level2;
};
</STRUCT>
<STRUCT>
<NAME>GstAlphaClass</NAME>
struct _GstAlphaClass
{
  GstVideoFilterClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_alpha_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_ALPHA_COLOR</NAME>
#define GST_TYPE_ALPHA_COLOR \
  (gst_alpha_color_get_type())
</MACRO>
<MACRO>
<NAME>GST_ALPHA_COLOR</NAME>
#define GST_ALPHA_COLOR(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_ALPHA_COLOR,GstAlphaColor))
</MACRO>
<MACRO>
<NAME>GST_ALPHA_COLOR_CLASS</NAME>
#define GST_ALPHA_COLOR_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_ALPHA_COLOR,GstAlphaColorClass))
</MACRO>
<MACRO>
<NAME>GST_IS_ALPHA_COLOR</NAME>
#define GST_IS_ALPHA_COLOR(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_ALPHA_COLOR))
</MACRO>
<MACRO>
<NAME>GST_IS_ALPHA_COLOR_CLASS</NAME>
#define GST_IS_ALPHA_COLOR_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_ALPHA_COLOR))
</MACRO>
<STRUCT>
<NAME>GstAlphaColor</NAME>
struct _GstAlphaColor
{
  GstVideoFilter parent;

  /*< private >*/
  void (*process) (GstVideoFrame * frame, const gint * matrix);

  const gint *matrix;
};
</STRUCT>
<STRUCT>
<NAME>GstAlphaColorClass</NAME>
struct _GstAlphaColorClass
{
  GstVideoFilterClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_alpha_color_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_APE_DEMUX</NAME>
#define GST_TYPE_APE_DEMUX             (gst_ape_demux_get_type())
</MACRO>
<MACRO>
<NAME>GST_APE_DEMUX</NAME>
#define GST_APE_DEMUX(obj)             (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_APE_DEMUX,GstApeDemux))
</MACRO>
<MACRO>
<NAME>GST_APE_DEMUX_CLASS</NAME>
#define GST_APE_DEMUX_CLASS(klass)     (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_APE_DEMUX,GstApeDemuxClass))
</MACRO>
<MACRO>
<NAME>GST_IS_APE_DEMUX</NAME>
#define GST_IS_APE_DEMUX(obj)          (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_APE_DEMUX))
</MACRO>
<MACRO>
<NAME>GST_IS_APE_DEMUX_CLASS</NAME>
#define GST_IS_APE_DEMUX_CLASS(klass)  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_APE_DEMUX))
</MACRO>
<STRUCT>
<NAME>GstApeDemux</NAME>
struct _GstApeDemux
{
  GstTagDemux tagdemux;
};
</STRUCT>
<STRUCT>
<NAME>GstApeDemuxClass</NAME>
struct _GstApeDemuxClass 
{
  GstTagDemuxClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_ape_demux_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_AUDIO_AMPLIFY</NAME>
#define GST_TYPE_AUDIO_AMPLIFY            (gst_audio_amplify_get_type())
</MACRO>
<MACRO>
<NAME>GST_AUDIO_AMPLIFY</NAME>
#define GST_AUDIO_AMPLIFY(obj)            (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_AUDIO_AMPLIFY,GstAudioAmplify))
</MACRO>
<MACRO>
<NAME>GST_IS_AUDIO_AMPLIFY</NAME>
#define GST_IS_AUDIO_AMPLIFY(obj)         (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_AUDIO_AMPLIFY))
</MACRO>
<MACRO>
<NAME>GST_AUDIO_AMPLIFY_CLASS</NAME>
#define GST_AUDIO_AMPLIFY_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST((klass) ,GST_TYPE_AUDIO_AMPLIFY,GstAudioAmplifyClass))
</MACRO>
<MACRO>
<NAME>GST_IS_AUDIO_AMPLIFY_CLASS</NAME>
#define GST_IS_AUDIO_AMPLIFY_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE((klass) ,GST_TYPE_AUDIO_AMPLIFY))
</MACRO>
<MACRO>
<NAME>GST_AUDIO_AMPLIFY_GET_CLASS</NAME>
#define GST_AUDIO_AMPLIFY_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS((obj) ,GST_TYPE_AUDIO_AMPLIFY,GstAudioAmplifyClass))
</MACRO>
<USER_FUNCTION>
<NAME>GstAudioAmplifyProcessFunc</NAME>
<RETURNS>void </RETURNS>
GstAudioAmplify *, void *, guint
</USER_FUNCTION>
<STRUCT>
<NAME>GstAudioAmplify</NAME>
struct _GstAudioAmplify
{
  GstAudioFilter audiofilter;

  gfloat amplification;

  /* < private > */
  GstAudioAmplifyProcessFunc process;
  gint clipping_method;
  GstAudioFormat format;
};
</STRUCT>
<STRUCT>
<NAME>GstAudioAmplifyClass</NAME>
struct _GstAudioAmplifyClass
{
  GstAudioFilterClass parent;
};
</STRUCT>
<FUNCTION>
<NAME>gst_audio_amplify_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_AUDIO_ECHO</NAME>
#define GST_TYPE_AUDIO_ECHO            (gst_audio_echo_get_type())
</MACRO>
<MACRO>
<NAME>GST_AUDIO_ECHO</NAME>
#define GST_AUDIO_ECHO(obj)            (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_AUDIO_ECHO,GstAudioEcho))
</MACRO>
<MACRO>
<NAME>GST_IS_AUDIO_ECHO</NAME>
#define GST_IS_AUDIO_ECHO(obj)         (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_AUDIO_ECHO))
</MACRO>
<MACRO>
<NAME>GST_AUDIO_ECHO_CLASS</NAME>
#define GST_AUDIO_ECHO_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST((klass) ,GST_TYPE_AUDIO_ECHO,GstAudioEchoClass))
</MACRO>
<MACRO>
<NAME>GST_IS_AUDIO_ECHO_CLASS</NAME>
#define GST_IS_AUDIO_ECHO_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE((klass) ,GST_TYPE_AUDIO_ECHO))
</MACRO>
<MACRO>
<NAME>GST_AUDIO_ECHO_GET_CLASS</NAME>
#define GST_AUDIO_ECHO_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS((obj) ,GST_TYPE_AUDIO_ECHO,GstAudioEchoClass))
</MACRO>
<USER_FUNCTION>
<NAME>GstAudioEchoProcessFunc</NAME>
<RETURNS>void </RETURNS>
GstAudioEcho *, guint8 *, guint
</USER_FUNCTION>
<STRUCT>
<NAME>GstAudioEcho</NAME>
struct _GstAudioEcho
{
  GstAudioFilter audiofilter;

  guint64 delay;
  guint64 max_delay;
  gfloat intensity;
  gfloat feedback;
  gboolean surdelay;
  guint64 surround_mask;

  /* < private > */
  GstAudioEchoProcessFunc process;
  guint delay_frames;
  guint8 *buffer;
  guint buffer_pos;
  guint buffer_size;
  guint buffer_size_frames;

  GMutex lock;
};
</STRUCT>
<STRUCT>
<NAME>GstAudioEchoClass</NAME>
struct _GstAudioEchoClass
{
  GstAudioFilterClass parent;
};
</STRUCT>
<FUNCTION>
<NAME>gst_audio_echo_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_AUDIO_DYNAMIC</NAME>
#define GST_TYPE_AUDIO_DYNAMIC            (gst_audio_dynamic_get_type())
</MACRO>
<MACRO>
<NAME>GST_AUDIO_DYNAMIC</NAME>
#define GST_AUDIO_DYNAMIC(obj)            (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_AUDIO_DYNAMIC,GstAudioDynamic))
</MACRO>
<MACRO>
<NAME>GST_IS_AUDIO_DYNAMIC</NAME>
#define GST_IS_AUDIO_DYNAMIC(obj)         (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_AUDIO_DYNAMIC))
</MACRO>
<MACRO>
<NAME>GST_AUDIO_DYNAMIC_CLASS</NAME>
#define GST_AUDIO_DYNAMIC_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST((klass) ,GST_TYPE_AUDIO_DYNAMIC,GstAudioDynamicClass))
</MACRO>
<MACRO>
<NAME>GST_IS_AUDIO_DYNAMIC_CLASS</NAME>
#define GST_IS_AUDIO_DYNAMIC_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE((klass) ,GST_TYPE_AUDIO_DYNAMIC))
</MACRO>
<MACRO>
<NAME>GST_AUDIO_DYNAMIC_GET_CLASS</NAME>
#define GST_AUDIO_DYNAMIC_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS((obj) ,GST_TYPE_AUDIO_DYNAMIC,GstAudioDynamicClass))
</MACRO>
<USER_FUNCTION>
<NAME>GstAudioDynamicProcessFunc</NAME>
<RETURNS>void </RETURNS>
GstAudioDynamic *, guint8 *, guint
</USER_FUNCTION>
<STRUCT>
<NAME>GstAudioDynamic</NAME>
struct _GstAudioDynamic
{
  GstAudioFilter audiofilter;

  /* < private > */
  GstAudioDynamicProcessFunc process;
  gint characteristics;
  gint mode;
  gfloat threshold;
  gfloat ratio;
};
</STRUCT>
<STRUCT>
<NAME>GstAudioDynamicClass</NAME>
struct _GstAudioDynamicClass
{
  GstAudioFilterClass parent;
};
</STRUCT>
<FUNCTION>
<NAME>gst_audio_dynamic_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_AUDIO_INVERT</NAME>
#define GST_TYPE_AUDIO_INVERT            (gst_audio_invert_get_type())
</MACRO>
<MACRO>
<NAME>GST_AUDIO_INVERT</NAME>
#define GST_AUDIO_INVERT(obj)            (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_AUDIO_INVERT,GstAudioInvert))
</MACRO>
<MACRO>
<NAME>GST_IS_AUDIO_INVERT</NAME>
#define GST_IS_AUDIO_INVERT(obj)         (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_AUDIO_INVERT))
</MACRO>
<MACRO>
<NAME>GST_AUDIO_INVERT_CLASS</NAME>
#define GST_AUDIO_INVERT_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST((klass) ,GST_TYPE_AUDIO_INVERT,GstAudioInvertClass))
</MACRO>
<MACRO>
<NAME>GST_IS_AUDIO_INVERT_CLASS</NAME>
#define GST_IS_AUDIO_INVERT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE((klass) ,GST_TYPE_AUDIO_INVERT))
</MACRO>
<MACRO>
<NAME>GST_AUDIO_INVERT_GET_CLASS</NAME>
#define GST_AUDIO_INVERT_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS((obj) ,GST_TYPE_AUDIO_INVERT,GstAudioInvertClass))
</MACRO>
<USER_FUNCTION>
<NAME>GstAudioInvertProcessFunc</NAME>
<RETURNS>void </RETURNS>
GstAudioInvert *, guint8 *, guint
</USER_FUNCTION>
<STRUCT>
<NAME>GstAudioInvert</NAME>
struct _GstAudioInvert
{
  GstAudioFilter audiofilter;

  gfloat degree;

  /* < private > */
  GstAudioInvertProcessFunc process;
};
</STRUCT>
<STRUCT>
<NAME>GstAudioInvertClass</NAME>
struct _GstAudioInvertClass
{
  GstAudioFilterClass parent;
};
</STRUCT>
<FUNCTION>
<NAME>gst_audio_invert_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_AUDIO_KARAOKE</NAME>
#define GST_TYPE_AUDIO_KARAOKE            (gst_audio_karaoke_get_type())
</MACRO>
<MACRO>
<NAME>GST_AUDIO_KARAOKE</NAME>
#define GST_AUDIO_KARAOKE(obj)            (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_AUDIO_KARAOKE,GstAudioKaraoke))
</MACRO>
<MACRO>
<NAME>GST_IS_AUDIO_KARAOKE</NAME>
#define GST_IS_AUDIO_KARAOKE(obj)         (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_AUDIO_KARAOKE))
</MACRO>
<MACRO>
<NAME>GST_AUDIO_KARAOKE_CLASS</NAME>
#define GST_AUDIO_KARAOKE_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST((klass) ,GST_TYPE_AUDIO_KARAOKE,GstAudioKaraokeClass))
</MACRO>
<MACRO>
<NAME>GST_IS_AUDIO_KARAOKE_CLASS</NAME>
#define GST_IS_AUDIO_KARAOKE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE((klass) ,GST_TYPE_AUDIO_KARAOKE))
</MACRO>
<MACRO>
<NAME>GST_AUDIO_KARAOKE_GET_CLASS</NAME>
#define GST_AUDIO_KARAOKE_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS((obj) ,GST_TYPE_AUDIO_KARAOKE,GstAudioKaraokeClass))
</MACRO>
<USER_FUNCTION>
<NAME>GstAudioKaraokeProcessFunc</NAME>
<RETURNS>void </RETURNS>
GstAudioKaraoke *, guint8 *, guint
</USER_FUNCTION>
<STRUCT>
<NAME>GstAudioKaraoke</NAME>
struct _GstAudioKaraoke
{
  GstAudioFilter audiofilter;

  /* properties */
  gfloat level;
  gfloat mono_level;
  gfloat filter_band;
  gfloat filter_width;

  /* filter coef */
  gfloat A, B, C;
  gfloat y1, y2;

  /* < private > */
  GstAudioKaraokeProcessFunc process;
};
</STRUCT>
<STRUCT>
<NAME>GstAudioKaraokeClass</NAME>
struct _GstAudioKaraokeClass
{
  GstAudioFilterClass parent;
};
</STRUCT>
<FUNCTION>
<NAME>gst_audio_karaoke_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_AUDIO_PANORAMA</NAME>
#define GST_TYPE_AUDIO_PANORAMA            (gst_audio_panorama_get_type())
</MACRO>
<MACRO>
<NAME>GST_AUDIO_PANORAMA</NAME>
#define GST_AUDIO_PANORAMA(obj)            (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_AUDIO_PANORAMA,GstAudioPanorama))
</MACRO>
<MACRO>
<NAME>GST_IS_AUDIO_PANORAMA</NAME>
#define GST_IS_AUDIO_PANORAMA(obj)         (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_AUDIO_PANORAMA))
</MACRO>
<MACRO>
<NAME>GST_AUDIO_PANORAMA_CLASS</NAME>
#define GST_AUDIO_PANORAMA_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST((klass) ,GST_TYPE_AUDIO_PANORAMA,GstAudioPanoramaClass))
</MACRO>
<MACRO>
<NAME>GST_IS_AUDIO_PANORAMA_CLASS</NAME>
#define GST_IS_AUDIO_PANORAMA_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE((klass) ,GST_TYPE_AUDIO_PANORAMA))
</MACRO>
<MACRO>
<NAME>GST_AUDIO_PANORAMA_GET_CLASS</NAME>
#define GST_AUDIO_PANORAMA_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS((obj) ,GST_TYPE_AUDIO_PANORAMA,GstAudioPanoramaClass))
</MACRO>
<USER_FUNCTION>
<NAME>GstAudioPanoramaProcessFunc</NAME>
<RETURNS>void </RETURNS>
gfloat, guint8*, guint8*, guint
</USER_FUNCTION>
<ENUM>
<NAME>GstAudioPanoramaMethod</NAME>
typedef enum
{
  METHOD_PSYCHOACOUSTIC = 0,
  METHOD_SIMPLE
} GstAudioPanoramaMethod;
</ENUM>
<STRUCT>
<NAME>GstAudioPanorama</NAME>
struct _GstAudioPanorama {
  GstBaseTransform element;

  /* properties */
  gfloat panorama;
  GstAudioPanoramaMethod method;

  /* < private > */
  GstAudioPanoramaProcessFunc process;
  GstAudioInfo info;
};
</STRUCT>
<STRUCT>
<NAME>GstAudioPanoramaClass</NAME>
struct _GstAudioPanoramaClass {
  GstBaseTransformClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_audio_panorama_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_AUDIO_CHEB_LIMIT</NAME>
#define GST_TYPE_AUDIO_CHEB_LIMIT            (gst_audio_cheb_limit_get_type())
</MACRO>
<MACRO>
<NAME>GST_AUDIO_CHEB_LIMIT</NAME>
#define GST_AUDIO_CHEB_LIMIT(obj)            (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_AUDIO_CHEB_LIMIT,GstAudioChebLimit))
</MACRO>
<MACRO>
<NAME>GST_IS_AUDIO_CHEB_LIMIT</NAME>
#define GST_IS_AUDIO_CHEB_LIMIT(obj)         (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_AUDIO_CHEB_LIMIT))
</MACRO>
<MACRO>
<NAME>GST_AUDIO_CHEB_LIMIT_CLASS</NAME>
#define GST_AUDIO_CHEB_LIMIT_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST((klass) ,GST_TYPE_AUDIO_CHEB_LIMIT,GstAudioChebLimitClass))
</MACRO>
<MACRO>
<NAME>GST_IS_AUDIO_CHEB_LIMIT_CLASS</NAME>
#define GST_IS_AUDIO_CHEB_LIMIT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE((klass) ,GST_TYPE_AUDIO_CHEB_LIMIT))
</MACRO>
<MACRO>
<NAME>GST_AUDIO_CHEB_LIMIT_GET_CLASS</NAME>
#define GST_AUDIO_CHEB_LIMIT_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS((obj) ,GST_TYPE_AUDIO_CHEB_LIMIT,GstAudioChebLimitClass))
</MACRO>
<STRUCT>
<NAME>GstAudioChebLimit</NAME>
struct _GstAudioChebLimit
{
  GstAudioFXBaseIIRFilter parent;

  gint mode;
  gint type;
  gint poles;
  gfloat cutoff;
  gfloat ripple;

  /* < private > */
  GMutex lock;
};
</STRUCT>
<STRUCT>
<NAME>GstAudioChebLimitClass</NAME>
struct _GstAudioChebLimitClass
{
  GstAudioFXBaseIIRFilterClass parent;
};
</STRUCT>
<FUNCTION>
<NAME>gst_audio_cheb_limit_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_AUDIO_CHEB_BAND</NAME>
#define GST_TYPE_AUDIO_CHEB_BAND            (gst_audio_cheb_band_get_type())
</MACRO>
<MACRO>
<NAME>GST_AUDIO_CHEB_BAND</NAME>
#define GST_AUDIO_CHEB_BAND(obj)            (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_AUDIO_CHEB_BAND,GstAudioChebBand))
</MACRO>
<MACRO>
<NAME>GST_IS_AUDIO_CHEB_BAND</NAME>
#define GST_IS_AUDIO_CHEB_BAND(obj)         (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_AUDIO_CHEB_BAND))
</MACRO>
<MACRO>
<NAME>GST_AUDIO_CHEB_BAND_CLASS</NAME>
#define GST_AUDIO_CHEB_BAND_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST((klass) ,GST_TYPE_AUDIO_CHEB_BAND,GstAudioChebBandClass))
</MACRO>
<MACRO>
<NAME>GST_IS_AUDIO_CHEB_BAND_CLASS</NAME>
#define GST_IS_AUDIO_CHEB_BAND_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE((klass) ,GST_TYPE_AUDIO_CHEB_BAND))
</MACRO>
<MACRO>
<NAME>GST_AUDIO_CHEB_BAND_GET_CLASS</NAME>
#define GST_AUDIO_CHEB_BAND_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS((obj) ,GST_TYPE_AUDIO_CHEB_BAND,GstAudioChebBandClass))
</MACRO>
<STRUCT>
<NAME>GstAudioChebBand</NAME>
struct _GstAudioChebBand
{
  GstAudioFXBaseIIRFilter parent;

  gint mode;
  gint type;
  gint poles;
  gfloat lower_frequency;
  gfloat upper_frequency;
  gfloat ripple;

  /* < private > */
  GMutex lock;
};
</STRUCT>
<STRUCT>
<NAME>GstAudioChebBandClass</NAME>
struct _GstAudioChebBandClass
{
  GstAudioFXBaseIIRFilterClass parent;
};
</STRUCT>
<FUNCTION>
<NAME>gst_audio_cheb_band_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_AUDIO_IIR_FILTER</NAME>
#define GST_TYPE_AUDIO_IIR_FILTER \
  (gst_audio_iir_filter_get_type())
</MACRO>
<MACRO>
<NAME>GST_AUDIO_IIR_FILTER</NAME>
#define GST_AUDIO_IIR_FILTER(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_AUDIO_IIR_FILTER,GstAudioIIRFilter))
</MACRO>
<MACRO>
<NAME>GST_AUDIO_IIR_FILTER_CLASS</NAME>
#define GST_AUDIO_IIR_FILTER_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_AUDIO_IIR_FILTER,GstAudioIIRFilterClass))
</MACRO>
<MACRO>
<NAME>GST_IS_AUDIO_IIR_FILTER</NAME>
#define GST_IS_AUDIO_IIR_FILTER(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_AUDIO_IIR_FILTER))
</MACRO>
<MACRO>
<NAME>GST_IS_AUDIO_IIR_FILTER_CLASS</NAME>
#define GST_IS_AUDIO_IIR_FILTER_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_AUDIO_IIR_FILTER))
</MACRO>
<STRUCT>
<NAME>GstAudioIIRFilter</NAME>
struct _GstAudioIIRFilter {
  GstAudioFXBaseIIRFilter parent;

  GValueArray *a, *b;

  /* < private > */
  GMutex lock;
};
</STRUCT>
<STRUCT>
<NAME>GstAudioIIRFilterClass</NAME>
struct _GstAudioIIRFilterClass {
  GstAudioFXBaseIIRFilterClass parent;

  void (*rate_changed) (GstElement * element, gint rate);
};
</STRUCT>
<FUNCTION>
<NAME>gst_audio_iir_filter_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_AUDIO_WSINC_BAND</NAME>
#define GST_TYPE_AUDIO_WSINC_BAND \
  (gst_audio_wsincband_get_type())
</MACRO>
<MACRO>
<NAME>GST_AUDIO_WSINC_BAND</NAME>
#define GST_AUDIO_WSINC_BAND(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_AUDIO_WSINC_BAND,GstAudioWSincBand))
</MACRO>
<MACRO>
<NAME>GST_AUDIO_WSINC_BAND_CLASS</NAME>
#define GST_AUDIO_WSINC_BAND_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_AUDIO_WSINC_BAND,GstAudioWSincBandClass))
</MACRO>
<MACRO>
<NAME>GST_IS_AUDIO_WSINC_BAND</NAME>
#define GST_IS_AUDIO_WSINC_BAND(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_AUDIO_WSINC_BAND))
</MACRO>
<MACRO>
<NAME>GST_IS_AUDIO_WSINC_BAND_CLASS</NAME>
#define GST_IS_AUDIO_WSINC_BAND_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_AUDIO_WSINC_BAND))
</MACRO>
<STRUCT>
<NAME>GstAudioWSincBand</NAME>
struct _GstAudioWSincBand {
  GstAudioFXBaseFIRFilter parent;

  gint mode;
  gint window;
  gfloat lower_frequency, upper_frequency;
  gint kernel_length;           /* length of the filter kernel */

  /* < private > */
  GMutex lock;
};
</STRUCT>
<STRUCT>
<NAME>GstAudioWSincBandClass</NAME>
struct _GstAudioWSincBandClass {
  GstAudioFilterClass parent;
};
</STRUCT>
<FUNCTION>
<NAME>gst_audio_wsincband_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_AUDIO_WSINC_LIMIT</NAME>
#define GST_TYPE_AUDIO_WSINC_LIMIT \
  (gst_audio_wsinclimit_get_type())
</MACRO>
<MACRO>
<NAME>GST_AUDIO_WSINC_LIMIT</NAME>
#define GST_AUDIO_WSINC_LIMIT(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_AUDIO_WSINC_LIMIT,GstAudioWSincLimit))
</MACRO>
<MACRO>
<NAME>GST_AUDIO_WSINC_LIMIT_CLASS</NAME>
#define GST_AUDIO_WSINC_LIMIT_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_AUDIO_WSINC_LIMIT,GstAudioWSincLimitClass))
</MACRO>
<MACRO>
<NAME>GST_IS_AUDIO_WSINC_LIMIT</NAME>
#define GST_IS_AUDIO_WSINC_LIMIT(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_AUDIO_WSINC_LIMIT))
</MACRO>
<MACRO>
<NAME>GST_IS_AUDIO_WSINC_LIMIT_CLASS</NAME>
#define GST_IS_AUDIO_WSINC_LIMIT_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_AUDIO_WSINC_LIMIT))
</MACRO>
<STRUCT>
<NAME>GstAudioWSincLimit</NAME>
struct _GstAudioWSincLimit {
  GstAudioFXBaseFIRFilter parent;

  gint mode;
  gint window;
  gfloat cutoff;
  gint kernel_length;

  /* < private > */
  GMutex lock;
};
</STRUCT>
<STRUCT>
<NAME>GstAudioWSincLimitClass</NAME>
struct _GstAudioWSincLimitClass {
  GstAudioFXBaseFIRFilterClass parent;
};
</STRUCT>
<FUNCTION>
<NAME>gst_audio_wsinclimit_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_AUDIO_FIR_FILTER</NAME>
#define GST_TYPE_AUDIO_FIR_FILTER \
  (gst_audio_fir_filter_get_type())
</MACRO>
<MACRO>
<NAME>GST_AUDIO_FIR_FILTER</NAME>
#define GST_AUDIO_FIR_FILTER(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_AUDIO_FIR_FILTER,GstAudioFIRFilter))
</MACRO>
<MACRO>
<NAME>GST_AUDIO_FIR_FILTER_CLASS</NAME>
#define GST_AUDIO_FIR_FILTER_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_AUDIO_FIR_FILTER,GstAudioFIRFilterClass))
</MACRO>
<MACRO>
<NAME>GST_IS_AUDIO_FIR_FILTER</NAME>
#define GST_IS_AUDIO_FIR_FILTER(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_AUDIO_FIR_FILTER))
</MACRO>
<MACRO>
<NAME>GST_IS_AUDIO_FIR_FILTER_CLASS</NAME>
#define GST_IS_AUDIO_FIR_FILTER_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_AUDIO_FIR_FILTER))
</MACRO>
<STRUCT>
<NAME>GstAudioFIRFilter</NAME>
struct _GstAudioFIRFilter {
  GstAudioFXBaseFIRFilter parent;

  GValueArray *kernel;
  guint64 latency;

  /* < private > */
  GMutex lock;
};
</STRUCT>
<STRUCT>
<NAME>GstAudioFIRFilterClass</NAME>
struct _GstAudioFIRFilterClass {
  GstAudioFXBaseFIRFilterClass parent;

  void (*rate_changed) (GstElement * element, gint rate);
};
</STRUCT>
<FUNCTION>
<NAME>gst_audio_fir_filter_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_SCALETEMPO</NAME>
#define GST_TYPE_SCALETEMPO            (gst_scaletempo_get_type())
</MACRO>
<MACRO>
<NAME>GST_SCALETEMPO</NAME>
#define GST_SCALETEMPO(obj)            (G_TYPE_CHECK_INSTANCE_CAST((obj), GST_TYPE_SCALETEMPO, GstScaletempo))
</MACRO>
<MACRO>
<NAME>GST_SCALETEMPO_CLASS</NAME>
#define GST_SCALETEMPO_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST((klass),  GST_TYPE_SCALETEMPO, GstScaletempoClass))
</MACRO>
<MACRO>
<NAME>GST_IS_SCALETEMPO</NAME>
#define GST_IS_SCALETEMPO(obj)         (G_TYPE_CHECK_INSTANCE_TYPE((obj), GST_TYPE_SCALETEMPO))
</MACRO>
<MACRO>
<NAME>GST_IS_SCALETEMPO_CLASS</NAME>
#define GST_IS_SCALETEMPO_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE((klass),  GST_TYPE_SCALETEMPO))
</MACRO>
<STRUCT>
<NAME>GstScaletempo</NAME>
struct _GstScaletempo
{
  GstBaseTransform element;

  gdouble scale;
  gboolean reverse;

  /* parameters */
  guint ms_stride;
  gdouble percent_overlap;
  guint ms_search;

  /* caps */
  GstAudioFormat format;
  guint samples_per_frame;      /* AKA number of channels */
  guint bytes_per_sample;
  guint bytes_per_frame;
  guint sample_rate;

  /* stride */
  gdouble frames_stride_scaled;
  gdouble frames_stride_error;
  guint bytes_stride;
  gdouble bytes_stride_scaled;
  guint bytes_queue_max;
  guint bytes_queued;
  guint bytes_to_slide;
  gint8 *buf_queue;

  /* overlap */
  guint samples_overlap;
  guint samples_standing;
  guint bytes_overlap;
  guint bytes_standing;
  gpointer buf_overlap;
  gpointer table_blend;
  void (*output_overlap) (GstScaletempo * scaletempo, gpointer out_buf, guint bytes_off);

  /* best overlap */
  guint frames_search;
  gpointer buf_pre_corr;
  gpointer table_window;
  guint (*best_overlap_offset) (GstScaletempo * scaletempo);

  /* gstreamer */
  GstSegment in_segment, out_segment;
  GstClockTime latency;

  /* threads */
  gboolean reinit_buffers;
};
</STRUCT>
<STRUCT>
<NAME>GstScaletempoClass</NAME>
struct _GstScaletempoClass
{
  GstBaseTransformClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_scaletempo_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<STRUCT>
<NAME>GstScaletempoPrivate</NAME>
</STRUCT>
<MACRO>
<NAME>GST_TYPE_AAC_PARSE</NAME>
#define GST_TYPE_AAC_PARSE \
  (gst_aac_parse_get_type())
</MACRO>
<MACRO>
<NAME>GST_AAC_PARSE</NAME>
#define GST_AAC_PARSE(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj), GST_TYPE_AAC_PARSE, GstAacParse))
</MACRO>
<MACRO>
<NAME>GST_AAC_PARSE_CLASS</NAME>
#define GST_AAC_PARSE_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass), GST_TYPE_AAC_PARSE, GstAacParseClass))
</MACRO>
<MACRO>
<NAME>GST_IS_AAC_PARSE</NAME>
#define GST_IS_AAC_PARSE(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj), GST_TYPE_AAC_PARSE))
</MACRO>
<MACRO>
<NAME>GST_IS_AAC_PARSE_CLASS</NAME>
#define GST_IS_AAC_PARSE_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass), GST_TYPE_AAC_PARSE))
</MACRO>
<ENUM>
<NAME>GstAacHeaderType</NAME>
typedef enum {
  DSPAAC_HEADER_NOT_PARSED,
  DSPAAC_HEADER_UNKNOWN,
  DSPAAC_HEADER_ADIF,
  DSPAAC_HEADER_ADTS,
  DSPAAC_HEADER_LOAS,
  DSPAAC_HEADER_NONE
} GstAacHeaderType;
</ENUM>
<STRUCT>
<NAME>GstAacParse</NAME>
struct _GstAacParse {
  GstBaseParse element;

  /* Stream type -related info */
  gint           object_type;
  gint           bitrate;
  gint           sample_rate;
  gint           channels;
  gint           mpegversion;
  gint           frame_samples;

  GstAacHeaderType header_type;
  GstAacHeaderType output_header_type;

  gboolean sent_codec_tag;

  gint last_parsed_sample_rate;
  gint last_parsed_channels;
};
</STRUCT>
<STRUCT>
<NAME>GstAacParseClass</NAME>
struct _GstAacParseClass {
  GstBaseParseClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_aac_parse_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_AC3_PARSE</NAME>
#define GST_TYPE_AC3_PARSE \
  (gst_ac3_parse_get_type())
</MACRO>
<MACRO>
<NAME>GST_AC3_PARSE</NAME>
#define GST_AC3_PARSE(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj), GST_TYPE_AC3_PARSE, GstAc3Parse))
</MACRO>
<MACRO>
<NAME>GST_AC3_PARSE_CLASS</NAME>
#define GST_AC3_PARSE_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass), GST_TYPE_AC3_PARSE, GstAc3ParseClass))
</MACRO>
<MACRO>
<NAME>GST_IS_AC3_PARSE</NAME>
#define GST_IS_AC3_PARSE(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj), GST_TYPE_AC3_PARSE))
</MACRO>
<MACRO>
<NAME>GST_IS_AC3_PARSE_CLASS</NAME>
#define GST_IS_AC3_PARSE_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass), GST_TYPE_AC3_PARSE))
</MACRO>
<STRUCT>
<NAME>GstAc3Parse</NAME>
struct _GstAc3Parse {
  GstBaseParse baseparse;

  /*< private >*/
  gint                  sample_rate;
  gint                  channels;
  gint                  blocks;
  gboolean              eac;
  gboolean              sent_codec_tag;
  volatile gint         align;
  GstPadChainFunction   baseparse_chainfunc;
};
</STRUCT>
<STRUCT>
<NAME>GstAc3ParseClass</NAME>
struct _GstAc3ParseClass {
  GstBaseParseClass baseparse_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_ac3_parse_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_AMR_PARSE</NAME>
#define GST_TYPE_AMR_PARSE \
  (gst_amr_parse_get_type())
</MACRO>
<MACRO>
<NAME>GST_AMR_PARSE</NAME>
#define GST_AMR_PARSE(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj), GST_TYPE_AMR_PARSE, GstAmrParse))
</MACRO>
<MACRO>
<NAME>GST_AMR_PARSE_CLASS</NAME>
#define GST_AMR_PARSE_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass), GST_TYPE_AMR_PARSE, GstAmrParseClass))
</MACRO>
<MACRO>
<NAME>GST_IS_AMR_PARSE</NAME>
#define GST_IS_AMR_PARSE(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj), GST_TYPE_AMR_PARSE))
</MACRO>
<MACRO>
<NAME>GST_IS_AMR_PARSE_CLASS</NAME>
#define GST_IS_AMR_PARSE_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass), GST_TYPE_AMR_PARSE))
</MACRO>
<STRUCT>
<NAME>GstAmrParse</NAME>
struct _GstAmrParse {
  GstBaseParse element;
  const gint *block_size;
  gboolean need_header;
  gboolean sent_codec_tag;
  gint header;
  gboolean wide;
};
</STRUCT>
<STRUCT>
<NAME>GstAmrParseClass</NAME>
struct _GstAmrParseClass {
  GstBaseParseClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_amr_parse_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_FLAC_PARSE</NAME>
#define GST_TYPE_FLAC_PARSE		   (gst_flac_parse_get_type())
</MACRO>
<MACRO>
<NAME>GST_FLAC_PARSE</NAME>
#define GST_FLAC_PARSE(obj)		   (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_FLAC_PARSE,GstFlacParse))
</MACRO>
<MACRO>
<NAME>GST_FLAC_PARSE_CLASS</NAME>
#define GST_FLAC_PARSE_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_FLAC_PARSE,GstFlacParseClass))
</MACRO>
<MACRO>
<NAME>GST_FLAC_PARSE_GET_CLASS</NAME>
#define GST_FLAC_PARSE_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS((obj),GST_TYPE_FLAC_PARSE,GstFlacParseClass))
</MACRO>
<MACRO>
<NAME>GST_IS_FLAC_PARSE</NAME>
#define GST_IS_FLAC_PARSE(obj)	   (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_FLAC_PARSE))
</MACRO>
<MACRO>
<NAME>GST_IS_FLAC_PARSE_CLASS</NAME>
#define GST_IS_FLAC_PARSE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_FLAC_PARSE))
</MACRO>
<MACRO>
<NAME>GST_FLAC_PARSE_CAST</NAME>
#define GST_FLAC_PARSE_CAST(obj)	((GstFlacParse *)(obj))
</MACRO>
<ENUM>
<NAME>GstFlacParseState</NAME>
typedef enum {
  GST_FLAC_PARSE_STATE_INIT,
  GST_FLAC_PARSE_STATE_HEADERS,
  GST_FLAC_PARSE_STATE_GENERATE_HEADERS,
  GST_FLAC_PARSE_STATE_DATA
} GstFlacParseState;
</ENUM>
<STRUCT>
<NAME>GstFlacParseSubFrame</NAME>
typedef struct {
  guint8 type;
} GstFlacParseSubFrame;
</STRUCT>
<STRUCT>
<NAME>GstFlacParse</NAME>
struct _GstFlacParse {
  GstBaseParse parent;

  /* Properties */
  gboolean check_frame_checksums;

  GstFlacParseState state;

  gint64 upstream_length;

  /* STREAMINFO content */
  guint16 min_blocksize, max_blocksize;
  guint32 min_framesize, max_framesize;
  guint32 samplerate;
  guint8 channels;
  guint8 bps;
  guint64 total_samples;

  /* Current frame */
  guint64 offset;
  guint8 blocking_strategy;
  guint16 block_size;
  guint64 sample_number;
  guint64 first_sample_number;
  gboolean strategy_checked;

  gboolean sent_codec_tag;

  GstTagList *tags;
  GstToc *toc;

  GList *headers;
  GstBuffer *seektable;

  gboolean force_variable_block_size;

  gsize header_size;
  gsize byte_offset;
  gboolean byte_mode;
};
</STRUCT>
<STRUCT>
<NAME>GstFlacParseClass</NAME>
struct _GstFlacParseClass {
  GstBaseParseClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_flac_parse_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_DCA_PARSE</NAME>
#define GST_TYPE_DCA_PARSE \
  (gst_dca_parse_get_type())
</MACRO>
<MACRO>
<NAME>GST_DCA_PARSE</NAME>
#define GST_DCA_PARSE(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj), GST_TYPE_DCA_PARSE, GstDcaParse))
</MACRO>
<MACRO>
<NAME>GST_DCA_PARSE_CLASS</NAME>
#define GST_DCA_PARSE_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass), GST_TYPE_DCA_PARSE, GstDcaParseClass))
</MACRO>
<MACRO>
<NAME>GST_IS_DCA_PARSE</NAME>
#define GST_IS_DCA_PARSE(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj), GST_TYPE_DCA_PARSE))
</MACRO>
<MACRO>
<NAME>GST_IS_DCA_PARSE_CLASS</NAME>
#define GST_IS_DCA_PARSE_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass), GST_TYPE_DCA_PARSE))
</MACRO>
<MACRO>
<NAME>DCA_MIN_FRAMESIZE</NAME>
#define DCA_MIN_FRAMESIZE 96
</MACRO>
<MACRO>
<NAME>DCA_MAX_FRAMESIZE</NAME>
#define DCA_MAX_FRAMESIZE 18725 /* 16384*16/14 */
</MACRO>
<STRUCT>
<NAME>GstDcaParse</NAME>
struct _GstDcaParse {
  GstBaseParse baseparse;

  /*< private >*/
  gint                  rate;
  gint                  channels;
  gint                  depth;
  gint                  endianness;
  gint                  block_size;
  gint                  frame_size;

  gboolean              sent_codec_tag;

  guint32               last_sync;

  GstPadChainFunction   baseparse_chainfunc;
};
</STRUCT>
<STRUCT>
<NAME>GstDcaParseClass</NAME>
struct _GstDcaParseClass {
  GstBaseParseClass baseparse_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_dca_parse_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_MPEG_AUDIO_PARSE</NAME>
#define GST_TYPE_MPEG_AUDIO_PARSE \
  (gst_mpeg_audio_parse_get_type())
</MACRO>
<MACRO>
<NAME>GST_MPEG_AUDIO_PARSE</NAME>
#define GST_MPEG_AUDIO_PARSE(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj), GST_TYPE_MPEG_AUDIO_PARSE, GstMpegAudioParse))
</MACRO>
<MACRO>
<NAME>GST_MPEG_AUDIO_PARSE_CLASS</NAME>
#define GST_MPEG_AUDIO_PARSE_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass), GST_TYPE_MPEG_AUDIO_PARSE, GstMpegAudioParseClass))
</MACRO>
<MACRO>
<NAME>GST_IS_MPEG_AUDIO_PARSE</NAME>
#define GST_IS_MPEG_AUDIO_PARSE(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj), GST_TYPE_MPEG_AUDIO_PARSE))
</MACRO>
<MACRO>
<NAME>GST_IS_MPEG_AUDIO_PARSE_CLASS</NAME>
#define GST_IS_MPEG_AUDIO_PARSE_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass), GST_TYPE_MPEG_AUDIO_PARSE))
</MACRO>
<STRUCT>
<NAME>GstMpegAudioParse</NAME>
struct _GstMpegAudioParse {
  GstBaseParse baseparse;

  /*< private >*/
  gint         rate;
  gint         channels;
  gint         layer;
  gint         version;

  GstClockTime max_bitreservoir;
  /* samples per frame */
  gint        spf;

  gint         freerate;

  gboolean     sent_codec_tag;
  guint        last_posted_bitrate;
  gint         last_posted_crc, last_crc;
  guint        last_posted_channel_mode, last_mode;

  /* Bitrate from non-vbr headers */
  guint32      hdr_bitrate;

  /* Xing info */
  guint32      xing_flags;
  guint32      xing_frames;
  GstClockTime xing_total_time;
  guint32      xing_bytes;
  /* percent -> filepos mapping */
  guchar       xing_seek_table[100];
  /* filepos -> percent mapping */
  guint16      xing_seek_table_inverse[256];
  guint32      xing_vbr_scale;
  guint        xing_bitrate;

  /* VBRI info */
  guint32      vbri_frames;
  GstClockTime vbri_total_time;
  guint32      vbri_bytes;
  guint        vbri_bitrate;
  guint        vbri_seek_points;
  guint32     *vbri_seek_table;
  gboolean     vbri_valid;

  /* LAME info */
  guint32      encoder_delay;
  guint32      encoder_padding;
};
</STRUCT>
<STRUCT>
<NAME>GstMpegAudioParseClass</NAME>
struct _GstMpegAudioParseClass {
  GstBaseParseClass baseparse_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_mpeg_audio_parse_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_AU_PARSE</NAME>
#define GST_TYPE_AU_PARSE \
  (gst_au_parse_get_type())
</MACRO>
<MACRO>
<NAME>GST_AU_PARSE</NAME>
#define GST_AU_PARSE(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_AU_PARSE,GstAuParse))
</MACRO>
<MACRO>
<NAME>GST_AU_PARSE_CLASS</NAME>
#define GST_AU_PARSE_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_AU_PARSE,GstAuParseClass))
</MACRO>
<MACRO>
<NAME>GST_IS_AU_PARSE</NAME>
#define GST_IS_AU_PARSE(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_AU_PARSE))
</MACRO>
<MACRO>
<NAME>GST_IS_AU_PARSE_CLASS</NAME>
#define GST_IS_AU_PARSE_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_AU_PARSE))
</MACRO>
<STRUCT>
<NAME>GstAuParse</NAME>
struct _GstAuParse {
  GstElement element;

  GstPad     *sinkpad;
  GstPad     *srcpad;

  GstCaps    *src_caps;

  GstAdapter *adapter;

  GstSegment  segment;
  gboolean    need_segment;

  gint64      offset;        /* where sample data starts */
  gint64      buffer_offset;
  guint       sample_size;
  guint       encoding;
  guint       samplerate;
  guint       channels;
};
</STRUCT>
<STRUCT>
<NAME>GstAuParseClass</NAME>
struct _GstAuParseClass {
  GstElementClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_au_parse_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_AUTO_AUDIO_SINK</NAME>
#define GST_TYPE_AUTO_AUDIO_SINK \
  (gst_auto_audio_sink_get_type ())
</MACRO>
<MACRO>
<NAME>GST_AUTO_AUDIO_SINK</NAME>
#define GST_AUTO_AUDIO_SINK(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST ((obj), GST_TYPE_AUTO_AUDIO_SINK, \
                               GstAutoAudioSink))
</MACRO>
<MACRO>
<NAME>GST_AUTO_AUDIO_SINK_CLASS</NAME>
#define GST_AUTO_AUDIO_SINK_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST ((klass), GST_TYPE_AUTO_AUDIO_SINK, \
                            GstAutoAudioSinkClass))
</MACRO>
<MACRO>
<NAME>GST_IS_AUTO_AUDIO_SINK</NAME>
#define GST_IS_AUTO_AUDIO_SINK(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GST_TYPE_AUTO_AUDIO_SINK))
</MACRO>
<MACRO>
<NAME>GST_IS_AUTO_AUDIO_SINK_CLASS</NAME>
#define GST_IS_AUTO_AUDIO_SINK_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE ((klass), GST_TYPE_AUTO_AUDIO_SINK))
</MACRO>
<STRUCT>
<NAME>GstAutoAudioSink</NAME>
typedef struct _GstAutoAudioSink {
  GstAutoDetect parent;

  GstClockTimeDiff ts_offset;
} GstAutoAudioSink;
</STRUCT>
<STRUCT>
<NAME>GstAutoAudioSinkClass</NAME>
typedef struct _GstAutoAudioSinkClass {
  GstAutoDetectClass parent_class;
} GstAutoAudioSinkClass;
</STRUCT>
<FUNCTION>
<NAME>gst_auto_audio_sink_get_type</NAME>
<RETURNS>GType    </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_AUTO_AUDIO_SRC</NAME>
#define GST_TYPE_AUTO_AUDIO_SRC \
  (gst_auto_audio_src_get_type ())
</MACRO>
<MACRO>
<NAME>GST_AUTO_AUDIO_SRC</NAME>
#define GST_AUTO_AUDIO_SRC(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST ((obj), GST_TYPE_AUTO_AUDIO_SRC, \
                               GstAutoAudioSrc))
</MACRO>
<MACRO>
<NAME>GST_AUTO_AUDIO_SRC_CLASS</NAME>
#define GST_AUTO_AUDIO_SRC_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST ((klass), GST_TYPE_AUTO_AUDIO_SRC, \
                            GstAutoAudioSrcClass))
</MACRO>
<MACRO>
<NAME>GST_IS_AUTO_AUDIO_SRC</NAME>
#define GST_IS_AUTO_AUDIO_SRC(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GST_TYPE_AUTO_AUDIO_SRC))
</MACRO>
<MACRO>
<NAME>GST_IS_AUTO_AUDIO_SRC_CLASS</NAME>
#define GST_IS_AUTO_AUDIO_SRC_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE ((klass), GST_TYPE_AUTO_AUDIO_SRC))
</MACRO>
<STRUCT>
<NAME>GstAutoAudioSrc</NAME>
typedef struct _GstAutoAudioSrc {
  GstAutoDetect parent;
} GstAutoAudioSrc;
</STRUCT>
<STRUCT>
<NAME>GstAutoAudioSrcClass</NAME>
typedef struct _GstAutoAudioSrcClass {
  GstAutoDetectClass parent_class;
} GstAutoAudioSrcClass;
</STRUCT>
<FUNCTION>
<NAME>gst_auto_audio_src_get_type</NAME>
<RETURNS>GType    </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_AUTO_VIDEO_SINK</NAME>
#define GST_TYPE_AUTO_VIDEO_SINK \
  (gst_auto_video_sink_get_type ())
</MACRO>
<MACRO>
<NAME>GST_AUTO_VIDEO_SINK</NAME>
#define GST_AUTO_VIDEO_SINK(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST ((obj), GST_TYPE_AUTO_VIDEO_SINK, \
                               GstAutoVideoSink))
</MACRO>
<MACRO>
<NAME>GST_AUTO_VIDEO_SINK_CLASS</NAME>
#define GST_AUTO_VIDEO_SINK_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST ((klass), GST_TYPE_AUTO_VIDEO_SINK, \
                            GstAutoVideoSinkClass))
</MACRO>
<MACRO>
<NAME>GST_IS_AUTO_VIDEO_SINK</NAME>
#define GST_IS_AUTO_VIDEO_SINK(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GST_TYPE_AUTO_VIDEO_SINK))
</MACRO>
<MACRO>
<NAME>GST_IS_AUTO_VIDEO_SINK_CLASS</NAME>
#define GST_IS_AUTO_VIDEO_SINK_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE ((klass), GST_TYPE_AUTO_VIDEO_SINK))
</MACRO>
<STRUCT>
<NAME>GstAutoVideoSink</NAME>
typedef struct _GstAutoVideoSink {
  GstAutoDetect parent;

  GstClockTimeDiff ts_offset;
} GstAutoVideoSink;
</STRUCT>
<STRUCT>
<NAME>GstAutoVideoSinkClass</NAME>
typedef struct _GstAutoVideoSinkClass {
  GstAutoDetectClass parent_class;
} GstAutoVideoSinkClass;
</STRUCT>
<FUNCTION>
<NAME>gst_auto_video_sink_get_type</NAME>
<RETURNS>GType    </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_AUTO_VIDEO_SRC</NAME>
#define GST_TYPE_AUTO_VIDEO_SRC \
  (gst_auto_video_src_get_type ())
</MACRO>
<MACRO>
<NAME>GST_AUTO_VIDEO_SRC</NAME>
#define GST_AUTO_VIDEO_SRC(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST ((obj), GST_TYPE_AUTO_VIDEO_SRC, \
                               GstAutoVideoSrc))
</MACRO>
<MACRO>
<NAME>GST_AUTO_VIDEO_SRC_CLASS</NAME>
#define GST_AUTO_VIDEO_SRC_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST ((klass), GST_TYPE_AUTO_VIDEO_SRC, \
                            GstAutoVideoSrcClass))
</MACRO>
<MACRO>
<NAME>GST_IS_AUTO_VIDEO_SRC</NAME>
#define GST_IS_AUTO_VIDEO_SRC(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GST_TYPE_AUTO_VIDEO_SRC))
</MACRO>
<MACRO>
<NAME>GST_IS_AUTO_VIDEO_SRC_CLASS</NAME>
#define GST_IS_AUTO_VIDEO_SRC_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE ((klass), GST_TYPE_AUTO_VIDEO_SRC))
</MACRO>
<STRUCT>
<NAME>GstAutoVideoSrc</NAME>
typedef struct _GstAutoVideoSrc {
  GstAutoDetect parent;
} GstAutoVideoSrc;
</STRUCT>
<STRUCT>
<NAME>GstAutoVideoSrcClass</NAME>
typedef struct _GstAutoVideoSrcClass {
  GstAutoDetectClass parent_class;
} GstAutoVideoSrcClass;
</STRUCT>
<FUNCTION>
<NAME>gst_auto_video_src_get_type</NAME>
<RETURNS>GType    </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_AVI_DEMUX</NAME>
#define GST_TYPE_AVI_DEMUX \
  (gst_avi_demux_get_type ())
</MACRO>
<MACRO>
<NAME>GST_AVI_DEMUX</NAME>
#define GST_AVI_DEMUX(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST ((obj), GST_TYPE_AVI_DEMUX, GstAviDemux))
</MACRO>
<MACRO>
<NAME>GST_AVI_DEMUX_CLASS</NAME>
#define GST_AVI_DEMUX_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST ((klass), GST_TYPE_AVI_DEMUX, GstAviDemuxClass))
</MACRO>
<MACRO>
<NAME>GST_IS_AVI_DEMUX</NAME>
#define GST_IS_AVI_DEMUX(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GST_TYPE_AVI_DEMUX))
</MACRO>
<MACRO>
<NAME>GST_IS_AVI_DEMUX_CLASS</NAME>
#define GST_IS_AVI_DEMUX_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE ((klass), GST_TYPE_AVI_DEMUX))
</MACRO>
<MACRO>
<NAME>GST_AVI_DEMUX_MAX_STREAMS</NAME>
#define GST_AVI_DEMUX_MAX_STREAMS       16
</MACRO>
<MACRO>
<NAME>CHUNKID_TO_STREAMNR</NAME>
#define CHUNKID_TO_STREAMNR(chunkid) \
  ((((chunkid) & 0xff) - '0') * 10 + \
   (((chunkid) >> 8) & 0xff) - '0')
</MACRO>
<STRUCT>
<NAME>GstAviIndexEntry</NAME>
typedef struct {
  guint32        flags;
  guint32        size;    /* bytes of the data */
  guint64        offset;  /* data offset in file */
  guint64        total;   /* total bytes before */
} GstAviIndexEntry;
</STRUCT>
<STRUCT>
<NAME>GstAviStream</NAME>
typedef struct {
  /* index of this streamcontext */
  guint          num;

  /* pad*/
  GstPad        *pad;
  gboolean       exposed;

  /* stream info and headers */
  gst_riff_strh *strh;
  union {
    gst_riff_strf_vids *vids;
    gst_riff_strf_auds *auds;
    gst_riff_strf_iavs *iavs;
    gpointer     data;
  } strf;
  GstBuffer     *extradata, *initdata;
  GstBuffer     *rgb8_palette;
  gchar         *name;

  /* the start/step/stop entries */
  guint          start_entry;
  guint          step_entry;
  guint          stop_entry;

  /* current index entry */
  guint          current_entry;
  /* position (byte, frame, time) for current_entry */
  guint          current_total;
  GstClockTime   current_timestamp;
  GstClockTime   current_ts_end;
  guint64        current_offset;
  guint64        current_offset_end;

  gboolean       discont;

  /* stream length */
  guint64        total_bytes;
  guint32        total_blocks;
  guint          n_keyframes;
  /* stream length according to index */
  GstClockTime   idx_duration;
  /* stream length according to header */
  GstClockTime   hdr_duration;
  /* stream length based on header/index */
  GstClockTime   duration;

  /* VBR indicator */
  gboolean       is_vbr;

  /* openDML support (for files >4GB) */
  gboolean       superindex;
  guint64       *indexes;

  /* new indexes */
  GstAviIndexEntry *index;     /* array with index entries */
  guint             idx_n;     /* number of entries */
  guint             idx_max;   /* max allocated size of entries */

  GstTagList	*taglist;

  gint           index_id;
  gboolean is_raw;
  gsize alignment;
} GstAviStream;
</STRUCT>
<ENUM>
<NAME>GstAviDemuxState</NAME>
typedef enum {
  GST_AVI_DEMUX_START,
  GST_AVI_DEMUX_HEADER,
  GST_AVI_DEMUX_MOVI,
  GST_AVI_DEMUX_SEEK,
} GstAviDemuxState;
</ENUM>
<ENUM>
<NAME>GstAviDemuxHeaderState</NAME>
typedef enum {
  GST_AVI_DEMUX_HEADER_TAG_LIST,
  GST_AVI_DEMUX_HEADER_AVIH,
  GST_AVI_DEMUX_HEADER_ELEMENTS,
  GST_AVI_DEMUX_HEADER_INFO,
  GST_AVI_DEMUX_HEADER_JUNK,
  GST_AVI_DEMUX_HEADER_DATA
} GstAviDemuxHeaderState;
</ENUM>
<STRUCT>
<NAME>GstAviDemux</NAME>
typedef struct _GstAviDemux {
  GstElement     parent;

  /* pads */
  GstPad        *sinkpad;

  /* AVI decoding state */
  GstAviDemuxState state;
  GstAviDemuxHeaderState header_state;
  guint64        offset;
  gboolean       abort_buffering;

  /* when we loaded the indexes */
  gboolean       have_index;
  /* index offset in the file */
  guint64        index_offset;

  /* streams */
  GstAviStream   stream[GST_AVI_DEMUX_MAX_STREAMS];
  guint          num_streams;
  guint          num_v_streams;
  guint          num_a_streams;
  guint          num_t_streams;   /* subtitle text streams */
  guint          num_sp_streams;  /* subpicture streams */

  guint          main_stream; /* used for seeking */

  GstFlowCombiner *flowcombiner;

  gboolean       have_group_id;
  guint          group_id;

  /* for streaming mode */
  gboolean       streaming;
  gboolean       have_eos;
  GstAdapter    *adapter;
  guint          todrop;

  /* some stream info for length */
  gst_riff_avih *avih;
  GstClockTime   duration;

  /* segment in TIME */
  GstSegment     segment;
  guint32        segment_seqnum;

  /* pending tags/events */
  GstEvent      *seg_event;
  GstTagList	*globaltags;
  gboolean	 got_tags;

#if 0
  /* gst index support */
  GstIndex      *element_index;
  gint           index_id;
#endif

  gboolean       seekable;

  guint64        first_movi_offset;
  guint64        idx1_offset; /* offset in file of list/chunk after movi */
  GstEvent      *seek_event;

  gboolean       building_index;
  guint          odml_stream;
  guint          odml_subidx;
  guint64       *odml_subidxs;

  guint64        seek_kf_offset; /* offset of the keyframe to which we want to seek */
} GstAviDemux;
</STRUCT>
<STRUCT>
<NAME>GstAviDemuxClass</NAME>
typedef struct _GstAviDemuxClass {
  GstElementClass parent_class;
} GstAviDemuxClass;
</STRUCT>
<FUNCTION>
<NAME>gst_avi_demux_get_type</NAME>
<RETURNS>GType            </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_AVI_MUX</NAME>
#define GST_TYPE_AVI_MUX \
  (gst_avi_mux_get_type())
</MACRO>
<MACRO>
<NAME>GST_AVI_MUX</NAME>
#define GST_AVI_MUX(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_AVI_MUX,GstAviMux))
</MACRO>
<MACRO>
<NAME>GST_AVI_MUX_CLASS</NAME>
#define GST_AVI_MUX_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_AVI_MUX,GstAviMuxClass))
</MACRO>
<MACRO>
<NAME>GST_IS_AVI_MUX</NAME>
#define GST_IS_AVI_MUX(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_AVI_MUX))
</MACRO>
<MACRO>
<NAME>GST_IS_AVI_MUX_CLASS</NAME>
#define GST_IS_AVI_MUX_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_AVI_MUX))
</MACRO>
<MACRO>
<NAME>GST_AVI_INDEX_OF_INDEXES</NAME>
#define GST_AVI_INDEX_OF_INDEXES     0
</MACRO>
<MACRO>
<NAME>GST_AVI_INDEX_OF_CHUNKS</NAME>
#define GST_AVI_INDEX_OF_CHUNKS      1
</MACRO>
<MACRO>
<NAME>GST_AVI_SUPERINDEX_COUNT</NAME>
#define GST_AVI_SUPERINDEX_COUNT    32
</MACRO>
<MACRO>
<NAME>GST_AVI_MAX_SIZE</NAME>
#define GST_AVI_MAX_SIZE    0x40000000
</MACRO>
<STRUCT>
<NAME>gst_avi_superindex_entry</NAME>
typedef struct _gst_avi_superindex_entry {
  guint64 offset;
  guint32 size;
  guint32 duration;
} gst_avi_superindex_entry;
</STRUCT>
<STRUCT>
<NAME>gst_riff_strh_full</NAME>
typedef struct _gst_riff_strh_full {
  gst_riff_strh  parent;
  /* rcFrame, RECT structure (struct of 4 shorts) */
  gint16  left;
  gint16  top;
  gint16  right;
  gint16  bottom;
} gst_riff_strh_full;
</STRUCT>
<USER_FUNCTION>
<NAME>GstAviPadHook</NAME>
<RETURNS>GstFlowReturn </RETURNS>
GstAviMux * avi, GstAviPad * avipad,
                                        GstBuffer * buffer
</USER_FUNCTION>
<STRUCT>
<NAME>GstAviPad</NAME>
struct _GstAviPad {
  /* do not extend, link to it */
  /* is NULL if original sink request pad has been removed */
  GstCollectData *collect;

  /* type */
  gboolean is_video;
  gboolean connected;

  /* chunk tag */
  gchar *tag;

  /* stream header */
  gst_riff_strh hdr;

  /* odml super indexes */
  gst_avi_superindex_entry idx[GST_AVI_SUPERINDEX_COUNT];
  gint idx_index;
  gchar *idx_tag;

  /* stream specific hook */
  GstAviPadHook hook;
};
</STRUCT>
<STRUCT>
<NAME>GstAviVideoPad</NAME>
typedef struct _GstAviVideoPad {
  GstAviPad parent;

  /* stream format */
  gst_riff_strf_vids vids;
  /* extra data */
  GstBuffer *vids_codec_data;
  /* ODML video properties */
  gst_riff_vprp vprp;

  GstBuffer *prepend_buffer;

} GstAviVideoPad;
</STRUCT>
<STRUCT>
<NAME>GstAviAudioPad</NAME>
typedef struct _GstAviAudioPad {
  GstAviPad parent;

  /* stream format */
  gst_riff_strf_auds auds;
  /* audio info for bps calculation */
  guint32 audio_size;
  guint64 audio_time;
  /* max audio chunk size for vbr */
  guint32 max_audio_chunk;

  /* counts the number of samples to put in indx chunk
   * useful for raw audio where usually there are more than
   * 1 sample in each GstBuffer */
  gint samples;

  /* extra data */
  GstBuffer *auds_codec_data;
} GstAviAudioPad;
</STRUCT>
<STRUCT>
<NAME>GstAviCollectData</NAME>
typedef struct _GstAviCollectData {
  /* extend the CollectData */
  GstCollectData collect;

  GstAviPad      *avipad;
} GstAviCollectData;
</STRUCT>
<STRUCT>
<NAME>GstAviMux</NAME>
struct _GstAviMux {
  GstElement element;

  /* pads */
  GstPad              *srcpad;
  /* sinkpads, video first */
  GSList              *sinkpads;
  /* video restricted to 1 pad */
  guint               video_pads, audio_pads;
  GstCollectPads     *collect;

  /* the AVI header */
  /* still some single stream video data in mux struct */
  gst_riff_avih avi_hdr;
  /* total number of (video) frames */
  guint32 total_frames;
  /* amount of total data (bytes) */
  guint64 total_data;
  /* amount of data (bytes) in the AVI/AVIX block;
   * actually the movi list, so counted from and including the movi tag */
  guint32 data_size, datax_size;
  /* num (video) frames in the AVI/AVIX block */
  guint32 num_frames, numx_frames;
  /* size of hdrl list, including tag as usual */

  /* total size of extra codec data */
  guint32 codec_data_size;
  /* state info */
  gboolean write_header;
  gboolean restart;

  /* tags */
  GstTagList *tags_snap;

  /* information about the AVI index ('idx') */
  gst_riff_index_entry *idx;
  gint idx_index, idx_count;
  /* offset of *chunk* (relative to a base offset); entered in the index */
  guint32 idx_offset;
  /* size of idx1 chunk (including! chunk header and size bytes) */
  guint32 idx_size;

  /* are we a big file already? */
  gboolean is_bigfile;
  guint64 avix_start;

  /* whether to use "large AVI files" or just stick to small indexed files */
  gboolean enable_large_avi;
};
</STRUCT>
<STRUCT>
<NAME>GstAviMuxClass</NAME>
struct _GstAviMuxClass {
  GstElementClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_avi_mux_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_AVI_SUBTITLE</NAME>
#define GST_TYPE_AVI_SUBTITLE (gst_avi_subtitle_get_type ())
</MACRO>
<MACRO>
<NAME>GST_AVI_SUBTITLE</NAME>
#define GST_AVI_SUBTITLE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), GST_TYPE_AVI_SUBTITLE, GstAviSubtitle))
</MACRO>
<MACRO>
<NAME>GST_AVI_SUBTITLE_CLASS</NAME>
#define GST_AVI_SUBTITLE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), GST_TYPE_AVI_SUBTITLE, GstAviSubtitleClass))
</MACRO>
<MACRO>
<NAME>GST_IS_AVI_SUBTITLE</NAME>
#define GST_IS_AVI_SUBTITLE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GST_TYPE_AVI_SUBTITLE))
</MACRO>
<MACRO>
<NAME>GST_IS_AVI_SUBTITLE_CLASS</NAME>
#define GST_IS_AVI_SUBTITLE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GST_TYPE_AVI_SUBTITLE))
</MACRO>
<MACRO>
<NAME>GST_AVI_SUBTITLE_GET_CLASS</NAME>
#define GST_AVI_SUBTITLE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), GST_TYPE_AVI_SUBTITLE, GstAviSubtitleClass))
</MACRO>
<FUNCTION>
<NAME>gst_avi_subtitle_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<STRUCT>
<NAME>GstAviSubtitle</NAME>
struct _GstAviSubtitle
{
  GstElement parent;

  GstPad    *src;
  GstPad    *sink;

  GstBuffer *subfile;  /* the complete subtitle file in one buffer */
};
</STRUCT>
<STRUCT>
<NAME>GstAviSubtitleClass</NAME>
struct _GstAviSubtitleClass
{
  GstElementClass parent;
};
</STRUCT>
<MACRO>
<NAME>GST_TYPE_CUTTER</NAME>
#define GST_TYPE_CUTTER \
  (gst_cutter_get_type())
</MACRO>
<MACRO>
<NAME>GST_CUTTER</NAME>
#define GST_CUTTER(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_CUTTER,GstCutter))
</MACRO>
<MACRO>
<NAME>GST_CUTTER_CLASS</NAME>
#define GST_CUTTER_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_CUTTER,GstCutterClass))
</MACRO>
<MACRO>
<NAME>GST_IS_CUTTER</NAME>
#define GST_IS_CUTTER(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_CUTTER))
</MACRO>
<MACRO>
<NAME>GST_IS_CUTTER_CLASS</NAME>
#define GST_IS_CUTTER_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_CUTTER))
</MACRO>
<STRUCT>
<NAME>GstCutter</NAME>
struct _GstCutter
{
  GstElement element;

  GstPad *sinkpad, *srcpad;

  double threshold_level;       /* level below which to cut */
  double threshold_length;      /* how long signal has to remain
                                 * below this level before cutting */
  double silent_run_length;     /* how long has it been below threshold ? */
  gboolean silent;
  gboolean silent_prev;

  double pre_length;            /* how long can the pre-record buffer be ? */
  double pre_run_length;        /* how long is it currently ? */
  GList *pre_buffer;            /* list of GstBuffers in pre-record buffer */
  gboolean leaky;               /* do we leak an overflowing prebuffer ? */

  GstAudioInfo info;
};
</STRUCT>
<STRUCT>
<NAME>GstCutterClass</NAME>
struct _GstCutterClass
{
  GstElementClass parent_class;
  void (*cut_start) (GstCutter* filter);
  void (*cut_stop) (GstCutter* filter);
};
</STRUCT>
<FUNCTION>
<NAME>gst_cutter_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_CAPS_SETTER</NAME>
#define GST_TYPE_CAPS_SETTER \
  (gst_caps_setter_get_type())
</MACRO>
<MACRO>
<NAME>GST_CAPS_SETTER</NAME>
#define GST_CAPS_SETTER(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_CAPS_SETTER,GstCapsSetter))
</MACRO>
<MACRO>
<NAME>GST_CAPS_SETTER_CLASS</NAME>
#define GST_CAPS_SETTER_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_CAPS_SETTER,GstCapsSetterClass))
</MACRO>
<MACRO>
<NAME>GST_IS_CAPS_SETTER</NAME>
#define GST_IS_CAPS_SETTER(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_CAPS_SETTER))
</MACRO>
<MACRO>
<NAME>GST_IS_CAPS_SETTER_CLASS</NAME>
#define GST_IS_CAPS_SETTER_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_CAPS_SETTER))
</MACRO>
<FUNCTION>
<NAME>gst_caps_setter_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<STRUCT>
<NAME>GstCapsSetter</NAME>
struct _GstCapsSetter
{
  GstBaseTransform parent;

  /* < private > */
  /* properties */
  GstCaps *caps;
  gboolean join;
  gboolean replace;
};
</STRUCT>
<STRUCT>
<NAME>GstCapsSetterClass</NAME>
struct _GstCapsSetterClass
{
  GstBaseTransformClass parent_class;
};
</STRUCT>
<MACRO>
<NAME>GST_TYPE_TAG_INJECT</NAME>
#define GST_TYPE_TAG_INJECT \
  (gst_tag_inject_get_type())
</MACRO>
<MACRO>
<NAME>GST_TAG_INJECT</NAME>
#define GST_TAG_INJECT(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_TAG_INJECT,GstTagInject))
</MACRO>
<MACRO>
<NAME>GST_TAG_INJECT_CLASS</NAME>
#define GST_TAG_INJECT_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_TAG_INJECT,GstTagInjectClass))
</MACRO>
<MACRO>
<NAME>GST_IS_TAG_INJECT</NAME>
#define GST_IS_TAG_INJECT(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_TAG_INJECT))
</MACRO>
<MACRO>
<NAME>GST_IS_TAG_INJECT_CLASS</NAME>
#define GST_IS_TAG_INJECT_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_TAG_INJECT))
</MACRO>
<STRUCT>
<NAME>GstTagInject</NAME>
struct _GstTagInject
{
  GstBaseTransform element;

  /*< private > */
  GstTagList *tags;
  gboolean tags_sent;
};
</STRUCT>
<STRUCT>
<NAME>GstTagInjectClass</NAME>
struct _GstTagInjectClass
{
  GstBaseTransformClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_tag_inject_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_PROGRESS_REPORT</NAME>
#define GST_TYPE_PROGRESS_REPORT \
  (gst_progress_report_get_type())
</MACRO>
<MACRO>
<NAME>GST_PROGRESS_REPORT</NAME>
#define GST_PROGRESS_REPORT(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_PROGRESS_REPORT,GstProgressReport))
</MACRO>
<MACRO>
<NAME>GST_PROGRESS_REPORT_CLASS</NAME>
#define GST_PROGRESS_REPORT_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_PROGRESS_REPORT,GstProgressReportClass))
</MACRO>
<MACRO>
<NAME>GST_IS_PROGRESS_REPORT</NAME>
#define GST_IS_PROGRESS_REPORT(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_PROGRESS_REPORT))
</MACRO>
<MACRO>
<NAME>GST_IS_PROGRESS_REPORT_CLASS</NAME>
#define GST_IS_PROGRESS_REPORT_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_PROGRESS_REPORT))
</MACRO>
<STRUCT>
<NAME>GstProgressReport</NAME>
struct _GstProgressReport
{
  GstBaseTransform basetransform;

  GstMessage *pending_msg;

  gint update_freq;
  gboolean silent;
  gboolean do_query;
  GTimeVal start_time;
  GTimeVal last_report;
  gint64 buffer_count;

  /* Format used for querying. Using a string here because the
   * format might not be registered yet when the property is set */
  gchar *format;
};
</STRUCT>
<STRUCT>
<NAME>GstProgressReportClass</NAME>
struct _GstProgressReportClass
{
  GstBaseTransformClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_progress_report_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_DEINTERLACE</NAME>
#define GST_TYPE_DEINTERLACE \
  (gst_deinterlace_get_type())
</MACRO>
<MACRO>
<NAME>GST_DEINTERLACE</NAME>
#define GST_DEINTERLACE(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_DEINTERLACE,GstDeinterlace))
</MACRO>
<MACRO>
<NAME>GST_DEINTERLACE_CLASS</NAME>
#define GST_DEINTERLACE_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_DEINTERLACE,GstDeinterlace))
</MACRO>
<MACRO>
<NAME>GST_IS_DEINTERLACE</NAME>
#define GST_IS_DEINTERLACE(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_DEINTERLACE))
</MACRO>
<MACRO>
<NAME>GST_IS_DEINTERLACE_CLASS</NAME>
#define GST_IS_DEINTERLACE_CLASS(obj) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_DEINTERLACE))
</MACRO>
<ENUM>
<NAME>GstDeinterlaceMethods</NAME>
typedef enum
{
  GST_DEINTERLACE_TOMSMOCOMP,
  GST_DEINTERLACE_GREEDY_H,
  GST_DEINTERLACE_GREEDY_L,
  GST_DEINTERLACE_VFIR,
  GST_DEINTERLACE_LINEAR,
  GST_DEINTERLACE_LINEAR_BLEND,
  GST_DEINTERLACE_SCALER_BOB,
  GST_DEINTERLACE_WEAVE,
  GST_DEINTERLACE_WEAVE_TFF,
  GST_DEINTERLACE_WEAVE_BFF
} GstDeinterlaceMethods;
</ENUM>
<ENUM>
<NAME>GstDeinterlaceFields</NAME>
typedef enum
{
  GST_DEINTERLACE_ALL,         /* All (missing data is interp.) */
  GST_DEINTERLACE_TF,          /* Top Fields Only */
  GST_DEINTERLACE_BF,          /* Bottom Fields Only */
  GST_DEINTERLACE_FIELDS_AUTO  /* Automatically detect */
} GstDeinterlaceFields;
</ENUM>
<ENUM>
<NAME>GstDeinterlaceFieldLayout</NAME>
typedef enum
{
  GST_DEINTERLACE_LAYOUT_AUTO,
  GST_DEINTERLACE_LAYOUT_TFF,
  GST_DEINTERLACE_LAYOUT_BFF
} GstDeinterlaceFieldLayout;
</ENUM>
<ENUM>
<NAME>GstDeinterlaceMode</NAME>
typedef enum {
  GST_DEINTERLACE_MODE_AUTO,
  GST_DEINTERLACE_MODE_INTERLACED,
  GST_DEINTERLACE_MODE_DISABLED,
  GST_DEINTERLACE_MODE_AUTO_STRICT
} GstDeinterlaceMode;
</ENUM>
<ENUM>
<NAME>GstDeinterlaceLocking</NAME>
typedef enum
{
  GST_DEINTERLACE_LOCKING_NONE,
  GST_DEINTERLACE_LOCKING_AUTO,
  GST_DEINTERLACE_LOCKING_ACTIVE,
  GST_DEINTERLACE_LOCKING_PASSIVE,
} GstDeinterlaceLocking;
</ENUM>
<MACRO>
<NAME>GST_DEINTERLACE_MAX_FIELD_HISTORY</NAME>
#define GST_DEINTERLACE_MAX_FIELD_HISTORY 10
</MACRO>
<MACRO>
<NAME>GST_DEINTERLACE_MAX_BUFFER_STATE_HISTORY</NAME>
#define GST_DEINTERLACE_MAX_BUFFER_STATE_HISTORY 50
</MACRO>
<STRUCT>
<NAME>TelecinePattern</NAME>
struct _TelecinePattern
{
  const gchar *nick;
  guint8 length;
  guint8 ratio_n, ratio_d;
  guint8 states[GST_DEINTERLACE_MAX_BUFFER_STATE_HISTORY];
};
</STRUCT>
<STRUCT>
<NAME>GstDeinterlaceBufferState</NAME>
struct _GstDeinterlaceBufferState
{
  GstClockTime timestamp;
  GstClockTime duration;
  guint8 state;
};
</STRUCT>
<STRUCT>
<NAME>GstDeinterlace</NAME>
struct _GstDeinterlace
{
  GstElement parent;

  GstPad *srcpad, *sinkpad;

  /* <private> */
  GstDeinterlaceMode mode;

  GstDeinterlaceFieldLayout field_layout;

  GstDeinterlaceFields fields;

  GstDeinterlaceFields user_set_fields;

  /* current state (differs when flushing/inverse telecine using weave) */
  GstDeinterlaceMethods method_id;
  /* property value */
  GstDeinterlaceMethods user_set_method_id;
  GstDeinterlaceMethod *method;

  GstVideoInfo vinfo;
  GstBufferPool *pool;
  GstAllocator *allocator;
  GstAllocationParams params;

  gboolean passthrough;
  gboolean discont;

  GstClockTime field_duration; /* Duration of one field */

  /* The most recent pictures 
     PictureHistory[0] is always the most recent.
     Pointers are NULL if the picture in question isn't valid, e.g. because
     the program just started or a picture was skipped.
   */
  GstDeinterlaceField field_history[GST_DEINTERLACE_MAX_FIELD_HISTORY];
  guint history_count;
  int cur_field_idx;

  /* Set to TRUE if we're in still frame mode,
     i.e. just forward all buffers
   */
  gboolean still_frame_mode;

  /* Last buffer that was pushed in */
  GstBuffer *last_buffer;

  /* Current segment */
  GstSegment segment;

  /* QoS stuff */
  gdouble proportion;
  GstClockTime earliest_time;
  gint64 processed;
  gint64 dropped;

  GstCaps *request_caps;

  gboolean reconfigure;
  GstDeinterlaceMode new_mode;
  GstDeinterlaceFields new_fields;

  GstDeinterlaceLocking locking;
  gint low_latency;
  gboolean drop_orphans;
  gboolean ignore_obscure;
  gboolean pattern_lock;
  gboolean pattern_refresh;
  GstDeinterlaceBufferState buf_states[GST_DEINTERLACE_MAX_BUFFER_STATE_HISTORY];
  gint state_count;
  gint pattern;
  guint8 pattern_phase;
  guint8 pattern_count;
  guint8 output_count;
  GstClockTime pattern_base_ts;
  GstClockTime pattern_buf_dur;

  gboolean need_more;
  gboolean have_eos;
};
</STRUCT>
<STRUCT>
<NAME>GstDeinterlaceClass</NAME>
struct _GstDeinterlaceClass
{
  GstElementClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_deinterlace_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_DTMF_SRC</NAME>
#define GST_TYPE_DTMF_SRC               (gst_dtmf_src_get_type())
</MACRO>
<MACRO>
<NAME>GST_DTMF_SRC</NAME>
#define GST_DTMF_SRC(obj)               (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_DTMF_SRC,GstDTMFSrc))
</MACRO>
<MACRO>
<NAME>GST_DTMF_SRC_CLASS</NAME>
#define GST_DTMF_SRC_CLASS(klass)       (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_DTMF_SRC,GstDTMFSrcClass))
</MACRO>
<MACRO>
<NAME>GST_DTMF_SRC_GET_CLASS</NAME>
#define GST_DTMF_SRC_GET_CLASS(obj)     (G_TYPE_INSTANCE_GET_CLASS ((obj), GST_TYPE_DTMF_SRC, GstDTMFSrcClass))
</MACRO>
<MACRO>
<NAME>GST_IS_DTMF_SRC</NAME>
#define GST_IS_DTMF_SRC(obj)            (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_DTMF_SRC))
</MACRO>
<MACRO>
<NAME>GST_IS_DTMF_SRC_CLASS</NAME>
#define GST_IS_DTMF_SRC_CLASS(klass)    (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_DTMF_SRC))
</MACRO>
<MACRO>
<NAME>GST_DTMF_SRC_CAST</NAME>
#define GST_DTMF_SRC_CAST(obj)          ((GstDTMFSrc *)(obj))
</MACRO>
<STRUCT>
<NAME>GstDTMFSrcEvent</NAME>
struct _GstDTMFSrcEvent
{
  GstDTMFEventType event_type;
  double sample;
  guint16 event_number;
  guint16 volume;
  guint32 packet_count;
};
</STRUCT>
<STRUCT>
<NAME>GstDTMFSrc</NAME>
struct _GstDTMFSrc
{
  /*< private >*/
  GstBaseSrc parent;
  GAsyncQueue *event_queue;
  GstDTMFSrcEvent *last_event;
  gboolean last_event_was_start;

  guint16 interval;
  GstClockTime timestamp;

  gboolean paused;
  GstClockID clockid;

  GstClockTime last_stop;

  gint sample_rate;
};
</STRUCT>
<STRUCT>
<NAME>GstDTMFSrcClass</NAME>
struct _GstDTMFSrcClass
{
  GstBaseSrcClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_dtmf_src_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_dtmf_src_plugin_init</NAME>
<RETURNS>gboolean  </RETURNS>
GstPlugin * plugin
</FUNCTION>
<STRUCT>
<NAME>GstDTMFSrcEvent</NAME>
</STRUCT>
<MACRO>
<NAME>GST_TYPE_RTP_DTMF_SRC</NAME>
#define GST_TYPE_RTP_DTMF_SRC		(gst_rtp_dtmf_src_get_type())
</MACRO>
<MACRO>
<NAME>GST_RTP_DTMF_SRC</NAME>
#define GST_RTP_DTMF_SRC(obj)		(G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_RTP_DTMF_SRC,GstRTPDTMFSrc))
</MACRO>
<MACRO>
<NAME>GST_RTP_DTMF_SRC_CLASS</NAME>
#define GST_RTP_DTMF_SRC_CLASS(klass)	(G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_RTP_DTMF_SRC,GstRTPDTMFSrcClass))
</MACRO>
<MACRO>
<NAME>GST_RTP_DTMF_SRC_GET_CLASS</NAME>
#define GST_RTP_DTMF_SRC_GET_CLASS(obj)     (G_TYPE_INSTANCE_GET_CLASS ((obj), GST_TYPE_RTP_DTMF_SRC, GstRTPDTMFSrcClass))
</MACRO>
<MACRO>
<NAME>GST_IS_RTP_DTMF_SRC</NAME>
#define GST_IS_RTP_DTMF_SRC(obj)		(G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_RTP_DTMF_SRC))
</MACRO>
<MACRO>
<NAME>GST_IS_RTP_DTMF_SRC_CLASS</NAME>
#define GST_IS_RTP_DTMF_SRC_CLASS(klass)	(G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_RTP_DTMF_SRC))
</MACRO>
<MACRO>
<NAME>GST_RTP_DTMF_SRC_CAST</NAME>
#define GST_RTP_DTMF_SRC_CAST(obj)		((GstRTPDTMFSrc *)(obj))
</MACRO>
<STRUCT>
<NAME>GstRTPDTMFSrcEvent</NAME>
struct _GstRTPDTMFSrcEvent
{
  GstRTPDTMFEventType event_type;
  GstRTPDTMFPayload *payload;
};
</STRUCT>
<STRUCT>
<NAME>GstRTPDTMFSrc</NAME>
struct _GstRTPDTMFSrc
{
  /*< private >*/
  GstBaseSrc basesrc;

  GAsyncQueue *event_queue;
  GstClockID clockid;
  gboolean paused;
  GstRTPDTMFPayload *payload;

  GstClockTime timestamp;
  GstClockTime start_timestamp;
  gboolean first_packet;
  gboolean last_packet;
  guint32 ts_base;
  guint16 seqnum_base;
  gint16 seqnum_offset;
  guint16 seqnum;
  gint32 ts_offset;
  guint32 rtp_timestamp;
  guint pt;
  guint ssrc;
  guint current_ssrc;
  guint16 ptime;
  guint16 packet_redundancy;
  guint32 clock_rate;
  gboolean last_event_was_start;

  GstClockTime last_stop;

  gboolean dirty;
  guint16 redundancy_count;
};
</STRUCT>
<STRUCT>
<NAME>GstRTPDTMFSrcClass</NAME>
struct _GstRTPDTMFSrcClass
{
  GstBaseSrcClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_rtp_dtmf_src_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_rtp_dtmf_src_plugin_init</NAME>
<RETURNS>gboolean  </RETURNS>
GstPlugin * plugin
</FUNCTION>
<STRUCT>
<NAME>GstRTPDTMFSrcEvent</NAME>
</STRUCT>
<MACRO>
<NAME>GST_TYPE_RTP_DTMF_DEPAY</NAME>
#define GST_TYPE_RTP_DTMF_DEPAY \
  (gst_rtp_dtmf_depay_get_type())
</MACRO>
<MACRO>
<NAME>GST_RTP_DTMF_DEPAY</NAME>
#define GST_RTP_DTMF_DEPAY(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_RTP_DTMF_DEPAY,GstRtpDTMFDepay))
</MACRO>
<MACRO>
<NAME>GST_RTP_DTMF_DEPAY_CLASS</NAME>
#define GST_RTP_DTMF_DEPAY_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_RTP_DTMF_DEPAY,GstRtpDTMFDepayClass))
</MACRO>
<MACRO>
<NAME>GST_IS_RTP_DTMF_DEPAY</NAME>
#define GST_IS_RTP_DTMF_DEPAY(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_RTP_DTMF_DEPAY))
</MACRO>
<MACRO>
<NAME>GST_IS_RTP_DTMF_DEPAY_CLASS</NAME>
#define GST_IS_RTP_DTMF_DEPAY_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_RTP_DTMF_DEPAY))
</MACRO>
<STRUCT>
<NAME>GstRtpDTMFDepay</NAME>
struct _GstRtpDTMFDepay
{
  /*< private >*/
  GstRTPBaseDepayload depayload;
  double sample;
  guint32 previous_ts;
  guint16 previous_duration;
  GstClockTime first_gst_ts;
  guint unit_time;
  guint max_duration;
};
</STRUCT>
<STRUCT>
<NAME>GstRtpDTMFDepayClass</NAME>
struct _GstRtpDTMFDepayClass
{
  GstRTPBaseDepayloadClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_rtp_dtmf_depay_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_rtp_dtmf_depay_plugin_init</NAME>
<RETURNS>gboolean  </RETURNS>
GstPlugin * plugin
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_AGINGTV</NAME>
#define GST_TYPE_AGINGTV \
  (gst_agingtv_get_type())
</MACRO>
<MACRO>
<NAME>GST_AGINGTV</NAME>
#define GST_AGINGTV(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_AGINGTV,GstAgingTV))
</MACRO>
<MACRO>
<NAME>GST_AGINGTV_CLASS</NAME>
#define GST_AGINGTV_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_AGINGTV,GstAgingTVClass))
</MACRO>
<MACRO>
<NAME>GST_IS_AGINGTV</NAME>
#define GST_IS_AGINGTV(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_AGINGTV))
</MACRO>
<MACRO>
<NAME>GST_IS_AGINGTV_CLASS</NAME>
#define GST_IS_AGINGTV_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_AGINGTV))
</MACRO>
<MACRO>
<NAME>SCRATCH_MAX</NAME>
#define SCRATCH_MAX 20
</MACRO>
<STRUCT>
<NAME>GstAgingTV</NAME>
struct _GstAgingTV
{
  GstVideoFilter videofilter;

  /* < private > */
  gboolean color_aging;
  gboolean pits;
  gboolean dusts;

  gint coloraging_state;

  scratch scratches[SCRATCH_MAX];
  gint scratch_lines;

  gint dust_interval;
  gint pits_interval;

};
</STRUCT>
<STRUCT>
<NAME>GstAgingTVClass</NAME>
struct _GstAgingTVClass
{
  GstVideoFilterClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_agingtv_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_DICETV</NAME>
#define GST_TYPE_DICETV \
  (gst_dicetv_get_type())
</MACRO>
<MACRO>
<NAME>GST_DICETV</NAME>
#define GST_DICETV(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_DICETV,GstDiceTV))
</MACRO>
<MACRO>
<NAME>GST_DICETV_CLASS</NAME>
#define GST_DICETV_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_DICETV,GstDiceTVClass))
</MACRO>
<MACRO>
<NAME>GST_IS_DICETV</NAME>
#define GST_IS_DICETV(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_DICETV))
</MACRO>
<MACRO>
<NAME>GST_IS_DICETV_CLASS</NAME>
#define GST_IS_DICETV_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_DICETV))
</MACRO>
<STRUCT>
<NAME>GstDiceTV</NAME>
struct _GstDiceTV
{
  GstVideoFilter videofilter;

  /* < private > */
  guint8 *dicemap;

  gint g_cube_bits;
  gint g_cube_size;
  gint g_map_height;
  gint g_map_width;
};
</STRUCT>
<STRUCT>
<NAME>GstDiceTVClass</NAME>
struct _GstDiceTVClass
{
  GstVideoFilterClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_dicetv_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_EDGETV</NAME>
#define GST_TYPE_EDGETV \
  (gst_edgetv_get_type())
</MACRO>
<MACRO>
<NAME>GST_EDGETV</NAME>
#define GST_EDGETV(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_EDGETV,GstEdgeTV))
</MACRO>
<MACRO>
<NAME>GST_EDGETV_CLASS</NAME>
#define GST_EDGETV_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_EDGETV,GstEdgeTVClass))
</MACRO>
<MACRO>
<NAME>GST_IS_EDGETV</NAME>
#define GST_IS_EDGETV(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_EDGETV))
</MACRO>
<MACRO>
<NAME>GST_IS_EDGETV_CLASS</NAME>
#define GST_IS_EDGETV_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_EDGETV))
</MACRO>
<STRUCT>
<NAME>GstEdgeTV</NAME>
struct _GstEdgeTV
{
  GstVideoFilter videofilter;

  /* < private > */
  gint map_width, map_height;
  guint32 *map;
  gint video_width_margin;
};
</STRUCT>
<STRUCT>
<NAME>GstEdgeTVClass</NAME>
struct _GstEdgeTVClass
{
  GstVideoFilterClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_edgetv_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_QUARKTV</NAME>
#define GST_TYPE_QUARKTV \
  (gst_quarktv_get_type())
</MACRO>
<MACRO>
<NAME>GST_QUARKTV</NAME>
#define GST_QUARKTV(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_QUARKTV,GstQuarkTV))
</MACRO>
<MACRO>
<NAME>GST_QUARKTV_CLASS</NAME>
#define GST_QUARKTV_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_QUARKTV,GstQuarkTVClass))
</MACRO>
<MACRO>
<NAME>GST_IS_QUARKTV</NAME>
#define GST_IS_QUARKTV(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_QUARKTV))
</MACRO>
<MACRO>
<NAME>GST_IS_QUARKTV_CLASS</NAME>
#define GST_IS_QUARKTV_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_QUARKTV))
</MACRO>
<STRUCT>
<NAME>GstQuarkTV</NAME>
struct _GstQuarkTV
{
  GstVideoFilter element;

  /* < private > */
  gint area;
  gint planes;
  gint current_plane;
  GstBuffer **planetable;
};
</STRUCT>
<STRUCT>
<NAME>GstQuarkTVClass</NAME>
struct _GstQuarkTVClass
{
  GstVideoFilterClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_quarktv_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_REVTV</NAME>
#define GST_TYPE_REVTV \
  (gst_revtv_get_type())
</MACRO>
<MACRO>
<NAME>GST_REVTV</NAME>
#define GST_REVTV(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_REVTV,GstRevTV))
</MACRO>
<MACRO>
<NAME>GST_REVTV_CLASS</NAME>
#define GST_REVTV_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_REVTV,GstRevTVClass))
</MACRO>
<MACRO>
<NAME>GST_IS_REVTV</NAME>
#define GST_IS_REVTV(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_REVTV))
</MACRO>
<MACRO>
<NAME>GST_IS_REVTV_CLASS</NAME>
#define GST_IS_REVTV_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_REVTV))
</MACRO>
<STRUCT>
<NAME>GstRevTV</NAME>
struct _GstRevTV
{
  GstVideoFilter videofilter;

  /* < private > */
  gint vgrabtime;
  gint vgrab;
  gint linespace;
  gint vscale;
};
</STRUCT>
<STRUCT>
<NAME>GstRevTVClass</NAME>
struct _GstRevTVClass
{
  GstVideoFilterClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_revtv_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_SHAGADELICTV</NAME>
#define GST_TYPE_SHAGADELICTV \
  (gst_shagadelictv_get_type())
</MACRO>
<MACRO>
<NAME>GST_SHAGADELICTV</NAME>
#define GST_SHAGADELICTV(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_SHAGADELICTV,GstShagadelicTV))
</MACRO>
<MACRO>
<NAME>GST_SHAGADELICTV_CLASS</NAME>
#define GST_SHAGADELICTV_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_SHAGADELICTV,GstShagadelicTVClass))
</MACRO>
<MACRO>
<NAME>GST_IS_SHAGADELICTV</NAME>
#define GST_IS_SHAGADELICTV(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_SHAGADELICTV))
</MACRO>
<MACRO>
<NAME>GST_IS_SHAGADELICTV_CLASS</NAME>
#define GST_IS_SHAGADELICTV_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_SHAGADELICTV))
</MACRO>
<STRUCT>
<NAME>GstShagadelicTV</NAME>
struct _GstShagadelicTV
{
  GstVideoFilter videofilter;

  /* < private > */
  guint8 *ripple;
  guint8 *spiral;
  guint8 phase;
  gint rx, ry;
  gint bx, by;
  gint rvx, rvy;
  gint bvx, bvy;
};
</STRUCT>
<STRUCT>
<NAME>GstShagadelicTVClass</NAME>
struct _GstShagadelicTVClass
{
  GstVideoFilterClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_shagadelictv_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_VERTIGOTV</NAME>
#define GST_TYPE_VERTIGOTV \
  (gst_vertigotv_get_type())
</MACRO>
<MACRO>
<NAME>GST_VERTIGOTV</NAME>
#define GST_VERTIGOTV(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_VERTIGOTV,GstVertigoTV))
</MACRO>
<MACRO>
<NAME>GST_VERTIGOTV_CLASS</NAME>
#define GST_VERTIGOTV_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_VERTIGOTV,GstVertigoTVClass))
</MACRO>
<MACRO>
<NAME>GST_IS_VERTIGOTV</NAME>
#define GST_IS_VERTIGOTV(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_VERTIGOTV))
</MACRO>
<MACRO>
<NAME>GST_IS_VERTIGOTV_CLASS</NAME>
#define GST_IS_VERTIGOTV_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_VERTIGOTV))
</MACRO>
<STRUCT>
<NAME>GstVertigoTV</NAME>
struct _GstVertigoTV
{
  GstVideoFilter videofilter;

  /* < private > */
  guint32 *buffer;
  guint32 *current_buffer, *alt_buffer;
  gint dx, dy;
  gint sx, sy;
  gdouble phase;
  gdouble phase_increment;
  gdouble zoomrate;
};
</STRUCT>
<STRUCT>
<NAME>GstVertigoTVClass</NAME>
struct _GstVertigoTVClass
{
  GstVideoFilterClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_vertigotv_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_WARPTV</NAME>
#define GST_TYPE_WARPTV \
  (gst_warptv_get_type())
</MACRO>
<MACRO>
<NAME>GST_WARPTV</NAME>
#define GST_WARPTV(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_WARPTV,GstWarpTV))
</MACRO>
<MACRO>
<NAME>GST_WARPTV_CLASS</NAME>
#define GST_WARPTV_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_WARPTV,GstWarpTVClass))
</MACRO>
<MACRO>
<NAME>GST_IS_WARPTV</NAME>
#define GST_IS_WARPTV(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_WARPTV))
</MACRO>
<MACRO>
<NAME>GST_IS_WARPTV_CLASS</NAME>
#define GST_IS_WARPTV_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_WARPTV))
</MACRO>
<STRUCT>
<NAME>GstWarpTV</NAME>
struct _GstWarpTV
{
  GstVideoFilter videofilter;

  /* < private > */
  gint32 *disttable;
  gint32 ctable[1024];
  gint tval;
};
</STRUCT>
<STRUCT>
<NAME>GstWarpTVClass</NAME>
struct _GstWarpTVClass
{
  GstVideoFilterClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_warptv_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_STREAKTV</NAME>
#define GST_TYPE_STREAKTV \
  (gst_streaktv_get_type())
</MACRO>
<MACRO>
<NAME>GST_STREAKTV</NAME>
#define GST_STREAKTV(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_STREAKTV,GstStreakTV))
</MACRO>
<MACRO>
<NAME>GST_STREAKTV_CLASS</NAME>
#define GST_STREAKTV_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_STREAKTV,GstStreakTVClass))
</MACRO>
<MACRO>
<NAME>GST_IS_STREAKTV</NAME>
#define GST_IS_STREAKTV(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_STREAKTV))
</MACRO>
<MACRO>
<NAME>GST_IS_STREAKTV_CLASS</NAME>
#define GST_IS_STREAKTV_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_STREAKTV))
</MACRO>
<MACRO>
<NAME>PLANES</NAME>
#define PLANES 32
</MACRO>
<STRUCT>
<NAME>GstStreakTV</NAME>
struct _GstStreakTV
{
  GstVideoFilter element;

  /* < private > */
  gboolean feedback;

  guint32 *planebuffer;
  guint32 *planetable[PLANES];
  gint plane;
};
</STRUCT>
<STRUCT>
<NAME>GstStreakTVClass</NAME>
struct _GstStreakTVClass
{
  GstVideoFilterClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_streaktv_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_RIPPLETV</NAME>
#define GST_TYPE_RIPPLETV \
  (gst_rippletv_get_type())
</MACRO>
<MACRO>
<NAME>GST_RIPPLETV</NAME>
#define GST_RIPPLETV(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_RIPPLETV,GstRippleTV))
</MACRO>
<MACRO>
<NAME>GST_RIPPLETV_CLASS</NAME>
#define GST_RIPPLETV_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_RIPPLETV,GstRippleTVClass))
</MACRO>
<MACRO>
<NAME>GST_IS_RIPPLETV</NAME>
#define GST_IS_RIPPLETV(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_RIPPLETV))
</MACRO>
<MACRO>
<NAME>GST_IS_RIPPLETV_CLASS</NAME>
#define GST_IS_RIPPLETV_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_RIPPLETV))
</MACRO>
<STRUCT>
<NAME>GstRippleTV</NAME>
struct _GstRippleTV
{
  GstVideoFilter element;

  /* < private > */
  gint mode;

  gint16 *background;
  guint8 *diff;

  gint *map, *map1, *map2, *map3;
  gint map_h, map_w;

  gint8 *vtable;

  gboolean bg_is_set;

  gint period;
  gint rain_stat;
  guint drop_prob;
  gint drop_prob_increment;
  gint drops_per_frame_max;
  gint drops_per_frame;
  gint drop_power;
};
</STRUCT>
<STRUCT>
<NAME>GstRippleTVClass</NAME>
struct _GstRippleTVClass
{
  GstVideoFilterClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_rippletv_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_OPTV</NAME>
#define GST_TYPE_OPTV \
  (gst_optv_get_type())
</MACRO>
<MACRO>
<NAME>GST_OPTV</NAME>
#define GST_OPTV(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_OPTV,GstOpTV))
</MACRO>
<MACRO>
<NAME>GST_OPTV_CLASS</NAME>
#define GST_OPTV_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_OPTV,GstOpTVClass))
</MACRO>
<MACRO>
<NAME>GST_IS_OPTV</NAME>
#define GST_IS_OPTV(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_OPTV))
</MACRO>
<MACRO>
<NAME>GST_IS_OPTV_CLASS</NAME>
#define GST_IS_OPTV_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_OPTV))
</MACRO>
<STRUCT>
<NAME>GstOpTV</NAME>
struct _GstOpTV
{
  GstVideoFilter element;

  /* < private > */
  gint mode;
  gint speed;
  guint threshold;

  gint8 *opmap[4];
  guint8 *diff;
  guint8 phase;
};
</STRUCT>
<STRUCT>
<NAME>GstOpTVClass</NAME>
struct _GstOpTVClass
{
  GstVideoFilterClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_optv_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_RADIOACTV</NAME>
#define GST_TYPE_RADIOACTV \
  (gst_radioactv_get_type())
</MACRO>
<MACRO>
<NAME>GST_RADIOACTV</NAME>
#define GST_RADIOACTV(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_RADIOACTV,GstRadioacTV))
</MACRO>
<MACRO>
<NAME>GST_RADIOACTV_CLASS</NAME>
#define GST_RADIOACTV_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_RADIOACTV,GstRadioacTVClass))
</MACRO>
<MACRO>
<NAME>GST_IS_RADIOACTV</NAME>
#define GST_IS_RADIOACTV(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_RADIOACTV))
</MACRO>
<MACRO>
<NAME>GST_IS_RADIOACTV_CLASS</NAME>
#define GST_IS_RADIOACTV_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_RADIOACTV))
</MACRO>
<STRUCT>
<NAME>GstRadioacTV</NAME>
struct _GstRadioacTV
{
  GstVideoFilter element;

  /* < private > */
  gint mode;
  gint color;
  guint interval;
  gboolean trigger;

  gint snaptime;

  guint32 *snapframe;
  guint8 *blurzoombuf;
  guint8 *diff;
  gint16 *background;
  gint *blurzoomx;
  gint *blurzoomy;

  gint buf_width_blocks;
  gint buf_width;
  gint buf_height;
  gint buf_area;
  gint buf_margin_right;
  gint buf_margin_left;
};
</STRUCT>
<STRUCT>
<NAME>GstRadioacTVClass</NAME>
struct _GstRadioacTVClass
{
  GstVideoFilterClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_radioactv_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_IIR_EQUALIZER</NAME>
#define GST_TYPE_IIR_EQUALIZER \
  (gst_iir_equalizer_get_type())
</MACRO>
<MACRO>
<NAME>GST_IIR_EQUALIZER</NAME>
#define GST_IIR_EQUALIZER(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_IIR_EQUALIZER,GstIirEqualizer))
</MACRO>
<MACRO>
<NAME>GST_IIR_EQUALIZER_CLASS</NAME>
#define GST_IIR_EQUALIZER_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_IIR_EQUALIZER,GstIirEqualizerClass))
</MACRO>
<MACRO>
<NAME>GST_IS_IIR_EQUALIZER</NAME>
#define GST_IS_IIR_EQUALIZER(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_IIR_EQUALIZER))
</MACRO>
<MACRO>
<NAME>GST_IS_IIR_EQUALIZER_CLASS</NAME>
#define GST_IS_IIR_EQUALIZER_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_IIR_EQUALIZER))
</MACRO>
<MACRO>
<NAME>LOWEST_FREQ</NAME>
#define LOWEST_FREQ (20.0)
</MACRO>
<MACRO>
<NAME>HIGHEST_FREQ</NAME>
#define HIGHEST_FREQ (20000.0)
</MACRO>
<USER_FUNCTION>
<NAME>ProcessFunc</NAME>
<RETURNS>void </RETURNS>
GstIirEqualizer * eq, guint8 * data, guint size,
    guint channels
</USER_FUNCTION>
<STRUCT>
<NAME>GstIirEqualizer</NAME>
struct _GstIirEqualizer
{
  GstAudioFilter audiofilter;

  /*< private >*/

  GMutex bands_lock;
  GstIirEqualizerBand **bands;

  /* properties */
  guint freq_band_count;
  /* for each band and channel */
  gpointer history;
  guint history_size;

  gboolean need_new_coefficients;

  ProcessFunc process;
};
</STRUCT>
<STRUCT>
<NAME>GstIirEqualizerClass</NAME>
struct _GstIirEqualizerClass
{
  GstAudioFilterClass audiofilter_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_iir_equalizer_compute_frequencies</NAME>
<RETURNS>void  </RETURNS>
GstIirEqualizer * equ, guint new_count
</FUNCTION>
<FUNCTION>
<NAME>gst_iir_equalizer_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<STRUCT>
<NAME>GstIirEqualizerBand</NAME>
</STRUCT>
<MACRO>
<NAME>GST_TYPE_IIR_EQUALIZER_3BANDS</NAME>
#define GST_TYPE_IIR_EQUALIZER_3BANDS \
  (gst_iir_equalizer_3bands_get_type())
</MACRO>
<MACRO>
<NAME>GST_IIR_EQUALIZER_3BANDS</NAME>
#define GST_IIR_EQUALIZER_3BANDS(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_IIR_EQUALIZER_3BANDS,GstIirEqualizer3Bands))
</MACRO>
<MACRO>
<NAME>GST_IIR_EQUALIZER_3BANDS_CLASS</NAME>
#define GST_IIR_EQUALIZER_3BANDS_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_IIR_EQUALIZER_3BANDS,GstIirEqualizer3BandsClass))
</MACRO>
<MACRO>
<NAME>GST_IS_IIR_EQUALIZER_3BANDS</NAME>
#define GST_IS_IIR_EQUALIZER_3BANDS(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_IIR_EQUALIZER_3BANDS))
</MACRO>
<MACRO>
<NAME>GST_IS_IIR_EQUALIZER_3BANDS_CLASS</NAME>
#define GST_IS_IIR_EQUALIZER_3BANDS_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_IIR_EQUALIZER_3BANDS))
</MACRO>
<STRUCT>
<NAME>GstIirEqualizer3Bands</NAME>
struct _GstIirEqualizer3Bands
{
  GstIirEqualizer equalizer;
};
</STRUCT>
<STRUCT>
<NAME>GstIirEqualizer3BandsClass</NAME>
struct _GstIirEqualizer3BandsClass
{
  GstIirEqualizerClass equalizer_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_iir_equalizer_3bands_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_IIR_EQUALIZER_10BANDS</NAME>
#define GST_TYPE_IIR_EQUALIZER_10BANDS \
  (gst_iir_equalizer_10bands_get_type())
</MACRO>
<MACRO>
<NAME>GST_IIR_EQUALIZER_10BANDS</NAME>
#define GST_IIR_EQUALIZER_10BANDS(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_IIR_EQUALIZER_10BANDS,GstIirEqualizer10Bands))
</MACRO>
<MACRO>
<NAME>GST_IIR_EQUALIZER_10BANDS_CLASS</NAME>
#define GST_IIR_EQUALIZER_10BANDS_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_IIR_EQUALIZER_10BANDS,GstIirEqualizer10BandsClass))
</MACRO>
<MACRO>
<NAME>GST_IS_IIR_EQUALIZER_10BANDS</NAME>
#define GST_IS_IIR_EQUALIZER_10BANDS(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_IIR_EQUALIZER_10BANDS))
</MACRO>
<MACRO>
<NAME>GST_IS_IIR_EQUALIZER_10BANDS_CLASS</NAME>
#define GST_IS_IIR_EQUALIZER_10BANDS_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_IIR_EQUALIZER_10BANDS))
</MACRO>
<STRUCT>
<NAME>GstIirEqualizer10Bands</NAME>
struct _GstIirEqualizer10Bands
{
  GstIirEqualizer equalizer;
};
</STRUCT>
<STRUCT>
<NAME>GstIirEqualizer10BandsClass</NAME>
struct _GstIirEqualizer10BandsClass
{
  GstIirEqualizerClass equalizer_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_iir_equalizer_10bands_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_IIR_EQUALIZER_NBANDS</NAME>
#define GST_TYPE_IIR_EQUALIZER_NBANDS \
  (gst_iir_equalizer_nbands_get_type())
</MACRO>
<MACRO>
<NAME>GST_IIR_EQUALIZER_NBANDS</NAME>
#define GST_IIR_EQUALIZER_NBANDS(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_IIR_EQUALIZER_NBANDS,GstIirEqualizerNBands))
</MACRO>
<MACRO>
<NAME>GST_IIR_EQUALIZER_NBANDS_CLASS</NAME>
#define GST_IIR_EQUALIZER_NBANDS_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_IIR_EQUALIZER_NBANDS,GstIirEqualizerNBandsClass))
</MACRO>
<MACRO>
<NAME>GST_IS_IIR_EQUALIZER_NBANDS</NAME>
#define GST_IS_IIR_EQUALIZER_NBANDS(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_IIR_EQUALIZER_NBANDS))
</MACRO>
<MACRO>
<NAME>GST_IS_IIR_EQUALIZER_NBANDS_CLASS</NAME>
#define GST_IS_IIR_EQUALIZER_NBANDS_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_IIR_EQUALIZER_NBANDS))
</MACRO>
<STRUCT>
<NAME>GstIirEqualizerNBands</NAME>
struct _GstIirEqualizerNBands
{
  GstIirEqualizer equalizer;
};
</STRUCT>
<STRUCT>
<NAME>GstIirEqualizerNBandsClass</NAME>
struct _GstIirEqualizerNBandsClass
{
  GstIirEqualizerClass equalizer_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_iir_equalizer_nbands_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_FLV_DEMUX</NAME>
#define GST_TYPE_FLV_DEMUX \
  (gst_flv_demux_get_type())
</MACRO>
<MACRO>
<NAME>GST_FLV_DEMUX</NAME>
#define GST_FLV_DEMUX(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_FLV_DEMUX,GstFlvDemux))
</MACRO>
<MACRO>
<NAME>GST_FLV_DEMUX_CLASS</NAME>
#define GST_FLV_DEMUX_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_FLV_DEMUX,GstFlvDemuxClass))
</MACRO>
<MACRO>
<NAME>GST_IS_FLV_DEMUX</NAME>
#define GST_IS_FLV_DEMUX(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_FLV_DEMUX))
</MACRO>
<MACRO>
<NAME>GST_IS_FLV_DEMUX_CLASS</NAME>
#define GST_IS_FLV_DEMUX_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_FLV_DEMUX))
</MACRO>
<ENUM>
<NAME>GstFlvDemuxState</NAME>
typedef enum
{
  FLV_STATE_HEADER,
  FLV_STATE_TAG_TYPE,
  FLV_STATE_TAG_VIDEO,
  FLV_STATE_TAG_AUDIO,
  FLV_STATE_TAG_SCRIPT,
  FLV_STATE_SEEK,
  FLV_STATE_DONE,
  FLV_STATE_SKIP,
  FLV_STATE_NONE
} GstFlvDemuxState;
</ENUM>
<STRUCT>
<NAME>GstFlvDemux</NAME>
struct _GstFlvDemux
{
  GstElement element;

  GstPad *sinkpad;

  GstPad *audio_pad;
  GstPad *video_pad;

  gboolean have_group_id;
  guint group_id;

  /* <private> */
  
  GstIndex *index;
  gint index_id;
  gboolean own_index;
  
  GArray * times;
  GArray * filepositions;

  GstAdapter *adapter;

  GstFlowCombiner *flowcombiner;

  GstSegment segment;

  GstEvent *new_seg_event;

  GstTagList *taglist;
  GstTagList *audio_tags;
  GstTagList *video_tags;

  GstFlvDemuxState state;

  guint64 offset;
  guint64 cur_tag_offset;
  GstClockTime duration;
  guint64 tag_size;
  guint64 tag_data_size;

  /* Audio infos */
  guint16 rate;
  guint16 channels;
  guint16 width;
  guint16 audio_codec_tag;
  guint64 audio_offset;
  gboolean audio_need_discont;
  gboolean audio_need_segment;
  gboolean audio_linked;
  GstBuffer * audio_codec_data;
  GstClockTime audio_start;
  guint32 last_audio_pts;
  GstClockTime audio_time_offset;

  /* Video infos */
  guint32 w;
  guint32 h;
  guint32 par_x;
  guint32 par_y;
  guint16 video_codec_tag;
  guint64 video_offset;
  gboolean video_need_discont;
  gboolean video_need_segment;
  gboolean video_linked;
  gboolean got_par;
  GstBuffer * video_codec_data;
  GstClockTime video_start;
  guint32 last_video_dts;
  GstClockTime video_time_offset;
  gdouble framerate;

  gboolean random_access;
  gboolean need_header;
  gboolean has_audio;
  gboolean has_video;
  gboolean strict;
  gboolean flushing;

  gboolean no_more_pads;

#ifndef GST_DISABLE_DEBUG
  gboolean no_audio_warned;
  gboolean no_video_warned;
#endif

  gboolean seeking;
  gboolean building_index;
  gboolean indexed; /* TRUE if index is completely built */
  gboolean upstream_seekable; /* TRUE if upstream is seekable */
  gint64 file_size;
  GstEvent *seek_event;
  gint64 seek_time;

  GstClockTime index_max_time;
  gint64 index_max_pos;

  /* reverse playback */
  GstClockTime video_first_ts;
  GstClockTime audio_first_ts;
  gboolean video_done;
  gboolean audio_done;
  gint64 from_offset;
  gint64 to_offset;
};
</STRUCT>
<STRUCT>
<NAME>GstFlvDemuxClass</NAME>
struct _GstFlvDemuxClass
{
  GstElementClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_flv_demux_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_FLV_MUX</NAME>
#define GST_TYPE_FLV_MUX \
  (gst_flv_mux_get_type ())
</MACRO>
<MACRO>
<NAME>GST_FLV_MUX</NAME>
#define GST_FLV_MUX(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST ((obj), GST_TYPE_FLV_MUX, GstFlvMux))
</MACRO>
<MACRO>
<NAME>GST_FLV_MUX_CLASS</NAME>
#define GST_FLV_MUX_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST ((klass), GST_TYPE_FLV_MUX, GstFlvMuxClass))
</MACRO>
<MACRO>
<NAME>GST_IS_FLV_MUX</NAME>
#define GST_IS_FLV_MUX(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GST_TYPE_FLV_MUX))
</MACRO>
<MACRO>
<NAME>GST_IS_FLV_MUX_CLASS</NAME>
#define GST_IS_FLV_MUX_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE ((klass), GST_TYPE_FLV_MUX))
</MACRO>
<ENUM>
<NAME>GstFlvMuxState</NAME>
typedef enum
{
  GST_FLV_MUX_STATE_HEADER,
  GST_FLV_MUX_STATE_DATA
} GstFlvMuxState;
</ENUM>
<STRUCT>
<NAME>GstFlvMux</NAME>
typedef struct _GstFlvMux {
  GstElement     element;

  GstPad         *srcpad;
  GstCollectPads *collect;

  /* <private> */
  GstFlvMuxState state;
  gboolean have_audio;
  gboolean have_video;
  gboolean streamable;
  gchar *metadatacreator;

  GstTagList *tags;
  gboolean new_tags;
  GList *index;
  guint64 byte_count;
  guint64 duration;
  gint64 first_timestamp;
} GstFlvMux;
</STRUCT>
<STRUCT>
<NAME>GstFlvMuxClass</NAME>
typedef struct _GstFlvMuxClass {
  GstElementClass parent;
} GstFlvMuxClass;
</STRUCT>
<FUNCTION>
<NAME>gst_flv_mux_get_type</NAME>
<RETURNS>GType     </RETURNS>
void
</FUNCTION>
<ENUM>
<NAME>GstFlxDecState</NAME>
typedef enum {
  GST_FLXDEC_READ_HEADER,
  GST_FLXDEC_PLAYING,
} GstFlxDecState;
</ENUM>
<STRUCT>
<NAME>GstFlxDec</NAME>
struct _GstFlxDec {
  GstElement element;

  GstPad *sinkpad, *srcpad;

  GstSegment segment;
  gboolean need_segment;

  gboolean active, new_meta;

  guint8 *delta_data, *frame_data;
  GstAdapter *adapter;
  gsize size;
  GstFlxDecState state;
  gint64 frame_time;
  gint64 next_time;
  gint64 duration;

  FlxColorSpaceConverter *converter;

  FlxHeader hdr;
};
</STRUCT>
<STRUCT>
<NAME>GstFlxDecClass</NAME>
struct _GstFlxDecClass {
  GstElementClass parent_class;
};
</STRUCT>
<MACRO>
<NAME>GST_TYPE_FLXDEC</NAME>
#define GST_TYPE_FLXDEC \
  (gst_flxdec_get_type())
</MACRO>
<MACRO>
<NAME>GST_FLXDEC</NAME>
#define GST_FLXDEC(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_FLXDEC,GstFlxDec))
</MACRO>
<MACRO>
<NAME>GST_FLXDEC_CLASS</NAME>
#define GST_FLXDEC_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_FLXDEC,GstFlxDecClass))
</MACRO>
<MACRO>
<NAME>GST_IS_FLXDEC</NAME>
#define GST_IS_FLXDEC(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_FLXDEC))
</MACRO>
<MACRO>
<NAME>GST_IS_FLXDEC_CLASS</NAME>
#define GST_IS_FLXDEC_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_FLXDEC))
</MACRO>
<FUNCTION>
<NAME>gst_flxdec_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GOOM_SAMPLES</NAME>
#define GOOM_SAMPLES 512
</MACRO>
<MACRO>
<NAME>GST_TYPE_GOOM</NAME>
#define GST_TYPE_GOOM            (gst_goom_get_type())
</MACRO>
<MACRO>
<NAME>GST_GOOM</NAME>
#define GST_GOOM(obj)            (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_GOOM,GstGoom))
</MACRO>
<MACRO>
<NAME>GST_GOOM_CLASS</NAME>
#define GST_GOOM_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_GOOM,GstGoomClass))
</MACRO>
<MACRO>
<NAME>GST_IS_GOOM</NAME>
#define GST_IS_GOOM(obj)         (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_GOOM))
</MACRO>
<MACRO>
<NAME>GST_IS_GOOM_CLASS</NAME>
#define GST_IS_GOOM_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_GOOM))
</MACRO>
<STRUCT>
<NAME>GstGoom</NAME>
struct _GstGoom
{
  GstAudioVisualizer parent;

  /* input tracking */
  gint channels;

  /* video state */
  gint width;
  gint height;

  /* goom stuff */
  PluginInfo *plugin;
};
</STRUCT>
<STRUCT>
<NAME>GstGoomClass</NAME>
struct _GstGoomClass
{
  GstAudioVisualizerClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_goom_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_goom_plugin_init</NAME>
<RETURNS>gboolean  </RETURNS>
GstPlugin * plugin
</FUNCTION>
<MACRO>
<NAME>GOOM2K1_SAMPLES</NAME>
#define GOOM2K1_SAMPLES 512
</MACRO>
<MACRO>
<NAME>GST_TYPE_GOOM2K1</NAME>
#define GST_TYPE_GOOM2K1            (gst_goom2k1_get_type())
</MACRO>
<MACRO>
<NAME>GST_GOOM2K1</NAME>
#define GST_GOOM2K1(obj)            (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_GOOM2K1,GstGoom2k1))
</MACRO>
<MACRO>
<NAME>GST_GOOM2K1_CLASS</NAME>
#define GST_GOOM2K1_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_GOOM2K1,GstGoom2k1Class))
</MACRO>
<MACRO>
<NAME>GST_IS_GOOM2K1</NAME>
#define GST_IS_GOOM2K1(obj)         (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_GOOM2K1))
</MACRO>
<MACRO>
<NAME>GST_IS_GOOM2K1_CLASS</NAME>
#define GST_IS_GOOM2K1_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_GOOM2K1))
</MACRO>
<STRUCT>
<NAME>GstGoom2k1</NAME>
struct _GstGoom2k1
{
  GstAudioVisualizer parent;

  /* input tracking */
  gint channels;

  /* video state */
  gint width;
  gint height;

  /* goom stuff */
  GoomData goomdata;
};
</STRUCT>
<STRUCT>
<NAME>GstGoom2k1Class</NAME>
struct _GstGoom2k1Class
{
  GstAudioVisualizerClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_goom2k1_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_goom2k1_plugin_init</NAME>
<RETURNS>gboolean  </RETURNS>
GstPlugin * plugin
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_ALAW_DEC</NAME>
#define GST_TYPE_ALAW_DEC \
  (gst_alaw_dec_get_type())
</MACRO>
<MACRO>
<NAME>GST_ALAW_DEC</NAME>
#define GST_ALAW_DEC(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_ALAW_DEC,GstALawDec))
</MACRO>
<MACRO>
<NAME>GST_ALAW_DEC_CLASS</NAME>
#define GST_ALAW_DEC_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_ALAW_DEC,GstALawDecClass))
</MACRO>
<MACRO>
<NAME>GST_IS_ALAW_DEC</NAME>
#define GST_IS_ALAW_DEC(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_ALAW_DEC))
</MACRO>
<MACRO>
<NAME>GST_IS_ALAW_DEC_CLASS</NAME>
#define GST_IS_ALAW_DEC_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_ALAW_DEC))
</MACRO>
<STRUCT>
<NAME>GstALawDec</NAME>
struct _GstALawDec {
  GstAudioDecoder element;
};
</STRUCT>
<STRUCT>
<NAME>GstALawDecClass</NAME>
struct _GstALawDecClass {
  GstAudioDecoderClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_alaw_dec_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_ALAW_ENC</NAME>
#define GST_TYPE_ALAW_ENC \
  (gst_alaw_enc_get_type())
</MACRO>
<MACRO>
<NAME>GST_ALAW_ENC</NAME>
#define GST_ALAW_ENC(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_ALAW_ENC,GstALawEnc))
</MACRO>
<MACRO>
<NAME>GST_ALAW_ENC_CLASS</NAME>
#define GST_ALAW_ENC_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_ALAW_ENC,GstALawEncClass))
</MACRO>
<MACRO>
<NAME>GST_IS_ALAW_ENC</NAME>
#define GST_IS_ALAW_ENC(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_ALAW_ENC))
</MACRO>
<MACRO>
<NAME>GST_IS_ALAW_ENC_CLASS</NAME>
#define GST_IS_ALAW_ENC_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_ALAW_ENC))
</MACRO>
<STRUCT>
<NAME>GstALawEnc</NAME>
struct _GstALawEnc {
  GstAudioEncoder encoder;

  gint channels;
  gint rate;
};
</STRUCT>
<STRUCT>
<NAME>GstALawEncClass</NAME>
struct _GstALawEncClass {
  GstAudioEncoderClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_alaw_enc_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_MULAWDEC</NAME>
#define GST_TYPE_MULAWDEC \
  (gst_mulawdec_get_type())
</MACRO>
<MACRO>
<NAME>GST_MULAWDEC</NAME>
#define GST_MULAWDEC(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_MULAWDEC,GstMuLawDec))
</MACRO>
<MACRO>
<NAME>GST_MULAWDEC_CLASS</NAME>
#define GST_MULAWDEC_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_MULAWDEC,GstMuLawDecClass))
</MACRO>
<MACRO>
<NAME>GST_IS_MULAWDEC</NAME>
#define GST_IS_MULAWDEC(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_MULAWDEC))
</MACRO>
<MACRO>
<NAME>GST_IS_MULAWDEC_CLASS</NAME>
#define GST_IS_MULAWDEC_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_MULAWDEC))
</MACRO>
<STRUCT>
<NAME>GstMuLawDec</NAME>
struct _GstMuLawDec
{
  GstAudioDecoder element;
};
</STRUCT>
<STRUCT>
<NAME>GstMuLawDecClass</NAME>
struct _GstMuLawDecClass
{
  GstAudioDecoderClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_mulawdec_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_MULAWENC</NAME>
#define GST_TYPE_MULAWENC \
  (gst_mulawenc_get_type())
</MACRO>
<MACRO>
<NAME>GST_MULAWENC</NAME>
#define GST_MULAWENC(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_MULAWENC,GstMuLawEnc))
</MACRO>
<MACRO>
<NAME>GST_MULAWENC_CLASS</NAME>
#define GST_MULAWENC_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_MULAWENC,GstMuLawEncClass))
</MACRO>
<MACRO>
<NAME>GST_IS_MULAWENC</NAME>
#define GST_IS_MULAWENC(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_MULAWENC))
</MACRO>
<MACRO>
<NAME>GST_IS_MULAWENC_CLASS</NAME>
#define GST_IS_MULAWENC_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_MULAWENC))
</MACRO>
<STRUCT>
<NAME>GstMuLawEnc</NAME>
struct _GstMuLawEnc
{
  GstAudioEncoder element;

  gint channels;
  gint rate;
};
</STRUCT>
<STRUCT>
<NAME>GstMuLawEncClass</NAME>
struct _GstMuLawEncClass
{
  GstAudioEncoderClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_mulawenc_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_ICYDEMUX</NAME>
#define GST_TYPE_ICYDEMUX \
  (gst_icydemux_get_type())
</MACRO>
<MACRO>
<NAME>GST_ICYDEMUX</NAME>
#define GST_ICYDEMUX(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_ICYDEMUX,GstICYDemux))
</MACRO>
<MACRO>
<NAME>GST_ICYDEMUX_CLASS</NAME>
#define GST_ICYDEMUX_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_ICYDEMUX,GstICYDemuxClass))
</MACRO>
<MACRO>
<NAME>GST_IS_ICYDEMUX</NAME>
#define GST_IS_ICYDEMUX(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_ICYDEMUX))
</MACRO>
<MACRO>
<NAME>GST_IS_ICYDEMUX_CLASS</NAME>
#define GST_IS_ICYDEMUX_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_ICYDEMUX))
</MACRO>
<STRUCT>
<NAME>GstICYDemux</NAME>
struct _GstICYDemux
{
  GstElement element;

  GstPad *sinkpad, *srcpad;

  /* Interval between metadata updates */
  gint meta_interval;

  /* Remaining bytes until the next metadata update */
  gint remaining;

  /* When 'remaining' is zero, this holds the number of bytes of metadata we
   * still need to read, or zero if we don't yet know (which means we need to
   * read one byte, after which we can initialise this properly) */
  gint meta_remaining;

  /* Caps for the data enclosed */
  GstCaps *src_caps;

  /* True if we're still typefinding */
  gboolean typefinding;

  GstTagList *cached_tags;
  GList *cached_events;

  GstAdapter *meta_adapter;

  GstBuffer *typefind_buf;

  /* upstream HTTP Content-Type */
  gchar *content_type;
};
</STRUCT>
<STRUCT>
<NAME>GstICYDemuxClass</NAME>
struct _GstICYDemuxClass 
{
  GstElementClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_icydemux_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_ID3DEMUX</NAME>
#define GST_TYPE_ID3DEMUX \
  (gst_id3demux_get_type())
</MACRO>
<MACRO>
<NAME>GST_ID3DEMUX</NAME>
#define GST_ID3DEMUX(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_ID3DEMUX,GstID3Demux))
</MACRO>
<MACRO>
<NAME>GST_ID3DEMUX_CLASS</NAME>
#define GST_ID3DEMUX_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_ID3DEMUX,GstID3DemuxClass))
</MACRO>
<MACRO>
<NAME>GST_IS_ID3DEMUX</NAME>
#define GST_IS_ID3DEMUX(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_ID3DEMUX))
</MACRO>
<MACRO>
<NAME>GST_IS_ID3DEMUX_CLASS</NAME>
#define GST_IS_ID3DEMUX_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_ID3DEMUX))
</MACRO>
<STRUCT>
<NAME>GstID3Demux</NAME>
struct _GstID3Demux
{
  GstTagDemux tagdemux;

  gboolean prefer_v1;     /* prefer ID3v1 tags over ID3v2 tags? */
};
</STRUCT>
<STRUCT>
<NAME>GstID3DemuxClass</NAME>
struct _GstID3DemuxClass 
{
  GstTagDemuxClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_id3demux_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_IMAGE_FREEZE</NAME>
#define GST_TYPE_IMAGE_FREEZE \
  (gst_image_freeze_get_type())
</MACRO>
<MACRO>
<NAME>GST_IMAGE_FREEZE</NAME>
#define GST_IMAGE_FREEZE(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_IMAGE_FREEZE,GstImageFreeze))
</MACRO>
<MACRO>
<NAME>GST_IMAGE_FREEZE_CLASS</NAME>
#define GST_IMAGE_FREEZE_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_IMAGE_FREEZE,GstImageFreezeClass))
</MACRO>
<MACRO>
<NAME>GST_IMAGE_FREEZE_GET_CLASS</NAME>
#define GST_IMAGE_FREEZE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj),GST_TYPE_IMAGE_FREEZE,GstImageFreezeClass))
</MACRO>
<MACRO>
<NAME>GST_IS_IMAGE_FREEZE</NAME>
#define GST_IS_IMAGE_FREEZE(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_IMAGE_FREEZE))
</MACRO>
<MACRO>
<NAME>GST_IS_IMAGE_FREEZE_CLASS</NAME>
#define GST_IS_IMAGE_FREEZE_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_IMAGE_FREEZE))
</MACRO>
<STRUCT>
<NAME>GstImageFreeze</NAME>
struct _GstImageFreeze
{
  GstElement parent;

  /* < private > */
  GstPad *sinkpad;
  GstPad *srcpad;

  GMutex lock;
  GstBuffer *buffer;
  gint fps_n, fps_d;

  GstSegment segment;
  gboolean need_segment;
  guint seqnum;

  guint64 offset;

  /* TRUE if currently doing a flushing seek, protected
   * by srcpad's stream lock */
  gint seeking;
};
</STRUCT>
<STRUCT>
<NAME>GstImageFreezeClass</NAME>
struct _GstImageFreezeClass
{
  GstElementClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_image_freeze_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_DEINTERLEAVE</NAME>
#define GST_TYPE_DEINTERLEAVE            (gst_deinterleave_get_type())
</MACRO>
<MACRO>
<NAME>GST_DEINTERLEAVE</NAME>
#define GST_DEINTERLEAVE(obj)            (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_DEINTERLEAVE,GstDeinterleave))
</MACRO>
<MACRO>
<NAME>GST_DEINTERLEAVE_CLASS</NAME>
#define GST_DEINTERLEAVE_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_DEINTERLEAVE,GstDeinterleaveClass))
</MACRO>
<MACRO>
<NAME>GST_DEINTERLEAVE_GET_CLASS</NAME>
#define GST_DEINTERLEAVE_GET_CLASS(obj) \
        (G_TYPE_INSTANCE_GET_CLASS ((obj),GST_TYPE_DEINTERLEAVE,GstDeinterleaveClass))
</MACRO>
<MACRO>
<NAME>GST_IS_DEINTERLEAVE</NAME>
#define GST_IS_DEINTERLEAVE(obj)         (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_DEINTERLEAVE))
</MACRO>
<MACRO>
<NAME>GST_IS_DEINTERLEAVE_CLASS</NAME>
#define GST_IS_DEINTERLEAVE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_DEINTERLEAVE))
</MACRO>
<USER_FUNCTION>
<NAME>GstDeinterleaveFunc</NAME>
<RETURNS>void </RETURNS>
gpointer out, gpointer in, guint stride, guint nframes
</USER_FUNCTION>
<STRUCT>
<NAME>GstDeinterleave</NAME>
struct _GstDeinterleave
{
  GstElement element;

  /*< private > */
  GList *srcpads;
  GstCaps *sinkcaps;
  GstAudioInfo audio_info;
  gboolean keep_positions;

  GstPad *sink;

  GstDeinterleaveFunc func;

  GList *pending_events;
};
</STRUCT>
<STRUCT>
<NAME>GstDeinterleaveClass</NAME>
struct _GstDeinterleaveClass
{
  GstElementClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_deinterleave_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_INTERLEAVE</NAME>
#define GST_TYPE_INTERLEAVE            (gst_interleave_get_type())
</MACRO>
<MACRO>
<NAME>GST_INTERLEAVE</NAME>
#define GST_INTERLEAVE(obj)            (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_INTERLEAVE,GstInterleave))
</MACRO>
<MACRO>
<NAME>GST_INTERLEAVE_CLASS</NAME>
#define GST_INTERLEAVE_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_INTERLEAVE,GstInterleaveClass))
</MACRO>
<MACRO>
<NAME>GST_INTERLEAVE_GET_CLASS</NAME>
#define GST_INTERLEAVE_GET_CLASS(obj) \
        (G_TYPE_INSTANCE_GET_CLASS ((obj),GST_TYPE_INTERLEAVE,GstInterleaveClass))
</MACRO>
<MACRO>
<NAME>GST_IS_INTERLEAVE</NAME>
#define GST_IS_INTERLEAVE(obj)         (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_INTERLEAVE))
</MACRO>
<MACRO>
<NAME>GST_IS_INTERLEAVE_CLASS</NAME>
#define GST_IS_INTERLEAVE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_INTERLEAVE))
</MACRO>
<USER_FUNCTION>
<NAME>GstInterleaveFunc</NAME>
<RETURNS>void </RETURNS>
gpointer out, gpointer in, guint stride, guint nframes
</USER_FUNCTION>
<STRUCT>
<NAME>GstInterleave</NAME>
struct _GstInterleave
{
  GstElement element;

  /*< private >*/
  GstCollectPads *collect;

  gint channels;
  gint padcounter;
  gint rate;
  gint width;

  GValueArray *channel_positions;
  GValueArray *input_channel_positions;
  gboolean channel_positions_from_input;

  gint default_channels_ordering_map[64];
  guint64 channel_mask;

  GstCaps *sinkcaps;
  gint configured_sinkpads_counter;

  GstClockTime timestamp;
  guint64 offset;

  GstEvent *pending_segment;

  GstInterleaveFunc func;

  GstPad *src;

  gboolean send_stream_start;
};
</STRUCT>
<STRUCT>
<NAME>GstInterleaveClass</NAME>
struct _GstInterleaveClass
{
  GstElementClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_interleave_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_LEVEL</NAME>
#define GST_TYPE_LEVEL \
  (gst_level_get_type())
</MACRO>
<MACRO>
<NAME>GST_LEVEL</NAME>
#define GST_LEVEL(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_LEVEL,GstLevel))
</MACRO>
<MACRO>
<NAME>GST_LEVEL_CLASS</NAME>
#define GST_LEVEL_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_LEVEL,GstLevelClass))
</MACRO>
<MACRO>
<NAME>GST_LEVEL_GET_CLASS</NAME>
#define GST_LEVEL_GET_CLASS(obj) \
  (G_TYPE_INSTANCE_GET_CLASS((obj),GST_TYPE_LEVEL,GstLevelClass))
</MACRO>
<MACRO>
<NAME>GST_IS_LEVEL</NAME>
#define GST_IS_LEVEL(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_LEVEL))
</MACRO>
<MACRO>
<NAME>GST_IS_LEVEL_CLASS</NAME>
#define GST_IS_LEVEL_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_LEVEL))
</MACRO>
<STRUCT>
<NAME>GstLevel</NAME>
struct _GstLevel {
  GstBaseTransform element;

  /* properties */
  gboolean post_messages;       /* whether or not to post messages */
  guint64 interval;             /* how many nanoseconds between emits */
  gdouble decay_peak_ttl;       /* time to live for peak in nanoseconds */
  gdouble decay_peak_falloff;   /* falloff in dB/sec */

  GstAudioInfo info;
  gint num_frames;              /* frame count (1 sample per channel)
                                 * since last emit */
  gint interval_frames;         /* after how many frame to sent a message */
  GstClockTime message_ts;      /* starttime for next message */

  /* per-channel arrays for intermediate values */
  gdouble *CS;                  /* normalized Cumulative Square */
  gdouble *peak;                /* normalized Peak value over buffer */
  gdouble *last_peak;           /* last normalized Peak value over interval */
  gdouble *decay_peak;          /* running decaying normalized Peak */
  gdouble *decay_peak_base;     /* value of last peak we are decaying from */
  GstClockTime *decay_peak_age; /* age of last peak */

  void (*process)(gpointer, guint, guint, gdouble*, gdouble*);
};
</STRUCT>
<STRUCT>
<NAME>GstLevelClass</NAME>
struct _GstLevelClass {
  GstBaseTransformClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_level_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_MATROSKA_DEMUX</NAME>
#define GST_TYPE_MATROSKA_DEMUX \
  (gst_matroska_demux_get_type ())
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_DEMUX</NAME>
#define GST_MATROSKA_DEMUX(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST ((obj), GST_TYPE_MATROSKA_DEMUX, GstMatroskaDemux))
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_DEMUX_CLASS</NAME>
#define GST_MATROSKA_DEMUX_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST ((klass), GST_TYPE_MATROSKA_DEMUX, GstMatroskaDemuxClass))
</MACRO>
<MACRO>
<NAME>GST_IS_MATROSKA_DEMUX</NAME>
#define GST_IS_MATROSKA_DEMUX(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GST_TYPE_MATROSKA_DEMUX))
</MACRO>
<MACRO>
<NAME>GST_IS_MATROSKA_DEMUX_CLASS</NAME>
#define GST_IS_MATROSKA_DEMUX_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE ((klass), GST_TYPE_MATROSKA_DEMUX))
</MACRO>
<STRUCT>
<NAME>GstMatroskaDemux</NAME>
typedef struct _GstMatroskaDemux {
  GstElement              parent;

  /* < private > */

  GstMatroskaReadCommon    common;

  /* pads */
  GstClock                *clock;
  guint                    num_v_streams;
  guint                    num_a_streams;
  guint                    num_t_streams;

  guint                    group_id;
  gboolean                 have_group_id;

  GstFlowCombiner         *flowcombiner;

  /* state */
  gboolean                 streaming;
  guint64                  seek_block;
  gboolean                 seek_first;

  /* did we parse cues/tracks/segmentinfo already? */
  gboolean                 tracks_parsed;
  GList                   *seek_parsed;

  /* cluster positions (optional) */
  GArray                  *clusters;

  /* keeping track of playback position */
  GstClockTime             last_stop_end;
  GstClockTime             stream_start_time;

  /* Stop time for reverse playback */
  GstClockTime             to_time;
  GstEvent                *new_segment;

  /* some state saving */
  GstClockTime             cluster_time;
  guint64                  cluster_offset;
  guint64                  first_cluster_offset;
  guint64                  next_cluster_offset;
  GstClockTime             requested_seek_time;
  guint64                  seek_offset;

  /* index stuff */
  gboolean                 seekable;
  gboolean                 building_index;
  guint64                  index_offset;
  GstEvent                *seek_event;
  gboolean                 need_segment;
  guint32                  segment_seqnum;

  /* reverse playback */
  GArray                  *seek_index;
  gint                     seek_entry;

  /* gap handling */
  guint64                  max_gap_time;

  /* for non-finalized files, with invalid segment duration */
  gboolean                 invalid_duration;

  /* Cached upstream length (default G_MAXUINT64) */
  guint64	           cached_length;
} GstMatroskaDemux;
</STRUCT>
<STRUCT>
<NAME>GstMatroskaDemuxClass</NAME>
typedef struct _GstMatroskaDemuxClass {
  GstElementClass parent;
} GstMatroskaDemuxClass;
</STRUCT>
<FUNCTION>
<NAME>gst_matroska_demux_plugin_init</NAME>
<RETURNS>gboolean  </RETURNS>
GstPlugin *plugin
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_MATROSKA_MUX</NAME>
#define GST_TYPE_MATROSKA_MUX \
  (gst_matroska_mux_get_type ())
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_MUX</NAME>
#define GST_MATROSKA_MUX(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST ((obj), GST_TYPE_MATROSKA_MUX, GstMatroskaMux))
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_MUX_CLASS</NAME>
#define GST_MATROSKA_MUX_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST ((klass), GST_TYPE_MATROSKA_MUX, GstMatroskaMuxClass))
</MACRO>
<MACRO>
<NAME>GST_IS_MATROSKA_MUX</NAME>
#define GST_IS_MATROSKA_MUX(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GST_TYPE_MATROSKA_MUX))
</MACRO>
<MACRO>
<NAME>GST_IS_MATROSKA_MUX_CLASS</NAME>
#define GST_IS_MATROSKA_MUX_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE ((klass), GST_TYPE_MATROSKA_MUX))
</MACRO>
<ENUM>
<NAME>GstMatroskaMuxState</NAME>
typedef enum {
  GST_MATROSKA_MUX_STATE_START,
  GST_MATROSKA_MUX_STATE_HEADER,
  GST_MATROSKA_MUX_STATE_DATA,
} GstMatroskaMuxState;
</ENUM>
<STRUCT>
<NAME>GstMatroskaMetaSeekIndex</NAME>
typedef struct _GstMatroskaMetaSeekIndex {
  guint32  id;
  guint64  pos;
} GstMatroskaMetaSeekIndex;
</STRUCT>
<USER_FUNCTION>
<NAME>GstMatroskaCapsFunc</NAME>
<RETURNS>gboolean </RETURNS>
GstPad *pad, GstCaps *caps
</USER_FUNCTION>
<STRUCT>
<NAME>GstMatroskaMux</NAME>
struct _GstMatroskaMux {
  GstElement     element;
  
  /* < private > */

  /* pads */
  GstPad        *srcpad;
  GstCollectPads *collect;
  GstEbmlWrite *ebml_write;

  guint          num_streams,
                 num_v_streams, num_a_streams, num_t_streams;

  /* Application name (for the writing application header element) */
  gchar          *writing_app;

  /* EBML DocType. */
  const gchar    *doctype;

  /* DocType version. */
  guint          doctype_version;

  /* state */
  GstMatroskaMuxState state;

  /* a cue (index) table */
  GstMatroskaIndex *index;
  guint          num_indexes;
  GstClockTimeDiff min_index_interval;
 
  /* timescale in the file */
  guint64        time_scale;
  /* based on timescale, limit of nanoseconds you can have in a cluster */ 
  guint64        max_cluster_duration;

  /* length, position (time, ns) */
  guint64        duration;

  /* byte-positions of master-elements (for replacing contents) */
  guint64        segment_pos,
                 seekhead_pos,
                 cues_pos,
                 chapters_pos,
                 tags_pos,
                 info_pos,
                 tracks_pos,
                 duration_pos,
                 meta_pos;
  guint64        segment_master;

  /* current cluster */
  guint64        cluster,
                 cluster_time,
                 cluster_pos,
		 prev_cluster_size;

  /* GstForceKeyUnit event */
  GstEvent       *force_key_unit_event;

  /* Flag to ease handling of WebM specifics */
  gboolean is_webm;

  /* used uids */
  GArray *used_uids;
};
</STRUCT>
<STRUCT>
<NAME>GstMatroskaMuxClass</NAME>
typedef struct _GstMatroskaMuxClass {
  GstElementClass parent;
} GstMatroskaMuxClass;
</STRUCT>
<FUNCTION>
<NAME>gst_matroska_mux_get_type</NAME>
<RETURNS>GType    </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_WEBM_MUX</NAME>
#define GST_TYPE_WEBM_MUX \
  (gst_webm_mux_get_type ())
</MACRO>
<MACRO>
<NAME>GST_WEBM_MUX</NAME>
#define GST_WEBM_MUX(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST ((obj), GST_TYPE_WEBM_MUX, GstWebMMux))
</MACRO>
<MACRO>
<NAME>GST_WEBM_MUX_CLASS</NAME>
#define GST_WEBM_MUX_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST ((klass), GST_TYPE_WEBM_MUX, GstWebMMuxClass))
</MACRO>
<MACRO>
<NAME>GST_IS_WEBM_MUX</NAME>
#define GST_IS_WEBM_MUX(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GST_TYPE_WEBM_MUX))
</MACRO>
<MACRO>
<NAME>GST_IS_WEBM_MUX_CLASS</NAME>
#define GST_IS_WEBM_MUX_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE ((klass), GST_TYPE_WEBM_MUX))
</MACRO>
<STRUCT>
<NAME>GstWebMMux</NAME>
struct _GstWebMMux {
  GstMatroskaMux matroskamux;
};
</STRUCT>
<STRUCT>
<NAME>GstWebMMuxClass</NAME>
struct _GstWebMMuxClass {
  GstMatroskaMuxClass matroskamuxclass;
};
</STRUCT>
<FUNCTION>
<NAME>gst_webm_mux_get_type</NAME>
<RETURNS>GType    </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_MONOSCOPE</NAME>
#define GST_TYPE_MONOSCOPE            (gst_monoscope_get_type())
</MACRO>
<MACRO>
<NAME>GST_MONOSCOPE</NAME>
#define GST_MONOSCOPE(obj)            (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_MONOSCOPE,GstMonoscope))
</MACRO>
<MACRO>
<NAME>GST_MONOSCOPE_CLASS</NAME>
#define GST_MONOSCOPE_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_MONOSCOPE,GstMonoscopeClass))
</MACRO>
<MACRO>
<NAME>GST_IS_MONOSCOPE</NAME>
#define GST_IS_MONOSCOPE(obj)         (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_MONOSCOPE))
</MACRO>
<MACRO>
<NAME>GST_IS_MONOSCOPE_CLASS</NAME>
#define GST_IS_MONOSCOPE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_MONOSCOPE))
</MACRO>
<STRUCT>
<NAME>GstMonoscope</NAME>
struct _GstMonoscope
{
  GstElement element;

  /* pads */
  GstPad      *sinkpad;
  GstPad      *srcpad;

  GstAdapter  *adapter;

  guint64      next_ts;             /* expected timestamp of the next frame */
  guint64      frame_duration;      /* video frame duration    */
  gint         rate;                /* sample rate             */
  guint        bps;                 /* bytes per sample        */
  guint        spf;                 /* samples per video frame */
  GstBufferPool *pool;

  GstSegment   segment;

  /* QoS stuff *//* with LOCK */
  gdouble      proportion;
  GstClockTime earliest_time;

  /* video state */
  gint         fps_num;
  gint         fps_denom;
  gint         width;
  gint         height;
  guint        outsize;

  /* visualisation state */
  struct monoscope_state *visstate;
};
</STRUCT>
<STRUCT>
<NAME>GstMonoscopeClass</NAME>
struct _GstMonoscopeClass
{
  GstElementClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_monoscope_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_MULTI_FILE_SINK</NAME>
#define GST_TYPE_MULTI_FILE_SINK \
  (gst_multi_file_sink_get_type())
</MACRO>
<MACRO>
<NAME>GST_MULTI_FILE_SINK</NAME>
#define GST_MULTI_FILE_SINK(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_MULTI_FILE_SINK,GstMultiFileSink))
</MACRO>
<MACRO>
<NAME>GST_MULTI_FILE_SINK_CLASS</NAME>
#define GST_MULTI_FILE_SINK_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_MULTI_FILE_SINK,GstMultiFileSinkClass))
</MACRO>
<MACRO>
<NAME>GST_IS_MULTI_FILE_SINK</NAME>
#define GST_IS_MULTI_FILE_SINK(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_MULTI_FILE_SINK))
</MACRO>
<MACRO>
<NAME>GST_IS_MULTI_FILE_SINK_CLASS</NAME>
#define GST_IS_MULTI_FILE_SINK_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_MULTI_FILE_SINK))
</MACRO>
<ENUM>
<NAME>GstMultiFileSinkNext</NAME>
typedef enum {
  GST_MULTI_FILE_SINK_NEXT_BUFFER,
  GST_MULTI_FILE_SINK_NEXT_DISCONT,
  GST_MULTI_FILE_SINK_NEXT_KEY_FRAME,
  GST_MULTI_FILE_SINK_NEXT_KEY_UNIT_EVENT,
  GST_MULTI_FILE_SINK_NEXT_MAX_SIZE,
  GST_MULTI_FILE_SINK_NEXT_MAX_DURATION
} GstMultiFileSinkNext;
</ENUM>
<STRUCT>
<NAME>GstMultiFileSink</NAME>
struct _GstMultiFileSink
{
  GstBaseSink parent;

  gchar *filename;
  gint index;
  gboolean post_messages;
  GstMultiFileSinkNext next_file;
  FILE *file;

  guint max_files;
  GQueue old_files;        /* keep track of old files for max_files handling */

  gint64 next_segment;

  int n_streamheaders;
  GstBuffer **streamheaders;
  guint force_key_unit_count;

  guint64 cur_file_size;
  guint64 max_file_size;

  GstClockTime file_pts;
  GstClockTime max_file_duration;

  gboolean aggregate_gops;
  GstAdapter *gop_adapter;  /* to aggregate GOPs */
  GList *potential_next_gop;	/* To detect false-positives */
};
</STRUCT>
<STRUCT>
<NAME>GstMultiFileSinkClass</NAME>
struct _GstMultiFileSinkClass
{
  GstBaseSinkClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_multi_file_sink_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_MULTI_FILE_SRC</NAME>
#define GST_TYPE_MULTI_FILE_SRC \
  (gst_multi_file_src_get_type())
</MACRO>
<MACRO>
<NAME>GST_MULTI_FILE_SRC</NAME>
#define GST_MULTI_FILE_SRC(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_MULTI_FILE_SRC,GstMultiFileSrc))
</MACRO>
<MACRO>
<NAME>GST_MULTI_FILE_SRC_CLASS</NAME>
#define GST_MULTI_FILE_SRC_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_MULTI_FILE_SRC,GstMultiFileSrcClass))
</MACRO>
<MACRO>
<NAME>GST_IS_MULTI_FILE_SRC</NAME>
#define GST_IS_MULTI_FILE_SRC(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_MULTI_FILE_SRC))
</MACRO>
<MACRO>
<NAME>GST_IS_MULTI_FILE_SRC_CLASS</NAME>
#define GST_IS_MULTI_FILE_SRC_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_MULTI_FILE_SRC))
</MACRO>
<STRUCT>
<NAME>GstMultiFileSrc</NAME>
struct _GstMultiFileSrc
{
  GstPushSrc parent;

  gchar *filename;
  int start_index;
  int stop_index;
  int index;

  int offset;

  gboolean loop;

  GstCaps *caps;
  gboolean successful_read;

  gint fps_n, fps_d;
};
</STRUCT>
<STRUCT>
<NAME>GstMultiFileSrcClass</NAME>
struct _GstMultiFileSrcClass
{
  GstPushSrcClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_multi_file_src_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_SPLIT_FILE_SRC</NAME>
#define GST_TYPE_SPLIT_FILE_SRC \
  (gst_split_file_src_get_type())
</MACRO>
<MACRO>
<NAME>GST_SPLIT_FILE_SRC</NAME>
#define GST_SPLIT_FILE_SRC(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_SPLIT_FILE_SRC,GstSplitFileSrc))
</MACRO>
<MACRO>
<NAME>GST_SPLIT_FILE_SRC_CLASS</NAME>
#define GST_SPLIT_FILE_SRC_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_SPLIT_FILE_SRC,GstSplitFileSrcClass))
</MACRO>
<MACRO>
<NAME>GST_IS_SPLIT_FILE_SRC</NAME>
#define GST_IS_SPLIT_FILE_SRC(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_SPLIT_FILE_SRC))
</MACRO>
<MACRO>
<NAME>GST_IS_SPLIT_FILE_SRC_CLASS</NAME>
#define GST_IS_SPLIT_FILE_SRC_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_SPLIT_FILE_SRC))
</MACRO>
<STRUCT>
<NAME>GstFilePart</NAME>
struct _GstFilePart
{
  GFileInputStream  *stream;
  gchar             *path;
  guint64            start; /* inclusive */
  guint64            stop;  /* inclusive */
};
</STRUCT>
<STRUCT>
<NAME>GstSplitFileSrc</NAME>
struct _GstSplitFileSrc
{
  GstBaseSrc   parent;

  gchar       *location;  /* OBJECT_LOCK */

  GstFilePart *parts;
  guint        num_parts;

  guint        cur_part;  /* part used last (likely also to be used next) */

  GCancellable *cancellable; /* so we can interrupt blocking operations */
};
</STRUCT>
<STRUCT>
<NAME>GstSplitFileSrcClass</NAME>
struct _GstSplitFileSrcClass
{
  GstBaseSrcClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_split_file_src_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_SPLITMUX_SRC</NAME>
#define GST_TYPE_SPLITMUX_SRC \
  (gst_splitmux_src_get_type())
</MACRO>
<MACRO>
<NAME>GST_SPLITMUX_SRC</NAME>
#define GST_SPLITMUX_SRC(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_SPLITMUX_SRC,GstSplitMuxSrc))
</MACRO>
<MACRO>
<NAME>GST_SPLITMUX_SRC_CLASS</NAME>
#define GST_SPLITMUX_SRC_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_SPLITMUX_SRC,GstSplitMuxSrcClass))
</MACRO>
<MACRO>
<NAME>GST_IS_SPLITMUX_SRC</NAME>
#define GST_IS_SPLITMUX_SRC(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_SPLITMUX_SRC))
</MACRO>
<MACRO>
<NAME>GST_IS_SPLITMUX_SRC_CLASS</NAME>
#define GST_IS_SPLITMUX_SRC_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_SPLITMUX_SRC))
</MACRO>
<STRUCT>
<NAME>GstSplitMuxSrc</NAME>
struct _GstSplitMuxSrc
{
  GstBin parent;

  GMutex lock;
  gboolean     running;

  gchar       *location;  /* OBJECT_LOCK */

  GstSplitMuxPartReader **parts;
  guint        num_parts;
  guint        cur_part;

  gboolean pads_complete;
  GMutex pads_lock;
  GList  *pads; /* pads_lock */

  GstClockTime total_duration;
  GstSegment play_segment;
  guint32 segment_seqnum;
};
</STRUCT>
<STRUCT>
<NAME>GstSplitMuxSrcClass</NAME>
struct _GstSplitMuxSrcClass
{
  GstBinClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>splitmux_src_pad_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>SPLITMUX_TYPE_SRC_PAD</NAME>
#define SPLITMUX_TYPE_SRC_PAD splitmux_src_pad_get_type()
</MACRO>
<MACRO>
<NAME>SPLITMUX_SRC_PAD_CAST</NAME>
#define SPLITMUX_SRC_PAD_CAST(p) ((SplitMuxSrcPad *)(p))
</MACRO>
<MACRO>
<NAME>SPLITMUX_SRC_PAD</NAME>
#define SPLITMUX_SRC_PAD(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),SPLITMUX_TYPE_SRC_PAD,SplitMuxSrcPad))
</MACRO>
<STRUCT>
<NAME>SplitMuxSrcPad</NAME>
struct _SplitMuxSrcPad
{
  GstPad parent;

  guint cur_part;
  GstSplitMuxPartReader *reader;
  GstPad *part_pad;

  GstSegment segment;

  gboolean set_next_discont;
  gboolean clear_next_discont;

  gboolean sent_stream_start;
  gboolean sent_caps;
  gboolean sent_segment;
};
</STRUCT>
<STRUCT>
<NAME>SplitMuxSrcPadClass</NAME>
struct _SplitMuxSrcPadClass
{
  GstPadClass parent;
};
</STRUCT>
<FUNCTION>
<NAME>gst_splitmux_src_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>register_splitmuxsrc</NAME>
<RETURNS>gboolean  </RETURNS>
GstPlugin * plugin
</FUNCTION>
<MACRO>
<NAME>SPLITMUX_SRC_LOCK</NAME>
#define SPLITMUX_SRC_LOCK(s) g_mutex_lock(&(s)->lock)
</MACRO>
<MACRO>
<NAME>SPLITMUX_SRC_UNLOCK</NAME>
#define SPLITMUX_SRC_UNLOCK(s) g_mutex_unlock(&(s)->lock)
</MACRO>
<MACRO>
<NAME>SPLITMUX_SRC_PADS_LOCK</NAME>
#define SPLITMUX_SRC_PADS_LOCK(s) g_mutex_lock(&(s)->pads_lock)
</MACRO>
<MACRO>
<NAME>SPLITMUX_SRC_PADS_UNLOCK</NAME>
#define SPLITMUX_SRC_PADS_UNLOCK(s) g_mutex_unlock(&(s)->pads_lock)
</MACRO>
<MACRO>
<NAME>GST_TYPE_SPLITMUX_SINK</NAME>
#define GST_TYPE_SPLITMUX_SINK               (gst_splitmux_sink_get_type())
</MACRO>
<MACRO>
<NAME>GST_SPLITMUX_SINK</NAME>
#define GST_SPLITMUX_SINK(obj)               (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_SPLITMUX_SINK,GstSplitMuxSink))
</MACRO>
<MACRO>
<NAME>GST_SPLITMUX_SINK_CLASS</NAME>
#define GST_SPLITMUX_SINK_CLASS(klass)       (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_SPLITMUX_SINK,GstSplitMuxSinkClass))
</MACRO>
<MACRO>
<NAME>GST_IS_SPLITMUX_SINK</NAME>
#define GST_IS_SPLITMUX_SINK(obj)            (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_SPLITMUX_SINK))
</MACRO>
<MACRO>
<NAME>GST_IS_SPLITMUX_SINK_CLASS</NAME>
#define GST_IS_SPLITMUX_SINK_CLASS(klass)    (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_SPLITMUX_SINK))
</MACRO>
<FUNCTION>
<NAME>gst_splitmux_sink_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>register_splitmuxsink</NAME>
<RETURNS>gboolean  </RETURNS>
GstPlugin * plugin
</FUNCTION>
<ENUM>
<NAME>SplitMuxInputState</NAME>
typedef enum _SplitMuxInputState
{
  SPLITMUX_INPUT_STATE_STOPPED,
  SPLITMUX_INPUT_STATE_COLLECTING_GOP_START,    /* Waiting for the next ref ctx keyframe */
  SPLITMUX_INPUT_STATE_WAITING_GOP_COLLECT,     /* Waiting for all streams to collect GOP */
  SPLITMUX_INPUT_STATE_FINISHING_UP             /* Got EOS from reference ctx, send everything */
} SplitMuxInputState;
</ENUM>
<ENUM>
<NAME>SplitMuxOutputState</NAME>
typedef enum _SplitMuxOutputState
{
  SPLITMUX_OUTPUT_STATE_STOPPED,
  SPLITMUX_OUTPUT_STATE_AWAITING_COMMAND,       /* Waiting first command packet from input */
  SPLITMUX_OUTPUT_STATE_OUTPUT_GOP,     /* Outputting a collected GOP */
  SPLITMUX_OUTPUT_STATE_ENDING_FILE,    /* Finishing the current fragment */
  SPLITMUX_OUTPUT_STATE_START_NEXT_FILE /* Restarting after ENDING_FILE */
} SplitMuxOutputState;
</ENUM>
<STRUCT>
<NAME>GstSplitMuxSink</NAME>
struct _GstSplitMuxSink
{
  GstBin parent;

  GMutex lock;
  GCond input_cond;
  GCond output_cond;

  gdouble mux_overhead;

  GstClockTime threshold_time;
  guint64 threshold_bytes;
  guint max_files;
  gboolean send_keyframe_requests;
  gchar *threshold_timecode_str;
  GstClockTime next_max_tc_time;

  GstElement *muxer;
  GstElement *sink;

  GstElement *provided_muxer;

  GstElement *provided_sink;
  GstElement *active_sink;

  gboolean ready_for_output;

  gchar *location;
  guint fragment_id;

  GList *contexts;

  SplitMuxInputState input_state;
  GstClockTimeDiff max_in_running_time;
  /* Number of bytes sent to the
   * current fragment */
  guint64 fragment_total_bytes;
  /* Number of bytes we've collected into
   * the GOP that's being collected */
  guint64 gop_total_bytes;
  /* Start time of the current fragment */
  GstClockTimeDiff fragment_start_time;
  /* Start time of the current GOP */
  GstClockTimeDiff gop_start_time;

  GQueue out_cmd_q;             /* Queue of commands for output thread */

  SplitMuxOutputState output_state;
  GstClockTimeDiff max_out_running_time;

  guint64 muxed_out_bytes;

  MqStreamCtx *reference_ctx;
  /* Count of queued keyframes in the reference ctx */
  guint queued_keyframes;

  gboolean switching_fragment;

  gboolean have_video;

  gboolean need_async_start;
  gboolean async_pending;
};
</STRUCT>
<STRUCT>
<NAME>GstSplitMuxSinkClass</NAME>
struct _GstSplitMuxSinkClass
{
  GstBinClass parent_class;
};
</STRUCT>
<MACRO>
<NAME>GST_TYPE_MULTIPART_DEMUX</NAME>
#define GST_TYPE_MULTIPART_DEMUX (gst_multipart_demux_get_type())
</MACRO>
<MACRO>
<NAME>GST_MULTIPART_DEMUX</NAME>
#define GST_MULTIPART_DEMUX(obj) (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_MULTIPART_DEMUX, GstMultipartDemux))
</MACRO>
<MACRO>
<NAME>GST_MULTIPART_DEMUX_CLASS</NAME>
#define GST_MULTIPART_DEMUX_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_MULTIPART_DEMUX, GstMultipartDemux))
</MACRO>
<MACRO>
<NAME>GST_MULTIPART_DEMUX_GET_CLASS</NAME>
#define GST_MULTIPART_DEMUX_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), GST_TYPE_MULTIPART_DEMUX, GstMultipartDemuxClass))
</MACRO>
<MACRO>
<NAME>GST_IS_MULTIPART_DEMUX</NAME>
#define GST_IS_MULTIPART_DEMUX(obj) (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_MULTIPART_DEMUX))
</MACRO>
<MACRO>
<NAME>GST_IS_MULTIPART_DEMUX_CLASS</NAME>
#define GST_IS_MULTIPART_DEMUX_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_MULTIPART_DEMUX))
</MACRO>
<MACRO>
<NAME>MULTIPART_NEED_MORE_DATA</NAME>
#define MULTIPART_NEED_MORE_DATA -1
</MACRO>
<MACRO>
<NAME>MULTIPART_DATA_ERROR</NAME>
#define MULTIPART_DATA_ERROR     -2
</MACRO>
<MACRO>
<NAME>MULTIPART_DATA_EOS</NAME>
#define MULTIPART_DATA_EOS       -3
</MACRO>
<STRUCT>
<NAME>GstMultipartDemux</NAME>
struct _GstMultipartDemux
{
  GstElement element;

  /* pad */
  GstPad *sinkpad;

  GSList *srcpads;
  guint numpads;

  GstAdapter *adapter;

  /* Header information of the current frame */
  gboolean header_completed;
  gchar *boundary;
  guint boundary_len;
  gchar *mime_type;
  gint content_length;

  /* Index inside the current data when manually looking for the boundary */
  gint scanpos;

  gboolean singleStream;

  /* to handle stream-start */
  gboolean have_group_id;
  guint group_id;
};
</STRUCT>
<STRUCT>
<NAME>GstMultipartDemuxClass</NAME>
struct _GstMultipartDemuxClass
{
  GstElementClass parent_class;

  GHashTable *gstnames;
};
</STRUCT>
<FUNCTION>
<NAME>gst_multipart_demux_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_multipart_demux_plugin_init</NAME>
<RETURNS>gboolean  </RETURNS>
GstPlugin * plugin
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_MULTIPART_MUX</NAME>
#define GST_TYPE_MULTIPART_MUX (gst_multipart_mux_get_type())
</MACRO>
<MACRO>
<NAME>GST_MULTIPART_MUX</NAME>
#define GST_MULTIPART_MUX(obj) (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_MULTIPART_MUX, GstMultipartMux))
</MACRO>
<MACRO>
<NAME>GST_MULTIPART_MUX_CLASS</NAME>
#define GST_MULTIPART_MUX_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_MULTIPART_MUX, GstMultipartMux))
</MACRO>
<MACRO>
<NAME>GST_MULTIPART_MUX_GET_CLASS</NAME>
#define GST_MULTIPART_MUX_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), GST_TYPE_MULTIPART_MUX, GstMultipartMuxClass))
</MACRO>
<MACRO>
<NAME>GST_IS_MULTIPART_MUX</NAME>
#define GST_IS_MULTIPART_MUX(obj) (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_MULTIPART_MUX))
</MACRO>
<MACRO>
<NAME>GST_IS_MULTIPART_MUX_CLASS</NAME>
#define GST_IS_MULTIPART_MUX_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_MULTIPART_MUX))
</MACRO>
<STRUCT>
<NAME>GstMultipartMux</NAME>
struct _GstMultipartMux
{
  GstElement element;

  /* pad */
  GstPad *srcpad;

  /* sinkpads */
  GstCollectPads *collect;

  gint numpads;

  /* offset in stream */
  guint64 offset;

  /* boundary string */
  gchar *boundary;

  gboolean negotiated;
  gboolean need_segment;
  gboolean need_stream_start;
};
</STRUCT>
<STRUCT>
<NAME>GstMultipartMuxClass</NAME>
struct _GstMultipartMuxClass
{
  GstElementClass parent_class;

  GHashTable *mimetypes;
};
</STRUCT>
<FUNCTION>
<NAME>gst_multipart_mux_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_multipart_mux_plugin_init</NAME>
<RETURNS>gboolean  </RETURNS>
GstPlugin * plugin
</FUNCTION>
<MACRO>
<NAME>GST_CAT_DEFAULT</NAME>
#define GST_CAT_DEFAULT qtdemux_debug
</MACRO>
<MACRO>
<NAME>GST_TYPE_QTDEMUX</NAME>
#define GST_TYPE_QTDEMUX \
  (gst_qtdemux_get_type())
</MACRO>
<MACRO>
<NAME>GST_QTDEMUX</NAME>
#define GST_QTDEMUX(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_QTDEMUX,GstQTDemux))
</MACRO>
<MACRO>
<NAME>GST_QTDEMUX_CLASS</NAME>
#define GST_QTDEMUX_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_QTDEMUX,GstQTDemuxClass))
</MACRO>
<MACRO>
<NAME>GST_IS_QTDEMUX</NAME>
#define GST_IS_QTDEMUX(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_QTDEMUX))
</MACRO>
<MACRO>
<NAME>GST_IS_QTDEMUX_CLASS</NAME>
#define GST_IS_QTDEMUX_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_QTDEMUX))
</MACRO>
<MACRO>
<NAME>GST_QTDEMUX_CAST</NAME>
#define GST_QTDEMUX_CAST(obj) ((GstQTDemux *)(obj))
</MACRO>
<MACRO>
<NAME>GST_QT_DEMUX_PRIVATE_TAG</NAME>
#define GST_QT_DEMUX_PRIVATE_TAG "private-qt-tag"
</MACRO>
<MACRO>
<NAME>GST_QT_DEMUX_CLASSIFICATION_TAG</NAME>
#define GST_QT_DEMUX_CLASSIFICATION_TAG "classification"
</MACRO>
<MACRO>
<NAME>GST_QTDEMUX_MAX_STREAMS</NAME>
#define GST_QTDEMUX_MAX_STREAMS         32
</MACRO>
<STRUCT>
<NAME>GstQTDemux</NAME>
struct _GstQTDemux {
  GstElement element;

  /* Global state */
  enum QtDemuxState state;

  /* static sink pad */
  GstPad *sinkpad;

  /* TRUE if pull-based */
  gboolean pullbased;

  gboolean posted_redirect;

  QtDemuxStream *streams[GST_QTDEMUX_MAX_STREAMS];
  gint     n_streams;
  gint     n_video_streams;
  gint     n_audio_streams;
  gint     n_sub_streams;

  GstFlowCombiner *flowcombiner;

  /* Incoming stream group-id to set on downstream STREAM_START events.
   * If upstream doesn't contain one, a global one will be generated */
  gboolean have_group_id;
  guint group_id;

  guint  major_brand;
  GstBuffer *comp_brands;

  /* [moov] header.
   * FIXME : This is discarded just after it's created. Just move it
   * to a temporary variable ? */
  GNode *moov_node;

  /* FIXME : This is never freed. It is only assigned once. memleak ? */
  GNode *moov_node_compressed;

  /* Set to TRUE when the [moov] header has been fully parsed */
  gboolean got_moov;

  /* Global timescale for the incoming stream. Use the QTTIME macros
   * to convert values to/from GstClockTime */
  guint32 timescale;

  /* Global duration (in global timescale). Use QTTIME macros to get GstClockTime */
  guint64 duration;

  /* Total size of header atoms. Used to calculate fallback overall bitrate */
  guint header_size;

  GstTagList *tag_list;

  /* configured playback region */
  GstSegment segment;

  /* The SEGMENT_EVENT from upstream *OR* generated from segment (above) */
  GstEvent *pending_newsegment;

  guint32 segment_seqnum;

  /* flag to indicate that we're working with a smoothstreaming fragment
   * Mss doesn't have 'moov' or any information about the streams format,
   * requiring qtdemux to expose and create the streams */
  gboolean mss_mode;

  /* Set to TRUE if the incoming stream is either a MSS stream or
   * a Fragmented MP4 (containing the [mvex] atom in the header) */
  gboolean fragmented;

  /* PULL-BASED only : If TRUE there is a pending seek */
  gboolean fragmented_seek_pending;

  /* PULL-BASED : offset of first [moof] or of fragment to seek to
   * PUSH-BASED : offset of latest [moof] */
  guint64 moof_offset;

  /* MSS streams have a single media that is unspecified at the atoms, so
   * upstream provides it at the caps */
  GstCaps *media_caps;

  /* Set to TRUE when all streams have been exposed */
  gboolean exposed;
    
  gint64 chapters_track_id;

  /* protection support */
  GPtrArray *protection_system_ids; /* Holds identifiers of all content protection systems for all tracks */
  GQueue protection_event_queue; /* holds copy of upstream protection events */
  guint64 cenc_aux_info_offset;
  guint8 *cenc_aux_info_sizes;
  guint32 cenc_aux_sample_count;


  /*
   * ALL VARIABLES BELOW ARE ONLY USED IN PUSH-BASED MODE 
   */
  GstAdapter *adapter;
  guint neededbytes;
  guint todrop;
  /* Used to store data if [mdat] is before the headers */
  GstBuffer *mdatbuffer;
  /* Amount of bytes left to read in the current [mdat] */
  guint64 mdatleft, mdatsize;

  /* When restoring the mdat to the adapter, this buffer stores any
   * trailing data that was after the last atom parsed as it has to be
   * restored later along with the correct offset. Used in fragmented
   * scenario where mdat/moof are one after the other in any order.
   *
   * Check https://bugzilla.gnome.org/show_bug.cgi?id=710623 */
  GstBuffer *restoredata_buffer;
  guint64 restoredata_offset;

  /* The current offset in bytes from upstream.
   * Note: While it makes complete sense when we are PULL-BASED (pulling
   * in BYTES from upstream) and PUSH-BASED with a BYTE SEGMENT (receiving
   * buffers with actual offsets), it is undefined in PUSH-BASED with a
   * TIME SEGMENT */
  guint64 offset;

  /* offset of the mdat atom */
  guint64 mdatoffset;
  /* Offset of the first mdat */
  guint64 first_mdat;
  /* offset of last [moov] seen */
  guint64 last_moov_offset;

  /* If TRUE, qtdemux received upstream newsegment in TIME format
   * which likely means that upstream is driving the pipeline (such as
   * adaptive demuxers or dlna sources) */
  gboolean upstream_format_is_time;

  /* Seqnum of the seek event sent upstream.  Will be used to
   * detect incoming FLUSH events corresponding to that */
  guint32 offset_seek_seqnum;

  /* UPSTREAM BYTE: Requested upstream byte seek offset.
   * Currently it is only used to check if an incoming BYTE SEGMENT
   * corresponds to a seek event that was sent upstream */
  gint64 seek_offset;

  /* UPSTREAM BYTE: Requested start/stop TIME values from
   * downstream.
   * Used to set on the downstream segment once the corresponding upstream
   * BYTE SEEK has succeeded */
  gint64 push_seek_start;
  gint64 push_seek_stop;

#if 0
  /* gst index support */
  GstIndex *element_index;
  gint index_id;
#endif

  /* Whether upstream is seekable in BYTES */
  gboolean upstream_seekable;
  /* UPSTREAM BYTE: Size of upstream content.
   * Note : This is only computed once ! If upstream grows in the meantime
   * it will not be updated */
  gint64 upstream_size;

  /* UPSTREAM TIME : Contains the PTS (if any) of the
   * buffer that contains a [moof] header. Will be used to establish
   * the actual PTS of the samples contained within that fragment. */
  guint64 fragment_start;
  /* UPSTREAM TIME : The offset in bytes of the [moof]
   * header start.
   * Note : This is not computed from the GST_BUFFER_OFFSET field */
  guint64 fragment_start_offset;
};
</STRUCT>
<STRUCT>
<NAME>GstQTDemuxClass</NAME>
struct _GstQTDemuxClass {
  GstElementClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_qtdemux_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<STRUCT>
<NAME>QtDemuxStream</NAME>
</STRUCT>
<MACRO>
<NAME>GST_TYPE_QT_MUX</NAME>
#define GST_TYPE_QT_MUX (gst_qt_mux_get_type())
</MACRO>
<MACRO>
<NAME>GST_QT_MUX</NAME>
#define GST_QT_MUX(obj) (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_QT_MUX, GstQTMux))
</MACRO>
<MACRO>
<NAME>GST_QT_MUX_CLASS</NAME>
#define GST_QT_MUX_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_QT_MUX, GstQTMux))
</MACRO>
<MACRO>
<NAME>GST_IS_QT_MUX</NAME>
#define GST_IS_QT_MUX(obj) (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_QT_MUX))
</MACRO>
<MACRO>
<NAME>GST_IS_QT_MUX_CLASS</NAME>
#define GST_IS_QT_MUX_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_QT_MUX))
</MACRO>
<MACRO>
<NAME>GST_QT_MUX_CAST</NAME>
#define GST_QT_MUX_CAST(obj) ((GstQTMux*)(obj))
</MACRO>
<USER_FUNCTION>
<NAME>GstQTPadPrepareBufferFunc</NAME>
<RETURNS>GstBuffer *</RETURNS>
GstQTPad * pad,
    GstBuffer * buf, GstQTMux * qtmux
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GstQTPadSetCapsFunc</NAME>
<RETURNS>gboolean </RETURNS>
GstQTPad * pad, GstCaps * caps
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GstQTPadCreateEmptyBufferFunc</NAME>
<RETURNS>GstBuffer *</RETURNS>
GstQTPad * pad, gint64 duration
</USER_FUNCTION>
<MACRO>
<NAME>QTMUX_NO_OF_TS</NAME>
#define QTMUX_NO_OF_TS   10
</MACRO>
<STRUCT>
<NAME>GstQTPad</NAME>
struct _GstQTPad
{
  GstCollectData collect;       /* we extend the CollectData */

  /* fourcc id of stream */
  guint32 fourcc;
  /* whether using format that have out of order buffers */
  gboolean is_out_of_order;
  /* if not 0, track with constant sized samples, e.g. raw audio */
  guint sample_size;
  /* make sync table entry */
  gboolean sync;
  /* if it is a sparse stream
   * (meaning we can't use PTS differences to compute duration) */
  gboolean sparse;
  /* bitrates */
  guint32 avg_bitrate, max_bitrate;

  /* for avg bitrate calculation */
  guint64 total_bytes;
  guint64 total_duration;

  GstBuffer *last_buf;
  /* dts of last_buf */
  GstClockTime last_dts;

  /* This is compensate for CTTS */
  GstClockTime dts_adjustment;

  /* store the first timestamp for comparing with other streams and
   * know if there are late streams */
  GstClockTime first_ts;
  GstClockTime first_dts;

  /* all the atom and chunk book-keeping is delegated here
   * unowned/uncounted reference, parent MOOV owns */
  AtomTRAK *trak;
  AtomTRAK *tc_trak;
  SampleTableEntry *trak_ste;
  /* fragmented support */
  /* meta data book-keeping delegated here */
  AtomTRAF *traf;
  /* fragment buffers */
  ATOM_ARRAY (GstBuffer *) fragment_buffers;
  /* running fragment duration */
  gint64 fragment_duration;
  /* optional fragment index book-keeping */
  AtomTFRA *tfra;

  /* Set when tags are received, cleared when written to moov */
  gboolean tags_changed;

  GstTagList *tags;

  /* if nothing is set, it won't be called */
  GstQTPadPrepareBufferFunc prepare_buf_func;
  GstQTPadSetCapsFunc set_caps;
  GstQTPadCreateEmptyBufferFunc create_empty_buffer;

  /* SMPTE timecode */
  GstVideoTimeCode *first_tc;
  GstClockTime first_pts;
  guint64 tc_pos;
};
</STRUCT>
<ENUM>
<NAME>GstQTMuxState</NAME>
typedef enum _GstQTMuxState
{
  GST_QT_MUX_STATE_NONE,
  GST_QT_MUX_STATE_STARTED,
  GST_QT_MUX_STATE_DATA,
  GST_QT_MUX_STATE_EOS
} GstQTMuxState;
</ENUM>
<ENUM>
<NAME>GstQtMuxMode</NAME>
typedef enum _GstQtMuxMode {
    GST_QT_MUX_MODE_MOOV_AT_END,
    GST_QT_MUX_MODE_FRAGMENTED,
    GST_QT_MUX_MODE_FRAGMENTED_STREAMABLE,
    GST_QT_MUX_MODE_FAST_START,
    GST_QT_MUX_MODE_ROBUST_RECORDING
} GstQtMuxMode;
</ENUM>
<STRUCT>
<NAME>GstQTMux</NAME>
struct _GstQTMux
{
  GstElement element;

  GstPad *srcpad;
  GstCollectPads *collect;
  GSList *sinkpads;

  /* state */
  GstQTMuxState state;

  /* Mux mode, inferred from property
   * set in gst_qt_mux_start_file() */
  GstQtMuxMode mux_mode;

  /* size of header (prefix, atoms (ftyp, possibly moov, mdat header)) */
  guint64 header_size;
  /* accumulated size of raw media data (not including mdat header) */
  guint64 mdat_size;
  /* position of the moov (for fragmented mode) or reserved moov atom
   * area (for robust-muxing mode) */
  guint64 moov_pos;
  /* position of mdat atom header (for later updating of size) in
   * moov-at-end, fragmented and robust-muxing modes */
  guint64 mdat_pos;

  /* keep track of the largest chunk to fine-tune brands */
  GstClockTime longest_chunk;

  /* Earliest timestamp across all pads/traks */
  GstClockTime first_ts;
  /* Last DTS across all pads (= duration) */
  GstClockTime last_dts;

  /* Last pad we used for writing the current chunk */
  GstQTPad *current_pad;
  guint64 current_chunk_size;
  GstClockTime current_chunk_duration;
  guint64 current_chunk_offset;

  /* atom helper objects */
  AtomsContext *context;
  AtomFTYP *ftyp;
  AtomMOOV *moov;
  GSList *extra_atoms; /* list of extra top-level atoms (e.g. UUID for xmp)
                        * Stored as AtomInfo structs */

  /* Set when tags are received, cleared when written to moov */
  gboolean tags_changed;

  /* fragmented file index */
  AtomMFRA *mfra;

  /* fast start */
  FILE *fast_start_file;

  /* moov recovery */
  FILE *moov_recov_file;

  /* fragment sequence */
  guint32 fragment_sequence;

  /* properties */
  guint32 timescale;
  guint32 trak_timescale;
  AtomsTreeFlavor flavor;
  gboolean fast_start;
  gboolean guess_pts;
#ifndef GST_REMOVE_DEPRECATED
  gint dts_method;
#endif
  gchar *fast_start_file_path;
  gchar *moov_recov_file_path;
  guint32 fragment_duration;
  /* Whether or not to work in 'streamable' mode and not
   * seek to rewrite headers - only valid for fragmented
   * mode. */
  gboolean streamable;

  /* Requested target maximum duration */
  GstClockTime reserved_max_duration;
  /* Estimate of remaining reserved header space (in ns of recording) */
  GstClockTime reserved_duration_remaining;
  /* Multiplier for conversion from reserved_max_duration to bytes */
  guint reserved_bytes_per_sec_per_trak;

  guint64 interleave_bytes;
  GstClockTime interleave_time;
  gboolean interleave_bytes_set, interleave_time_set;

  /* Reserved minimum MOOV size in bytes
   * This is converted from reserved_max_duration
   * using the bytes/trak/sec estimate */
  guint32 reserved_moov_size;
  /* Basic size of the moov (static headers + tags) */
  guint32 base_moov_size;
  /* Size of the most recently generated moov header */
  guint32 last_moov_size;
  /* True if the first moov in the ping-pong buffers
   * is the active one. See gst_qt_mux_robust_recording_rewrite_moov() */
  gboolean reserved_moov_first_active;

  /* Tracking of periodic MOOV updates */
  GstClockTime last_moov_update;
  GstClockTime reserved_moov_update_period;
  GstClockTime muxed_since_last_update;

  /* for request pad naming */
  guint video_pads, audio_pads, subtitle_pads;
};
</STRUCT>
<STRUCT>
<NAME>GstQTMuxClass</NAME>
struct _GstQTMuxClass
{
  GstElementClass parent_class;

  GstQTMuxFormat format;
};
</STRUCT>
<MACRO>
<NAME>GST_QT_MUX_PARAMS_QDATA</NAME>
#define GST_QT_MUX_PARAMS_QDATA g_quark_from_static_string("qt-mux-params")
</MACRO>
<FUNCTION>
<NAME>gst_qt_mux_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_qt_mux_register</NAME>
<RETURNS>gboolean  </RETURNS>
GstPlugin * plugin
</FUNCTION>
<MACRO>
<NAME>GST_TAG_3GP_CLASSIFICATION</NAME>
#define GST_TAG_3GP_CLASSIFICATION "classification"
</MACRO>
<STRUCT>
<NAME>Gst3GPPMux</NAME>
</STRUCT>
<STRUCT>
<NAME>GstISMLMux</NAME>
</STRUCT>
<STRUCT>
<NAME>GstMJ2Mux</NAME>
</STRUCT>
<STRUCT>
<NAME>GstMP4Mux</NAME>
</STRUCT>
<MACRO>
<NAME>GST_TYPE_RG_ANALYSIS</NAME>
#define GST_TYPE_RG_ANALYSIS \
  (gst_rg_analysis_get_type())
</MACRO>
<MACRO>
<NAME>GST_RG_ANALYSIS</NAME>
#define GST_RG_ANALYSIS(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_RG_ANALYSIS,GstRgAnalysis))
</MACRO>
<MACRO>
<NAME>GST_RG_ANALYSIS_CLASS</NAME>
#define GST_RG_ANALYSIS_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_RG_ANALYSIS,GstRgAnalysisClass))
</MACRO>
<MACRO>
<NAME>GST_IS_RG_ANALYSIS</NAME>
#define GST_IS_RG_ANALYSIS(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_RG_ANALYSIS))
</MACRO>
<MACRO>
<NAME>GST_IS_RG_ANALYSIS_CLASS</NAME>
#define GST_IS_RG_ANALYSIS_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_RG_ANALYSIS))
</MACRO>
<STRUCT>
<NAME>GstRgAnalysis</NAME>
struct _GstRgAnalysis
{
  GstBaseTransform element;

  /*< private >*/

  RgAnalysisCtx *ctx;
  void (*analyze) (RgAnalysisCtx * ctx, gconstpointer data, gsize size,
      guint depth);
  gint depth;

  /* Property values. */
  guint num_tracks;
  gdouble reference_level;
  gboolean forced;
  gboolean message;

  /* State machinery for skipping. */
  gboolean ignore_tags;
  gboolean skip;
  gboolean has_track_gain;
  gboolean has_track_peak;
  gboolean has_album_gain;
  gboolean has_album_peak;
};
</STRUCT>
<STRUCT>
<NAME>GstRgAnalysisClass</NAME>
struct _GstRgAnalysisClass
{
  GstBaseTransformClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_rg_analysis_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_RG_LIMITER</NAME>
#define GST_TYPE_RG_LIMITER \
  (gst_rg_limiter_get_type())
</MACRO>
<MACRO>
<NAME>GST_RG_LIMITER</NAME>
#define GST_RG_LIMITER(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_RG_LIMITER,GstRgLimiter))
</MACRO>
<MACRO>
<NAME>GST_RG_LIMITER_CLASS</NAME>
#define GST_RG_LIMITER_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_RG_LIMITER,GstRgLimiterClass))
</MACRO>
<MACRO>
<NAME>GST_IS_RG_LIMITER</NAME>
#define GST_IS_RG_LIMITER(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_RG_LIMITER))
</MACRO>
<MACRO>
<NAME>GST_IS_RG_LIMITER_CLASS</NAME>
#define GST_IS_RG_LIMITER_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_RG_LIMITER))
</MACRO>
<STRUCT>
<NAME>GstRgLimiter</NAME>
struct _GstRgLimiter
{
  GstBaseTransform element;

  /*< private >*/

  gboolean enabled;
};
</STRUCT>
<STRUCT>
<NAME>GstRgLimiterClass</NAME>
struct _GstRgLimiterClass
{
  GstBaseTransformClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_rg_limiter_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_RG_VOLUME</NAME>
#define GST_TYPE_RG_VOLUME \
  (gst_rg_volume_get_type())
</MACRO>
<MACRO>
<NAME>GST_RG_VOLUME</NAME>
#define GST_RG_VOLUME(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_RG_VOLUME,GstRgVolume))
</MACRO>
<MACRO>
<NAME>GST_RG_VOLUME_CLASS</NAME>
#define GST_RG_VOLUME_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_RG_VOLUME,GstRgVolumeClass))
</MACRO>
<MACRO>
<NAME>GST_IS_RG_VOLUME</NAME>
#define GST_IS_RG_VOLUME(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_RG_VOLUME))
</MACRO>
<MACRO>
<NAME>GST_IS_RG_VOLUME_CLASS</NAME>
#define GST_IS_RG_VOLUME_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_RG_VOLUME))
</MACRO>
<STRUCT>
<NAME>GstRgVolume</NAME>
struct _GstRgVolume
{
  GstBin bin;

  /*< private >*/

  GstElement *volume_element;
  gdouble max_volume;

  gboolean album_mode;
  gdouble headroom;
  gdouble pre_amp;
  gdouble fallback_gain;

  gdouble target_gain;
  gdouble result_gain;

  gdouble track_gain;
  gdouble track_peak;
  gdouble album_gain;
  gdouble album_peak;

  gboolean has_track_gain;
  gboolean has_track_peak;
  gboolean has_album_gain;
  gboolean has_album_peak;

  gdouble reference_level;
};
</STRUCT>
<STRUCT>
<NAME>GstRgVolumeClass</NAME>
struct _GstRgVolumeClass
{
  GstBinClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_rg_volume_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_RTP_J2K_PAY</NAME>
#define GST_TYPE_RTP_J2K_PAY \
  (gst_rtp_j2k_pay_get_type())
</MACRO>
<MACRO>
<NAME>GST_RTP_J2K_PAY</NAME>
#define GST_RTP_J2K_PAY(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_RTP_J2K_PAY,GstRtpJ2KPay))
</MACRO>
<MACRO>
<NAME>GST_RTP_J2K_PAY_CLASS</NAME>
#define GST_RTP_J2K_PAY_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_RTP_J2K_PAY,GstRtpJ2KPayClass))
</MACRO>
<MACRO>
<NAME>GST_IS_RTP_J2K_PAY</NAME>
#define GST_IS_RTP_J2K_PAY(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_RTP_J2K_PAY))
</MACRO>
<MACRO>
<NAME>GST_IS_RTP_J2K_PAY_CLASS</NAME>
#define GST_IS_RTP_J2K_PAY_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_RTP_J2K_PAY))
</MACRO>
<STRUCT>
<NAME>GstRtpJ2KPay</NAME>
struct _GstRtpJ2KPay
{
  GstRTPBasePayload payload;

  gint height;
  gint width;
};
</STRUCT>
<STRUCT>
<NAME>GstRtpJ2KPayClass</NAME>
struct _GstRtpJ2KPayClass
{
  GstRTPBasePayloadClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_rtp_j2k_pay_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_rtp_j2k_pay_plugin_init</NAME>
<RETURNS>gboolean  </RETURNS>
GstPlugin * plugin
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_RTP_JPEG_PAY</NAME>
#define GST_TYPE_RTP_JPEG_PAY \
  (gst_rtp_jpeg_pay_get_type())
</MACRO>
<MACRO>
<NAME>GST_RTP_JPEG_PAY</NAME>
#define GST_RTP_JPEG_PAY(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_RTP_JPEG_PAY,GstRtpJPEGPay))
</MACRO>
<MACRO>
<NAME>GST_RTP_JPEG_PAY_CLASS</NAME>
#define GST_RTP_JPEG_PAY_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_RTP_JPEG_PAY,GstRtpJPEGPayClass))
</MACRO>
<MACRO>
<NAME>GST_IS_RTP_JPEG_PAY</NAME>
#define GST_IS_RTP_JPEG_PAY(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_RTP_JPEG_PAY))
</MACRO>
<MACRO>
<NAME>GST_IS_RTP_JPEG_PAY_CLASS</NAME>
#define GST_IS_RTP_JPEG_PAY_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_RTP_JPEG_PAY))
</MACRO>
<STRUCT>
<NAME>GstRtpJPEGPay</NAME>
struct _GstRtpJPEGPay
{
  GstRTPBasePayload payload;

  guint8 quality;
  guint8 type;

  gint height;
  gint width;

  guint8 quant;
};
</STRUCT>
<STRUCT>
<NAME>GstRtpJPEGPayClass</NAME>
struct _GstRtpJPEGPayClass
{
  GstRTPBasePayloadClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_rtp_jpeg_pay_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_rtp_jpeg_pay_plugin_init</NAME>
<RETURNS>gboolean  </RETURNS>
GstPlugin * plugin
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_RTP_BIN</NAME>
#define GST_TYPE_RTP_BIN \
  (gst_rtp_bin_get_type())
</MACRO>
<MACRO>
<NAME>GST_RTP_BIN</NAME>
#define GST_RTP_BIN(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_RTP_BIN,GstRtpBin))
</MACRO>
<MACRO>
<NAME>GST_RTP_BIN_CLASS</NAME>
#define GST_RTP_BIN_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_RTP_BIN,GstRtpBinClass))
</MACRO>
<MACRO>
<NAME>GST_IS_RTP_BIN</NAME>
#define GST_IS_RTP_BIN(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_RTP_BIN))
</MACRO>
<MACRO>
<NAME>GST_IS_RTP_BIN_CLASS</NAME>
#define GST_IS_RTP_BIN_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_RTP_BIN))
</MACRO>
<ENUM>
<NAME>GstRTCPSync</NAME>
typedef enum
{
  GST_RTP_BIN_RTCP_SYNC_ALWAYS,
  GST_RTP_BIN_RTCP_SYNC_INITIAL,
  GST_RTP_BIN_RTCP_SYNC_RTP
} GstRTCPSync;
</ENUM>
<STRUCT>
<NAME>GstRtpBin</NAME>
struct _GstRtpBin {
  GstBin         bin;

  /*< private >*/
  /* default latency for sessions */
  guint           latency_ms;
  guint64         latency_ns;
  gboolean        drop_on_latency;
  gboolean        do_lost;
  gboolean        ignore_pt;
  gboolean        ntp_sync;
  gint            rtcp_sync;
  guint           rtcp_sync_interval;
  RTPJitterBufferMode buffer_mode;
  gboolean        buffering;
  gboolean        use_pipeline_clock;
  GstRtpNtpTimeSource ntp_time_source;
  gboolean        send_sync_event;
  GstClockTime    buffer_start;
  gboolean        do_retransmission;
  GstRTPProfile   rtp_profile;
  gboolean        rtcp_sync_send_time;
  gint            max_rtcp_rtp_time_diff;
  guint32         max_dropout_time;
  guint32         max_misorder_time;
  gboolean        rfc7273_sync;
  guint           max_streams;

  /* a list of session */
  GSList         *sessions;

  /* a list of clients, these are streams with the same CNAME */
  GSList         *clients;

  /* the default SDES items for sessions */
  GstStructure   *sdes;

  /*< private >*/
  GstRtpBinPrivate *priv;
};
</STRUCT>
<STRUCT>
<NAME>GstRtpBinClass</NAME>
struct _GstRtpBinClass {
  GstBinClass  parent_class;

  /* get the caps for pt */
  GstCaps*    (*request_pt_map)       (GstRtpBin *rtpbin, guint session, guint pt);

  void        (*payload_type_change)  (GstRtpBin *rtpbin, guint session, guint pt);

  void        (*new_jitterbuffer)     (GstRtpBin *rtpbin, GstElement *jitterbuffer, guint session, guint32 ssrc);

  /* action signals */
  void        (*clear_pt_map)         (GstRtpBin *rtpbin);
  void        (*reset_sync)           (GstRtpBin *rtpbin);
  GstElement* (*get_session)          (GstRtpBin *rtpbin, guint session);
  RTPSession* (*get_internal_session) (GstRtpBin *rtpbin, guint session);

  /* session manager signals */
  void     (*on_new_ssrc)       (GstRtpBin *rtpbin, guint session, guint32 ssrc);
  void     (*on_ssrc_collision) (GstRtpBin *rtpbin, guint session, guint32 ssrc);
  void     (*on_ssrc_validated) (GstRtpBin *rtpbin, guint session, guint32 ssrc);
  void     (*on_ssrc_active)    (GstRtpBin *rtpbin, guint session, guint32 ssrc);
  void     (*on_ssrc_sdes)      (GstRtpBin *rtpbin, guint session, guint32 ssrc);
  void     (*on_bye_ssrc)       (GstRtpBin *rtpbin, guint session, guint32 ssrc);
  void     (*on_bye_timeout)    (GstRtpBin *rtpbin, guint session, guint32 ssrc);
  void     (*on_timeout)        (GstRtpBin *rtpbin, guint session, guint32 ssrc);
  void     (*on_sender_timeout) (GstRtpBin *rtpbin, guint session, guint32 ssrc);
  void     (*on_npt_stop)       (GstRtpBin *rtpbin, guint session, guint32 ssrc);

  GstElement* (*request_rtp_encoder)  (GstRtpBin *rtpbin, guint session);
  GstElement* (*request_rtp_decoder)  (GstRtpBin *rtpbin, guint session);
  GstElement* (*request_rtcp_encoder) (GstRtpBin *rtpbin, guint session);
  GstElement* (*request_rtcp_decoder) (GstRtpBin *rtpbin, guint session);

  GstElement* (*request_aux_sender)   (GstRtpBin *rtpbin, guint session);
  GstElement* (*request_aux_receiver) (GstRtpBin *rtpbin, guint session);

  void     (*on_new_sender_ssrc)      (GstRtpBin *rtpbin, guint session, guint32 ssrc);
  void     (*on_sender_ssrc_active)   (GstRtpBin *rtpbin, guint session, guint32 ssrc);

  guint    (*on_bundled_ssrc)         (GstRtpBin *rtpbin, guint ssrc);
};
</STRUCT>
<FUNCTION>
<NAME>gst_rtp_bin_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<STRUCT>
<NAME>GstRtpBinPrivate</NAME>
</STRUCT>
<MACRO>
<NAME>GST_TYPE_RTP_JITTER_BUFFER</NAME>
#define GST_TYPE_RTP_JITTER_BUFFER \
  (gst_rtp_jitter_buffer_get_type())
</MACRO>
<MACRO>
<NAME>GST_RTP_JITTER_BUFFER</NAME>
#define GST_RTP_JITTER_BUFFER(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj), \
  GST_TYPE_RTP_JITTER_BUFFER,GstRtpJitterBuffer))
</MACRO>
<MACRO>
<NAME>GST_RTP_JITTER_BUFFER_CLASS</NAME>
#define GST_RTP_JITTER_BUFFER_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass), \
  GST_TYPE_RTP_JITTER_BUFFER,GstRtpJitterBufferClass))
</MACRO>
<MACRO>
<NAME>GST_IS_RTP_JITTER_BUFFER</NAME>
#define GST_IS_RTP_JITTER_BUFFER(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_RTP_JITTER_BUFFER))
</MACRO>
<MACRO>
<NAME>GST_IS_RTP_JITTER_BUFFER_CLASS</NAME>
#define GST_IS_RTP_JITTER_BUFFER_CLASS(obj) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_RTP_JITTER_BUFFER))
</MACRO>
<MACRO>
<NAME>GST_RTP_JITTER_BUFFER_CAST</NAME>
#define GST_RTP_JITTER_BUFFER_CAST(obj) \
  ((GstRtpJitterBuffer *)(obj))
</MACRO>
<STRUCT>
<NAME>GstRtpJitterBuffer</NAME>
struct _GstRtpJitterBuffer
{
  GstElement parent;

  /*< private >*/
  GstRtpJitterBufferPrivate *priv; /* FIXME: remove? */
};
</STRUCT>
<STRUCT>
<NAME>GstRtpJitterBufferClass</NAME>
struct _GstRtpJitterBufferClass
{
  GstElementClass parent_class;

  /* signals */
  GstCaps* (*request_pt_map)   (GstRtpJitterBuffer *buffer, guint pt);

  void     (*handle_sync)      (GstRtpJitterBuffer *buffer, GstStructure *s);
  void     (*on_npt_stop)      (GstRtpJitterBuffer *buffer);

  /* actions */
  void     (*clear_pt_map)   (GstRtpJitterBuffer *buffer);

  GstClockTime (*set_active)     (GstRtpJitterBuffer *buffer, gboolean active, guint64 elapsed);
};
</STRUCT>
<FUNCTION>
<NAME>gst_rtp_jitter_buffer_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<STRUCT>
<NAME>GstRtpJitterBufferPrivate</NAME>
</STRUCT>
<MACRO>
<NAME>GST_TYPE_RTP_PT_DEMUX</NAME>
#define GST_TYPE_RTP_PT_DEMUX            (gst_rtp_pt_demux_get_type())
</MACRO>
<MACRO>
<NAME>GST_RTP_PT_DEMUX</NAME>
#define GST_RTP_PT_DEMUX(obj)            (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_RTP_PT_DEMUX,GstRtpPtDemux))
</MACRO>
<MACRO>
<NAME>GST_RTP_PT_DEMUX_CLASS</NAME>
#define GST_RTP_PT_DEMUX_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_RTP_PT_DEMUX,GstRtpPtDemuxClass))
</MACRO>
<MACRO>
<NAME>GST_IS_RTP_PT_DEMUX</NAME>
#define GST_IS_RTP_PT_DEMUX(obj)         (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_RTP_PT_DEMUX))
</MACRO>
<MACRO>
<NAME>GST_IS_RTP_PT_DEMUX_CLASS</NAME>
#define GST_IS_RTP_PT_DEMUX_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_RTP_PT_DEMUX))
</MACRO>
<STRUCT>
<NAME>GstRtpPtDemux</NAME>
struct _GstRtpPtDemux
{
  GstElement parent;  /**< parent class */

  GstPad *sink;       /**< the sink pad */
  guint16 last_pt;    /**< pt of the last packet 0xFFFF if none */
  GSList *srcpads;    /**< a linked list of GstRtpPtDemuxPad objects */
};
</STRUCT>
<STRUCT>
<NAME>GstRtpPtDemuxClass</NAME>
struct _GstRtpPtDemuxClass
{
  GstElementClass parent_class;

  /* get the caps for pt */
  GstCaps* (*request_pt_map)      (GstRtpPtDemux *demux, guint pt);

  /* signal emmited when a new PT is found from the incoming stream */
  void     (*new_payload_type)    (GstRtpPtDemux *demux, guint pt, GstPad * pad);

  /* signal emitted when the payload type changes */
  void     (*payload_type_change) (GstRtpPtDemux *demux, guint pt);

  void     (*clear_pt_map)        (GstRtpPtDemux *demux);
};
</STRUCT>
<FUNCTION>
<NAME>gst_rtp_pt_demux_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<STRUCT>
<NAME>GstRtpPtDemuxPad</NAME>
</STRUCT>
<MACRO>
<NAME>GST_TYPE_RTP_SESSION</NAME>
#define GST_TYPE_RTP_SESSION \
  (gst_rtp_session_get_type())
</MACRO>
<MACRO>
<NAME>GST_RTP_SESSION</NAME>
#define GST_RTP_SESSION(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_RTP_SESSION,GstRtpSession))
</MACRO>
<MACRO>
<NAME>GST_RTP_SESSION_CLASS</NAME>
#define GST_RTP_SESSION_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_RTP_SESSION,GstRtpSessionClass))
</MACRO>
<MACRO>
<NAME>GST_IS_RTP_SESSION</NAME>
#define GST_IS_RTP_SESSION(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_RTP_SESSION))
</MACRO>
<MACRO>
<NAME>GST_IS_RTP_SESSION_CLASS</NAME>
#define GST_IS_RTP_SESSION_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_RTP_SESSION))
</MACRO>
<MACRO>
<NAME>GST_RTP_SESSION_CAST</NAME>
#define GST_RTP_SESSION_CAST(obj) ((GstRtpSession *)(obj))
</MACRO>
<STRUCT>
<NAME>GstRtpSession</NAME>
struct _GstRtpSession {
  GstElement     element;

  /*< private >*/
  GstPad        *recv_rtp_sink;
  GstSegment     recv_rtp_seg;
  GstPad        *recv_rtcp_sink;
  GstPad        *send_rtp_sink;
  GstSegment     send_rtp_seg;

  GstPad        *recv_rtp_src;
  GstPad        *sync_src;
  GstPad        *send_rtp_src;
  GstPad        *send_rtcp_src;

  GstRtpSessionPrivate *priv;
};
</STRUCT>
<STRUCT>
<NAME>GstRtpSessionClass</NAME>
struct _GstRtpSessionClass {
  GstElementClass parent_class;

  /* signals */
  GstCaps* (*request_pt_map) (GstRtpSession *sess, guint pt);
  void     (*clear_pt_map)   (GstRtpSession *sess);

  void     (*on_new_ssrc)       (GstRtpSession *sess, guint32 ssrc);
  void     (*on_ssrc_collision) (GstRtpSession *sess, guint32 ssrc);
  void     (*on_ssrc_validated) (GstRtpSession *sess, guint32 ssrc);
  void     (*on_ssrc_active)    (GstRtpSession *sess, guint32 ssrc);
  void     (*on_ssrc_sdes)      (GstRtpSession *sess, guint32 ssrc);
  void     (*on_bye_ssrc)       (GstRtpSession *sess, guint32 ssrc);
  void     (*on_bye_timeout)    (GstRtpSession *sess, guint32 ssrc);
  void     (*on_timeout)        (GstRtpSession *sess, guint32 ssrc);
  void     (*on_sender_timeout) (GstRtpSession *sess, guint32 ssrc);
  void     (*on_new_sender_ssrc)      (GstRtpSession *sess, guint32 ssrc);
  void     (*on_sender_ssrc_active)   (GstRtpSession *sess, guint32 ssrc);
};
</STRUCT>
<FUNCTION>
<NAME>gst_rtp_session_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<ENUM>
<NAME>GstRtpNtpTimeSource</NAME>
typedef enum {
  GST_RTP_NTP_TIME_SOURCE_NTP,
  GST_RTP_NTP_TIME_SOURCE_UNIX,
  GST_RTP_NTP_TIME_SOURCE_RUNNING_TIME,
  GST_RTP_NTP_TIME_SOURCE_CLOCK_TIME
} GstRtpNtpTimeSource;
</ENUM>
<FUNCTION>
<NAME>gst_rtp_ntp_time_source_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<STRUCT>
<NAME>GstRtpSessionPrivate</NAME>
</STRUCT>
<MACRO>
<NAME>GST_TYPE_RTP_SSRC_DEMUX</NAME>
#define GST_TYPE_RTP_SSRC_DEMUX            (gst_rtp_ssrc_demux_get_type())
</MACRO>
<MACRO>
<NAME>GST_RTP_SSRC_DEMUX</NAME>
#define GST_RTP_SSRC_DEMUX(obj)            (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_RTP_SSRC_DEMUX,GstRtpSsrcDemux))
</MACRO>
<MACRO>
<NAME>GST_RTP_SSRC_DEMUX_CLASS</NAME>
#define GST_RTP_SSRC_DEMUX_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_RTP_SSRC_DEMUX,GstRtpSsrcDemuxClass))
</MACRO>
<MACRO>
<NAME>GST_IS_RTP_SSRC_DEMUX</NAME>
#define GST_IS_RTP_SSRC_DEMUX(obj)         (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_RTP_SSRC_DEMUX))
</MACRO>
<MACRO>
<NAME>GST_IS_RTP_SSRC_DEMUX_CLASS</NAME>
#define GST_IS_RTP_SSRC_DEMUX_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_RTP_SSRC_DEMUX))
</MACRO>
<STRUCT>
<NAME>GstRtpSsrcDemux</NAME>
struct _GstRtpSsrcDemux
{
  GstElement parent;

  GstPad *rtp_sink;
  GstPad *rtcp_sink;

  GRecMutex padlock;
  GSList *srcpads;
};
</STRUCT>
<STRUCT>
<NAME>GstRtpSsrcDemuxClass</NAME>
struct _GstRtpSsrcDemuxClass
{
  GstElementClass parent_class;

  /* signals */
  void (*new_ssrc_pad)     (GstRtpSsrcDemux *demux, guint32 ssrc, GstPad *pad);
  void (*removed_ssrc_pad) (GstRtpSsrcDemux *demux, guint32 ssrc, GstPad *pad);

  /* actions */
  void (*clear_ssrc)       (GstRtpSsrcDemux *demux, guint32 ssrc);
};
</STRUCT>
<FUNCTION>
<NAME>gst_rtp_ssrc_demux_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<STRUCT>
<NAME>GstRtpSsrcDemuxPad</NAME>
</STRUCT>
<MACRO>
<NAME>GST_TYPE_RTP_MUX</NAME>
#define GST_TYPE_RTP_MUX (gst_rtp_mux_get_type())
</MACRO>
<MACRO>
<NAME>GST_RTP_MUX</NAME>
#define GST_RTP_MUX(obj) (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_RTP_MUX, GstRTPMux))
</MACRO>
<MACRO>
<NAME>GST_RTP_MUX_CLASS</NAME>
#define GST_RTP_MUX_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_RTP_MUX, GstRTPMuxClass))
</MACRO>
<MACRO>
<NAME>GST_RTP_MUX_GET_CLASS</NAME>
#define GST_RTP_MUX_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), GST_TYPE_RTP_MUX, GstRTPMuxClass))
</MACRO>
<MACRO>
<NAME>GST_IS_RTP_MUX</NAME>
#define GST_IS_RTP_MUX(obj) (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_RTP_MUX))
</MACRO>
<MACRO>
<NAME>GST_IS_RTP_MUX_CLASS</NAME>
#define GST_IS_RTP_MUX_CLASS(obj) (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_RTP_MUX))
</MACRO>
<STRUCT>
<NAME>GstRTPMux</NAME>
struct _GstRTPMux
{
  GstElement element;

  /* pad */
  GstPad *srcpad;

  guint32 ts_base;
  guint16 seqnum_base;

  gint32 ts_offset;
  gint16 seqnum_offset;
  guint16 seqnum;               /* protected by object lock */
  guint ssrc;
  guint current_ssrc;
  gboolean have_ssrc;
  gboolean ssrc_random;

  GstPad *last_pad; /* protected by object lock */

  GstClockTime last_stop;
  gboolean send_stream_start;
};
</STRUCT>
<STRUCT>
<NAME>GstRTPMuxClass</NAME>
struct _GstRTPMuxClass
{
  GstElementClass parent_class;

  gboolean (*accept_buffer_locked) (GstRTPMux *rtp_mux,
      GstRTPMuxPadPrivate * padpriv, GstRTPBuffer * buffer);

  gboolean (*src_event) (GstRTPMux *rtp_mux, GstEvent *event);
};
</STRUCT>
<FUNCTION>
<NAME>gst_rtp_mux_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_rtp_mux_plugin_init</NAME>
<RETURNS>gboolean  </RETURNS>
GstPlugin * plugin
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_RTP_DTMF_MUX</NAME>
#define GST_TYPE_RTP_DTMF_MUX (gst_rtp_dtmf_mux_get_type())
</MACRO>
<MACRO>
<NAME>GST_RTP_DTMF_MUX</NAME>
#define GST_RTP_DTMF_MUX(obj) (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_RTP_DTMF_MUX, GstRTPDTMFMux))
</MACRO>
<MACRO>
<NAME>GST_RTP_DTMF_MUX_CLASS</NAME>
#define GST_RTP_DTMF_MUX_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_RTP_DTMF_MUX, GstRTPDTMFMux))
</MACRO>
<MACRO>
<NAME>GST_IS_RTP_DTMF_MUX</NAME>
#define GST_IS_RTP_DTMF_MUX(obj) (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_RTP_DTMF_MUX))
</MACRO>
<MACRO>
<NAME>GST_IS_RTP_DTMF_MUX_CLASS</NAME>
#define GST_IS_RTP_DTMF_MUX_CLASS(obj) (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_RTP_DTMF_MUX))
</MACRO>
<STRUCT>
<NAME>GstRTPDTMFMux</NAME>
struct _GstRTPDTMFMux
{
  GstRTPMux mux;

  /* Protected by object lock */
  GstClockTime last_priority_end;
};
</STRUCT>
<STRUCT>
<NAME>GstRTPDTMFMuxClass</NAME>
struct _GstRTPDTMFMuxClass
{
  GstRTPMuxClass parent_class;

  /* signals */
  void (*locking) (GstElement * element, GstPad * pad);
  void (*unlocked) (GstElement * element, GstPad * pad);
};
</STRUCT>
<FUNCTION>
<NAME>gst_rtp_dtmf_mux_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_rtp_dtmf_mux_plugin_init</NAME>
<RETURNS>gboolean  </RETURNS>
GstPlugin * plugin
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_RTP_RTX_SEND</NAME>
#define GST_TYPE_RTP_RTX_SEND (gst_rtp_rtx_send_get_type())
</MACRO>
<MACRO>
<NAME>GST_RTP_RTX_SEND</NAME>
#define GST_RTP_RTX_SEND(obj) (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_RTP_RTX_SEND, GstRtpRtxSend))
</MACRO>
<MACRO>
<NAME>GST_RTP_RTX_SEND_CLASS</NAME>
#define GST_RTP_RTX_SEND_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_RTP_RTX_SEND, GstRtpRtxSendClass))
</MACRO>
<MACRO>
<NAME>GST_RTP_RTX_SEND_GET_CLASS</NAME>
#define GST_RTP_RTX_SEND_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), GST_TYPE_RTP_RTX_SEND, GstRtpRtxSendClass))
</MACRO>
<MACRO>
<NAME>GST_IS_RTP_RTX_SEND</NAME>
#define GST_IS_RTP_RTX_SEND(obj) (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_RTP_RTX_SEND))
</MACRO>
<MACRO>
<NAME>GST_IS_RTP_RTX_SEND_CLASS</NAME>
#define GST_IS_RTP_RTX_SEND_CLASS(obj) (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_RTP_RTX_SEND))
</MACRO>
<STRUCT>
<NAME>GstRtpRtxSend</NAME>
struct _GstRtpRtxSend
{
  GstElement element;

  /* pad */
  GstPad *sinkpad;
  GstPad *srcpad;

  /* rtp packets that will be pushed out */
  GstDataQueue *queue;

  /* ssrc -> SSRCRtxData */
  GHashTable *ssrc_data;
  /* rtx ssrc -> master ssrc */
  GHashTable *rtx_ssrcs;

  /* master ssrc -> rtx ssrc (property) */
  GstStructure *external_ssrc_map;

  /* orig pt (uint) -> rtx pt (uint) */
  GHashTable *rtx_pt_map;
  /* orig pt (string) -> rtx pt (uint) */
  GstStructure *rtx_pt_map_structure;

  /* buffering control properties */
  guint max_size_time;
  guint max_size_packets;

  /* statistics */
  guint num_rtx_requests;
  guint num_rtx_packets;
};
</STRUCT>
<STRUCT>
<NAME>GstRtpRtxSendClass</NAME>
struct _GstRtpRtxSendClass
{
  GstElementClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_rtp_rtx_send_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_rtp_rtx_send_plugin_init</NAME>
<RETURNS>gboolean  </RETURNS>
GstPlugin * plugin
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_RTP_RTX_RECEIVE</NAME>
#define GST_TYPE_RTP_RTX_RECEIVE (gst_rtp_rtx_receive_get_type())
</MACRO>
<MACRO>
<NAME>GST_RTP_RTX_RECEIVE</NAME>
#define GST_RTP_RTX_RECEIVE(obj) (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_RTP_RTX_RECEIVE, GstRtpRtxReceive))
</MACRO>
<MACRO>
<NAME>GST_RTP_RTX_RECEIVE_CLASS</NAME>
#define GST_RTP_RTX_RECEIVE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_RTP_RTX_RECEIVE, GstRtpRtxReceiveClass))
</MACRO>
<MACRO>
<NAME>GST_RTP_RTX_RECEIVE_GET_CLASS</NAME>
#define GST_RTP_RTX_RECEIVE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), GST_TYPE_RTP_RTX_RECEIVE, GstRtpRtxReceiveClass))
</MACRO>
<MACRO>
<NAME>GST_IS_RTP_RTX_RECEIVE</NAME>
#define GST_IS_RTP_RTX_RECEIVE(obj) (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_RTP_RTX_RECEIVE))
</MACRO>
<MACRO>
<NAME>GST_IS_RTP_RTX_RECEIVE_CLASS</NAME>
#define GST_IS_RTP_RTX_RECEIVE_CLASS(obj) (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_RTP_RTX_RECEIVE))
</MACRO>
<STRUCT>
<NAME>GstRtpRtxReceive</NAME>
struct _GstRtpRtxReceive
{
  GstElement element;

  /* pad */
  GstPad *sinkpad;
  GstPad *srcpad;

  /* retrieve associated master stream from rtx stream
   * it also works to retrieve rtx stream from master stream
   * as we make sure all ssrc are unique */
  GHashTable *ssrc2_ssrc1_map;

  /* contains seqnum of request packets of whom their ssrc have
   * not been associated to a rtx stream yet */
  GHashTable *seqnum_ssrc1_map;

  /* rtx pt (uint) -> origin pt (uint) */
  GHashTable *rtx_pt_map;
  /* origin pt (string) -> rtx pt (uint) */
  GstStructure *rtx_pt_map_structure;

  /* statistics */
  guint num_rtx_requests;
  guint num_rtx_packets;
  guint num_rtx_assoc_packets;

  GstClockTime last_time;
};
</STRUCT>
<STRUCT>
<NAME>GstRtpRtxReceiveClass</NAME>
struct _GstRtpRtxReceiveClass
{
  GstElementClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_rtp_rtx_receive_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_rtp_rtx_receive_plugin_init</NAME>
<RETURNS>gboolean  </RETURNS>
GstPlugin * plugin
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_RTP_DEC</NAME>
#define GST_TYPE_RTP_DEC  		(gst_rtp_dec_get_type())
</MACRO>
<MACRO>
<NAME>GST_IS_RTP_DEC</NAME>
#define GST_IS_RTP_DEC(obj)  		(G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_RTP_DEC))
</MACRO>
<MACRO>
<NAME>GST_IS_RTP_DEC_CLASS</NAME>
#define GST_IS_RTP_DEC_CLASS(klass) 	(G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_RTP_DEC))
</MACRO>
<MACRO>
<NAME>GST_RTP_DEC</NAME>
#define GST_RTP_DEC(obj)  		(G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_RTP_DEC, GstRTPDec))
</MACRO>
<MACRO>
<NAME>GST_RTP_DEC_CLASS</NAME>
#define GST_RTP_DEC_CLASS(klass)  	(G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_RTP_DEC, GstRTPDecClass))
</MACRO>
<STRUCT>
<NAME>GstRTPDec</NAME>
struct _GstRTPDec {
  GstElement  element;

  guint       latency;
  GSList     *sessions;
  GstClock   *provided_clock;
};
</STRUCT>
<STRUCT>
<NAME>GstRTPDecClass</NAME>
struct _GstRTPDecClass {
  GstElementClass parent_class;

  /* get the caps for pt */
  GstCaps* (*request_pt_map)  (GstRTPDec *rtpdec, guint session, guint pt);

  void     (*clear_pt_map)    (GstRTPDec *rtpdec);

  void     (*on_new_ssrc)       (GstRTPDec *rtpdec, guint session, guint32 ssrc);
  void     (*on_ssrc_collision) (GstRTPDec *rtpdec, guint session, guint32 ssrc);
  void     (*on_ssrc_validated) (GstRTPDec *rtpdec, guint session, guint32 ssrc);
  void     (*on_bye_ssrc)       (GstRTPDec *rtpdec, guint session, guint32 ssrc);
  void     (*on_bye_timeout)    (GstRTPDec *rtpdec, guint session, guint32 ssrc);
  void     (*on_timeout)        (GstRTPDec *rtpdec, guint session, guint32 ssrc);
};
</STRUCT>
<FUNCTION>
<NAME>gst_rtp_dec_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<STRUCT>
<NAME>GstRTPDecSession</NAME>
</STRUCT>
<MACRO>
<NAME>GST_TYPE_RTSPSRC</NAME>
#define GST_TYPE_RTSPSRC \
  (gst_rtspsrc_get_type())
</MACRO>
<MACRO>
<NAME>GST_RTSPSRC</NAME>
#define GST_RTSPSRC(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_RTSPSRC,GstRTSPSrc))
</MACRO>
<MACRO>
<NAME>GST_RTSPSRC_CLASS</NAME>
#define GST_RTSPSRC_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_RTSPSRC,GstRTSPSrcClass))
</MACRO>
<MACRO>
<NAME>GST_IS_RTSPSRC</NAME>
#define GST_IS_RTSPSRC(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_RTSPSRC))
</MACRO>
<MACRO>
<NAME>GST_IS_RTSPSRC_CLASS</NAME>
#define GST_IS_RTSPSRC_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_RTSPSRC))
</MACRO>
<MACRO>
<NAME>GST_RTSPSRC_CAST</NAME>
#define GST_RTSPSRC_CAST(obj) \
  ((GstRTSPSrc *)(obj))
</MACRO>
<MACRO>
<NAME>GST_RTSP_STATE_GET_LOCK</NAME>
#define GST_RTSP_STATE_GET_LOCK(rtsp)    (&GST_RTSPSRC_CAST(rtsp)->state_rec_lock)
</MACRO>
<MACRO>
<NAME>GST_RTSP_STATE_LOCK</NAME>
#define GST_RTSP_STATE_LOCK(rtsp)        (g_rec_mutex_lock (GST_RTSP_STATE_GET_LOCK(rtsp)))
</MACRO>
<MACRO>
<NAME>GST_RTSP_STATE_UNLOCK</NAME>
#define GST_RTSP_STATE_UNLOCK(rtsp)      (g_rec_mutex_unlock (GST_RTSP_STATE_GET_LOCK(rtsp)))
</MACRO>
<MACRO>
<NAME>GST_RTSP_STREAM_GET_LOCK</NAME>
#define GST_RTSP_STREAM_GET_LOCK(rtsp)   (&GST_RTSPSRC_CAST(rtsp)->stream_rec_lock)
</MACRO>
<MACRO>
<NAME>GST_RTSP_STREAM_LOCK</NAME>
#define GST_RTSP_STREAM_LOCK(rtsp)       (g_rec_mutex_lock (GST_RTSP_STREAM_GET_LOCK(rtsp)))
</MACRO>
<MACRO>
<NAME>GST_RTSP_STREAM_UNLOCK</NAME>
#define GST_RTSP_STREAM_UNLOCK(rtsp)     (g_rec_mutex_unlock (GST_RTSP_STREAM_GET_LOCK(rtsp)))
</MACRO>
<STRUCT>
<NAME>GstRTSPConnInfo</NAME>
struct _GstRTSPConnInfo {
  gchar              *location;
  GstRTSPUrl         *url;
  gchar              *url_str;
  GstRTSPConnection  *connection;
  gboolean            connected;
  gboolean            flushing;

  GMutex              send_lock;
  GMutex              recv_lock;
};
</STRUCT>
<STRUCT>
<NAME>GstRTSPStream</NAME>
struct _GstRTSPStream {
  gint          id;

  GstRTSPSrc   *parent; /* parent, no extra ref to parent is taken */

  /* pad we expose or NULL when it does not have an actual pad */
  GstPad       *srcpad;
  GstFlowReturn last_ret;
  gboolean      added;
  gboolean      setup;
  gboolean      skipped;
  gboolean      eos;
  gboolean      discont;
  gboolean      need_caps;

  /* for interleaved mode */
  guint8        channel[2];
  GstPad       *channelpad[2];

  /* our udp sources */
  GstElement   *udpsrc[2];
  GstPad       *blockedpad;
  gulong        blockid;
  gboolean      is_ipv6;

  /* our udp sinks back to the server */
  GstElement   *udpsink[2];
  GstPad       *rtcppad;

  /* fakesrc for sending dummy data */
  GstElement   *fakesrc;

  /* state */
  guint         port;
  gboolean      container;
  gboolean      is_real;
  guint8        default_pt;
  GstRTSPProfile profile;
  GArray       *ptmap;
  /* original control url */
  gchar        *control_url;
  guint32       ssrc;
  guint32       seqbase;
  guint64       timebase;
  GstElement   *srtpdec;
  GstCaps      *srtcpparams;
  GstElement   *srtpenc;
  guint32       send_ssrc;

  /* per stream connection */
  GstRTSPConnInfo  conninfo;

  /* session */
  GObject      *session;

  /* srtp key management */
  GstMIKEYMessage *mikey;

  /* bandwidth */
  guint         as_bandwidth;
  guint         rs_bandwidth;
  guint         rr_bandwidth;

  /* destination */
  gchar        *destination;
  gboolean      is_multicast;
  guint         ttl;

  GstStructure     *rtx_pt_map;
};
</STRUCT>
<ENUM>
<NAME>GstRTSPNatMethod</NAME>
typedef enum
{
  GST_RTSP_NAT_NONE,
  GST_RTSP_NAT_DUMMY
} GstRTSPNatMethod;
</ENUM>
<STRUCT>
<NAME>GstRTSPSrc</NAME>
struct _GstRTSPSrc {
  GstBin           parent;

  /* task and mutex for interleaved mode */
  gboolean         interleaved;
  GstTask         *task;
  GRecMutex        stream_rec_lock;
  GstSegment       segment;
  gboolean         running;
  gboolean         need_range;
  gboolean         skip;
  gint             free_channel;
  gboolean         need_segment;
  GstClockTime     base_time;

  /* UDP mode loop */
  gint             pending_cmd;
  gint             busy_cmd;
  gboolean         ignore_timeout;
  gboolean         open_error;

  /* mutex for protecting state changes */
  GRecMutex        state_rec_lock;

  GstSDPMessage   *sdp;
  gboolean         from_sdp;
  GList           *streams;
  GstStructure    *props;
  gboolean         need_activate;

  /* properties */
  GstRTSPLowerTrans protocols;
  gboolean          debug;
  guint             retry;
  guint64           udp_timeout;
  GTimeVal          tcp_timeout;
  GTimeVal         *ptcp_timeout;
  guint             latency;
  gboolean          drop_on_latency;
  guint64           connection_speed;
  GstRTSPNatMethod  nat_method;
  gboolean          do_rtcp;
  gboolean          do_rtsp_keep_alive;
  gchar            *proxy_host;
  guint             proxy_port;
  gchar            *proxy_user;        /* from url or property */
  gchar            *proxy_passwd;      /* from url or property */
  gchar            *prop_proxy_id;     /* set via property */
  gchar            *prop_proxy_pw;     /* set via property */
  guint             rtp_blocksize;
  gchar            *user_id;
  gchar            *user_pw;
  gint              buffer_mode;
  GstRTSPRange      client_port_range;
  gint              udp_buffer_size;
  gboolean          short_header;
  guint             probation;
  gboolean          udp_reconnect;
  gchar            *multi_iface;
  gboolean          ntp_sync;
  gboolean          use_pipeline_clock;
  GstStructure     *sdes;
  GTlsCertificateFlags tls_validation_flags;
  GTlsDatabase     *tls_database;
  GTlsInteraction  *tls_interaction;
  gboolean          do_retransmission;
  gint              ntp_time_source;
  gchar            *user_agent;
  GstClockTime      max_rtcp_rtp_time_diff;
  gboolean          rfc7273_sync;

  /* state */
  GstRTSPState       state;
  gchar             *content_base;
  GstRTSPLowerTrans  cur_protocols;
  gboolean           tried_url_auth;
  gchar             *addr;
  gboolean           need_redirect;
  GstRTSPTimeRange  *range;
  gchar             *control;
  guint              next_port_num;
  GstClock          *provided_clock;

  /* supported methods */
  gint               methods;

  gboolean           seekable;
  GstClockTime       last_pos;

  /* session management */
  GstElement      *manager;
  gulong           manager_sig_id;
  gulong           manager_ptmap_id;
  gboolean         use_buffering;

  GstRTSPConnInfo  conninfo;

  /* a list of RTSP extensions as GstElement */
  GstRTSPExtensionList  *extensions;
};
</STRUCT>
<STRUCT>
<NAME>GstRTSPSrcClass</NAME>
struct _GstRTSPSrcClass {
  GstBinClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_rtspsrc_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_SHAPE_WIPE</NAME>
#define GST_TYPE_SHAPE_WIPE \
  (gst_shape_wipe_get_type())
</MACRO>
<MACRO>
<NAME>GST_SHAPE_WIPE</NAME>
#define GST_SHAPE_WIPE(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_SHAPE_WIPE,GstShapeWipe))
</MACRO>
<MACRO>
<NAME>GST_SHAPE_WIPE_CLASS</NAME>
#define GST_SHAPE_WIPE_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_SHAPE_WIPE,GstShapeWipeClass))
</MACRO>
<MACRO>
<NAME>GST_SHAPE_WIPE_GET_CLASS</NAME>
#define GST_SHAPE_WIPE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj),GST_TYPE_SHAPE_WIPE,GstShapeWipeClass))
</MACRO>
<MACRO>
<NAME>GST_IS_SHAPE_WIPE</NAME>
#define GST_IS_SHAPE_WIPE(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_SHAPE_WIPE))
</MACRO>
<MACRO>
<NAME>GST_IS_SHAPE_WIPE_CLASS</NAME>
#define GST_IS_SHAPE_WIPE_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_SHAPE_WIPE))
</MACRO>
<STRUCT>
<NAME>GstShapeWipe</NAME>
struct _GstShapeWipe
{
  GstElement parent;

  /* private */
  GstPad *video_sinkpad;
  GstPad *mask_sinkpad;

  GstPad *srcpad;

  GstSegment segment;

  GstBuffer *mask;
  gfloat mask_position;
  gfloat mask_border;
  GMutex mask_mutex;
  GCond mask_cond;
  gint mask_bpp;

  GstVideoInfo vinfo;
  GstVideoInfo minfo;

  gboolean shutdown;

  gdouble proportion;
  GstClockTime earliest_time;
  GstClockTime frame_duration;
};
</STRUCT>
<STRUCT>
<NAME>GstShapeWipeClass</NAME>
struct _GstShapeWipeClass
{
  GstElementClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_shape_wipe_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_SMPTE</NAME>
#define GST_TYPE_SMPTE \
  (gst_smpte_get_type())
</MACRO>
<MACRO>
<NAME>GST_SMPTE</NAME>
#define GST_SMPTE(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_SMPTE,GstSMPTE))
</MACRO>
<MACRO>
<NAME>GST_SMPTE_CLASS</NAME>
#define GST_SMPTE_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_SMPTE,GstSMPTEClass))
</MACRO>
<MACRO>
<NAME>GST_IS_SMPTE</NAME>
#define GST_IS_SMPTE(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_SMPTE))
</MACRO>
<MACRO>
<NAME>GST_IS_SMPTE_CLASS</NAME>
#define GST_IS_SMPTE_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_SMPTE))
</MACRO>
<STRUCT>
<NAME>GstSMPTE</NAME>
struct _GstSMPTE {
  GstElement     element;

  /* pads */
  GstPad        *srcpad,
                *sinkpad1,
                *sinkpad2;
  GstCollectPads *collect;
  gboolean        send_stream_start;

  /* properties */
  gint           type;
  gint           border;
  gint           depth;
  guint64        duration;
  gboolean       invert;

  /* negotiated format */
  gint           width;
  gint           height;
  gint           fps_num;
  gint           fps_denom;
  GstVideoInfo   vinfo1;
  GstVideoInfo   vinfo2;

  /* state of the effect */
  gint           position;
  gint           end_position;
  GstMask       *mask;
};
</STRUCT>
<STRUCT>
<NAME>GstSMPTEClass</NAME>
struct _GstSMPTEClass {
  GstElementClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_smpte_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_smpte_plugin_init</NAME>
<RETURNS>gboolean  </RETURNS>
GstPlugin * plugin
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_SMPTE_ALPHA</NAME>
#define GST_TYPE_SMPTE_ALPHA \
  (gst_smpte_alpha_get_type())
</MACRO>
<MACRO>
<NAME>GST_SMPTE_ALPHA</NAME>
#define GST_SMPTE_ALPHA(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_SMPTE_ALPHA,GstSMPTEAlpha))
</MACRO>
<MACRO>
<NAME>GST_SMPTE_ALPHA_CLASS</NAME>
#define GST_SMPTE_ALPHA_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_SMPTE_ALPHA,GstSMPTEAlphaClass))
</MACRO>
<MACRO>
<NAME>GST_IS_SMPTE_ALPHA</NAME>
#define GST_IS_SMPTE_ALPHA(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_SMPTE_ALPHA))
</MACRO>
<MACRO>
<NAME>GST_IS_SMPTE_ALPHA_CLASS</NAME>
#define GST_IS_SMPTE_ALPHA_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_SMPTE_ALPHA))
</MACRO>
<STRUCT>
<NAME>GstSMPTEAlpha</NAME>
struct _GstSMPTEAlpha {
  GstVideoFilter element;

  /* properties */
  gint           type;
  gint           border;
  gint           depth;
  gdouble        position;
  gboolean       invert;

  /* negotiated format */
  GstVideoFormat in_format, out_format;
  gint           width;
  gint           height;

  /* state of the effect */
  GstMask       *mask;

  /* processing function */
  void (*process) (GstSMPTEAlpha * smpte, const GstVideoFrame * in, GstVideoFrame * out,
    GstMask * mask, gint border, gint pos);
};
</STRUCT>
<STRUCT>
<NAME>GstSMPTEAlphaClass</NAME>
struct _GstSMPTEAlphaClass {
  GstVideoFilterClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_smpte_alpha_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_smpte_alpha_plugin_init</NAME>
<RETURNS>gboolean  </RETURNS>
GstPlugin * plugin
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_SPECTRUM</NAME>
#define GST_TYPE_SPECTRUM            (gst_spectrum_get_type())
</MACRO>
<MACRO>
<NAME>GST_SPECTRUM</NAME>
#define GST_SPECTRUM(obj)            (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_SPECTRUM,GstSpectrum))
</MACRO>
<MACRO>
<NAME>GST_IS_SPECTRUM</NAME>
#define GST_IS_SPECTRUM(obj)         (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_SPECTRUM))
</MACRO>
<MACRO>
<NAME>GST_SPECTRUM_CLASS</NAME>
#define GST_SPECTRUM_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST((klass), GST_TYPE_SPECTRUM,GstSpectrumClass))
</MACRO>
<MACRO>
<NAME>GST_IS_SPECTRUM_CLASS</NAME>
#define GST_IS_SPECTRUM_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE((klass), GST_TYPE_SPECTRUM))
</MACRO>
<USER_FUNCTION>
<NAME>GstSpectrumInputData</NAME>
<RETURNS>void </RETURNS>
const guint8 * in, gfloat * out,
    guint len, guint channels, gfloat max_value, guint op, guint nfft
</USER_FUNCTION>
<STRUCT>
<NAME>GstSpectrumChannel</NAME>
struct _GstSpectrumChannel
{
  gfloat *input;
  gfloat *input_tmp;
  GstFFTF32Complex *freqdata;
  gfloat *spect_magnitude;      /* accumulated mangitude and phase */
  gfloat *spect_phase;          /* will be scaled by num_fft before sending */
  GstFFTF32 *fft_ctx;
};
</STRUCT>
<STRUCT>
<NAME>GstSpectrum</NAME>
struct _GstSpectrum
{
  GstAudioFilter parent;

  /* properties */
  gboolean post_messages;       /* whether or not to post messages */
  gboolean message_magnitude;
  gboolean message_phase;
  guint64 interval;             /* how many nanoseconds between emits */
  guint64 frames_per_interval;  /* how many frames per interval */
  guint64 frames_todo;
  guint bands;                  /* number of spectrum bands */
  gint threshold;               /* energy level treshold */
  gboolean multi_channel;       /* send separate channel results */

  guint64 num_frames;           /* frame count (1 sample per channel)
                                 * since last emit */
  guint64 num_fft;              /* number of FFTs since last emit */
  GstClockTime message_ts;      /* starttime for next message */

  /* <private> */
  GstSpectrumChannel *channel_data;
  guint num_channels;

  guint input_pos;
  guint64 error_per_interval;
  guint64 accumulated_error;

  GMutex lock;

  GstSpectrumInputData input_data;
};
</STRUCT>
<STRUCT>
<NAME>GstSpectrumClass</NAME>
struct _GstSpectrumClass
{
  GstAudioFilterClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_spectrum_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_MULTIUDPSINK</NAME>
#define GST_TYPE_MULTIUDPSINK            (gst_multiudpsink_get_type())
</MACRO>
<MACRO>
<NAME>GST_MULTIUDPSINK</NAME>
#define GST_MULTIUDPSINK(obj)            (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_MULTIUDPSINK,GstMultiUDPSink))
</MACRO>
<MACRO>
<NAME>GST_MULTIUDPSINK_CLASS</NAME>
#define GST_MULTIUDPSINK_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_MULTIUDPSINK,GstMultiUDPSinkClass))
</MACRO>
<MACRO>
<NAME>GST_IS_MULTIUDPSINK</NAME>
#define GST_IS_MULTIUDPSINK(obj)         (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_MULTIUDPSINK))
</MACRO>
<MACRO>
<NAME>GST_IS_MULTIUDPSINK_CLASS</NAME>
#define GST_IS_MULTIUDPSINK_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_MULTIUDPSINK))
</MACRO>
<MACRO>
<NAME>GST_MULTIUDPSINK_CAST</NAME>
#define GST_MULTIUDPSINK_CAST(obj)       ((GstMultiUDPSink*)(obj))
</MACRO>
<MACRO>
<NAME>HAVE_G_SOCKET_SEND_MESSAGES</NAME>
#define HAVE_G_SOCKET_SEND_MESSAGES
</MACRO>
<STRUCT>
<NAME>GstOutputMessage</NAME>
typedef struct {
  /*< private >*/
  GSocketAddress         *address;

  GOutputVector          *vectors;
  guint                   num_vectors;

  guint                   bytes_sent;

  GSocketControlMessage **control_messages;
  guint                   num_control_messages;
} GstOutputMessage;
</STRUCT>
<STRUCT>
<NAME>GstUDPClient</NAME>
typedef struct {
  gint ref_count;         /* for memory management */
  gint add_count;         /* how often this address has been added */

  GSocketAddress *addr;
  gchar *host;
  gint port;

  /* Per-client stats */
  guint64 bytes_sent;
  guint64 packets_sent;
  guint64 connect_time;
  guint64 disconnect_time;
} GstUDPClient;
</STRUCT>
<STRUCT>
<NAME>GstMultiUDPSink</NAME>
struct _GstMultiUDPSink {
  GstBaseSink parent;

  GSocket       *used_socket, *used_socket_v6;

  GCancellable  *cancellable;
  gboolean       made_cancel_fd;

  /* client management */
  GMutex         client_lock;
  GList         *clients;
  guint          num_v4_unique;  /* number IPv4 clients (excluding duplicates) */
  guint          num_v4_all;     /* number IPv4 clients (including duplicates) */
  guint          num_v6_unique;  /* number IPv6 clients (excluding duplicates) */
  guint          num_v6_all;     /* number IPv6 clients (including duplicates) */
  GList         *clients_to_be_removed;

  /* pre-allocated scrap space for render function */
  GOutputVector    *vecs;
  guint             n_vecs;
  GstMapInfo       *maps;
  guint             n_maps;
  GstOutputMessage *messages;
  guint             n_messages;

  /* properties */
  guint64        bytes_to_serve;
  guint64        bytes_served;
  GSocket       *socket, *socket_v6;
  gboolean       close_socket;

  gboolean       external_socket;

  gboolean       auto_multicast;
  gchar         *multi_iface;
  gint           ttl;
  gint           ttl_mc;
  gboolean       loop;
  gboolean       force_ipv4;
  gint           qos_dscp;

  gboolean       send_duplicates;
  gint           buffer_size;
  gchar         *bind_address;
  gint           bind_port;
};
</STRUCT>
<STRUCT>
<NAME>GstMultiUDPSinkClass</NAME>
struct _GstMultiUDPSinkClass {
  GstBaseSinkClass parent_class;

  /* element methods */
  void          (*add)          (GstMultiUDPSink *sink, const gchar *host, gint port);
  void          (*remove)       (GstMultiUDPSink *sink, const gchar *host, gint port);
  void          (*clear)        (GstMultiUDPSink *sink);
  GstStructure* (*get_stats)    (GstMultiUDPSink *sink, const gchar *host, gint port);

  /* signals */
  void          (*client_added) (GstElement *element, const gchar *host, gint port);
  void          (*client_removed) (GstElement *element, const gchar *host, gint port);
};
</STRUCT>
<FUNCTION>
<NAME>gst_multiudpsink_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_multiudpsink_add</NAME>
<RETURNS>void             </RETURNS>
GstMultiUDPSink *sink, const gchar *host, gint port
</FUNCTION>
<FUNCTION>
<NAME>gst_multiudpsink_remove</NAME>
<RETURNS>void             </RETURNS>
GstMultiUDPSink *sink, const gchar *host, gint port
</FUNCTION>
<FUNCTION>
<NAME>gst_multiudpsink_clear</NAME>
<RETURNS>void             </RETURNS>
GstMultiUDPSink *sink
</FUNCTION>
<FUNCTION>
<NAME>gst_multiudpsink_get_stats</NAME>
<RETURNS>GstStructure *   </RETURNS>
GstMultiUDPSink *sink, const gchar *host, gint port
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_UDPSRC</NAME>
#define GST_TYPE_UDPSRC \
  (gst_udpsrc_get_type())
</MACRO>
<MACRO>
<NAME>GST_UDPSRC</NAME>
#define GST_UDPSRC(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_UDPSRC,GstUDPSrc))
</MACRO>
<MACRO>
<NAME>GST_UDPSRC_CLASS</NAME>
#define GST_UDPSRC_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_UDPSRC,GstUDPSrcClass))
</MACRO>
<MACRO>
<NAME>GST_IS_UDPSRC</NAME>
#define GST_IS_UDPSRC(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_UDPSRC))
</MACRO>
<MACRO>
<NAME>GST_IS_UDPSRC_CLASS</NAME>
#define GST_IS_UDPSRC_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_UDPSRC))
</MACRO>
<MACRO>
<NAME>GST_UDPSRC_CAST</NAME>
#define GST_UDPSRC_CAST(obj) ((GstUDPSrc *)(obj))
</MACRO>
<STRUCT>
<NAME>GstUDPSrc</NAME>
struct _GstUDPSrc {
  GstPushSrc parent;

  /* properties */
  gchar     *address;
  gint       port;
  gchar     *multi_iface;
  gint       ttl;
  GstCaps   *caps;
  gint       buffer_size;
  guint64    timeout;
  gint       skip_first_bytes;
  GSocket   *socket;
  gboolean   close_socket;
  gboolean   auto_multicast;
  gboolean   reuse;
  gboolean   loop;
  gboolean   retrieve_sender_address;

  /* stats */
  guint      max_size;

  /* our sockets */
  GSocket   *used_socket;
  GInetSocketAddress *addr;
  gboolean   external_socket;

  gboolean   made_cancel_fd;
  GCancellable *cancellable;

  /* memory management */
  GstAllocator *allocator;
  GstAllocationParams params;

  GstMemory   *mem;
  GstMapInfo   map;
  GstMemory   *mem_max;
  GstMapInfo   map_max;
  GInputVector vec[2];

  gchar     *uri;
};
</STRUCT>
<STRUCT>
<NAME>GstUDPSrcClass</NAME>
struct _GstUDPSrcClass {
  GstPushSrcClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_udpsrc_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_UDPSINK</NAME>
#define GST_TYPE_UDPSINK                (gst_udpsink_get_type())
</MACRO>
<MACRO>
<NAME>GST_UDPSINK</NAME>
#define GST_UDPSINK(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_UDPSINK,GstUDPSink))
</MACRO>
<MACRO>
<NAME>GST_UDPSINK_CLASS</NAME>
#define GST_UDPSINK_CLASS(klass)        (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_UDPSINK,GstUDPSinkClass))
</MACRO>
<MACRO>
<NAME>GST_IS_UDPSINK</NAME>
#define GST_IS_UDPSINK(obj)             (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_UDPSINK))
</MACRO>
<MACRO>
<NAME>GST_IS_UDPSINK_CLASS</NAME>
#define GST_IS_UDPSINK_CLASS(klass)     (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_UDPSINK))
</MACRO>
<STRUCT>
<NAME>GstUDPSink</NAME>
struct _GstUDPSink {
  GstMultiUDPSink parent;

  gchar *host;
  guint16 port;

  gchar *uri;
};
</STRUCT>
<STRUCT>
<NAME>GstUDPSinkClass</NAME>
struct _GstUDPSinkClass {
  GstMultiUDPSinkClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_udpsink_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_VIDEO_BOX</NAME>
#define GST_TYPE_VIDEO_BOX \
  (gst_video_box_get_type())
</MACRO>
<MACRO>
<NAME>GST_VIDEO_BOX</NAME>
#define GST_VIDEO_BOX(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_VIDEO_BOX,GstVideoBox))
</MACRO>
<MACRO>
<NAME>GST_VIDEO_BOX_CLASS</NAME>
#define GST_VIDEO_BOX_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_VIDEO_BOX,GstVideoBoxClass))
</MACRO>
<MACRO>
<NAME>GST_IS_VIDEO_BOX</NAME>
#define GST_IS_VIDEO_BOX(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_VIDEO_BOX))
</MACRO>
<MACRO>
<NAME>GST_IS_VIDEO_BOX_CLASS</NAME>
#define GST_IS_VIDEO_BOX_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_VIDEO_BOX))
</MACRO>
<ENUM>
<NAME>GstVideoBoxFill</NAME>
typedef enum
{
  VIDEO_BOX_FILL_BLACK,
  VIDEO_BOX_FILL_GREEN,
  VIDEO_BOX_FILL_BLUE,
  VIDEO_BOX_FILL_RED,
  VIDEO_BOX_FILL_YELLOW,
  VIDEO_BOX_FILL_WHITE,
  VIDEO_BOX_FILL_LAST
}
GstVideoBoxFill;
</ENUM>
<STRUCT>
<NAME>GstVideoBox</NAME>
struct _GstVideoBox
{
  GstVideoFilter element;

  /* <private> */

  /* Guarding everything below */
  GMutex mutex;
  /* caps */
  GstVideoFormat in_format;
  gint in_width, in_height;
  gboolean in_sdtv;
  GstVideoFormat out_format;
  gint out_width, out_height;
  gboolean out_sdtv;

  gint box_left, box_right, box_top, box_bottom;

  gint border_left, border_right, border_top, border_bottom;
  gint crop_left, crop_right, crop_top, crop_bottom;

  gdouble alpha;
  gdouble border_alpha;

  GstVideoBoxFill fill_type;

  gboolean autocrop;

  void (*fill) (GstVideoBoxFill fill_type, guint b_alpha, GstVideoFrame *dest, gboolean sdtv);
  void (*copy) (guint i_alpha, GstVideoFrame * dest, gboolean dest_sdtv, gint dest_x, gint dest_y, GstVideoFrame * src, gboolean src_sdtv, gint src_x, gint src_y, gint w, gint h);
};
</STRUCT>
<STRUCT>
<NAME>GstVideoBoxClass</NAME>
struct _GstVideoBoxClass
{
  GstVideoFilterClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_video_box_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_VIDEO_CROP</NAME>
#define GST_TYPE_VIDEO_CROP \
  (gst_video_crop_get_type())
</MACRO>
<MACRO>
<NAME>GST_VIDEO_CROP</NAME>
#define GST_VIDEO_CROP(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_VIDEO_CROP,GstVideoCrop))
</MACRO>
<MACRO>
<NAME>GST_VIDEO_CROP_CLASS</NAME>
#define GST_VIDEO_CROP_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_VIDEO_CROP,GstVideoCropClass))
</MACRO>
<MACRO>
<NAME>GST_IS_VIDEO_CROP</NAME>
#define GST_IS_VIDEO_CROP(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_VIDEO_CROP))
</MACRO>
<MACRO>
<NAME>GST_IS_VIDEO_CROP_CLASS</NAME>
#define GST_IS_VIDEO_CROP_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_VIDEO_CROP))
</MACRO>
<ENUM>
<NAME>VideoCropPixelFormat</NAME>
typedef enum {
  VIDEO_CROP_PIXEL_FORMAT_PACKED_SIMPLE = 0,  /* RGBx, AYUV */
  VIDEO_CROP_PIXEL_FORMAT_PACKED_COMPLEX,     /* UYVY, YVYU */
  VIDEO_CROP_PIXEL_FORMAT_PLANAR,             /* I420, YV12 */
  VIDEO_CROP_PIXEL_FORMAT_SEMI_PLANAR         /* NV12, NV21 */
} VideoCropPixelFormat;
</ENUM>
<STRUCT>
<NAME>GstVideoCrop</NAME>
struct _GstVideoCrop
{
  GstVideoFilter parent;

  /*< private >*/
  gint prop_left;
  gint prop_right;
  gint prop_top;
  gint prop_bottom;
  gboolean need_update;

  GstVideoInfo in_info;
  GstVideoInfo out_info;

  gint crop_left;
  gint crop_right;
  gint crop_top;
  gint crop_bottom;

  VideoCropPixelFormat  packing;
  gint macro_y_off;
};
</STRUCT>
<STRUCT>
<NAME>GstVideoCropClass</NAME>
struct _GstVideoCropClass
{
  GstVideoFilterClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_video_crop_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<STRUCT>
<NAME>GstVideoCropImageDetails</NAME>
</STRUCT>
<MACRO>
<NAME>GST_TYPE_ASPECT_RATIO_CROP</NAME>
#define GST_TYPE_ASPECT_RATIO_CROP \
  (gst_aspect_ratio_crop_get_type())
</MACRO>
<MACRO>
<NAME>GST_ASPECT_RATIO_CROP</NAME>
#define GST_ASPECT_RATIO_CROP(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_ASPECT_RATIO_CROP,GstAspectRatioCrop))
</MACRO>
<MACRO>
<NAME>GST_ASPECT_RATIO_CROP_CLASS</NAME>
#define GST_ASPECT_RATIO_CROP_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_ASPECT_RATIO_CROP,GstAspectRatioCropClass))
</MACRO>
<MACRO>
<NAME>GST_IS_ASPECT_RATIO_CROP</NAME>
#define GST_IS_ASPECT_RATIO_CROP(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_ASPECT_RATIO_CROP))
</MACRO>
<MACRO>
<NAME>GST_IS_ASPECT_RATIO_CROP_CLASS</NAME>
#define GST_IS_ASPECT_RATIO_CROP_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_ASPECT_RATIO_CROP))
</MACRO>
<STRUCT>
<NAME>GstAspectRatioCrop</NAME>
struct _GstAspectRatioCrop
{
  GstBin parent;

  /* our videocrop element */
  GstElement *videocrop;

  GstPad *sink;

  /* target aspect ratio */
  gint ar_num; /* if < 1 then don't change ar */
  gint ar_denom;

  GMutex crop_lock;
};
</STRUCT>
<STRUCT>
<NAME>GstAspectRatioCropClass</NAME>
struct _GstAspectRatioCropClass
{
  GstBinClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_aspect_ratio_crop_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_GAMMA</NAME>
#define GST_TYPE_GAMMA \
  (gst_gamma_get_type())
</MACRO>
<MACRO>
<NAME>GST_GAMMA</NAME>
#define GST_GAMMA(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_GAMMA,GstGamma))
</MACRO>
<MACRO>
<NAME>GST_GAMMA_CLASS</NAME>
#define GST_GAMMA_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_GAMMA,GstGammaClass))
</MACRO>
<MACRO>
<NAME>GST_IS_GAMMA</NAME>
#define GST_IS_GAMMA(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_GAMMA))
</MACRO>
<MACRO>
<NAME>GST_IS_GAMMA_CLASS</NAME>
#define GST_IS_GAMMA_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_GAMMA))
</MACRO>
<STRUCT>
<NAME>GstGamma</NAME>
struct _GstGamma
{
  GstVideoFilter videofilter;

  /* < private > */
  /* properties */
  gdouble gamma;

  /* tables */
  guint8 gamma_table[256];

  void (*process) (GstGamma *gamma, GstVideoFrame *frame);
};
</STRUCT>
<STRUCT>
<NAME>GstGammaClass</NAME>
struct _GstGammaClass
{
  GstVideoFilterClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_gamma_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_VIDEO_BALANCE</NAME>
#define GST_TYPE_VIDEO_BALANCE \
  (gst_video_balance_get_type())
</MACRO>
<MACRO>
<NAME>GST_VIDEO_BALANCE</NAME>
#define GST_VIDEO_BALANCE(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_VIDEO_BALANCE,GstVideoBalance))
</MACRO>
<MACRO>
<NAME>GST_VIDEO_BALANCE_CLASS</NAME>
#define GST_VIDEO_BALANCE_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_VIDEO_BALANCE,GstVideoBalanceClass))
</MACRO>
<MACRO>
<NAME>GST_IS_VIDEO_BALANCE</NAME>
#define GST_IS_VIDEO_BALANCE(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_VIDEO_BALANCE))
</MACRO>
<MACRO>
<NAME>GST_IS_VIDEO_BALANCE_CLASS</NAME>
#define GST_IS_VIDEO_BALANCE_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_VIDEO_BALANCE))
</MACRO>
<STRUCT>
<NAME>GstVideoBalance</NAME>
struct _GstVideoBalance {
  GstVideoFilter videofilter;

  /* < private > */

  /* channels for interface */
  GList *channels;

  /* properties */
  gdouble contrast;
  gdouble brightness;
  gdouble hue;
  gdouble saturation;

  /* tables */
  guint8 tabley[256];
  guint8 *tableu[256];
  guint8 *tablev[256];

  void (*process) (GstVideoBalance *balance, GstVideoFrame *frame);
};
</STRUCT>
<STRUCT>
<NAME>GstVideoBalanceClass</NAME>
struct _GstVideoBalanceClass {
  GstVideoFilterClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_video_balance_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<ENUM>
<NAME>GstVideoFlipMethod</NAME>
typedef enum {
  GST_VIDEO_FLIP_METHOD_IDENTITY,
  GST_VIDEO_FLIP_METHOD_90R,
  GST_VIDEO_FLIP_METHOD_180,
  GST_VIDEO_FLIP_METHOD_90L,
  GST_VIDEO_FLIP_METHOD_HORIZ,
  GST_VIDEO_FLIP_METHOD_VERT,
  GST_VIDEO_FLIP_METHOD_TRANS,
  GST_VIDEO_FLIP_METHOD_OTHER,
  GST_VIDEO_FLIP_METHOD_AUTO
} GstVideoFlipMethod;
</ENUM>
<MACRO>
<NAME>GST_TYPE_VIDEO_FLIP</NAME>
#define GST_TYPE_VIDEO_FLIP \
  (gst_video_flip_get_type())
</MACRO>
<MACRO>
<NAME>GST_VIDEO_FLIP</NAME>
#define GST_VIDEO_FLIP(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_VIDEO_FLIP,GstVideoFlip))
</MACRO>
<MACRO>
<NAME>GST_VIDEO_FLIP_CLASS</NAME>
#define GST_VIDEO_FLIP_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_VIDEO_FLIP,GstVideoFlipClass))
</MACRO>
<MACRO>
<NAME>GST_IS_VIDEO_FLIP</NAME>
#define GST_IS_VIDEO_FLIP(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_VIDEO_FLIP))
</MACRO>
<MACRO>
<NAME>GST_IS_VIDEO_FLIP_CLASS</NAME>
#define GST_IS_VIDEO_FLIP_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_VIDEO_FLIP))
</MACRO>
<STRUCT>
<NAME>GstVideoFlip</NAME>
struct _GstVideoFlip {
  GstVideoFilter videofilter;

  /* < private > */
  GstVideoOrientationMethod method;
  GstVideoOrientationMethod tag_method;
  GstVideoOrientationMethod active_method;
  void (*process) (GstVideoFlip *videoflip, GstVideoFrame *dest, const GstVideoFrame *src);
};
</STRUCT>
<STRUCT>
<NAME>GstVideoFlipClass</NAME>
struct _GstVideoFlipClass {
  GstVideoFilterClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_video_flip_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_VIDEO_MIXER2</NAME>
#define GST_TYPE_VIDEO_MIXER2 (gst_videomixer2_get_type())
</MACRO>
<MACRO>
<NAME>GST_VIDEO_MIXER2</NAME>
#define GST_VIDEO_MIXER2(obj) \
        (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_VIDEO_MIXER2, GstVideoMixer2))
</MACRO>
<MACRO>
<NAME>GST_VIDEO_MIXER2_CLASS</NAME>
#define GST_VIDEO_MIXER2_CLASS(klass) \
        (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_VIDEO_MIXER2, GstVideoMixer2Class))
</MACRO>
<MACRO>
<NAME>GST_IS_VIDEO_MIXER2</NAME>
#define GST_IS_VIDEO_MIXER2(obj) \
        (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_VIDEO_MIXER2))
</MACRO>
<MACRO>
<NAME>GST_IS_VIDEO_MIXER2_CLASS</NAME>
#define GST_IS_VIDEO_MIXER2_CLASS(klass) \
        (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_VIDEO_MIXER2))
</MACRO>
<ENUM>
<NAME>GstVideoMixer2Background</NAME>
typedef enum
{
  VIDEO_MIXER2_BACKGROUND_CHECKER,
  VIDEO_MIXER2_BACKGROUND_BLACK,
  VIDEO_MIXER2_BACKGROUND_WHITE,
  VIDEO_MIXER2_BACKGROUND_TRANSPARENT,
}
GstVideoMixer2Background;
</ENUM>
<STRUCT>
<NAME>GstVideoMixer2</NAME>
struct _GstVideoMixer2
{
  GstElement element;

  /* < private > */

  /* pad */
  GstPad *srcpad;

  /* Lock to prevent the state to change while blending */
  GMutex lock;

  /* Lock to prevent two src setcaps from happening at the same time  */
  GMutex setcaps_lock;

  /* Sink pads using Collect Pads 2*/
  GstCollectPads *collect;

  /* sinkpads, a GSList of GstVideoMixer2Pads */
  GSList *sinkpads;
  gint numpads;
  /* Next available sinkpad index */
  guint next_sinkpad;

  /* Output caps */
  GstVideoInfo info;

  /* current caps */
  GstCaps *current_caps;
  gboolean send_caps;

  gboolean newseg_pending;

  GstVideoMixer2Background background;

  /* Current downstream segment */
  GstSegment segment;
  GstClockTime ts_offset;
  guint64 nframes;

  /* QoS stuff */
  gdouble proportion;
  GstClockTime earliest_time;
  guint64 qos_processed, qos_dropped;

  BlendFunction blend, overlay;
  FillCheckerFunction fill_checker;
  FillColorFunction fill_color;

  gboolean send_stream_start;

  /* latency */
  gboolean live;

  GstTagList *pending_tags;
};
</STRUCT>
<STRUCT>
<NAME>GstVideoMixer2Class</NAME>
struct _GstVideoMixer2Class
{
  GstElementClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_videomixer2_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_VIDEO_MIXER2_PAD</NAME>
#define GST_TYPE_VIDEO_MIXER2_PAD (gst_videomixer2_pad_get_type())
</MACRO>
<MACRO>
<NAME>GST_VIDEO_MIXER2_PAD</NAME>
#define GST_VIDEO_MIXER2_PAD(obj) \
        (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_VIDEO_MIXER2_PAD, GstVideoMixer2Pad))
</MACRO>
<MACRO>
<NAME>GST_VIDEO_MIXER2_PAD_CLASS</NAME>
#define GST_VIDEO_MIXER2_PAD_CLASS(klass) \
        (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_VIDEO_MIXER_PAD, GstVideoMixer2PadClass))
</MACRO>
<MACRO>
<NAME>GST_IS_VIDEO_MIXER2_PAD</NAME>
#define GST_IS_VIDEO_MIXER2_PAD(obj) \
        (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_VIDEO_MIXER2_PAD))
</MACRO>
<MACRO>
<NAME>GST_IS_VIDEO_MIXER2_PAD_CLASS</NAME>
#define GST_IS_VIDEO_MIXER2_PAD_CLASS(klass) \
        (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_VIDEO_MIXER2_PAD))
</MACRO>
<STRUCT>
<NAME>GstVideoMixer2Pad</NAME>
struct _GstVideoMixer2Pad
{
  GstPad parent;

  /* < private > */

  /* caps */
  GstVideoInfo info;

  /* properties */
  gint xpos, ypos;
  guint zorder;
  gdouble alpha;

  GstVideoMixer2Collect *mixcol;

  /* caps used for conversion if needed */
  GstVideoInfo conversion_info;

  /* Converter, if NULL no conversion is done */
  GstVideoConverter *convert;

  gboolean need_conversion_update;
};
</STRUCT>
<STRUCT>
<NAME>GstVideoMixer2PadClass</NAME>
struct _GstVideoMixer2PadClass
{
  GstPadClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_videomixer2_pad_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<STRUCT>
<NAME>GstVideoMixer2Collect</NAME>
</STRUCT>
<MACRO>
<NAME>GST_TYPE_WAVENC</NAME>
#define GST_TYPE_WAVENC \
  (gst_wavenc_get_type())
</MACRO>
<MACRO>
<NAME>GST_WAVENC</NAME>
#define GST_WAVENC(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_WAVENC,GstWavEnc))
</MACRO>
<MACRO>
<NAME>GST_WAVENC_CLASS</NAME>
#define GST_WAVENC_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_WAVENC,GstWavEncClass))
</MACRO>
<MACRO>
<NAME>GST_IS_WAVENC</NAME>
#define GST_IS_WAVENC(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_WAVENC))
</MACRO>
<MACRO>
<NAME>GST_IS_WAVENC_CLASS</NAME>
#define GST_IS_WAVENC_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_WAVENC))
</MACRO>
<STRUCT>
<NAME>GstWavEnc</NAME>
struct _GstWavEnc {
  GstElement element;

  GstPad    *sinkpad;
  GstPad    *srcpad;

  GstTagList *tags;
  GstToc    *toc;
  GList     *cues;
  GList     *labls;
  GList     *notes;

  /* useful audio data */
  GstAudioFormat audio_format;
  guint16    format;
  guint      width;
  guint      rate;
  guint      channels;
  guint64    channel_mask;
  GstAudioChannelPosition srcPos[64];
  GstAudioChannelPosition destPos[64];
  
  /* data sizes */
  guint64    audio_length;
  guint32    meta_length;

  gboolean   use_rf64;
  gboolean   sent_header;
  gboolean   finished_properly;
};
</STRUCT>
<STRUCT>
<NAME>GstWavEncClass</NAME>
struct _GstWavEncClass {
  GstElementClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_wavenc_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_WAVPARSE</NAME>
#define GST_TYPE_WAVPARSE \
  (gst_wavparse_get_type())
</MACRO>
<MACRO>
<NAME>GST_WAVPARSE</NAME>
#define GST_WAVPARSE(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_WAVPARSE,GstWavParse))
</MACRO>
<MACRO>
<NAME>GST_WAVPARSE_CLASS</NAME>
#define GST_WAVPARSE_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_WAVPARSE,GstWavParseClass))
</MACRO>
<MACRO>
<NAME>GST_IS_WAVPARSE</NAME>
#define GST_IS_WAVPARSE(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_WAVPARSE))
</MACRO>
<MACRO>
<NAME>GST_IS_WAVPARSE_CLASS</NAME>
#define GST_IS_WAVPARSE_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_WAVPARSE))
</MACRO>
<ENUM>
<NAME>GstWavParseState</NAME>
typedef enum {
  GST_WAVPARSE_START,
  GST_WAVPARSE_HEADER,
  GST_WAVPARSE_DATA
} GstWavParseState;
</ENUM>
<STRUCT>
<NAME>GstWavParse</NAME>
struct _GstWavParse {
  GstElement parent;

  /* pads */
  GstPad *sinkpad,*srcpad;

  /* for delayed source pad creation for when
   * we have the first chunk of data and know
   * the format for sure */
  GstCaps     *caps;
  GstTagList  *tags;
  GstToc      *toc;
  GList       *cues;
  GList       *labls;
  GList       *notes;
  GstEvent    *start_segment;

  /* WAVE decoding state */
  GstWavParseState state;
  gboolean abort_buffering;

  /* format of audio, see defines below */
  gint format;

  /* useful audio data */
  guint16 depth;
  guint32 rate;
  guint16 channels;
  guint16 blockalign;
  guint16 width;
  guint32 av_bps;
  guint64 fact;

  /* real bps used or 0 when no bitrate is known */
  guint32 bps;
  gboolean vbr;

  guint bytes_per_sample;
  guint max_buf_size;

  /* position in data part */
  guint64	offset;
  guint64	end_offset;
  guint64 	dataleft;
  /* offset/length of data part */
  guint64 	datastart;
  guint64 	datasize;
  /* duration in time */
  guint64 	duration;

  /* pending seek */
  GstEvent *seek_event;

  /* For streaming */
  GstAdapter *adapter;
  gboolean got_fmt;
  gboolean streaming;

  /* configured segment, start/stop expressed in time or bytes */
  GstSegment segment;

  /* for late pad configuration */
  gboolean first;
  /* discont after seek */
  gboolean discont;

  gboolean ignore_length;
};
</STRUCT>
<STRUCT>
<NAME>GstWavParseClass</NAME>
struct _GstWavParseClass {
  GstElementClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_wavparse_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_Y4M_ENCODE</NAME>
#define GST_TYPE_Y4M_ENCODE \
  (gst_y4m_encode_get_type())
</MACRO>
<MACRO>
<NAME>GST_Y4M_ENCODE</NAME>
#define GST_Y4M_ENCODE(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj), GST_TYPE_Y4M_ENCODE, GstY4mEncode))
</MACRO>
<MACRO>
<NAME>GST_Y4M_ENCODE_CLASS</NAME>
#define GST_Y4M_ENCODE_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass), GST_TYPE_Y4M_ENCODE, GstY4mEncodeClass))
</MACRO>
<MACRO>
<NAME>GST_Y4M_ENCODE_GET_CLASS</NAME>
#define GST_Y4M_ENCODE_GET_CLASS(obj) \
  (G_TYPE_INSTANCE_GET_CLASS((obj), GST_TYPE_Y4M_ENCODE, GstY4mEncodeClass))
</MACRO>
<MACRO>
<NAME>GST_IS_Y4M_ENCODE</NAME>
#define GST_IS_Y4M_ENCODE(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj), GST_TYPE_Y4M_ENCODE))
</MACRO>
<MACRO>
<NAME>GST_IS_Y4M_ENCODE_CLASS</NAME>
#define GST_IS_Y4M_ENCODE_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass), GST_TYPE_Y4M_ENCODE))
</MACRO>
<STRUCT>
<NAME>GstY4mEncode</NAME>
struct _GstY4mEncode {
  GstVideoEncoder parent;

  /* caps information */
  GstVideoInfo info;

  const gchar *colorspace;
  /* state information */
  gboolean header;
};
</STRUCT>
<STRUCT>
<NAME>GstY4mEncodeClass</NAME>
struct _GstY4mEncodeClass {
  GstVideoEncoderClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_y4m_encode_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_DIRECTSOUND_SINK</NAME>
#define GST_TYPE_DIRECTSOUND_SINK            (gst_directsound_sink_get_type())
</MACRO>
<MACRO>
<NAME>GST_DIRECTSOUND_SINK</NAME>
#define GST_DIRECTSOUND_SINK(obj)            (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_DIRECTSOUND_SINK,GstDirectSoundSink))
</MACRO>
<MACRO>
<NAME>GST_DIRECTSOUND_SINK_CLASS</NAME>
#define GST_DIRECTSOUND_SINK_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_DIRECTSOUND_SINK,GstDirectSoundSinkClass))
</MACRO>
<MACRO>
<NAME>GST_IS_DIRECTSOUND_SINK</NAME>
#define GST_IS_DIRECTSOUND_SINK(obj)         (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_DIRECTSOUND_SINK))
</MACRO>
<MACRO>
<NAME>GST_IS_DIRECTSOUND_SINK_CLASS</NAME>
#define GST_IS_DIRECTSOUND_SINK_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_DIRECTSOUND_SINK))
</MACRO>
<MACRO>
<NAME>GST_DSOUND_LOCK</NAME>
#define GST_DSOUND_LOCK(obj)	(g_mutex_lock (&obj->dsound_lock))
</MACRO>
<MACRO>
<NAME>GST_DSOUND_UNLOCK</NAME>
#define GST_DSOUND_UNLOCK(obj)	(g_mutex_unlock (&obj->dsound_lock))
</MACRO>
<STRUCT>
<NAME>GstDirectSoundSink</NAME>
struct _GstDirectSoundSink
{
  GstAudioSink sink;


  /* directsound object interface pointer */
  LPDIRECTSOUND pDS;

  /* directsound sound object interface pointer */
  LPDIRECTSOUNDBUFFER pDSBSecondary;

  /* directSound buffer size */
  guint buffer_size;

  /* offset of the circular buffer where we must write next */
  guint current_circular_offset;

  guint bytes_per_sample;

  /* current volume setup by mixer interface */
  glong volume;
  gboolean mute;
  
  /* current directsound device ID */
  gchar * device_id;

  GstCaps *cached_caps;
  /* lock used to protect writes and resets */
  GMutex dsound_lock;

  GstClock *system_clock;
  GstClockID write_wait_clock_id;
  gboolean reset_while_sleeping;

  gboolean first_buffer_after_reset;

  GstAudioRingBufferFormatType type;
};
</STRUCT>
<STRUCT>
<NAME>GstDirectSoundSinkClass</NAME>
struct _GstDirectSoundSinkClass
{
  GstAudioSinkClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_directsound_sink_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_OSS4_SINK</NAME>
#define GST_TYPE_OSS4_SINK            (gst_oss4_sink_get_type())
</MACRO>
<MACRO>
<NAME>GST_OSS4_SINK</NAME>
#define GST_OSS4_SINK(obj)            (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_OSS4_SINK,GstOss4Sink))
</MACRO>
<MACRO>
<NAME>GST_OSS4_SINK_CAST</NAME>
#define GST_OSS4_SINK_CAST(obj)       ((GstOss4Sink *)(obj))
</MACRO>
<MACRO>
<NAME>GST_OSS4_SINK_CLASS</NAME>
#define GST_OSS4_SINK_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_OSS4_SINK,GstOss4SinkClass))
</MACRO>
<MACRO>
<NAME>GST_IS_OSS4_SINK</NAME>
#define GST_IS_OSS4_SINK(obj)         (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_OSS4_SINK))
</MACRO>
<MACRO>
<NAME>GST_IS_OSS4_SINK_CLASS</NAME>
#define GST_IS_OSS4_SINK_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_OSS4_SINK))
</MACRO>
<STRUCT>
<NAME>GstOss4Sink</NAME>
struct _GstOss4Sink {
  GstAudioSink  audio_sink;

  gchar       * device;             /* NULL if none was set      */
  gchar       * open_device;        /* the device we opened      */
  gchar       * device_name;        /* set if the device is open */
  gint          fd;                 /* -1 if not open            */
  gint          bytes_per_sample;
  gint          mute_volume;

  GstCaps     * probed_caps;
};
</STRUCT>
<STRUCT>
<NAME>GstOss4SinkClass</NAME>
struct _GstOss4SinkClass {
  GstAudioSinkClass audio_sink_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_oss4_sink_get_type</NAME>
<RETURNS>GType   </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_OSS4_SOURCE</NAME>
#define GST_TYPE_OSS4_SOURCE            (gst_oss4_source_get_type())
</MACRO>
<MACRO>
<NAME>GST_OSS4_SOURCE</NAME>
#define GST_OSS4_SOURCE(obj)            (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_OSS4_SOURCE,GstOss4Source))
</MACRO>
<MACRO>
<NAME>GST_OSS4_SOURCE_CAST</NAME>
#define GST_OSS4_SOURCE_CAST(obj)       ((GstOss4Source *)(obj))
</MACRO>
<MACRO>
<NAME>GST_OSS4_SOURCE_CLASS</NAME>
#define GST_OSS4_SOURCE_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_OSS4_SOURCE,GstOss4SourceClass))
</MACRO>
<MACRO>
<NAME>GST_IS_OSS4_SOURCE</NAME>
#define GST_IS_OSS4_SOURCE(obj)         (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_OSS4_SOURCE))
</MACRO>
<MACRO>
<NAME>GST_IS_OSS4_SOURCE_CLASS</NAME>
#define GST_IS_OSS4_SOURCE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_OSS4_SOURCE))
</MACRO>
<STRUCT>
<NAME>GstOss4Source</NAME>
struct _GstOss4Source {
  GstAudioSrc     audiosrc;

  gchar         * device;             /* NULL if none was set      */
  gchar         * open_device;        /* the device we opened      */
  gchar         * device_name;        /* set if the device is open */
  gint            fd;                 /* -1 if not open            */
  gint            bytes_per_sample;

  GstCaps       * probed_caps;
};
</STRUCT>
<STRUCT>
<NAME>GstOss4SourceClass</NAME>
struct _GstOss4SourceClass {
  GstAudioSrcClass audiosrc_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_oss4_source_get_type</NAME>
<RETURNS>GType   </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_OSSSINK</NAME>
#define GST_TYPE_OSSSINK            (gst_oss_sink_get_type())
</MACRO>
<MACRO>
<NAME>GST_OSSSINK</NAME>
#define GST_OSSSINK(obj)            (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_OSSSINK,GstOssSink))
</MACRO>
<MACRO>
<NAME>GST_OSSSINK_CLASS</NAME>
#define GST_OSSSINK_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_OSSSINK,GstOssSinkClass))
</MACRO>
<MACRO>
<NAME>GST_IS_OSSSINK</NAME>
#define GST_IS_OSSSINK(obj)         (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_OSSSINK))
</MACRO>
<MACRO>
<NAME>GST_IS_OSSSINK_CLASS</NAME>
#define GST_IS_OSSSINK_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_OSSSINK))
</MACRO>
<STRUCT>
<NAME>GstOssSink</NAME>
struct _GstOssSink {
  GstAudioSink    sink;

  gchar *device;
  gint   fd;
  gint   bytes_per_sample;

  GstCaps *probed_caps;
};
</STRUCT>
<STRUCT>
<NAME>GstOssSinkClass</NAME>
struct _GstOssSinkClass {
  GstAudioSinkClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_oss_sink_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_OSS_SRC</NAME>
#define GST_TYPE_OSS_SRC           (gst_oss_src_get_type())
</MACRO>
<MACRO>
<NAME>GST_OSS_SRC</NAME>
#define GST_OSS_SRC(obj)           (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_OSS_SRC,GstOssSrc))
</MACRO>
<MACRO>
<NAME>GST_OSS_SRC_CLASS</NAME>
#define GST_OSS_SRC_CLASS(klass)   (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_OSS_SRC,GstOssSrcClass))
</MACRO>
<MACRO>
<NAME>GST_IS_OSS_SRC</NAME>
#define GST_IS_OSS_SRC(obj)        (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_OSS_SRC))
</MACRO>
<MACRO>
<NAME>GST_IS_OSS_SRC_CLASS</NAME>
#define GST_IS_OSS_SRC_CLASS(klas) (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_OSS_SRC))
</MACRO>
<STRUCT>
<NAME>GstOssSrc</NAME>
struct _GstOssSrc {
  GstAudioSrc    src;

  gint fd;
  gint           bytes_per_sample;

  gchar *device;
  gchar *device_name;

  GstCaps       *probed_caps;
};
</STRUCT>
<STRUCT>
<NAME>GstOssSrcClass</NAME>
struct _GstOssSrcClass {
  GstAudioSrcClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_oss_src_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_OSX_AUDIO_SRC_CAPS</NAME>
#define GST_OSX_AUDIO_SRC_CAPS "audio/x-raw, " \
        "format = (string) " GST_AUDIO_FORMATS_ALL ", " \
        "layout = (string) interleaved, " \
        "rate = (int) [1, MAX], " "channels = (int) [1, MAX]"
</MACRO>
<MACRO>
<NAME>GST_TYPE_OSX_AUDIO_SRC</NAME>
#define GST_TYPE_OSX_AUDIO_SRC \
  (gst_osx_audio_src_get_type())
</MACRO>
<MACRO>
<NAME>GST_OSX_AUDIO_SRC</NAME>
#define GST_OSX_AUDIO_SRC(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_OSX_AUDIO_SRC,GstOsxAudioSrc))
</MACRO>
<MACRO>
<NAME>GST_OSX_AUDIO_SRC_CLASS</NAME>
#define GST_OSX_AUDIO_SRC_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_OSX_AUDIO_SRC,GstOsxAudioSrcClass))
</MACRO>
<MACRO>
<NAME>GST_IS_OSX_AUDIO_SRC</NAME>
#define GST_IS_OSX_AUDIO_SRC(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_OSX_AUDIO_SRC))
</MACRO>
<STRUCT>
<NAME>GstOsxAudioSrc</NAME>
struct _GstOsxAudioSrc
{
  GstAudioBaseSrc src;

  AudioDeviceID device_id;
};
</STRUCT>
<STRUCT>
<NAME>GstOsxAudioSrcClass</NAME>
struct _GstOsxAudioSrcClass
{
  GstAudioBaseSrcClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_osx_audio_src_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_OSX_AUDIO_SINK_CAPS</NAME>
#define GST_OSX_AUDIO_SINK_CAPS "audio/x-raw, " \
        "format = (string) " GST_AUDIO_FORMATS_ALL ", " \
        "layout = (string) interleaved, " \
        "rate = (int) [1, MAX], " \
        "channels = (int) [1, 9];" \
        "audio/x-ac3, framed = (boolean) true;" \
        "audio/x-dts, framed = (boolean) true"
</MACRO>
<MACRO>
<NAME>GST_TYPE_OSX_AUDIO_SINK</NAME>
#define GST_TYPE_OSX_AUDIO_SINK \
  (gst_osx_audio_sink_get_type())
</MACRO>
<MACRO>
<NAME>GST_OSX_AUDIO_SINK</NAME>
#define GST_OSX_AUDIO_SINK(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_OSX_AUDIO_SINK,GstOsxAudioSink))
</MACRO>
<MACRO>
<NAME>GST_OSX_AUDIO_SINK_CLASS</NAME>
#define GST_OSX_AUDIO_SINK_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_OSX_AUDIO_SINK,GstOsxAudioSinkClass))
</MACRO>
<MACRO>
<NAME>GST_IS_OSX_AUDIO_SINK</NAME>
#define GST_IS_OSX_AUDIO_SINK(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_OSX_AUDIO_SINK))
</MACRO>
<STRUCT>
<NAME>GstOsxAudioSink</NAME>
struct _GstOsxAudioSink
{
  GstAudioBaseSink sink;

  AudioDeviceID device_id;

  AudioUnit audiounit;
  double volume;

  guint channels;
};
</STRUCT>
<STRUCT>
<NAME>GstOsxAudioSinkClass</NAME>
struct _GstOsxAudioSinkClass
{
  GstAudioBaseSinkClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_osx_audio_sink_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_CAT_DEFAULT</NAME>
#define GST_CAT_DEFAULT gst_debug_osx_video_sink
</MACRO>
<MACRO>
<NAME>GST_TYPE_OSX_VIDEO_SINK</NAME>
#define GST_TYPE_OSX_VIDEO_SINK \
  (gst_osx_video_sink_get_type())
</MACRO>
<MACRO>
<NAME>GST_OSX_VIDEO_SINK</NAME>
#define GST_OSX_VIDEO_SINK(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj), GST_TYPE_OSX_VIDEO_SINK, GstOSXVideoSink))
</MACRO>
<MACRO>
<NAME>GST_OSX_VIDEO_SINK_CLASS</NAME>
#define GST_OSX_VIDEO_SINK_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass), GST_TYPE_OSX_VIDEO_SINK, GstOSXVideoSinkClass))
</MACRO>
<MACRO>
<NAME>GST_IS_OSX_VIDEO_SINK</NAME>
#define GST_IS_OSX_VIDEO_SINK(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj), GST_TYPE_OSX_VIDEO_SINK))
</MACRO>
<MACRO>
<NAME>GST_IS_OSX_VIDEO_SINK_CLASS</NAME>
#define GST_IS_OSX_VIDEO_SINK_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass), GST_TYPE_OSX_VIDEO_SINK))
</MACRO>
<MACRO>
<NAME>GST_TYPE_OSXVIDEOBUFFER</NAME>
#define GST_TYPE_OSXVIDEOBUFFER (gst_osxvideobuffer_get_type())
</MACRO>
<ENUM>
<NAME>GstOSXVideoSinkRunLoopState</NAME>
typedef enum {
  GST_OSX_VIDEO_SINK_RUN_LOOP_STATE_NOT_RUNNING = 0,
  GST_OSX_VIDEO_SINK_RUN_LOOP_STATE_RUNNING = 1,
  GST_OSX_VIDEO_SINK_RUN_LOOP_STATE_UNKNOWN = 2,
} GstOSXVideoSinkRunLoopState;
</ENUM>
<STRUCT>
<NAME>GstOSXWindow</NAME>
struct _GstOSXWindow {
  gint width, height;
  gboolean closed;
  gboolean internal;
  GstGLView* gstview;
  GstOSXVideoSinkWindow* win;
};
</STRUCT>
<STRUCT>
<NAME>GstOSXVideoSink</NAME>
struct _GstOSXVideoSink {
  /* Our element stuff */
  GstVideoSink videosink;
  GstOSXWindow *osxwindow;
  void *osxvideosinkobject;
  NSView *superview;
  gboolean keep_par;
  GstVideoInfo info;
};
</STRUCT>
<STRUCT>
<NAME>GstOSXVideoSinkClass</NAME>
struct _GstOSXVideoSinkClass {
  GstVideoSinkClass parent_class;

  GstOSXVideoSinkRunLoopState run_loop_state;
  NSThread *ns_app_thread;
};
</STRUCT>
<FUNCTION>
<NAME>gst_osx_video_sink_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_V4L2SRC</NAME>
#define GST_TYPE_V4L2SRC \
  (gst_v4l2src_get_type())
</MACRO>
<MACRO>
<NAME>GST_V4L2SRC</NAME>
#define GST_V4L2SRC(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_V4L2SRC,GstV4l2Src))
</MACRO>
<MACRO>
<NAME>GST_V4L2SRC_CLASS</NAME>
#define GST_V4L2SRC_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_V4L2SRC,GstV4l2SrcClass))
</MACRO>
<MACRO>
<NAME>GST_IS_V4L2SRC</NAME>
#define GST_IS_V4L2SRC(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_V4L2SRC))
</MACRO>
<MACRO>
<NAME>GST_IS_V4L2SRC_CLASS</NAME>
#define GST_IS_V4L2SRC_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_V4L2SRC))
</MACRO>
<STRUCT>
<NAME>GstV4l2Src</NAME>
struct _GstV4l2Src
{
  GstPushSrc pushsrc;

  /*< private >*/
  GstV4l2Object * v4l2object;

  guint64 offset;

  /* offset adjust after renegotiation */
  guint64 renegotiation_adjust;

  GstClockTime ctrl_time;

  gboolean pending_set_fmt;

  /* Timestamp sanity check */
  GstClockTime last_timestamp;
  gboolean has_bad_timestamp;
};
</STRUCT>
<STRUCT>
<NAME>GstV4l2SrcClass</NAME>
struct _GstV4l2SrcClass
{
  GstPushSrcClass parent_class;

  GList *v4l2_class_devices;
};
</STRUCT>
<FUNCTION>
<NAME>gst_v4l2src_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_V4L2SINK</NAME>
#define GST_TYPE_V4L2SINK \
  (gst_v4l2sink_get_type())
</MACRO>
<MACRO>
<NAME>GST_V4L2SINK</NAME>
#define GST_V4L2SINK(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj), GST_TYPE_V4L2SINK, GstV4l2Sink))
</MACRO>
<MACRO>
<NAME>GST_V4L2SINK_CLASS</NAME>
#define GST_V4L2SINK_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass), GST_TYPE_V4L2SINK, GstV4l2SinkClass))
</MACRO>
<MACRO>
<NAME>GST_IS_V4L2SINK</NAME>
#define GST_IS_V4L2SINK(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj), GST_TYPE_V4L2SINK))
</MACRO>
<MACRO>
<NAME>GST_IS_V4L2SINK_CLASS</NAME>
#define GST_IS_V4L2SINK_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass), GST_TYPE_V4L2SINK))
</MACRO>
<STRUCT>
<NAME>GstV4l2Sink</NAME>
struct _GstV4l2Sink {
  GstVideoSink videosink;

  /*< private >*/
  GstV4l2Object * v4l2object;

  gint video_width, video_height;      /* original (unscaled) video w/h */

  /*
   * field to store requested overlay and crop top/left/width/height props:
   * note, could maybe be combined with 'vwin' field in GstV4l2Object?
   */
  struct v4l2_rect overlay, crop;

  /*
   * bitmask to track which overlay and crop fields user has requested by
   * setting properties:
   */
  guint8 overlay_fields_set, crop_fields_set;
};
</STRUCT>
<STRUCT>
<NAME>GstV4l2SinkClass</NAME>
struct _GstV4l2SinkClass {
  GstVideoSinkClass parent_class;

  GList *v4l2_class_devices;
};
</STRUCT>
<FUNCTION>
<NAME>gst_v4l2sink_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_V4L2_TRANSFORM</NAME>
#define GST_TYPE_V4L2_TRANSFORM \
  (gst_v4l2_transform_get_type())
</MACRO>
<MACRO>
<NAME>GST_V4L2_TRANSFORM</NAME>
#define GST_V4L2_TRANSFORM(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_V4L2_TRANSFORM,GstV4l2Transform))
</MACRO>
<MACRO>
<NAME>GST_V4L2_TRANSFORM_CLASS</NAME>
#define GST_V4L2_TRANSFORM_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_V4L2_TRANSFORM,GstV4l2TransformClass))
</MACRO>
<MACRO>
<NAME>GST_IS_V4L2_TRANSFORM</NAME>
#define GST_IS_V4L2_TRANSFORM(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_V4L2_TRANSFORM))
</MACRO>
<MACRO>
<NAME>GST_IS_V4L2_TRANSFORM_CLASS</NAME>
#define GST_IS_V4L2_TRANSFORM_CLASS(obj) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_V4L2_TRANSFORM))
</MACRO>
<MACRO>
<NAME>GST_V4L2_TRANSFORM_GET_CLASS</NAME>
#define GST_V4L2_TRANSFORM_GET_CLASS(inst) \
  (G_TYPE_INSTANCE_GET_CLASS ((inst),GST_TYPE_V4L2_TRANSFORM,GstV4l2TransformClass))
</MACRO>
<STRUCT>
<NAME>GstV4l2Transform</NAME>
struct _GstV4l2Transform
{
  GstBaseTransform parent;

  /* < private > */
  GstV4l2Object * v4l2output;
  GstV4l2Object * v4l2capture;

  /* pads */
  GstCaps *probed_srccaps;
  GstCaps *probed_sinkcaps;

  /* Selected caps */
  GstCaps *incaps;
  GstCaps *outcaps;
};
</STRUCT>
<STRUCT>
<NAME>GstV4l2TransformClass</NAME>
struct _GstV4l2TransformClass
{
  GstBaseTransformClass parent_class;
  gchar *default_device;
};
</STRUCT>
<FUNCTION>
<NAME>gst_v4l2_transform_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_v4l2_is_transform</NAME>
<RETURNS>gboolean  </RETURNS>
GstCaps * sink_caps, GstCaps * src_caps
</FUNCTION>
<FUNCTION>
<NAME>gst_v4l2_transform_register</NAME>
<RETURNS>gboolean  </RETURNS>
GstPlugin * plugin, const gchar *basename, const gchar *device_path, GstCaps * sink_caps, GstCaps * src_caps
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_V4L2_VIDEO_DEC</NAME>
#define GST_TYPE_V4L2_VIDEO_DEC \
  (gst_v4l2_video_dec_get_type())
</MACRO>
<MACRO>
<NAME>GST_V4L2_VIDEO_DEC</NAME>
#define GST_V4L2_VIDEO_DEC(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_V4L2_VIDEO_DEC,GstV4l2VideoDec))
</MACRO>
<MACRO>
<NAME>GST_V4L2_VIDEO_DEC_CLASS</NAME>
#define GST_V4L2_VIDEO_DEC_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_V4L2_VIDEO_DEC,GstV4l2VideoDecClass))
</MACRO>
<MACRO>
<NAME>GST_IS_V4L2_VIDEO_DEC</NAME>
#define GST_IS_V4L2_VIDEO_DEC(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_V4L2_VIDEO_DEC))
</MACRO>
<MACRO>
<NAME>GST_IS_V4L2_VIDEO_DEC_CLASS</NAME>
#define GST_IS_V4L2_VIDEO_DEC_CLASS(obj) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_V4L2_VIDEO_DEC))
</MACRO>
<STRUCT>
<NAME>GstV4l2VideoDec</NAME>
struct _GstV4l2VideoDec
{
  GstVideoDecoder parent;

  /* < private > */
  GstV4l2Object * v4l2output;
  GstV4l2Object * v4l2capture;

  /* pads */
  GstCaps *probed_srccaps;
  GstCaps *probed_sinkcaps;

  /* State */
  GstVideoCodecState *input_state;
  gboolean active;
  GstFlowReturn output_flow;
};
</STRUCT>
<STRUCT>
<NAME>GstV4l2VideoDecClass</NAME>
struct _GstV4l2VideoDecClass
{
  GstVideoDecoderClass parent_class;

  gchar *default_device;
};
</STRUCT>
<FUNCTION>
<NAME>gst_v4l2_video_dec_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_v4l2_is_video_dec</NAME>
<RETURNS>gboolean  </RETURNS>
GstCaps * sink_caps, GstCaps * src_caps
</FUNCTION>
<FUNCTION>
<NAME>gst_v4l2_video_dec_register</NAME>
<RETURNS>gboolean  </RETURNS>
GstPlugin * plugin, const gchar *basename, const gchar *device_path, GstCaps * sink_caps, GstCaps * src_caps
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_V4L2RADIO</NAME>
#define GST_TYPE_V4L2RADIO \
  (gst_v4l2radio_get_type())
</MACRO>
<MACRO>
<NAME>GST_V4L2RADIO</NAME>
#define GST_V4L2RADIO(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_V4L2RADIO,GstV4l2Radio))
</MACRO>
<MACRO>
<NAME>GST_V4L2RADIO_CLASS</NAME>
#define GST_V4L2RADIO_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_V4L2RADIO,GstV4l2RadioClass))
</MACRO>
<MACRO>
<NAME>GST_IS_V4L2RADIO</NAME>
#define GST_IS_V4L2RADIO(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_V4L2RADIO))
</MACRO>
<MACRO>
<NAME>GST_IS_V4L2RADIO_CLASS</NAME>
#define GST_IS_V4L2RADIO_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_V4L2RADIO))
</MACRO>
<STRUCT>
<NAME>GstV4l2Radio</NAME>
struct _GstV4l2Radio
{
  GstElement element;

  /*< private >*/
  GstV4l2Object * v4l2object;
};
</STRUCT>
<STRUCT>
<NAME>GstV4l2RadioClass</NAME>
struct _GstV4l2RadioClass
{
  GstElementClass parent_class;

  GList *v4l2_class_devices;
};
</STRUCT>
<FUNCTION>
<NAME>gst_v4l2radio_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>WAVE_FORMAT_96M08</NAME>
#define WAVE_FORMAT_96M08       0x00001000       /* 96   kHz, Mono,   8-bit  */
</MACRO>
<MACRO>
<NAME>WAVE_FORMAT_96S08</NAME>
#define WAVE_FORMAT_96S08       0x00002000       /* 96   kHz, Stereo, 8-bit  */
</MACRO>
<MACRO>
<NAME>WAVE_FORMAT_96M16</NAME>
#define WAVE_FORMAT_96M16       0x00004000       /* 96   kHz, Mono,   16-bit */
</MACRO>
<MACRO>
<NAME>WAVE_FORMAT_96S16</NAME>
#define WAVE_FORMAT_96S16       0x00008000       /* 96   kHz, Stereo, 16-bit */
</MACRO>
<MACRO>
<NAME>ERROR_LENGTH</NAME>
#define ERROR_LENGTH MAXERRORLENGTH+50
</MACRO>
<MACRO>
<NAME>BUFFER_COUNT</NAME>
#define BUFFER_COUNT 20
</MACRO>
<MACRO>
<NAME>BUFFER_SIZE</NAME>
#define BUFFER_SIZE 8192
</MACRO>
<MACRO>
<NAME>GST_TYPE_WAVEFORM_SINK</NAME>
#define GST_TYPE_WAVEFORM_SINK                (gst_waveform_sink_get_type())
</MACRO>
<MACRO>
<NAME>GST_WAVEFORM_SINK</NAME>
#define GST_WAVEFORM_SINK(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_WAVEFORM_SINK,GstWaveFormSink))
</MACRO>
<MACRO>
<NAME>GST_WAVEFORM_SINK_CLASS</NAME>
#define GST_WAVEFORM_SINK_CLASS(klass)        (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_WAVEFORM_SINK,GstWaveFormSinkClass))
</MACRO>
<MACRO>
<NAME>GST_IS_WAVEFORM_SINK</NAME>
#define GST_IS_WAVEFORM_SINK(obj)             (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_WAVEFORM_SINK))
</MACRO>
<MACRO>
<NAME>GST_IS_WAVEFORM_SINK_CLASS</NAME>
#define GST_IS_WAVEFORM_SINK_CLASS(klass)     (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_WAVEFORM_SINK))
</MACRO>
<STRUCT>
<NAME>GstWaveFormSink</NAME>
struct _GstWaveFormSink
{
  /* parent object */
  GstAudioSink sink;

  /* supported caps */
  GstCaps *cached_caps;
  
  /* handle to the waveform-audio output device */
  HWAVEOUT hwaveout;
  
  /* table of buffer headers */
  WAVEHDR *wave_buffers;

  /* critical section protecting access to the number of free buffers */
  CRITICAL_SECTION critic_wave;

  /* number of free buffers available */
  guint free_buffers_count;
  
  /* current free buffer where you have to write incoming data */
  guint write_buffer;
  
  /* size of buffers streamed to the device */
  guint buffer_size;

  /* number of buffers streamed to the device */
  guint buffer_count;

  /* total of bytes in queue before they are written to the device */
  guint bytes_in_queue;

  /* bytes per sample from setcaps used to evaluate the number samples returned by delay */
  guint bytes_per_sample;

  /* wave form error string */
  gchar error_string[ERROR_LENGTH];
};
</STRUCT>
<STRUCT>
<NAME>GstWaveFormSinkClass</NAME>
struct _GstWaveFormSinkClass
{
  GstAudioSinkClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_waveform_sink_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_XIMAGE_SRC</NAME>
#define GST_TYPE_XIMAGE_SRC (gst_ximage_src_get_type())
</MACRO>
<MACRO>
<NAME>GST_XIMAGE_SRC</NAME>
#define GST_XIMAGE_SRC(obj) (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_XIMAGE_SRC,GstXImageSrc))
</MACRO>
<MACRO>
<NAME>GST_XIMAGE_SRC_CLASS</NAME>
#define GST_XIMAGE_SRC_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_XIMAGE_SRC,GstXImageSrc))
</MACRO>
<MACRO>
<NAME>GST_IS_XIMAGE_SRC</NAME>
#define GST_IS_XIMAGE_SRC(obj) (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_XIMAGE_SRC))
</MACRO>
<MACRO>
<NAME>GST_IS_XIMAGE_SRC_CLASS</NAME>
#define GST_IS_XIMAGE_SRC_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_XIMAGE_SRC))
</MACRO>
<FUNCTION>
<NAME>gst_ximage_src_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<STRUCT>
<NAME>GstXImageSrc</NAME>
struct _GstXImageSrc
{
  GstPushSrc parent;

  /* Information on display */
  GstXContext *xcontext;
  gint x;
  gint y;
  gint width;
  gint height;

  Window xwindow;
  gchar *display_name;

  /* Window selection */
  guint64 xid;
  gchar *xname;

  /* Desired output framerate */
  gint fps_n;
  gint fps_d;

  /* for framerate sync */
  GstClockID clock_id;
  gint64 last_frame_no;

  /* Protect X Windows calls */
  GMutex  x_lock;

  /* Gathered pool of emitted buffers */
  GMutex  pool_lock;
  GSList *buffer_pool;

  /* XFixes and XDamage support */
  gboolean have_xfixes;
  gboolean have_xdamage;
  gboolean show_pointer;
  gboolean use_damage;

  /* co-ordinates for start and end */
  guint startx;
  guint starty;
  guint endx;
  guint endy;

  /* whether to use remote friendly calls */
  gboolean remote;

#ifdef HAVE_XFIXES
  int fixes_event_base;
  XFixesCursorImage *cursor_image;
#endif
#ifdef HAVE_XDAMAGE
  Damage damage;
  int damage_event_base;
  XserverRegion damage_region;
  GC damage_copy_gc;
  GstBuffer *last_ximage;
#endif
};
</STRUCT>
<STRUCT>
<NAME>GstXImageSrcClass</NAME>
struct _GstXImageSrcClass
{
  GstPushSrcClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_udp_parse_uri</NAME>
<RETURNS>gboolean      </RETURNS>
const gchar *uristr, gchar **host, guint16 *port
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_DYNUDPSINK</NAME>
#define GST_TYPE_DYNUDPSINK             (gst_dynudpsink_get_type())
</MACRO>
<MACRO>
<NAME>GST_DYNUDPSINK</NAME>
#define GST_DYNUDPSINK(obj)             (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_DYNUDPSINK,GstDynUDPSink))
</MACRO>
<MACRO>
<NAME>GST_DYNUDPSINK_CLASS</NAME>
#define GST_DYNUDPSINK_CLASS(klass)     (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_DYNUDPSINK,GstDynUDPSinkClass))
</MACRO>
<MACRO>
<NAME>GST_IS_DYNUDPSINK</NAME>
#define GST_IS_DYNUDPSINK(obj)          (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_DYNUDPSINK))
</MACRO>
<MACRO>
<NAME>GST_IS_DYNUDPSINK_CLASS</NAME>
#define GST_IS_DYNUDPSINK_CLASS(klass)  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_DYNUDPSINK))
</MACRO>
<STRUCT>
<NAME>GstDynUDPSink</NAME>
struct _GstDynUDPSink {
  GstBaseSink parent;

  /* properties */
  GSocket *socket, *socket_v6;
  gboolean close_socket;
  gchar *bind_address;
  gint bind_port;

  /* the socket in use */
  GSocket *used_socket, *used_socket_v6;
  gboolean external_socket;
  gboolean made_cancel_fd;
  GCancellable *cancellable;
};
</STRUCT>
<STRUCT>
<NAME>GstDynUDPSinkClass</NAME>
struct _GstDynUDPSinkClass {
  GstBaseSinkClass parent_class;

  /* element methods */
  GstStructure*  (*get_stats)    (GstDynUDPSink *sink, const gchar *host, gint port);

  /* signals */
};
</STRUCT>
<FUNCTION>
<NAME>gst_dynudpsink_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_RTP_XQT_DEPAY</NAME>
#define GST_TYPE_RTP_XQT_DEPAY \
  (gst_rtp_xqt_depay_get_type())
</MACRO>
<MACRO>
<NAME>GST_RTP_XQT_DEPAY</NAME>
#define GST_RTP_XQT_DEPAY(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_RTP_XQT_DEPAY,GstRtpXQTDepay))
</MACRO>
<MACRO>
<NAME>GST_RTP_XQT_DEPAY_CLASS</NAME>
#define GST_RTP_XQT_DEPAY_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_RTP_XQT_DEPAY,GstRtpXQTDepayClass))
</MACRO>
<MACRO>
<NAME>GST_IS_RTP_XQT_DEPAY</NAME>
#define GST_IS_RTP_XQT_DEPAY(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_RTP_XQT_DEPAY))
</MACRO>
<MACRO>
<NAME>GST_IS_RTP_XQT_DEPAY_CLASS</NAME>
#define GST_IS_RTP_XQT_DEPAY_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_RTP_XQT_DEPAY))
</MACRO>
<STRUCT>
<NAME>GstRtpXQTDepay</NAME>
struct _GstRtpXQTDepay
{
  GstRTPBaseDepayload depayload;

  GstAdapter *adapter;

  gboolean need_resync;
  guint16 previous_id;
  guint16 current_id;
  gboolean have_sd;
};
</STRUCT>
<STRUCT>
<NAME>GstRtpXQTDepayClass</NAME>
struct _GstRtpXQTDepayClass
{
  GstRTPBaseDepayloadClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_rtp_xqt_depay_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>OBJECT_DESC_TAG</NAME>
#define OBJECT_DESC_TAG            0x01
</MACRO>
<MACRO>
<NAME>INIT_OBJECT_DESC_TAG</NAME>
#define INIT_OBJECT_DESC_TAG       0x02
</MACRO>
<MACRO>
<NAME>ES_DESCRIPTOR_TAG</NAME>
#define ES_DESCRIPTOR_TAG          0x03
</MACRO>
<MACRO>
<NAME>DECODER_CONFIG_DESC_TAG</NAME>
#define DECODER_CONFIG_DESC_TAG    0x04
</MACRO>
<MACRO>
<NAME>DECODER_SPECIFIC_INFO_TAG</NAME>
#define DECODER_SPECIFIC_INFO_TAG  0x05
</MACRO>
<MACRO>
<NAME>SL_CONFIG_DESC_TAG</NAME>
#define SL_CONFIG_DESC_TAG         0x06
</MACRO>
<MACRO>
<NAME>ES_ID_INC_TAG</NAME>
#define ES_ID_INC_TAG              0x0E
</MACRO>
<MACRO>
<NAME>MP4_INIT_OBJECT_DESC_TAG</NAME>
#define MP4_INIT_OBJECT_DESC_TAG   0x10
</MACRO>
<MACRO>
<NAME>ESDS_OBJECT_TYPE_MPEG1_P3</NAME>
#define ESDS_OBJECT_TYPE_MPEG1_P3       0x6B
</MACRO>
<MACRO>
<NAME>ESDS_OBJECT_TYPE_MPEG2_P7_MAIN</NAME>
#define ESDS_OBJECT_TYPE_MPEG2_P7_MAIN  0x66
</MACRO>
<MACRO>
<NAME>ESDS_OBJECT_TYPE_MPEG4_P7_LC</NAME>
#define ESDS_OBJECT_TYPE_MPEG4_P7_LC    0x67
</MACRO>
<MACRO>
<NAME>ESDS_OBJECT_TYPE_MPEG4_P7_SSR</NAME>
#define ESDS_OBJECT_TYPE_MPEG4_P7_SSR   0x68
</MACRO>
<MACRO>
<NAME>ESDS_OBJECT_TYPE_MPEG4_P2</NAME>
#define ESDS_OBJECT_TYPE_MPEG4_P2       0x20
</MACRO>
<MACRO>
<NAME>ESDS_OBJECT_TYPE_MPEG4_P3</NAME>
#define ESDS_OBJECT_TYPE_MPEG4_P3       0x40
</MACRO>
<MACRO>
<NAME>ESDS_STREAM_TYPE_VISUAL</NAME>
#define ESDS_STREAM_TYPE_VISUAL         0x04
</MACRO>
<MACRO>
<NAME>ESDS_STREAM_TYPE_AUDIO</NAME>
#define ESDS_STREAM_TYPE_AUDIO          0x05
</MACRO>
<STRUCT>
<NAME>DecoderConfigDescriptor</NAME>
typedef struct _DecoderConfigDescriptor {
  BaseDescriptor base;

  guint8 object_type;

  /* following are condensed into streamType:
   * bit(6) streamType;
   * bit(1) upStream;
   * const bit(1) reserved=1;
  */
  guint8 stream_type;

  guint8 buffer_size_DB[3];
  guint32 max_bitrate;
  guint32 avg_bitrate;

  DecoderSpecificInfoDescriptor *dec_specific_info;
} DecoderConfigDescriptor;
</STRUCT>
<FUNCTION>
<NAME>desc_es_init</NAME>
<RETURNS>void     </RETURNS>
ESDescriptor *es
</FUNCTION>
<FUNCTION>
<NAME>desc_es_descriptor_new</NAME>
<RETURNS>ESDescriptor  *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>desc_es_descriptor_copy_data</NAME>
<RETURNS>guint64  </RETURNS>
ESDescriptor *es, guint8 **buffer, guint64 *size, guint64 *offset
</FUNCTION>
<FUNCTION>
<NAME>desc_es_descriptor_clear</NAME>
<RETURNS>void     </RETURNS>
ESDescriptor *es
</FUNCTION>
<FUNCTION>
<NAME>desc_dec_specific_info_new</NAME>
<RETURNS>DecoderSpecificInfoDescriptor  *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>desc_dec_specific_info_free</NAME>
<RETURNS>void     </RETURNS>
DecoderSpecificInfoDescriptor *dsid
</FUNCTION>
<FUNCTION>
<NAME>desc_dec_specific_info_alloc_data</NAME>
<RETURNS>void     </RETURNS>
DecoderSpecificInfoDescriptor *dsid, guint32 size
</FUNCTION>
<FUNCTION>
<NAME>qt_atom_parser_has_remaining</NAME>
<RETURNS>gboolean </RETURNS>
GstByteReader * parser, guint64 bytes_needed
</FUNCTION>
<FUNCTION>
<NAME>qt_atom_parser_has_chunks</NAME>
<RETURNS>gboolean </RETURNS>
GstByteReader * parser, guint32 n_chunks, guint32 chunk_size
</FUNCTION>
<FUNCTION>
<NAME>qt_atom_parser_peek_sub</NAME>
<RETURNS>gboolean </RETURNS>
GstByteReader * parser, guint offset, guint size, GstByteReader * sub
</FUNCTION>
<FUNCTION>
<NAME>qt_atom_parser_skipn_and_get_uint32</NAME>
<RETURNS>gboolean </RETURNS>
GstByteReader * parser, guint bytes_to_skip, guint32 * val
</FUNCTION>
<FUNCTION>
<NAME>qtdemux_lang_map_qt_code_to_iso</NAME>
<RETURNS>void  </RETURNS>
gchar id[4], guint16 qt_lang_code
</FUNCTION>
<ENUM>
<NAME>GstQTMuxFormat</NAME>
typedef enum _GstQTMuxFormat
{
  GST_QT_MUX_FORMAT_NONE = 0,
  GST_QT_MUX_FORMAT_QT,
  GST_QT_MUX_FORMAT_MP4,
  GST_QT_MUX_FORMAT_3GP,
  GST_QT_MUX_FORMAT_MJ2,
  GST_QT_MUX_FORMAT_ISML
} GstQTMuxFormat;
</ENUM>
<FUNCTION>
<NAME>gst_qt_mux_map_format_to_header</NAME>
<RETURNS>void             </RETURNS>
GstQTMuxFormat format, GstBuffer ** _prefix, guint32 * _major, guint32 * verson, GList ** _compatible, AtomMOOV * moov, GstClockTime longest_chunk, gboolean faststart
</FUNCTION>
<FUNCTION>
<NAME>gst_qt_mux_map_format_to_flavor</NAME>
<RETURNS>AtomsTreeFlavor  </RETURNS>
GstQTMuxFormat format
</FUNCTION>
<MACRO>
<NAME>ATOMS_RECOV_FILE_VERSION</NAME>
#define ATOMS_RECOV_FILE_VERSION          1
</MACRO>
<MACRO>
<NAME>ATOMS_RECOV_QUARK</NAME>
#define ATOMS_RECOV_QUARK (g_quark_from_string ("qtmux-atoms-recovery"))
</MACRO>
<MACRO>
<NAME>ATOMS_RECOV_ERR_GENERIC</NAME>
#define ATOMS_RECOV_ERR_GENERIC           1
</MACRO>
<MACRO>
<NAME>ATOMS_RECOV_ERR_FILE</NAME>
#define ATOMS_RECOV_ERR_FILE              2
</MACRO>
<MACRO>
<NAME>ATOMS_RECOV_ERR_PARSING</NAME>
#define ATOMS_RECOV_ERR_PARSING           3
</MACRO>
<MACRO>
<NAME>ATOMS_RECOV_ERR_VERSION</NAME>
#define ATOMS_RECOV_ERR_VERSION           4
</MACRO>
<MACRO>
<NAME>TRAK_BUFFER_ENTRY_INFO_SIZE</NAME>
#define TRAK_BUFFER_ENTRY_INFO_SIZE 34
</MACRO>
<FUNCTION>
<NAME>atoms_recov_write_trak_info</NAME>
<RETURNS>gboolean  </RETURNS>
FILE * f, AtomTRAK * trak
</FUNCTION>
<FUNCTION>
<NAME>atoms_recov_write_headers</NAME>
<RETURNS>gboolean  </RETURNS>
FILE * f, AtomFTYP * ftyp, GstBuffer * prefix, AtomMOOV * moov, guint32 timescale, guint32 traks_number
</FUNCTION>
<FUNCTION>
<NAME>atoms_recov_write_trak_samples</NAME>
<RETURNS>gboolean  </RETURNS>
FILE * f, AtomTRAK * trak, guint32 nsamples, guint32 delta, guint32 size, guint64 chunk_offset, gboolean sync, gboolean do_pts, gint64 pts_offset
</FUNCTION>
<FUNCTION>
<NAME>mdat_recov_file_create</NAME>
<RETURNS>MdatRecovFile  * </RETURNS>
FILE * file, gboolean datafile, GError ** err
</FUNCTION>
<FUNCTION>
<NAME>mdat_recov_file_free</NAME>
<RETURNS>void             </RETURNS>
MdatRecovFile * mrf
</FUNCTION>
<FUNCTION>
<NAME>moov_recov_file_create</NAME>
<RETURNS>MoovRecovFile  * </RETURNS>
FILE * file, GError ** err
</FUNCTION>
<FUNCTION>
<NAME>moov_recov_file_free</NAME>
<RETURNS>void             </RETURNS>
MoovRecovFile * moovrf
</FUNCTION>
<FUNCTION>
<NAME>moov_recov_parse_buffers</NAME>
<RETURNS>gboolean         </RETURNS>
MoovRecovFile * moovrf, MdatRecovFile * mdatrf, GError ** err
</FUNCTION>
<FUNCTION>
<NAME>moov_recov_write_file</NAME>
<RETURNS>gboolean         </RETURNS>
MoovRecovFile * moovrf, MdatRecovFile * mdatrf, FILE * outf, GError ** err
</FUNCTION>
<FUNCTION>
<NAME>qtdemux_dump_mvhd</NAME>
<RETURNS>gboolean  </RETURNS>
GstQTDemux * qtdemux, GstByteReader * data, int depth
</FUNCTION>
<FUNCTION>
<NAME>qtdemux_dump_tkhd</NAME>
<RETURNS>gboolean  </RETURNS>
GstQTDemux * qtdemux, GstByteReader * data, int depth
</FUNCTION>
<FUNCTION>
<NAME>qtdemux_dump_elst</NAME>
<RETURNS>gboolean  </RETURNS>
GstQTDemux * qtdemux, GstByteReader * data, int depth
</FUNCTION>
<FUNCTION>
<NAME>qtdemux_dump_mdhd</NAME>
<RETURNS>gboolean  </RETURNS>
GstQTDemux * qtdemux, GstByteReader * data, int depth
</FUNCTION>
<FUNCTION>
<NAME>qtdemux_dump_hdlr</NAME>
<RETURNS>gboolean  </RETURNS>
GstQTDemux * qtdemux, GstByteReader * data, int depth
</FUNCTION>
<FUNCTION>
<NAME>qtdemux_dump_vmhd</NAME>
<RETURNS>gboolean  </RETURNS>
GstQTDemux * qtdemux, GstByteReader * data, int depth
</FUNCTION>
<FUNCTION>
<NAME>qtdemux_dump_dref</NAME>
<RETURNS>gboolean  </RETURNS>
GstQTDemux * qtdemux, GstByteReader * data, int depth
</FUNCTION>
<FUNCTION>
<NAME>qtdemux_dump_stsd</NAME>
<RETURNS>gboolean  </RETURNS>
GstQTDemux * qtdemux, GstByteReader * data, int depth
</FUNCTION>
<FUNCTION>
<NAME>qtdemux_dump_stts</NAME>
<RETURNS>gboolean  </RETURNS>
GstQTDemux * qtdemux, GstByteReader * data, int depth
</FUNCTION>
<FUNCTION>
<NAME>qtdemux_dump_stss</NAME>
<RETURNS>gboolean  </RETURNS>
GstQTDemux * qtdemux, GstByteReader * data, int depth
</FUNCTION>
<FUNCTION>
<NAME>qtdemux_dump_stps</NAME>
<RETURNS>gboolean  </RETURNS>
GstQTDemux * qtdemux, GstByteReader * data, int depth
</FUNCTION>
<FUNCTION>
<NAME>qtdemux_dump_stsc</NAME>
<RETURNS>gboolean  </RETURNS>
GstQTDemux * qtdemux, GstByteReader * data, int depth
</FUNCTION>
<FUNCTION>
<NAME>qtdemux_dump_stsz</NAME>
<RETURNS>gboolean  </RETURNS>
GstQTDemux * qtdemux, GstByteReader * data, int depth
</FUNCTION>
<FUNCTION>
<NAME>qtdemux_dump_stco</NAME>
<RETURNS>gboolean  </RETURNS>
GstQTDemux * qtdemux, GstByteReader * data, int depth
</FUNCTION>
<FUNCTION>
<NAME>qtdemux_dump_co64</NAME>
<RETURNS>gboolean  </RETURNS>
GstQTDemux * qtdemux, GstByteReader * data, int depth
</FUNCTION>
<FUNCTION>
<NAME>qtdemux_dump_dcom</NAME>
<RETURNS>gboolean  </RETURNS>
GstQTDemux * qtdemux, GstByteReader * data, int depth
</FUNCTION>
<FUNCTION>
<NAME>qtdemux_dump_cmvd</NAME>
<RETURNS>gboolean  </RETURNS>
GstQTDemux * qtdemux, GstByteReader * data, int depth
</FUNCTION>
<FUNCTION>
<NAME>qtdemux_dump_ctts</NAME>
<RETURNS>gboolean  </RETURNS>
GstQTDemux * qtdemux, GstByteReader * data, int depth
</FUNCTION>
<FUNCTION>
<NAME>qtdemux_dump_cslg</NAME>
<RETURNS>gboolean  </RETURNS>
GstQTDemux * qtdemux, GstByteReader * data, int depth
</FUNCTION>
<FUNCTION>
<NAME>qtdemux_dump_mfro</NAME>
<RETURNS>gboolean  </RETURNS>
GstQTDemux * qtdemux, GstByteReader * data, int depth
</FUNCTION>
<FUNCTION>
<NAME>qtdemux_dump_mfhd</NAME>
<RETURNS>gboolean  </RETURNS>
GstQTDemux * qtdemux, GstByteReader * data, int depth
</FUNCTION>
<FUNCTION>
<NAME>qtdemux_dump_tfra</NAME>
<RETURNS>gboolean  </RETURNS>
GstQTDemux * qtdemux, GstByteReader * data, int depth
</FUNCTION>
<FUNCTION>
<NAME>qtdemux_dump_tfhd</NAME>
<RETURNS>gboolean  </RETURNS>
GstQTDemux * qtdemux, GstByteReader * data, int depth
</FUNCTION>
<FUNCTION>
<NAME>qtdemux_dump_trun</NAME>
<RETURNS>gboolean  </RETURNS>
GstQTDemux * qtdemux, GstByteReader * data, int depth
</FUNCTION>
<FUNCTION>
<NAME>qtdemux_dump_trex</NAME>
<RETURNS>gboolean  </RETURNS>
GstQTDemux * qtdemux, GstByteReader * data, int depth
</FUNCTION>
<FUNCTION>
<NAME>qtdemux_dump_mehd</NAME>
<RETURNS>gboolean  </RETURNS>
GstQTDemux * qtdemux, GstByteReader * data, int depth
</FUNCTION>
<FUNCTION>
<NAME>qtdemux_dump_sdtp</NAME>
<RETURNS>gboolean  </RETURNS>
GstQTDemux * qtdemux, GstByteReader * data, int depth
</FUNCTION>
<FUNCTION>
<NAME>qtdemux_dump_tfdt</NAME>
<RETURNS>gboolean  </RETURNS>
GstQTDemux * qtdemux, GstByteReader * data, int depth
</FUNCTION>
<FUNCTION>
<NAME>qtdemux_dump_unknown</NAME>
<RETURNS>gboolean  </RETURNS>
GstQTDemux * qtdemux, GstByteReader * data, int depth
</FUNCTION>
<FUNCTION>
<NAME>qtdemux_dump_svmi</NAME>
<RETURNS>gboolean  </RETURNS>
GstQTDemux *qtdemux, GstByteReader *data, int depth
</FUNCTION>
<FUNCTION>
<NAME>qtdemux_dump_dfLa</NAME>
<RETURNS>gboolean  </RETURNS>
GstQTDemux * qtdemux, GstByteReader * data, int depth
</FUNCTION>
<FUNCTION>
<NAME>qtdemux_dump_fLaC</NAME>
<RETURNS>gboolean  </RETURNS>
GstQTDemux * qtdemux, GstByteReader * data, int depth
</FUNCTION>
<FUNCTION>
<NAME>qtdemux_node_dump</NAME>
<RETURNS>gboolean  </RETURNS>
GstQTDemux * qtdemux, GNode * node
</FUNCTION>
<FUNCTION>
<NAME>prop_copy_ensure_buffer</NAME>
<RETURNS>void     </RETURNS>
guint8 ** buffer, guint64 * bsize, guint64 * offset, guint64 size
</FUNCTION>
<FUNCTION>
<NAME>prop_copy_uint8</NAME>
<RETURNS>guint64  </RETURNS>
guint8 prop, guint8 **buffer, guint64 *size, guint64 *offset
</FUNCTION>
<FUNCTION>
<NAME>prop_copy_uint16</NAME>
<RETURNS>guint64  </RETURNS>
guint16 prop, guint8 **buffer, guint64 *size, guint64 *offset
</FUNCTION>
<FUNCTION>
<NAME>prop_copy_uint32</NAME>
<RETURNS>guint64  </RETURNS>
guint32 prop, guint8 **buffer, guint64 *size, guint64 *offset
</FUNCTION>
<FUNCTION>
<NAME>prop_copy_uint64</NAME>
<RETURNS>guint64  </RETURNS>
guint64 prop, guint8 **buffer, guint64 *size, guint64 *offset
</FUNCTION>
<FUNCTION>
<NAME>prop_copy_int32</NAME>
<RETURNS>guint64  </RETURNS>
gint32 prop, guint8 **buffer, guint64 *size, guint64 *offset
</FUNCTION>
<FUNCTION>
<NAME>prop_copy_uint8_array</NAME>
<RETURNS>guint64  </RETURNS>
guint8 *prop, guint size, guint8 **buffer, guint64 *bsize, guint64 *offset
</FUNCTION>
<FUNCTION>
<NAME>prop_copy_uint16_array</NAME>
<RETURNS>guint64  </RETURNS>
guint16 *prop, guint size, guint8 **buffer, guint64 *bsize, guint64 *offset
</FUNCTION>
<FUNCTION>
<NAME>prop_copy_uint32_array</NAME>
<RETURNS>guint64  </RETURNS>
guint32 *prop, guint size, guint8 **buffer, guint64 *bsize, guint64 *offset
</FUNCTION>
<FUNCTION>
<NAME>prop_copy_uint64_array</NAME>
<RETURNS>guint64  </RETURNS>
guint64 *prop, guint size, guint8 **buffer, guint64 *bsize, guint64 *offset
</FUNCTION>
<FUNCTION>
<NAME>prop_copy_fourcc</NAME>
<RETURNS>guint64  </RETURNS>
guint32 prop, guint8 **buffer, guint64 *size, guint64 *offset
</FUNCTION>
<FUNCTION>
<NAME>prop_copy_fourcc_array</NAME>
<RETURNS>guint64  </RETURNS>
guint32 *prop, guint size, guint8 **buffer, guint64 *bsize, guint64 *offset
</FUNCTION>
<FUNCTION>
<NAME>prop_copy_fixed_size_string</NAME>
<RETURNS>guint64  </RETURNS>
guint8 *string, guint str_size, guint8 **buffer, guint64 *size, guint64 *offset
</FUNCTION>
<FUNCTION>
<NAME>prop_copy_size_string</NAME>
<RETURNS>guint64  </RETURNS>
guint8 *string, guint str_size, guint8 **buffer, guint64 *size, guint64 *offset
</FUNCTION>
<FUNCTION>
<NAME>prop_copy_null_terminated_string</NAME>
<RETURNS>guint64  </RETURNS>
gchar *string, guint8 **buffer, guint64 *size, guint64 *offset
</FUNCTION>
<USER_FUNCTION>
<NAME>QtDumpFunc</NAME>
<RETURNS>gboolean </RETURNS>
GstQTDemux * qtdemux, GstByteReader * data,
    int depth
</USER_FUNCTION>
<MACRO>
<NAME>QT_UINT32</NAME>
#define QT_UINT32(a)  (GST_READ_UINT32_BE(a))
</MACRO>
<MACRO>
<NAME>QT_UINT24</NAME>
#define QT_UINT24(a)  (GST_READ_UINT32_BE(a) >> 8)
</MACRO>
<MACRO>
<NAME>QT_UINT16</NAME>
#define QT_UINT16(a)  (GST_READ_UINT16_BE(a))
</MACRO>
<MACRO>
<NAME>QT_UINT8</NAME>
#define QT_UINT8(a)   (GST_READ_UINT8(a))
</MACRO>
<MACRO>
<NAME>QT_FP32</NAME>
#define QT_FP32(a)    ((GST_READ_UINT32_BE(a))/65536.0)
</MACRO>
<MACRO>
<NAME>QT_SFP32</NAME>
#define QT_SFP32(a)   (((gint)(GST_READ_UINT32_BE(a)))/65536.0)
</MACRO>
<MACRO>
<NAME>QT_FP16</NAME>
#define QT_FP16(a)    ((GST_READ_UINT16_BE(a))/256.0)
</MACRO>
<MACRO>
<NAME>QT_FOURCC</NAME>
#define QT_FOURCC(a)  (GST_READ_UINT32_LE(a))
</MACRO>
<MACRO>
<NAME>QT_UINT64</NAME>
#define QT_UINT64(a)  ((((guint64)QT_UINT32(a))<<32)|QT_UINT32(((guint8 *)a)+4))
</MACRO>
<ENUM>
<NAME>QtFlags</NAME>
typedef enum {
  QT_FLAG_NONE      = (0),
  QT_FLAG_CONTAINER = (1 << 0)
} QtFlags;
</ENUM>
<STRUCT>
<NAME>QtNodeType</NAME>
struct _QtNodeType {
  guint32      fourcc;
  const gchar *name;
  QtFlags      flags;
  QtDumpFunc   dump;
};
</STRUCT>
<FUNCTION>
<NAME>qtdemux_type_get</NAME>
<RETURNS>const QtNodeType  *</RETURNS>
guint32 fourcc
</FUNCTION>
<ENUM>
<NAME>GstIsoffParserResult</NAME>
typedef enum {
  GST_ISOFF_QT_PARSER_OK,
  GST_ISOFF_QT_PARSER_DONE,
  GST_ISOFF_QT_PARSER_UNEXPECTED,
  GST_ISOFF_QT_PARSER_ERROR
} GstIsoffParserResult;
</ENUM>
<MACRO>
<NAME>GST_ISOFF_QT_FULL_BOX_SIZE</NAME>
#define GST_ISOFF_QT_FULL_BOX_SIZE 12
</MACRO>
<MACRO>
<NAME>GST_ISOFF_QT_FOURCC_SIDX</NAME>
#define GST_ISOFF_QT_FOURCC_SIDX GST_MAKE_FOURCC('s','i','d','x')
</MACRO>
<ENUM>
<NAME>GstSidxParserStatus</NAME>
typedef enum _GstSidxParserStatus
{
  GST_ISOFF_QT_SIDX_PARSER_INIT,
  GST_ISOFF_QT_SIDX_PARSER_HEADER,
  GST_ISOFF_QT_SIDX_PARSER_DATA,
  GST_ISOFF_QT_SIDX_PARSER_FINISHED
} GstSidxParserStatus;
</ENUM>
<FUNCTION>
<NAME>gst_isoff_qt_sidx_parser_init</NAME>
<RETURNS>void  </RETURNS>
GstSidxParser * parser
</FUNCTION>
<FUNCTION>
<NAME>gst_isoff_qt_sidx_parser_clear</NAME>
<RETURNS>void  </RETURNS>
GstSidxParser * parser
</FUNCTION>
<FUNCTION>
<NAME>gst_isoff_qt_sidx_parser_add_data</NAME>
<RETURNS>GstIsoffParserResult  </RETURNS>
GstSidxParser * parser, const guint8 * buffer, gint length, guint * consumed
</FUNCTION>
<FUNCTION>
<NAME>gst_isoff_qt_sidx_parser_add_buffer</NAME>
<RETURNS>GstIsoffParserResult  </RETURNS>
GstSidxParser * parser, GstBuffer * buf, guint * consumed
</FUNCTION>
<MACRO>
<NAME>ATOM_ARRAY</NAME>
#define ATOM_ARRAY(struct_type) \
struct { \
  guint size; \
  guint len; \
  struct_type *data; \
}
</MACRO>
<MACRO>
<NAME>atom_array_init</NAME>
#define atom_array_init(array, reserve)                                       \
G_STMT_START {                                                                \
  (array)->len = 0;                                                           \
  (array)->size = reserve;                                                    \
  (array)->data = g_malloc (sizeof (*(array)->data) * reserve);               \
} G_STMT_END
</MACRO>
<MACRO>
<NAME>atom_array_append</NAME>
#define atom_array_append(array, elmt, inc)                                   \
G_STMT_START {                                                                \
  g_assert ((array)->data);                                                   \
  g_assert (inc > 0);                                                         \
  if (G_UNLIKELY ((array)->len == (array)->size)) {                           \
    (array)->size += inc;                                                     \
    (array)->data =                                                           \
        g_realloc ((array)->data, sizeof (*((array)->data)) * (array)->size); \
  }                                                                           \
  (array)->data[(array)->len] = elmt;                                         \
  (array)->len++;                                                             \
} G_STMT_END
</MACRO>
<MACRO>
<NAME>atom_array_get_len</NAME>
#define atom_array_get_len(array)                  ((array)->len)
</MACRO>
<MACRO>
<NAME>atom_array_index</NAME>
#define atom_array_index(array, index)             ((array)->data[index])
</MACRO>
<MACRO>
<NAME>atom_array_clear</NAME>
#define atom_array_clear(array)                                               \
G_STMT_START {                                                                \
  (array)->size = (array)->len = 0;                                           \
  g_free ((array)->data);                                                     \
  (array)->data = NULL;                                                       \
} G_STMT_END
</MACRO>
<ENUM>
<NAME>AtomsTreeFlavor</NAME>
typedef enum _AtomsTreeFlavor
{
  ATOMS_TREE_FLAVOR_MOV,
  ATOMS_TREE_FLAVOR_ISOM,
  ATOMS_TREE_FLAVOR_3GP,
  ATOMS_TREE_FLAVOR_ISML
} AtomsTreeFlavor;
</ENUM>
<FUNCTION>
<NAME>atoms_context_new</NAME>
<RETURNS>AtomsContext * </RETURNS>
AtomsTreeFlavor flavor
</FUNCTION>
<FUNCTION>
<NAME>atoms_context_free</NAME>
<RETURNS>void           </RETURNS>
AtomsContext *context
</FUNCTION>
<MACRO>
<NAME>METADATA_DATA_FLAG</NAME>
#define METADATA_DATA_FLAG 0x0
</MACRO>
<MACRO>
<NAME>METADATA_TEXT_FLAG</NAME>
#define METADATA_TEXT_FLAG 0x1
</MACRO>
<ENUM>
<NAME>SampleEntryKind</NAME>
typedef enum _SampleEntryKind
{
  UNKNOWN,
  AUDIO,
  VIDEO,
  SUBTITLE,
  TIMECODE
} SampleEntryKind;
</ENUM>
<USER_FUNCTION>
<NAME>AtomCopyDataFunc</NAME>
<RETURNS>guint64 </RETURNS>
Atom *atom, guint8 **buffer, guint64 *size, guint64 *offset
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>AtomFreeFunc</NAME>
<RETURNS>guint64 </RETURNS>
Atom *atom
</USER_FUNCTION>
<STRUCT>
<NAME>AtomInfo</NAME>
struct _AtomInfo
{
  Atom *atom;
  AtomCopyDataFunc copy_data_func;
  AtomFreeFunc free_func;
};
</STRUCT>
<FUNCTION>
<NAME>atoms_get_current_qt_time</NAME>
<RETURNS>guint64     </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>atom_copy_data</NAME>
<RETURNS>guint64     </RETURNS>
Atom *atom, guint8 **buffer, guint64 *size, guint64* offset
</FUNCTION>
<FUNCTION>
<NAME>atom_ftyp_new</NAME>
<RETURNS>AtomFTYP *  </RETURNS>
AtomsContext *context, guint32 major, guint32 version, GList *brands
</FUNCTION>
<FUNCTION>
<NAME>atom_ftyp_copy_data</NAME>
<RETURNS>guint64     </RETURNS>
AtomFTYP *ftyp, guint8 **buffer, guint64 *size, guint64 *offset
</FUNCTION>
<FUNCTION>
<NAME>atom_ftyp_free</NAME>
<RETURNS>void        </RETURNS>
AtomFTYP *ftyp
</FUNCTION>
<FUNCTION>
<NAME>atom_trak_new</NAME>
<RETURNS>AtomTRAK *  </RETURNS>
AtomsContext *context
</FUNCTION>
<FUNCTION>
<NAME>atom_trak_add_samples</NAME>
<RETURNS>void        </RETURNS>
AtomTRAK * trak, guint32 nsamples, guint32 delta, guint32 size, guint64 chunk_offset, gboolean sync, gint64 pts_offset
</FUNCTION>
<FUNCTION>
<NAME>atom_trak_set_elst_entry</NAME>
<RETURNS>void        </RETURNS>
AtomTRAK * trak, gint index, guint32 duration, guint32 media_time, guint32 rate
</FUNCTION>
<FUNCTION>
<NAME>atom_trak_edts_clear</NAME>
<RETURNS>void        </RETURNS>
AtomTRAK * trak
</FUNCTION>
<FUNCTION>
<NAME>atom_trak_get_timescale</NAME>
<RETURNS>guint32     </RETURNS>
AtomTRAK *trak
</FUNCTION>
<FUNCTION>
<NAME>atom_trak_get_id</NAME>
<RETURNS>guint32     </RETURNS>
AtomTRAK * trak
</FUNCTION>
<FUNCTION>
<NAME>atom_stbl_add_samples</NAME>
<RETURNS>void        </RETURNS>
AtomSTBL * stbl, guint32 nsamples, guint32 delta, guint32 size, guint64 chunk_offset, gboolean sync, gint64 pts_offset
</FUNCTION>
<FUNCTION>
<NAME>atom_moov_new</NAME>
<RETURNS>AtomMOOV *  </RETURNS>
AtomsContext *context
</FUNCTION>
<FUNCTION>
<NAME>atom_moov_free</NAME>
<RETURNS>void        </RETURNS>
AtomMOOV *moov
</FUNCTION>
<FUNCTION>
<NAME>atom_moov_copy_data</NAME>
<RETURNS>guint64     </RETURNS>
AtomMOOV *atom, guint8 **buffer, guint64 *size, guint64* offset
</FUNCTION>
<FUNCTION>
<NAME>atom_moov_update_timescale</NAME>
<RETURNS>void        </RETURNS>
AtomMOOV *moov, guint32 timescale
</FUNCTION>
<FUNCTION>
<NAME>atom_moov_update_duration</NAME>
<RETURNS>void        </RETURNS>
AtomMOOV *moov
</FUNCTION>
<FUNCTION>
<NAME>atom_moov_set_fragmented</NAME>
<RETURNS>void        </RETURNS>
AtomMOOV *moov, gboolean fragmented
</FUNCTION>
<FUNCTION>
<NAME>atom_moov_chunks_set_offset</NAME>
<RETURNS>void        </RETURNS>
AtomMOOV *moov, guint32 offset
</FUNCTION>
<FUNCTION>
<NAME>atom_moov_add_trak</NAME>
<RETURNS>void        </RETURNS>
AtomMOOV *moov, AtomTRAK *trak
</FUNCTION>
<FUNCTION>
<NAME>atom_moov_get_trak_count</NAME>
<RETURNS>guint       </RETURNS>
AtomMOOV *moov
</FUNCTION>
<FUNCTION>
<NAME>atom_framerate_to_timescale</NAME>
<RETURNS>guint       </RETURNS>
gint fps_n, gint fps_d
</FUNCTION>
<FUNCTION>
<NAME>atom_mvhd_copy_data</NAME>
<RETURNS>guint64     </RETURNS>
AtomMVHD * atom, guint8 ** buffer, guint64 * size, guint64 * offset
</FUNCTION>
<FUNCTION>
<NAME>atom_stco64_chunks_set_offset</NAME>
<RETURNS>void        </RETURNS>
AtomSTCO64 * stco64, guint32 offset
</FUNCTION>
<FUNCTION>
<NAME>atom_trak_copy_data</NAME>
<RETURNS>guint64     </RETURNS>
AtomTRAK * atom, guint8 ** buffer, guint64 * size, guint64 * offset
</FUNCTION>
<FUNCTION>
<NAME>atom_stbl_clear</NAME>
<RETURNS>void        </RETURNS>
AtomSTBL * stbl
</FUNCTION>
<FUNCTION>
<NAME>atom_stbl_init</NAME>
<RETURNS>void        </RETURNS>
AtomSTBL * stbl
</FUNCTION>
<FUNCTION>
<NAME>atom_stss_copy_data</NAME>
<RETURNS>guint64     </RETURNS>
AtomSTSS *atom, guint8 **buffer, guint64 *size, guint64* offset
</FUNCTION>
<FUNCTION>
<NAME>atom_stts_copy_data</NAME>
<RETURNS>guint64     </RETURNS>
AtomSTTS *atom, guint8 **buffer, guint64 *size, guint64* offset
</FUNCTION>
<FUNCTION>
<NAME>atom_stsc_copy_data</NAME>
<RETURNS>guint64     </RETURNS>
AtomSTSC *atom, guint8 **buffer, guint64 *size, guint64* offset
</FUNCTION>
<FUNCTION>
<NAME>atom_stsz_copy_data</NAME>
<RETURNS>guint64     </RETURNS>
AtomSTSZ *atom, guint8 **buffer, guint64 *size, guint64* offset
</FUNCTION>
<FUNCTION>
<NAME>atom_ctts_copy_data</NAME>
<RETURNS>guint64     </RETURNS>
AtomCTTS *atom, guint8 **buffer, guint64 *size, guint64* offset
</FUNCTION>
<FUNCTION>
<NAME>atom_stco64_copy_data</NAME>
<RETURNS>guint64     </RETURNS>
AtomSTCO64 *atom, guint8 **buffer, guint64 *size, guint64* offset
</FUNCTION>
<FUNCTION>
<NAME>atom_moof_new</NAME>
<RETURNS>AtomMOOF *  </RETURNS>
AtomsContext *context, guint32 sequence_number
</FUNCTION>
<FUNCTION>
<NAME>atom_moof_free</NAME>
<RETURNS>void        </RETURNS>
AtomMOOF *moof
</FUNCTION>
<FUNCTION>
<NAME>atom_moof_copy_data</NAME>
<RETURNS>guint64     </RETURNS>
AtomMOOF *moof, guint8 **buffer, guint64 *size, guint64* offset
</FUNCTION>
<FUNCTION>
<NAME>atom_traf_new</NAME>
<RETURNS>AtomTRAF  * </RETURNS>
AtomsContext * context, guint32 track_ID
</FUNCTION>
<FUNCTION>
<NAME>atom_traf_free</NAME>
<RETURNS>void        </RETURNS>
AtomTRAF * traf
</FUNCTION>
<FUNCTION>
<NAME>atom_traf_set_base_decode_time</NAME>
<RETURNS>void        </RETURNS>
AtomTRAF * traf, guint64 base_decode_time
</FUNCTION>
<FUNCTION>
<NAME>atom_traf_add_samples</NAME>
<RETURNS>void        </RETURNS>
AtomTRAF * traf, guint32 delta, guint32 size, gboolean sync, gint64 pts_offset, gboolean sdtp_sync
</FUNCTION>
<FUNCTION>
<NAME>atom_traf_get_sample_num</NAME>
<RETURNS>guint32     </RETURNS>
AtomTRAF * traf
</FUNCTION>
<FUNCTION>
<NAME>atom_moof_add_traf</NAME>
<RETURNS>void        </RETURNS>
AtomMOOF *moof, AtomTRAF *traf
</FUNCTION>
<FUNCTION>
<NAME>atom_mfra_new</NAME>
<RETURNS>AtomMFRA *  </RETURNS>
AtomsContext *context
</FUNCTION>
<FUNCTION>
<NAME>atom_mfra_free</NAME>
<RETURNS>void        </RETURNS>
AtomMFRA *mfra
</FUNCTION>
<FUNCTION>
<NAME>atom_tfra_new</NAME>
<RETURNS>AtomTFRA *  </RETURNS>
AtomsContext *context, guint32 track_ID
</FUNCTION>
<FUNCTION>
<NAME>atom_tfra_add_entry</NAME>
<RETURNS>void        </RETURNS>
AtomTFRA *tfra, guint64 dts, guint32 sample_num
</FUNCTION>
<FUNCTION>
<NAME>atom_tfra_update_offset</NAME>
<RETURNS>void        </RETURNS>
AtomTFRA * tfra, guint64 offset
</FUNCTION>
<FUNCTION>
<NAME>atom_mfra_add_tfra</NAME>
<RETURNS>void        </RETURNS>
AtomMFRA *mfra, AtomTFRA *tfra
</FUNCTION>
<FUNCTION>
<NAME>atom_mfra_copy_data</NAME>
<RETURNS>guint64     </RETURNS>
AtomMFRA *mfra, guint8 **buffer, guint64 *size, guint64* offset
</FUNCTION>
<FUNCTION>
<NAME>subtitle_sample_entry_init</NAME>
<RETURNS>void  </RETURNS>
SubtitleSampleEntry * entry
</FUNCTION>
<FUNCTION>
<NAME>atom_trak_set_audio_type</NAME>
<RETURNS>SampleTableEntryMP4A  * </RETURNS>
AtomTRAK * trak, AtomsContext * context, AudioSampleEntry * entry, guint32 scale, AtomInfo * ext, gint sample_size
</FUNCTION>
<FUNCTION>
<NAME>atom_trak_set_video_type</NAME>
<RETURNS>SampleTableEntryMP4V  * </RETURNS>
AtomTRAK * trak, AtomsContext * context, VisualSampleEntry * entry, guint32 rate, GList * ext_atoms_list
</FUNCTION>
<FUNCTION>
<NAME>atom_trak_set_subtitle_type</NAME>
<RETURNS>SampleTableEntryTX3G  * </RETURNS>
AtomTRAK * trak, AtomsContext * context, SubtitleSampleEntry * entry
</FUNCTION>
<FUNCTION>
<NAME>atom_trak_set_timecode_type</NAME>
<RETURNS>SampleTableEntryTMCD  *</RETURNS>
AtomTRAK * trak, AtomsContext * context, GstVideoTimeCode * tc
</FUNCTION>
<FUNCTION>
<NAME>atom_trak_update_bitrates</NAME>
<RETURNS>void  </RETURNS>
AtomTRAK * trak, guint32 avg_bitrate, guint32 max_bitrate
</FUNCTION>
<FUNCTION>
<NAME>atom_trak_tx3g_update_dimension</NAME>
<RETURNS>void  </RETURNS>
AtomTRAK * trak, guint32 width, guint32 height
</FUNCTION>
<FUNCTION>
<NAME>sample_table_entry_add_ext_atom</NAME>
<RETURNS>void  </RETURNS>
SampleTableEntry * ste, AtomInfo * ext
</FUNCTION>
<FUNCTION>
<NAME>build_codec_data_extension</NAME>
<RETURNS>AtomInfo  *   </RETURNS>
guint32 fourcc, const GstBuffer * codec_data
</FUNCTION>
<FUNCTION>
<NAME>build_mov_aac_extension</NAME>
<RETURNS>AtomInfo  *   </RETURNS>
AtomTRAK * trak, const GstBuffer * codec_data, guint32 avg_bitrate, guint32 max_bitrate
</FUNCTION>
<FUNCTION>
<NAME>build_mov_alac_extension</NAME>
<RETURNS>AtomInfo  *   </RETURNS>
const GstBuffer * codec_data
</FUNCTION>
<FUNCTION>
<NAME>build_esds_extension</NAME>
<RETURNS>AtomInfo  *   </RETURNS>
AtomTRAK * trak, guint8 object_type, guint8 stream_type, const GstBuffer * codec_data, guint32 avg_bitrate, guint32 max_bitrate
</FUNCTION>
<FUNCTION>
<NAME>build_btrt_extension</NAME>
<RETURNS>AtomInfo  *   </RETURNS>
guint32 buffer_size_db, guint32 avg_bitrate, guint32 max_bitrate
</FUNCTION>
<FUNCTION>
<NAME>build_jp2h_extension</NAME>
<RETURNS>AtomInfo  *   </RETURNS>
gint width, gint height, const gchar *colorspace, gint ncomp, const GValue * cmap_array, const GValue * cdef_array
</FUNCTION>
<FUNCTION>
<NAME>build_jp2x_extension</NAME>
<RETURNS>AtomInfo  *   </RETURNS>
const GstBuffer * prefix
</FUNCTION>
<FUNCTION>
<NAME>build_fiel_extension</NAME>
<RETURNS>AtomInfo  *   </RETURNS>
GstVideoInterlaceMode mode, GstVideoFieldOrder order
</FUNCTION>
<FUNCTION>
<NAME>build_colr_extension</NAME>
<RETURNS>AtomInfo  *   </RETURNS>
const GstVideoColorimetry *colorimetry, gboolean is_mp4
</FUNCTION>
<FUNCTION>
<NAME>build_clap_extension</NAME>
<RETURNS>AtomInfo  *   </RETURNS>
gint width_n, gint width_d, gint height_n, gint height_d, gint h_off_n, gint h_off_d, gint v_off_n, gint v_off_d
</FUNCTION>
<FUNCTION>
<NAME>build_tapt_extension</NAME>
<RETURNS>AtomInfo  *   </RETURNS>
gint clef_width, gint clef_height, gint prof_width, gint prof_height, gint enof_width, gint enof_height
</FUNCTION>
<FUNCTION>
<NAME>build_ac3_extension</NAME>
<RETURNS>AtomInfo  *   </RETURNS>
guint8 fscod, guint8 bsid, guint8 bsmod, guint8 acmod, guint8 lfe_on, guint8 bitrate_code
</FUNCTION>
<FUNCTION>
<NAME>build_opus_extension</NAME>
<RETURNS>AtomInfo  *   </RETURNS>
guint32 rate, guint8 channels, guint8 mapping_family, guint8 stream_count, guint8 coupled_count, guint8 channel_mapping[256], guint16 pre_skip, guint16 output_gain
</FUNCTION>
<FUNCTION>
<NAME>build_amr_extension</NAME>
<RETURNS>AtomInfo  *   </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>build_h263_extension</NAME>
<RETURNS>AtomInfo  *   </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>build_gama_atom</NAME>
<RETURNS>AtomInfo  *   </RETURNS>
gdouble gamma
</FUNCTION>
<FUNCTION>
<NAME>build_SMI_atom</NAME>
<RETURNS>AtomInfo  *   </RETURNS>
const GstBuffer *seqh
</FUNCTION>
<FUNCTION>
<NAME>build_ima_adpcm_extension</NAME>
<RETURNS>AtomInfo  *   </RETURNS>
gint channels, gint rate, gint blocksize
</FUNCTION>
<FUNCTION>
<NAME>build_uuid_xmp_atom</NAME>
<RETURNS>AtomInfo  *   </RETURNS>
GstBuffer * xmp
</FUNCTION>
<FUNCTION>
<NAME>atom_udta_clear_tags</NAME>
<RETURNS>void  </RETURNS>
AtomUDTA *udta
</FUNCTION>
<FUNCTION>
<NAME>atom_udta_add_str_tag</NAME>
<RETURNS>void  </RETURNS>
AtomUDTA *udta, guint32 fourcc, const gchar *value
</FUNCTION>
<FUNCTION>
<NAME>atom_udta_add_uint_tag</NAME>
<RETURNS>void  </RETURNS>
AtomUDTA *udta, guint32 fourcc, guint32 flags, guint32 value
</FUNCTION>
<FUNCTION>
<NAME>atom_udta_add_tag</NAME>
<RETURNS>void  </RETURNS>
AtomUDTA *udta, guint32 fourcc, guint32 flags, const guint8 * data, guint size
</FUNCTION>
<FUNCTION>
<NAME>atom_udta_add_blob_tag</NAME>
<RETURNS>void  </RETURNS>
AtomUDTA *udta, guint8 *data, guint size
</FUNCTION>
<FUNCTION>
<NAME>atom_udta_add_3gp_str_tag</NAME>
<RETURNS>void  </RETURNS>
AtomUDTA *udta, guint32 fourcc, const gchar * value
</FUNCTION>
<FUNCTION>
<NAME>atom_udta_add_3gp_uint_tag</NAME>
<RETURNS>void  </RETURNS>
AtomUDTA *udta, guint32 fourcc, guint16 value
</FUNCTION>
<FUNCTION>
<NAME>atom_udta_add_3gp_str_int_tag</NAME>
<RETURNS>void  </RETURNS>
AtomUDTA *udta, guint32 fourcc, const gchar * value, gint16 ivalue
</FUNCTION>
<FUNCTION>
<NAME>atom_udta_add_3gp_tag</NAME>
<RETURNS>void  </RETURNS>
AtomUDTA *udta, guint32 fourcc, guint8 * data, guint size
</FUNCTION>
<FUNCTION>
<NAME>atom_udta_add_xmp_tags</NAME>
<RETURNS>void  </RETURNS>
AtomUDTA *udta, GstBuffer * xmp
</FUNCTION>
<FUNCTION>
<NAME>atom_tref_new</NAME>
<RETURNS>AtomTREF  * </RETURNS>
guint32 reftype
</FUNCTION>
<FUNCTION>
<NAME>atom_tref_add_entry</NAME>
<RETURNS>void  </RETURNS>
AtomTREF * tref, guint32 sample
</FUNCTION>
<MACRO>
<NAME>GST_QT_MUX_DEFAULT_TAG_LANGUAGE</NAME>
#define GST_QT_MUX_DEFAULT_TAG_LANGUAGE   "und" /* undefined/unknown */
</MACRO>
<FUNCTION>
<NAME>language_code</NAME>
<RETURNS>guint16   </RETURNS>
const char * lang
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_QT_MOOV_RECOVER</NAME>
#define GST_TYPE_QT_MOOV_RECOVER (gst_qt_moov_recover_get_type())
</MACRO>
<MACRO>
<NAME>GST_QT_MOOV_RECOVER</NAME>
#define GST_QT_MOOV_RECOVER(obj) (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_QT_MOOV_RECOVER, GstQTMoovRecover))
</MACRO>
<MACRO>
<NAME>GST_QT_MOOV_RECOVER_CLASS</NAME>
#define GST_QT_MOOV_RECOVER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_QT_MOOV_RECOVER, GstQTMoovRecover))
</MACRO>
<MACRO>
<NAME>GST_IS_QT_MOOV_RECOVER</NAME>
#define GST_IS_QT_MOOV_RECOVER(obj) (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_QT_MOOV_RECOVER))
</MACRO>
<MACRO>
<NAME>GST_IS_QT_MOOV_RECOVER_CLASS</NAME>
#define GST_IS_QT_MOOV_RECOVER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_QT_MOOV_RECOVER))
</MACRO>
<MACRO>
<NAME>GST_QT_MOOV_RECOVER_CAST</NAME>
#define GST_QT_MOOV_RECOVER_CAST(obj) ((GstQTMoovRecover*)(obj))
</MACRO>
<STRUCT>
<NAME>GstQTMoovRecover</NAME>
struct _GstQTMoovRecover
{
  GstPipeline pipeline;

  GstTask *task;
  GRecMutex task_mutex;

  /* properties */
  gboolean  faststart_mode;
  gchar    *recovery_input;
  gchar    *fixed_output;
  gchar    *broken_input;
};
</STRUCT>
<STRUCT>
<NAME>GstQTMoovRecoverClass</NAME>
struct _GstQTMoovRecoverClass
{
  GstPipelineClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_qt_moov_recover_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_qt_moov_recover_register</NAME>
<RETURNS>gboolean  </RETURNS>
GstPlugin * plugin
</FUNCTION>
<MACRO>
<NAME>FOURCC_null</NAME>
#define FOURCC_null     0x0
</MACRO>
<MACRO>
<NAME>FOURCC_2vuy</NAME>
#define FOURCC_2vuy     GST_MAKE_FOURCC('2','v','u','y')
</MACRO>
<MACRO>
<NAME>FOURCC_FMP4</NAME>
#define FOURCC_FMP4     GST_MAKE_FOURCC('F','M','P','4')
</MACRO>
<MACRO>
<NAME>FOURCC_H264</NAME>
#define FOURCC_H264     GST_MAKE_FOURCC('H','2','6','4')
</MACRO>
<MACRO>
<NAME>FOURCC_H265</NAME>
#define FOURCC_H265     GST_MAKE_FOURCC('H','2','6','5')
</MACRO>
<MACRO>
<NAME>FOURCC_MAC3</NAME>
#define FOURCC_MAC3     GST_MAKE_FOURCC('M','A','C','3')
</MACRO>
<MACRO>
<NAME>FOURCC_MAC6</NAME>
#define FOURCC_MAC6     GST_MAKE_FOURCC('M','A','C','6')
</MACRO>
<MACRO>
<NAME>FOURCC_MP4V</NAME>
#define FOURCC_MP4V     GST_MAKE_FOURCC('M','P','4','V')
</MACRO>
<MACRO>
<NAME>FOURCC_PICT</NAME>
#define FOURCC_PICT     GST_MAKE_FOURCC('P','I','C','T')
</MACRO>
<MACRO>
<NAME>FOURCC_QDM2</NAME>
#define FOURCC_QDM2     GST_MAKE_FOURCC('Q','D','M','2')
</MACRO>
<MACRO>
<NAME>FOURCC_SVQ3</NAME>
#define FOURCC_SVQ3     GST_MAKE_FOURCC('S','V','Q','3')
</MACRO>
<MACRO>
<NAME>FOURCC_VP31</NAME>
#define FOURCC_VP31     GST_MAKE_FOURCC('V','P','3','1')
</MACRO>
<MACRO>
<NAME>FOURCC_VP80</NAME>
#define FOURCC_VP80     GST_MAKE_FOURCC('V','P','8','0')
</MACRO>
<MACRO>
<NAME>FOURCC_WRLE</NAME>
#define FOURCC_WRLE     GST_MAKE_FOURCC('W','R','L','E')
</MACRO>
<MACRO>
<NAME>FOURCC_XMP_</NAME>
#define FOURCC_XMP_     GST_MAKE_FOURCC('X','M','P','_')
</MACRO>
<MACRO>
<NAME>FOURCC_XVID</NAME>
#define FOURCC_XVID     GST_MAKE_FOURCC('X','V','I','D')
</MACRO>
<MACRO>
<NAME>FOURCC__ART</NAME>
#define FOURCC__ART     GST_MAKE_FOURCC(0xa9,'A','R','T')
</MACRO>
<MACRO>
<NAME>FOURCC_____</NAME>
#define FOURCC_____     GST_MAKE_FOURCC('-','-','-','-')
</MACRO>
<MACRO>
<NAME>FOURCC___in</NAME>
#define FOURCC___in     GST_MAKE_FOURCC(' ',' ','i','n')
</MACRO>
<MACRO>
<NAME>FOURCC___ty</NAME>
#define FOURCC___ty     GST_MAKE_FOURCC(' ',' ','t','y')
</MACRO>
<MACRO>
<NAME>FOURCC__alb</NAME>
#define FOURCC__alb     GST_MAKE_FOURCC(0xa9,'a','l','b')
</MACRO>
<MACRO>
<NAME>FOURCC__cpy</NAME>
#define FOURCC__cpy     GST_MAKE_FOURCC(0xa9,'c','p','y')
</MACRO>
<MACRO>
<NAME>FOURCC__day</NAME>
#define FOURCC__day     GST_MAKE_FOURCC(0xa9,'d','a','y')
</MACRO>
<MACRO>
<NAME>FOURCC__des</NAME>
#define FOURCC__des     GST_MAKE_FOURCC(0xa9,'d','e','s')
</MACRO>
<MACRO>
<NAME>FOURCC__enc</NAME>
#define FOURCC__enc     GST_MAKE_FOURCC(0xa9,'e','n','c')
</MACRO>
<MACRO>
<NAME>FOURCC__gen</NAME>
#define FOURCC__gen     GST_MAKE_FOURCC(0xa9, 'g', 'e', 'n')
</MACRO>
<MACRO>
<NAME>FOURCC__grp</NAME>
#define FOURCC__grp     GST_MAKE_FOURCC(0xa9,'g','r','p')
</MACRO>
<MACRO>
<NAME>FOURCC__inf</NAME>
#define FOURCC__inf     GST_MAKE_FOURCC(0xa9,'i','n','f')
</MACRO>
<MACRO>
<NAME>FOURCC__lyr</NAME>
#define FOURCC__lyr     GST_MAKE_FOURCC(0xa9,'l','y','r')
</MACRO>
<MACRO>
<NAME>FOURCC__mp3</NAME>
#define FOURCC__mp3     GST_MAKE_FOURCC('.','m','p','3')
</MACRO>
<MACRO>
<NAME>FOURCC__nam</NAME>
#define FOURCC__nam     GST_MAKE_FOURCC(0xa9,'n','a','m')
</MACRO>
<MACRO>
<NAME>FOURCC__req</NAME>
#define FOURCC__req     GST_MAKE_FOURCC(0xa9,'r','e','q')
</MACRO>
<MACRO>
<NAME>FOURCC__too</NAME>
#define FOURCC__too     GST_MAKE_FOURCC(0xa9,'t','o','o')
</MACRO>
<MACRO>
<NAME>FOURCC__wrt</NAME>
#define FOURCC__wrt     GST_MAKE_FOURCC(0xa9,'w','r','t')
</MACRO>
<MACRO>
<NAME>FOURCC_aART</NAME>
#define FOURCC_aART     GST_MAKE_FOURCC('a','A','R','T')
</MACRO>
<MACRO>
<NAME>FOURCC_ac_3</NAME>
#define FOURCC_ac_3     GST_MAKE_FOURCC('a','c','-','3')
</MACRO>
<MACRO>
<NAME>FOURCC_agsm</NAME>
#define FOURCC_agsm     GST_MAKE_FOURCC('a','g','s','m')
</MACRO>
<MACRO>
<NAME>FOURCC_alac</NAME>
#define FOURCC_alac     GST_MAKE_FOURCC('a','l','a','c')
</MACRO>
<MACRO>
<NAME>FOURCC_fLaC</NAME>
#define FOURCC_fLaC     GST_MAKE_FOURCC('f','L','a','C')
</MACRO>
<MACRO>
<NAME>FOURCC_dfLa</NAME>
#define FOURCC_dfLa     GST_MAKE_FOURCC('d','f','L','a')
</MACRO>
<MACRO>
<NAME>FOURCC_alaw</NAME>
#define FOURCC_alaw     GST_MAKE_FOURCC('a','l','a','w')
</MACRO>
<MACRO>
<NAME>FOURCC_alis</NAME>
#define FOURCC_alis     GST_MAKE_FOURCC('a','l','i','s')
</MACRO>
<MACRO>
<NAME>FOURCC_appl</NAME>
#define FOURCC_appl     GST_MAKE_FOURCC('a','p','p','l')
</MACRO>
<MACRO>
<NAME>FOURCC_avc1</NAME>
#define FOURCC_avc1     GST_MAKE_FOURCC('a','v','c','1')
</MACRO>
<MACRO>
<NAME>FOURCC_avc3</NAME>
#define FOURCC_avc3     GST_MAKE_FOURCC('a','v','c','3')
</MACRO>
<MACRO>
<NAME>FOURCC_avcC</NAME>
#define FOURCC_avcC     GST_MAKE_FOURCC('a','v','c','C')
</MACRO>
<MACRO>
<NAME>FOURCC_clip</NAME>
#define FOURCC_clip     GST_MAKE_FOURCC('c','l','i','p')
</MACRO>
<MACRO>
<NAME>FOURCC_cmov</NAME>
#define FOURCC_cmov     GST_MAKE_FOURCC('c','m','o','v')
</MACRO>
<MACRO>
<NAME>FOURCC_cmvd</NAME>
#define FOURCC_cmvd     GST_MAKE_FOURCC('c','m','v','d')
</MACRO>
<MACRO>
<NAME>FOURCC_co64</NAME>
#define FOURCC_co64     GST_MAKE_FOURCC('c','o','6','4')
</MACRO>
<MACRO>
<NAME>FOURCC_covr</NAME>
#define FOURCC_covr     GST_MAKE_FOURCC('c','o','v','r')
</MACRO>
<MACRO>
<NAME>FOURCC_cpil</NAME>
#define FOURCC_cpil     GST_MAKE_FOURCC('c','p','i','l')
</MACRO>
<MACRO>
<NAME>FOURCC_cprt</NAME>
#define FOURCC_cprt     GST_MAKE_FOURCC('c','p','r','t')
</MACRO>
<MACRO>
<NAME>FOURCC_crgn</NAME>
#define FOURCC_crgn     GST_MAKE_FOURCC('c','r','g','n')
</MACRO>
<MACRO>
<NAME>FOURCC_ctab</NAME>
#define FOURCC_ctab     GST_MAKE_FOURCC('c','t','a','b')
</MACRO>
<MACRO>
<NAME>FOURCC_ctts</NAME>
#define FOURCC_ctts     GST_MAKE_FOURCC('c','t','t','s')
</MACRO>
<MACRO>
<NAME>FOURCC_cslg</NAME>
#define FOURCC_cslg     GST_MAKE_FOURCC('c','s','l','g')
</MACRO>
<MACRO>
<NAME>FOURCC_d263</NAME>
#define FOURCC_d263     GST_MAKE_FOURCC('d','2','6','3')
</MACRO>
<MACRO>
<NAME>FOURCC_dac3</NAME>
#define FOURCC_dac3     GST_MAKE_FOURCC('d','a','c','3')
</MACRO>
<MACRO>
<NAME>FOURCC_damr</NAME>
#define FOURCC_damr     GST_MAKE_FOURCC('d','a','m','r')
</MACRO>
<MACRO>
<NAME>FOURCC_data</NAME>
#define FOURCC_data     GST_MAKE_FOURCC('d','a','t','a')
</MACRO>
<MACRO>
<NAME>FOURCC_dcom</NAME>
#define FOURCC_dcom     GST_MAKE_FOURCC('d','c','o','m')
</MACRO>
<MACRO>
<NAME>FOURCC_desc</NAME>
#define FOURCC_desc     GST_MAKE_FOURCC('d','e','s','c')
</MACRO>
<MACRO>
<NAME>FOURCC_dhlr</NAME>
#define FOURCC_dhlr     GST_MAKE_FOURCC('d','h','l','r')
</MACRO>
<MACRO>
<NAME>FOURCC_dinf</NAME>
#define FOURCC_dinf     GST_MAKE_FOURCC('d','i','n','f')
</MACRO>
<MACRO>
<NAME>FOURCC_disc</NAME>
#define FOURCC_disc     GST_MAKE_FOURCC('d','i','s','c')
</MACRO>
<MACRO>
<NAME>FOURCC_disk</NAME>
#define FOURCC_disk     GST_MAKE_FOURCC('d','i','s','k')
</MACRO>
<MACRO>
<NAME>FOURCC_drac</NAME>
#define FOURCC_drac     GST_MAKE_FOURCC('d','r','a','c')
</MACRO>
<MACRO>
<NAME>FOURCC_dref</NAME>
#define FOURCC_dref     GST_MAKE_FOURCC('d','r','e','f')
</MACRO>
<MACRO>
<NAME>FOURCC_drmi</NAME>
#define FOURCC_drmi     GST_MAKE_FOURCC('d','r','m','i')
</MACRO>
<MACRO>
<NAME>FOURCC_drms</NAME>
#define FOURCC_drms     GST_MAKE_FOURCC('d','r','m','s')
</MACRO>
<MACRO>
<NAME>FOURCC_dvcp</NAME>
#define FOURCC_dvcp     GST_MAKE_FOURCC('d','v','c','p')
</MACRO>
<MACRO>
<NAME>FOURCC_dvc_</NAME>
#define FOURCC_dvc_     GST_MAKE_FOURCC('d','v','c',' ')
</MACRO>
<MACRO>
<NAME>FOURCC_dv5p</NAME>
#define FOURCC_dv5p     GST_MAKE_FOURCC('d','v','5','p')
</MACRO>
<MACRO>
<NAME>FOURCC_dv5n</NAME>
#define FOURCC_dv5n     GST_MAKE_FOURCC('d','v','5','n')
</MACRO>
<MACRO>
<NAME>FOURCC_edts</NAME>
#define FOURCC_edts     GST_MAKE_FOURCC('e','d','t','s')
</MACRO>
<MACRO>
<NAME>FOURCC_elst</NAME>
#define FOURCC_elst     GST_MAKE_FOURCC('e','l','s','t')
</MACRO>
<MACRO>
<NAME>FOURCC_enda</NAME>
#define FOURCC_enda     GST_MAKE_FOURCC('e','n','d','a')
</MACRO>
<MACRO>
<NAME>FOURCC_esds</NAME>
#define FOURCC_esds     GST_MAKE_FOURCC('e','s','d','s')
</MACRO>
<MACRO>
<NAME>FOURCC_fmp4</NAME>
#define FOURCC_fmp4     GST_MAKE_FOURCC('f','m','p','4')
</MACRO>
<MACRO>
<NAME>FOURCC_free</NAME>
#define FOURCC_free     GST_MAKE_FOURCC('f','r','e','e')
</MACRO>
<MACRO>
<NAME>FOURCC_frma</NAME>
#define FOURCC_frma     GST_MAKE_FOURCC('f','r','m','a')
</MACRO>
<MACRO>
<NAME>FOURCC_ftyp</NAME>
#define FOURCC_ftyp     GST_MAKE_FOURCC('f','t','y','p')
</MACRO>
<MACRO>
<NAME>FOURCC_ftab</NAME>
#define FOURCC_ftab     GST_MAKE_FOURCC('f','t','a','b')
</MACRO>
<MACRO>
<NAME>FOURCC_gama</NAME>
#define FOURCC_gama     GST_MAKE_FOURCC('g','a','m','a')
</MACRO>
<MACRO>
<NAME>FOURCC_glbl</NAME>
#define FOURCC_glbl     GST_MAKE_FOURCC('g','l','b','l')
</MACRO>
<MACRO>
<NAME>FOURCC_gmhd</NAME>
#define FOURCC_gmhd     GST_MAKE_FOURCC('g','m','h','d')
</MACRO>
<MACRO>
<NAME>FOURCC_gmin</NAME>
#define FOURCC_gmin     GST_MAKE_FOURCC('g','m','i','n')
</MACRO>
<MACRO>
<NAME>FOURCC_gnre</NAME>
#define FOURCC_gnre     GST_MAKE_FOURCC('g','n','r','e')
</MACRO>
<MACRO>
<NAME>FOURCC_h263</NAME>
#define FOURCC_h263     GST_MAKE_FOURCC('h','2','6','3')
</MACRO>
<MACRO>
<NAME>FOURCC_hdlr</NAME>
#define FOURCC_hdlr     GST_MAKE_FOURCC('h','d','l','r')
</MACRO>
<MACRO>
<NAME>FOURCC_hev1</NAME>
#define FOURCC_hev1     GST_MAKE_FOURCC('h','e','v','1')
</MACRO>
<MACRO>
<NAME>FOURCC_hint</NAME>
#define FOURCC_hint     GST_MAKE_FOURCC('h','i','n','t')
</MACRO>
<MACRO>
<NAME>FOURCC_hmhd</NAME>
#define FOURCC_hmhd     GST_MAKE_FOURCC('h','m','h','d')
</MACRO>
<MACRO>
<NAME>FOURCC_hndl</NAME>
#define FOURCC_hndl     GST_MAKE_FOURCC('h','n','d','l')
</MACRO>
<MACRO>
<NAME>FOURCC_hnti</NAME>
#define FOURCC_hnti     GST_MAKE_FOURCC('h','n','t','i')
</MACRO>
<MACRO>
<NAME>FOURCC_hvc1</NAME>
#define FOURCC_hvc1     GST_MAKE_FOURCC('h','v','c','1')
</MACRO>
<MACRO>
<NAME>FOURCC_hvcC</NAME>
#define FOURCC_hvcC     GST_MAKE_FOURCC('h','v','c','C')
</MACRO>
<MACRO>
<NAME>FOURCC_ilst</NAME>
#define FOURCC_ilst     GST_MAKE_FOURCC('i','l','s','t')
</MACRO>
<MACRO>
<NAME>FOURCC_ima4</NAME>
#define FOURCC_ima4     GST_MAKE_FOURCC('i','m','a','4')
</MACRO>
<MACRO>
<NAME>FOURCC_imap</NAME>
#define FOURCC_imap     GST_MAKE_FOURCC('i','m','a','p')
</MACRO>
<MACRO>
<NAME>FOURCC_in24</NAME>
#define FOURCC_in24     GST_MAKE_FOURCC('i','n','2','4')
</MACRO>
<MACRO>
<NAME>FOURCC_jp2c</NAME>
#define FOURCC_jp2c     GST_MAKE_FOURCC('j','p','2','c')
</MACRO>
<MACRO>
<NAME>FOURCC_jpeg</NAME>
#define FOURCC_jpeg     GST_MAKE_FOURCC('j','p','e','g')
</MACRO>
<MACRO>
<NAME>FOURCC_keyw</NAME>
#define FOURCC_keyw     GST_MAKE_FOURCC('k','e','y','w')
</MACRO>
<MACRO>
<NAME>FOURCC_kmat</NAME>
#define FOURCC_kmat     GST_MAKE_FOURCC('k','m','a','t')
</MACRO>
<MACRO>
<NAME>FOURCC_kywd</NAME>
#define FOURCC_kywd     GST_MAKE_FOURCC('k','y','w','d')
</MACRO>
<MACRO>
<NAME>FOURCC_load</NAME>
#define FOURCC_load     GST_MAKE_FOURCC('l','o','a','d')
</MACRO>
<MACRO>
<NAME>FOURCC_matt</NAME>
#define FOURCC_matt     GST_MAKE_FOURCC('m','a','t','t')
</MACRO>
<MACRO>
<NAME>FOURCC_mdat</NAME>
#define FOURCC_mdat     GST_MAKE_FOURCC('m','d','a','t')
</MACRO>
<MACRO>
<NAME>FOURCC_mdhd</NAME>
#define FOURCC_mdhd     GST_MAKE_FOURCC('m','d','h','d')
</MACRO>
<MACRO>
<NAME>FOURCC_mdia</NAME>
#define FOURCC_mdia     GST_MAKE_FOURCC('m','d','i','a')
</MACRO>
<MACRO>
<NAME>FOURCC_mdir</NAME>
#define FOURCC_mdir     GST_MAKE_FOURCC('m','d','i','r')
</MACRO>
<MACRO>
<NAME>FOURCC_mean</NAME>
#define FOURCC_mean     GST_MAKE_FOURCC('m','e','a','n')
</MACRO>
<MACRO>
<NAME>FOURCC_meta</NAME>
#define FOURCC_meta     GST_MAKE_FOURCC('m','e','t','a')
</MACRO>
<MACRO>
<NAME>FOURCC_mhlr</NAME>
#define FOURCC_mhlr     GST_MAKE_FOURCC('m','h','l','r')
</MACRO>
<MACRO>
<NAME>FOURCC_minf</NAME>
#define FOURCC_minf     GST_MAKE_FOURCC('m','i','n','f')
</MACRO>
<MACRO>
<NAME>FOURCC_moov</NAME>
#define FOURCC_moov     GST_MAKE_FOURCC('m','o','o','v')
</MACRO>
<MACRO>
<NAME>FOURCC_mp4a</NAME>
#define FOURCC_mp4a     GST_MAKE_FOURCC('m','p','4','a')
</MACRO>
<MACRO>
<NAME>FOURCC_mp4s</NAME>
#define FOURCC_mp4s     GST_MAKE_FOURCC('m','p','4','s')
</MACRO>
<MACRO>
<NAME>FOURCC_mp4v</NAME>
#define FOURCC_mp4v     GST_MAKE_FOURCC('m','p','4','v')
</MACRO>
<MACRO>
<NAME>FOURCC_name</NAME>
#define FOURCC_name     GST_MAKE_FOURCC('n','a','m','e')
</MACRO>
<MACRO>
<NAME>FOURCC_nclc</NAME>
#define FOURCC_nclc     GST_MAKE_FOURCC('n','c','l','c')
</MACRO>
<MACRO>
<NAME>FOURCC_nclx</NAME>
#define FOURCC_nclx     GST_MAKE_FOURCC('n','c','l','x')
</MACRO>
<MACRO>
<NAME>FOURCC_opus</NAME>
#define FOURCC_opus     GST_MAKE_FOURCC('O','p','u','s')
</MACRO>
<MACRO>
<NAME>FOURCC_dops</NAME>
#define FOURCC_dops     GST_MAKE_FOURCC('d','O','p','s')
</MACRO>
<MACRO>
<NAME>FOURCC_pasp</NAME>
#define FOURCC_pasp     GST_MAKE_FOURCC('p','a','s','p')
</MACRO>
<MACRO>
<NAME>FOURCC_colr</NAME>
#define FOURCC_colr     GST_MAKE_FOURCC('c','o','l','r')
</MACRO>
<MACRO>
<NAME>FOURCC_clap</NAME>
#define FOURCC_clap     GST_MAKE_FOURCC('c','l','a','p')
</MACRO>
<MACRO>
<NAME>FOURCC_tapt</NAME>
#define FOURCC_tapt     GST_MAKE_FOURCC('t','a','p','t')
</MACRO>
<MACRO>
<NAME>FOURCC_clef</NAME>
#define FOURCC_clef     GST_MAKE_FOURCC('c','l','e','f')
</MACRO>
<MACRO>
<NAME>FOURCC_prof</NAME>
#define FOURCC_prof     GST_MAKE_FOURCC('p','r','o','f')
</MACRO>
<MACRO>
<NAME>FOURCC_enof</NAME>
#define FOURCC_enof     GST_MAKE_FOURCC('e','n','o','f')
</MACRO>
<MACRO>
<NAME>FOURCC_fiel</NAME>
#define FOURCC_fiel     GST_MAKE_FOURCC('f','i','e','l')
</MACRO>
<MACRO>
<NAME>FOURCC_pcst</NAME>
#define FOURCC_pcst     GST_MAKE_FOURCC('p','c','s','t')
</MACRO>
<MACRO>
<NAME>FOURCC_pgap</NAME>
#define FOURCC_pgap     GST_MAKE_FOURCC('p','g','a','p')
</MACRO>
<MACRO>
<NAME>FOURCC_pnot</NAME>
#define FOURCC_pnot     GST_MAKE_FOURCC('p','n','o','t')
</MACRO>
<MACRO>
<NAME>FOURCC_qt__</NAME>
#define FOURCC_qt__     GST_MAKE_FOURCC('q','t',' ',' ')
</MACRO>
<MACRO>
<NAME>FOURCC_qtim</NAME>
#define FOURCC_qtim     GST_MAKE_FOURCC('q','t','i','m')
</MACRO>
<MACRO>
<NAME>FOURCC_raw_</NAME>
#define FOURCC_raw_     GST_MAKE_FOURCC('r','a','w',' ')
</MACRO>
<MACRO>
<NAME>FOURCC_rdrf</NAME>
#define FOURCC_rdrf     GST_MAKE_FOURCC('r','d','r','f')
</MACRO>
<MACRO>
<NAME>FOURCC_rle_</NAME>
#define FOURCC_rle_     GST_MAKE_FOURCC('r','l','e',' ')
</MACRO>
<MACRO>
<NAME>FOURCC_rmda</NAME>
#define FOURCC_rmda     GST_MAKE_FOURCC('r','m','d','a')
</MACRO>
<MACRO>
<NAME>FOURCC_rmdr</NAME>
#define FOURCC_rmdr     GST_MAKE_FOURCC('r','m','d','r')
</MACRO>
<MACRO>
<NAME>FOURCC_rmra</NAME>
#define FOURCC_rmra     GST_MAKE_FOURCC('r','m','r','a')
</MACRO>
<MACRO>
<NAME>FOURCC_rmvc</NAME>
#define FOURCC_rmvc     GST_MAKE_FOURCC('r','m','v','c')
</MACRO>
<MACRO>
<NAME>FOURCC_rtp_</NAME>
#define FOURCC_rtp_     GST_MAKE_FOURCC('r','t','p',' ')
</MACRO>
<MACRO>
<NAME>FOURCC_rtsp</NAME>
#define FOURCC_rtsp     GST_MAKE_FOURCC('r','t','s','p')
</MACRO>
<MACRO>
<NAME>FOURCC_s263</NAME>
#define FOURCC_s263     GST_MAKE_FOURCC('s','2','6','3')
</MACRO>
<MACRO>
<NAME>FOURCC_samr</NAME>
#define FOURCC_samr     GST_MAKE_FOURCC('s','a','m','r')
</MACRO>
<MACRO>
<NAME>FOURCC_sawb</NAME>
#define FOURCC_sawb     GST_MAKE_FOURCC('s','a','w','b')
</MACRO>
<MACRO>
<NAME>FOURCC_sbtl</NAME>
#define FOURCC_sbtl     GST_MAKE_FOURCC('s','b','t','l')
</MACRO>
<MACRO>
<NAME>FOURCC_sdp_</NAME>
#define FOURCC_sdp_     GST_MAKE_FOURCC('s','d','p',' ')
</MACRO>
<MACRO>
<NAME>FOURCC_sidx</NAME>
#define FOURCC_sidx     GST_MAKE_FOURCC('s','i','d','x')
</MACRO>
<MACRO>
<NAME>FOURCC_smhd</NAME>
#define FOURCC_smhd     GST_MAKE_FOURCC('s','m','h','d')
</MACRO>
<MACRO>
<NAME>FOURCC_soaa</NAME>
#define FOURCC_soaa     GST_MAKE_FOURCC('s','o','a','a')
</MACRO>
<MACRO>
<NAME>FOURCC_soal</NAME>
#define FOURCC_soal     GST_MAKE_FOURCC('s','o','a','l')
</MACRO>
<MACRO>
<NAME>FOURCC_soar</NAME>
#define FOURCC_soar     GST_MAKE_FOURCC('s','o','a','r')
</MACRO>
<MACRO>
<NAME>FOURCC_soco</NAME>
#define FOURCC_soco     GST_MAKE_FOURCC('s','o','c','o')
</MACRO>
<MACRO>
<NAME>FOURCC_sonm</NAME>
#define FOURCC_sonm     GST_MAKE_FOURCC('s','o','n','m')
</MACRO>
<MACRO>
<NAME>FOURCC_sosn</NAME>
#define FOURCC_sosn     GST_MAKE_FOURCC('s','o','s','n')
</MACRO>
<MACRO>
<NAME>FOURCC_soun</NAME>
#define FOURCC_soun     GST_MAKE_FOURCC('s','o','u','n')
</MACRO>
<MACRO>
<NAME>FOURCC_sowt</NAME>
#define FOURCC_sowt     GST_MAKE_FOURCC('s','o','w','t')
</MACRO>
<MACRO>
<NAME>FOURCC_stbl</NAME>
#define FOURCC_stbl     GST_MAKE_FOURCC('s','t','b','l')
</MACRO>
<MACRO>
<NAME>FOURCC_stco</NAME>
#define FOURCC_stco     GST_MAKE_FOURCC('s','t','c','o')
</MACRO>
<MACRO>
<NAME>FOURCC_stpp</NAME>
#define FOURCC_stpp     GST_MAKE_FOURCC('s','t','p','p')
</MACRO>
<MACRO>
<NAME>FOURCC_stps</NAME>
#define FOURCC_stps     GST_MAKE_FOURCC('s','t','p','s')
</MACRO>
<MACRO>
<NAME>FOURCC_strf</NAME>
#define FOURCC_strf     GST_MAKE_FOURCC('s','t','r','f')
</MACRO>
<MACRO>
<NAME>FOURCC_strm</NAME>
#define FOURCC_strm     GST_MAKE_FOURCC('s','t','r','m')
</MACRO>
<MACRO>
<NAME>FOURCC_stsc</NAME>
#define FOURCC_stsc     GST_MAKE_FOURCC('s','t','s','c')
</MACRO>
<MACRO>
<NAME>FOURCC_stsd</NAME>
#define FOURCC_stsd     GST_MAKE_FOURCC('s','t','s','d')
</MACRO>
<MACRO>
<NAME>FOURCC_stss</NAME>
#define FOURCC_stss     GST_MAKE_FOURCC('s','t','s','s')
</MACRO>
<MACRO>
<NAME>FOURCC_stsz</NAME>
#define FOURCC_stsz     GST_MAKE_FOURCC('s','t','s','z')
</MACRO>
<MACRO>
<NAME>FOURCC_stts</NAME>
#define FOURCC_stts     GST_MAKE_FOURCC('s','t','t','s')
</MACRO>
<MACRO>
<NAME>FOURCC_styp</NAME>
#define FOURCC_styp     GST_MAKE_FOURCC('s','t','y','p')
</MACRO>
<MACRO>
<NAME>FOURCC_subp</NAME>
#define FOURCC_subp     GST_MAKE_FOURCC('s','u','b','p')
</MACRO>
<MACRO>
<NAME>FOURCC_subt</NAME>
#define FOURCC_subt     GST_MAKE_FOURCC('s','u','b','t')
</MACRO>
<MACRO>
<NAME>FOURCC_text</NAME>
#define FOURCC_text     GST_MAKE_FOURCC('t','e','x','t')
</MACRO>
<MACRO>
<NAME>FOURCC_tcmi</NAME>
#define FOURCC_tcmi     GST_MAKE_FOURCC('t','c','m','i')
</MACRO>
<MACRO>
<NAME>FOURCC_tkhd</NAME>
#define FOURCC_tkhd     GST_MAKE_FOURCC('t','k','h','d')
</MACRO>
<MACRO>
<NAME>FOURCC_tmcd</NAME>
#define FOURCC_tmcd     GST_MAKE_FOURCC('t','m','c','d')
</MACRO>
<MACRO>
<NAME>FOURCC_tmpo</NAME>
#define FOURCC_tmpo     GST_MAKE_FOURCC('t','m','p','o')
</MACRO>
<MACRO>
<NAME>FOURCC_trak</NAME>
#define FOURCC_trak     GST_MAKE_FOURCC('t','r','a','k')
</MACRO>
<MACRO>
<NAME>FOURCC_tref</NAME>
#define FOURCC_tref     GST_MAKE_FOURCC('t','r','e','f')
</MACRO>
<MACRO>
<NAME>FOURCC_trkn</NAME>
#define FOURCC_trkn     GST_MAKE_FOURCC('t','r','k','n')
</MACRO>
<MACRO>
<NAME>FOURCC_tven</NAME>
#define FOURCC_tven     GST_MAKE_FOURCC('t','v','e','n')
</MACRO>
<MACRO>
<NAME>FOURCC_tves</NAME>
#define FOURCC_tves     GST_MAKE_FOURCC('t','v','e','s')
</MACRO>
<MACRO>
<NAME>FOURCC_tvsh</NAME>
#define FOURCC_tvsh     GST_MAKE_FOURCC('t','v','s','h')
</MACRO>
<MACRO>
<NAME>FOURCC_tvsn</NAME>
#define FOURCC_tvsn     GST_MAKE_FOURCC('t','v','s','n')
</MACRO>
<MACRO>
<NAME>FOURCC_twos</NAME>
#define FOURCC_twos     GST_MAKE_FOURCC('t','w','o','s')
</MACRO>
<MACRO>
<NAME>FOURCC_tx3g</NAME>
#define FOURCC_tx3g     GST_MAKE_FOURCC('t','x','3','g')
</MACRO>
<MACRO>
<NAME>FOURCC_udta</NAME>
#define FOURCC_udta     GST_MAKE_FOURCC('u','d','t','a')
</MACRO>
<MACRO>
<NAME>FOURCC_ulaw</NAME>
#define FOURCC_ulaw     GST_MAKE_FOURCC('u','l','a','w')
</MACRO>
<MACRO>
<NAME>FOURCC_url_</NAME>
#define FOURCC_url_     GST_MAKE_FOURCC('u','r','l',' ')
</MACRO>
<MACRO>
<NAME>FOURCC_uuid</NAME>
#define FOURCC_uuid     GST_MAKE_FOURCC('u','u','i','d')
</MACRO>
<MACRO>
<NAME>FOURCC_v210</NAME>
#define FOURCC_v210     GST_MAKE_FOURCC('v','2','1','0')
</MACRO>
<MACRO>
<NAME>FOURCC_vc_1</NAME>
#define FOURCC_vc_1     GST_MAKE_FOURCC('v','c','-','1')
</MACRO>
<MACRO>
<NAME>FOURCC_vide</NAME>
#define FOURCC_vide     GST_MAKE_FOURCC('v','i','d','e')
</MACRO>
<MACRO>
<NAME>FOURCC_vmhd</NAME>
#define FOURCC_vmhd     GST_MAKE_FOURCC('v','m','h','d')
</MACRO>
<MACRO>
<NAME>FOURCC_xvid</NAME>
#define FOURCC_xvid     GST_MAKE_FOURCC('x','v','i','d')
</MACRO>
<MACRO>
<NAME>FOURCC_wave</NAME>
#define FOURCC_wave     GST_MAKE_FOURCC('w','a','v','e')
</MACRO>
<MACRO>
<NAME>FOURCC_wide</NAME>
#define FOURCC_wide     GST_MAKE_FOURCC('w','i','d','e')
</MACRO>
<MACRO>
<NAME>FOURCC_zlib</NAME>
#define FOURCC_zlib     GST_MAKE_FOURCC('z','l','i','b')
</MACRO>
<MACRO>
<NAME>FOURCC_cfhd</NAME>
#define FOURCC_cfhd     GST_MAKE_FOURCC('C','F','H','D')
</MACRO>
<MACRO>
<NAME>FOURCC_ap4x</NAME>
#define FOURCC_ap4x     GST_MAKE_FOURCC('a','p','4','x')
</MACRO>
<MACRO>
<NAME>FOURCC_ap4h</NAME>
#define FOURCC_ap4h     GST_MAKE_FOURCC('a','p','4','h')
</MACRO>
<MACRO>
<NAME>FOURCC_apch</NAME>
#define FOURCC_apch     GST_MAKE_FOURCC('a','p','c','h')
</MACRO>
<MACRO>
<NAME>FOURCC_apcn</NAME>
#define FOURCC_apcn     GST_MAKE_FOURCC('a','p','c','n')
</MACRO>
<MACRO>
<NAME>FOURCC_apco</NAME>
#define FOURCC_apco     GST_MAKE_FOURCC('a','p','c','o')
</MACRO>
<MACRO>
<NAME>FOURCC_apcs</NAME>
#define FOURCC_apcs     GST_MAKE_FOURCC('a','p','c','s')
</MACRO>
<MACRO>
<NAME>FOURCC_m1v</NAME>
#define FOURCC_m1v      GST_MAKE_FOURCC('m','1','v',' ')
</MACRO>
<MACRO>
<NAME>FOURCC_vivo</NAME>
#define FOURCC_vivo     GST_MAKE_FOURCC('v','i','v','o')
</MACRO>
<MACRO>
<NAME>FOURCC_saiz</NAME>
#define FOURCC_saiz     GST_MAKE_FOURCC('s','a','i','z')
</MACRO>
<MACRO>
<NAME>FOURCC_saio</NAME>
#define FOURCC_saio     GST_MAKE_FOURCC('s','a','i','o')
</MACRO>
<MACRO>
<NAME>FOURCC_3gg6</NAME>
#define FOURCC_3gg6     GST_MAKE_FOURCC('3','g','g','6')
</MACRO>
<MACRO>
<NAME>FOURCC_3gg7</NAME>
#define FOURCC_3gg7     GST_MAKE_FOURCC('3','g','g','7')
</MACRO>
<MACRO>
<NAME>FOURCC_3gp4</NAME>
#define FOURCC_3gp4     GST_MAKE_FOURCC('3','g','p','4')
</MACRO>
<MACRO>
<NAME>FOURCC_3gp6</NAME>
#define FOURCC_3gp6     GST_MAKE_FOURCC('3','g','p','6')
</MACRO>
<MACRO>
<NAME>FOURCC_3gr6</NAME>
#define FOURCC_3gr6     GST_MAKE_FOURCC('3','g','r','6')
</MACRO>
<MACRO>
<NAME>FOURCC_3g__</NAME>
#define FOURCC_3g__     GST_MAKE_FOURCC('3','g',0,0)
</MACRO>
<MACRO>
<NAME>FOURCC_isml</NAME>
#define FOURCC_isml     GST_MAKE_FOURCC('i','s','m','l')
</MACRO>
<MACRO>
<NAME>FOURCC_iso2</NAME>
#define FOURCC_iso2     GST_MAKE_FOURCC('i','s','o','2')
</MACRO>
<MACRO>
<NAME>FOURCC_isom</NAME>
#define FOURCC_isom     GST_MAKE_FOURCC('i','s','o','m')
</MACRO>
<MACRO>
<NAME>FOURCC_mp41</NAME>
#define FOURCC_mp41     GST_MAKE_FOURCC('m','p','4','1')
</MACRO>
<MACRO>
<NAME>FOURCC_mp42</NAME>
#define FOURCC_mp42     GST_MAKE_FOURCC('m','p','4','2')
</MACRO>
<MACRO>
<NAME>FOURCC_piff</NAME>
#define FOURCC_piff     GST_MAKE_FOURCC('p','i','f','f')
</MACRO>
<MACRO>
<NAME>FOURCC_titl</NAME>
#define FOURCC_titl     GST_MAKE_FOURCC('t','i','t','l')
</MACRO>
<MACRO>
<NAME>FOURCC_SEQH</NAME>
#define FOURCC_SEQH     GST_MAKE_FOURCC('S','E','Q','H')
</MACRO>
<MACRO>
<NAME>FOURCC_SMI_</NAME>
#define FOURCC_SMI_     GST_MAKE_FOURCC('S','M','I',' ')
</MACRO>
<MACRO>
<NAME>FOURCC_albm</NAME>
#define FOURCC_albm     GST_MAKE_FOURCC('a','l','b','m')
</MACRO>
<MACRO>
<NAME>FOURCC_auth</NAME>
#define FOURCC_auth     GST_MAKE_FOURCC('a','u','t','h')
</MACRO>
<MACRO>
<NAME>FOURCC_clsf</NAME>
#define FOURCC_clsf     GST_MAKE_FOURCC('c','l','s','f')
</MACRO>
<MACRO>
<NAME>FOURCC_dscp</NAME>
#define FOURCC_dscp     GST_MAKE_FOURCC('d','s','c','p')
</MACRO>
<MACRO>
<NAME>FOURCC_loci</NAME>
#define FOURCC_loci     GST_MAKE_FOURCC('l','o','c','i')
</MACRO>
<MACRO>
<NAME>FOURCC_perf</NAME>
#define FOURCC_perf     GST_MAKE_FOURCC('p','e','r','f')
</MACRO>
<MACRO>
<NAME>FOURCC_rtng</NAME>
#define FOURCC_rtng     GST_MAKE_FOURCC('r','t','n','g')
</MACRO>
<MACRO>
<NAME>FOURCC_yrrc</NAME>
#define FOURCC_yrrc     GST_MAKE_FOURCC('y','r','r','c')
</MACRO>
<MACRO>
<NAME>FOURCC_ID32</NAME>
#define FOURCC_ID32     GST_MAKE_FOURCC('I', 'D','3','2')
</MACRO>
<MACRO>
<NAME>FOURCC_cdef</NAME>
#define FOURCC_cdef     GST_MAKE_FOURCC('c','d','e','f')
</MACRO>
<MACRO>
<NAME>FOURCC_cmap</NAME>
#define FOURCC_cmap     GST_MAKE_FOURCC('c','m','a','p')
</MACRO>
<MACRO>
<NAME>FOURCC_ihdr</NAME>
#define FOURCC_ihdr     GST_MAKE_FOURCC('i','h','d','r')
</MACRO>
<MACRO>
<NAME>FOURCC_jp2h</NAME>
#define FOURCC_jp2h     GST_MAKE_FOURCC('j','p','2','h')
</MACRO>
<MACRO>
<NAME>FOURCC_jp2x</NAME>
#define FOURCC_jp2x     GST_MAKE_FOURCC('j','p','2','x')
</MACRO>
<MACRO>
<NAME>FOURCC_mjp2</NAME>
#define FOURCC_mjp2     GST_MAKE_FOURCC('m','j','p','2')
</MACRO>
<MACRO>
<NAME>FOURCC_mhdr</NAME>
#define FOURCC_mhdr     GST_MAKE_FOURCC('m','h','d','r')
</MACRO>
<MACRO>
<NAME>FOURCC_btrt</NAME>
#define FOURCC_btrt     GST_MAKE_FOURCC('b','t','r','t')
</MACRO>
<MACRO>
<NAME>FOURCC_mehd</NAME>
#define FOURCC_mehd     GST_MAKE_FOURCC('m','e','h','d')
</MACRO>
<MACRO>
<NAME>FOURCC_mfhd</NAME>
#define FOURCC_mfhd     GST_MAKE_FOURCC('m','f','h','d')
</MACRO>
<MACRO>
<NAME>FOURCC_mfra</NAME>
#define FOURCC_mfra     GST_MAKE_FOURCC('m','f','r','a')
</MACRO>
<MACRO>
<NAME>FOURCC_mfro</NAME>
#define FOURCC_mfro     GST_MAKE_FOURCC('m','f','r','o')
</MACRO>
<MACRO>
<NAME>FOURCC_moof</NAME>
#define FOURCC_moof     GST_MAKE_FOURCC('m','o','o','f')
</MACRO>
<MACRO>
<NAME>FOURCC_mvex</NAME>
#define FOURCC_mvex     GST_MAKE_FOURCC('m','v','e','x')
</MACRO>
<MACRO>
<NAME>FOURCC_mvhd</NAME>
#define FOURCC_mvhd     GST_MAKE_FOURCC('m','v','h','d')
</MACRO>
<MACRO>
<NAME>FOURCC_ovc1</NAME>
#define FOURCC_ovc1     GST_MAKE_FOURCC('o','v','c','1')
</MACRO>
<MACRO>
<NAME>FOURCC_owma</NAME>
#define FOURCC_owma     GST_MAKE_FOURCC('o','w','m','a')
</MACRO>
<MACRO>
<NAME>FOURCC_sdtp</NAME>
#define FOURCC_sdtp     GST_MAKE_FOURCC('s','d','t','p')
</MACRO>
<MACRO>
<NAME>FOURCC_tfhd</NAME>
#define FOURCC_tfhd     GST_MAKE_FOURCC('t','f','h','d')
</MACRO>
<MACRO>
<NAME>FOURCC_tfra</NAME>
#define FOURCC_tfra     GST_MAKE_FOURCC('t','f','r','a')
</MACRO>
<MACRO>
<NAME>FOURCC_traf</NAME>
#define FOURCC_traf     GST_MAKE_FOURCC('t','r','a','f')
</MACRO>
<MACRO>
<NAME>FOURCC_trex</NAME>
#define FOURCC_trex     GST_MAKE_FOURCC('t','r','e','x')
</MACRO>
<MACRO>
<NAME>FOURCC_trun</NAME>
#define FOURCC_trun     GST_MAKE_FOURCC('t','r','u','n')
</MACRO>
<MACRO>
<NAME>FOURCC_wma_</NAME>
#define FOURCC_wma_     GST_MAKE_FOURCC('w','m','a',' ')
</MACRO>
<MACRO>
<NAME>FOURCC_tfdt</NAME>
#define FOURCC_tfdt     GST_MAKE_FOURCC('t','f','d','t')
</MACRO>
<MACRO>
<NAME>FOURCC_XdxT</NAME>
#define FOURCC_XdxT     GST_MAKE_FOURCC('X','d','x','T')
</MACRO>
<MACRO>
<NAME>FOURCC_XiTh</NAME>
#define FOURCC_XiTh     GST_MAKE_FOURCC('X','i','T','h')
</MACRO>
<MACRO>
<NAME>FOURCC_tCtC</NAME>
#define FOURCC_tCtC     GST_MAKE_FOURCC('t','C','t','C')
</MACRO>
<MACRO>
<NAME>FOURCC_tCtH</NAME>
#define FOURCC_tCtH     GST_MAKE_FOURCC('t','C','t','H')
</MACRO>
<MACRO>
<NAME>FOURCC_tCt_</NAME>
#define FOURCC_tCt_     GST_MAKE_FOURCC('t','C','t','#')
</MACRO>
<MACRO>
<NAME>FOURCC__cmt</NAME>
#define FOURCC__cmt     GST_MAKE_FOURCC(0xa9, 'c','m','t')
</MACRO>
<MACRO>
<NAME>FOURCC__mak</NAME>
#define FOURCC__mak     GST_MAKE_FOURCC(0xa9, 'm','a','k')
</MACRO>
<MACRO>
<NAME>FOURCC__mod</NAME>
#define FOURCC__mod     GST_MAKE_FOURCC(0xa9, 'm','o','d')
</MACRO>
<MACRO>
<NAME>FOURCC__swr</NAME>
#define FOURCC__swr     GST_MAKE_FOURCC(0xa9, 's','w','r')
</MACRO>
<MACRO>
<NAME>FOURCC_chap</NAME>
#define FOURCC_chap     GST_MAKE_FOURCC('c','h','a','p')
</MACRO>
<MACRO>
<NAME>MS_WAVE_FOURCC</NAME>
#define MS_WAVE_FOURCC(codecid)  GST_MAKE_FOURCC( \
        'm', 's', ((codecid)>>8)&0xff, ((codecid)&0xff))
</MACRO>
<MACRO>
<NAME>FOURCC_ss01</NAME>
#define FOURCC_ss01     GST_MAKE_FOURCC('s','s','0','1')
</MACRO>
<MACRO>
<NAME>FOURCC_ss02</NAME>
#define FOURCC_ss02     GST_MAKE_FOURCC('s','s','0','2')
</MACRO>
<MACRO>
<NAME>FOURCC_svmi</NAME>
#define FOURCC_svmi     GST_MAKE_FOURCC('s','v','m','i')
</MACRO>
<MACRO>
<NAME>FOURCC_scdi</NAME>
#define FOURCC_scdi     GST_MAKE_FOURCC('s','c','d','i')
</MACRO>
<MACRO>
<NAME>FOURCC_encv</NAME>
#define FOURCC_encv     GST_MAKE_FOURCC('e','n','c','v')
</MACRO>
<MACRO>
<NAME>FOURCC_enca</NAME>
#define FOURCC_enca     GST_MAKE_FOURCC('e','n','c','a')
</MACRO>
<MACRO>
<NAME>FOURCC_enct</NAME>
#define FOURCC_enct     GST_MAKE_FOURCC('e','n','c','t')
</MACRO>
<MACRO>
<NAME>FOURCC_encs</NAME>
#define FOURCC_encs     GST_MAKE_FOURCC('e','n','c','s')
</MACRO>
<MACRO>
<NAME>FOURCC_sinf</NAME>
#define FOURCC_sinf     GST_MAKE_FOURCC('s','i','n','f')
</MACRO>
<MACRO>
<NAME>FOURCC_schm</NAME>
#define FOURCC_schm     GST_MAKE_FOURCC('s','c','h','m')
</MACRO>
<MACRO>
<NAME>FOURCC_schi</NAME>
#define FOURCC_schi     GST_MAKE_FOURCC('s','c','h','i')
</MACRO>
<MACRO>
<NAME>FOURCC_pssh</NAME>
#define FOURCC_pssh     GST_MAKE_FOURCC('p','s','s','h')
</MACRO>
<MACRO>
<NAME>FOURCC_tenc</NAME>
#define FOURCC_tenc     GST_MAKE_FOURCC('t','e','n','c')
</MACRO>
<MACRO>
<NAME>FOURCC_cenc</NAME>
#define FOURCC_cenc     GST_MAKE_FOURCC('c','e','n','c')
</MACRO>
<USER_FUNCTION>
<NAME>BlendFunction</NAME>
<RETURNS>void </RETURNS>
GstVideoFrame *srcframe, gint xpos, gint ypos, gdouble src_alpha, GstVideoFrame * destframe
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>FillCheckerFunction</NAME>
<RETURNS>void </RETURNS>
GstVideoFrame * frame
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>FillColorFunction</NAME>
<RETURNS>void </RETURNS>
GstVideoFrame * frame, gint c1, gint c2, gint c3
</USER_FUNCTION>
<VARIABLE>
<NAME>gst_video_mixer_blend_argb</NAME>
extern BlendFunction gst_video_mixer_blend_argb;
</VARIABLE>
<VARIABLE>
<NAME>gst_video_mixer_blend_bgra</NAME>
extern BlendFunction gst_video_mixer_blend_bgra;
</VARIABLE>
<MACRO>
<NAME>gst_video_mixer_blend_ayuv</NAME>
#define gst_video_mixer_blend_ayuv gst_video_mixer_blend_argb
</MACRO>
<MACRO>
<NAME>gst_video_mixer_blend_abgr</NAME>
#define gst_video_mixer_blend_abgr gst_video_mixer_blend_argb
</MACRO>
<MACRO>
<NAME>gst_video_mixer_blend_rgba</NAME>
#define gst_video_mixer_blend_rgba gst_video_mixer_blend_bgra
</MACRO>
<VARIABLE>
<NAME>gst_video_mixer_overlay_argb</NAME>
extern BlendFunction gst_video_mixer_overlay_argb;
</VARIABLE>
<VARIABLE>
<NAME>gst_video_mixer_overlay_bgra</NAME>
extern BlendFunction gst_video_mixer_overlay_bgra;
</VARIABLE>
<MACRO>
<NAME>gst_video_mixer_overlay_ayuv</NAME>
#define gst_video_mixer_overlay_ayuv gst_video_mixer_overlay_argb
</MACRO>
<MACRO>
<NAME>gst_video_mixer_overlay_abgr</NAME>
#define gst_video_mixer_overlay_abgr gst_video_mixer_overlay_argb
</MACRO>
<MACRO>
<NAME>gst_video_mixer_overlay_rgba</NAME>
#define gst_video_mixer_overlay_rgba gst_video_mixer_overlay_bgra
</MACRO>
<VARIABLE>
<NAME>gst_video_mixer_blend_i420</NAME>
extern BlendFunction gst_video_mixer_blend_i420;
</VARIABLE>
<MACRO>
<NAME>gst_video_mixer_blend_yv12</NAME>
#define gst_video_mixer_blend_yv12 gst_video_mixer_blend_i420
</MACRO>
<VARIABLE>
<NAME>gst_video_mixer_blend_nv12</NAME>
extern BlendFunction gst_video_mixer_blend_nv12;
</VARIABLE>
<VARIABLE>
<NAME>gst_video_mixer_blend_nv21</NAME>
extern BlendFunction gst_video_mixer_blend_nv21;
</VARIABLE>
<VARIABLE>
<NAME>gst_video_mixer_blend_y41b</NAME>
extern BlendFunction gst_video_mixer_blend_y41b;
</VARIABLE>
<VARIABLE>
<NAME>gst_video_mixer_blend_y42b</NAME>
extern BlendFunction gst_video_mixer_blend_y42b;
</VARIABLE>
<VARIABLE>
<NAME>gst_video_mixer_blend_y444</NAME>
extern BlendFunction gst_video_mixer_blend_y444;
</VARIABLE>
<VARIABLE>
<NAME>gst_video_mixer_blend_rgb</NAME>
extern BlendFunction gst_video_mixer_blend_rgb;
</VARIABLE>
<MACRO>
<NAME>gst_video_mixer_blend_bgr</NAME>
#define gst_video_mixer_blend_bgr gst_video_mixer_blend_rgb
</MACRO>
<VARIABLE>
<NAME>gst_video_mixer_blend_rgbx</NAME>
extern BlendFunction gst_video_mixer_blend_rgbx;
</VARIABLE>
<MACRO>
<NAME>gst_video_mixer_blend_bgrx</NAME>
#define gst_video_mixer_blend_bgrx gst_video_mixer_blend_rgbx
</MACRO>
<MACRO>
<NAME>gst_video_mixer_blend_xrgb</NAME>
#define gst_video_mixer_blend_xrgb gst_video_mixer_blend_rgbx
</MACRO>
<MACRO>
<NAME>gst_video_mixer_blend_xbgr</NAME>
#define gst_video_mixer_blend_xbgr gst_video_mixer_blend_rgbx
</MACRO>
<VARIABLE>
<NAME>gst_video_mixer_blend_yuy2</NAME>
extern BlendFunction gst_video_mixer_blend_yuy2;
</VARIABLE>
<MACRO>
<NAME>gst_video_mixer_blend_uyvy</NAME>
#define gst_video_mixer_blend_uyvy gst_video_mixer_blend_yuy2;
</MACRO>
<MACRO>
<NAME>gst_video_mixer_blend_yvyu</NAME>
#define gst_video_mixer_blend_yvyu gst_video_mixer_blend_yuy2;
</MACRO>
<VARIABLE>
<NAME>gst_video_mixer_fill_checker_argb</NAME>
extern FillCheckerFunction gst_video_mixer_fill_checker_argb;
</VARIABLE>
<MACRO>
<NAME>gst_video_mixer_fill_checker_abgr</NAME>
#define gst_video_mixer_fill_checker_abgr gst_video_mixer_fill_checker_argb
</MACRO>
<VARIABLE>
<NAME>gst_video_mixer_fill_checker_bgra</NAME>
extern FillCheckerFunction gst_video_mixer_fill_checker_bgra;
</VARIABLE>
<MACRO>
<NAME>gst_video_mixer_fill_checker_rgba</NAME>
#define gst_video_mixer_fill_checker_rgba gst_video_mixer_fill_checker_bgra
</MACRO>
<VARIABLE>
<NAME>gst_video_mixer_fill_checker_ayuv</NAME>
extern FillCheckerFunction gst_video_mixer_fill_checker_ayuv;
</VARIABLE>
<VARIABLE>
<NAME>gst_video_mixer_fill_checker_i420</NAME>
extern FillCheckerFunction gst_video_mixer_fill_checker_i420;
</VARIABLE>
<MACRO>
<NAME>gst_video_mixer_fill_checker_yv12</NAME>
#define gst_video_mixer_fill_checker_yv12 gst_video_mixer_fill_checker_i420
</MACRO>
<VARIABLE>
<NAME>gst_video_mixer_fill_checker_nv12</NAME>
extern FillCheckerFunction gst_video_mixer_fill_checker_nv12;
</VARIABLE>
<VARIABLE>
<NAME>gst_video_mixer_fill_checker_nv21</NAME>
extern FillCheckerFunction gst_video_mixer_fill_checker_nv21;
</VARIABLE>
<VARIABLE>
<NAME>gst_video_mixer_fill_checker_y41b</NAME>
extern FillCheckerFunction gst_video_mixer_fill_checker_y41b;
</VARIABLE>
<VARIABLE>
<NAME>gst_video_mixer_fill_checker_y42b</NAME>
extern FillCheckerFunction gst_video_mixer_fill_checker_y42b;
</VARIABLE>
<VARIABLE>
<NAME>gst_video_mixer_fill_checker_y444</NAME>
extern FillCheckerFunction gst_video_mixer_fill_checker_y444;
</VARIABLE>
<VARIABLE>
<NAME>gst_video_mixer_fill_checker_rgb</NAME>
extern FillCheckerFunction gst_video_mixer_fill_checker_rgb;
</VARIABLE>
<MACRO>
<NAME>gst_video_mixer_fill_checker_bgr</NAME>
#define gst_video_mixer_fill_checker_bgr gst_video_mixer_fill_checker_rgb
</MACRO>
<VARIABLE>
<NAME>gst_video_mixer_fill_checker_rgbx</NAME>
extern FillCheckerFunction gst_video_mixer_fill_checker_rgbx;
</VARIABLE>
<MACRO>
<NAME>gst_video_mixer_fill_checker_bgrx</NAME>
#define gst_video_mixer_fill_checker_bgrx gst_video_mixer_fill_checker_rgbx
</MACRO>
<MACRO>
<NAME>gst_video_mixer_fill_checker_xrgb</NAME>
#define gst_video_mixer_fill_checker_xrgb gst_video_mixer_fill_checker_rgbx
</MACRO>
<MACRO>
<NAME>gst_video_mixer_fill_checker_xbgr</NAME>
#define gst_video_mixer_fill_checker_xbgr gst_video_mixer_fill_checker_rgbx
</MACRO>
<VARIABLE>
<NAME>gst_video_mixer_fill_checker_yuy2</NAME>
extern FillCheckerFunction gst_video_mixer_fill_checker_yuy2;
</VARIABLE>
<MACRO>
<NAME>gst_video_mixer_fill_checker_yvyu</NAME>
#define gst_video_mixer_fill_checker_yvyu gst_video_mixer_fill_checker_yuy2;
</MACRO>
<VARIABLE>
<NAME>gst_video_mixer_fill_checker_uyvy</NAME>
extern FillCheckerFunction gst_video_mixer_fill_checker_uyvy;
</VARIABLE>
<VARIABLE>
<NAME>gst_video_mixer_fill_color_argb</NAME>
extern FillColorFunction gst_video_mixer_fill_color_argb;
</VARIABLE>
<VARIABLE>
<NAME>gst_video_mixer_fill_color_abgr</NAME>
extern FillColorFunction gst_video_mixer_fill_color_abgr;
</VARIABLE>
<VARIABLE>
<NAME>gst_video_mixer_fill_color_bgra</NAME>
extern FillColorFunction gst_video_mixer_fill_color_bgra;
</VARIABLE>
<VARIABLE>
<NAME>gst_video_mixer_fill_color_rgba</NAME>
extern FillColorFunction gst_video_mixer_fill_color_rgba;
</VARIABLE>
<VARIABLE>
<NAME>gst_video_mixer_fill_color_ayuv</NAME>
extern FillColorFunction gst_video_mixer_fill_color_ayuv;
</VARIABLE>
<VARIABLE>
<NAME>gst_video_mixer_fill_color_i420</NAME>
extern FillColorFunction gst_video_mixer_fill_color_i420;
</VARIABLE>
<VARIABLE>
<NAME>gst_video_mixer_fill_color_yv12</NAME>
extern FillColorFunction gst_video_mixer_fill_color_yv12;
</VARIABLE>
<VARIABLE>
<NAME>gst_video_mixer_fill_color_nv12</NAME>
extern FillColorFunction gst_video_mixer_fill_color_nv12;
</VARIABLE>
<MACRO>
<NAME>gst_video_mixer_fill_color_nv21</NAME>
#define gst_video_mixer_fill_color_nv21 gst_video_mixer_fill_color_nv12;
</MACRO>
<VARIABLE>
<NAME>gst_video_mixer_fill_color_y41b</NAME>
extern FillColorFunction gst_video_mixer_fill_color_y41b;
</VARIABLE>
<VARIABLE>
<NAME>gst_video_mixer_fill_color_y42b</NAME>
extern FillColorFunction gst_video_mixer_fill_color_y42b;
</VARIABLE>
<VARIABLE>
<NAME>gst_video_mixer_fill_color_y444</NAME>
extern FillColorFunction gst_video_mixer_fill_color_y444;
</VARIABLE>
<VARIABLE>
<NAME>gst_video_mixer_fill_color_rgb</NAME>
extern FillColorFunction gst_video_mixer_fill_color_rgb;
</VARIABLE>
<VARIABLE>
<NAME>gst_video_mixer_fill_color_bgr</NAME>
extern FillColorFunction gst_video_mixer_fill_color_bgr;
</VARIABLE>
<VARIABLE>
<NAME>gst_video_mixer_fill_color_xrgb</NAME>
extern FillColorFunction gst_video_mixer_fill_color_xrgb;
</VARIABLE>
<VARIABLE>
<NAME>gst_video_mixer_fill_color_xbgr</NAME>
extern FillColorFunction gst_video_mixer_fill_color_xbgr;
</VARIABLE>
<VARIABLE>
<NAME>gst_video_mixer_fill_color_rgbx</NAME>
extern FillColorFunction gst_video_mixer_fill_color_rgbx;
</VARIABLE>
<VARIABLE>
<NAME>gst_video_mixer_fill_color_bgrx</NAME>
extern FillColorFunction gst_video_mixer_fill_color_bgrx;
</VARIABLE>
<VARIABLE>
<NAME>gst_video_mixer_fill_color_yuy2</NAME>
extern FillColorFunction gst_video_mixer_fill_color_yuy2;
</VARIABLE>
<VARIABLE>
<NAME>gst_video_mixer_fill_color_yvyu</NAME>
extern FillColorFunction gst_video_mixer_fill_color_yvyu;
</VARIABLE>
<VARIABLE>
<NAME>gst_video_mixer_fill_color_uyvy</NAME>
extern FillColorFunction gst_video_mixer_fill_color_uyvy;
</VARIABLE>
<FUNCTION>
<NAME>gst_video_mixer_init_blend</NAME>
<RETURNS>void  </RETURNS>
void
</FUNCTION>
<TYPEDEF>
<NAME>orc_int8</NAME>
typedef int8_t orc_int8;
</TYPEDEF>
<TYPEDEF>
<NAME>orc_int16</NAME>
typedef int16_t orc_int16;
</TYPEDEF>
<TYPEDEF>
<NAME>orc_int32</NAME>
typedef int32_t orc_int32;
</TYPEDEF>
<TYPEDEF>
<NAME>orc_int64</NAME>
typedef int64_t orc_int64;
</TYPEDEF>
<TYPEDEF>
<NAME>orc_uint8</NAME>
typedef uint8_t orc_uint8;
</TYPEDEF>
<TYPEDEF>
<NAME>orc_uint16</NAME>
typedef uint16_t orc_uint16;
</TYPEDEF>
<TYPEDEF>
<NAME>orc_uint32</NAME>
typedef uint32_t orc_uint32;
</TYPEDEF>
<TYPEDEF>
<NAME>orc_uint64</NAME>
typedef uint64_t orc_uint64;
</TYPEDEF>
<MACRO>
<NAME>ORC_UINT64_C</NAME>
#define ORC_UINT64_C(x) UINT64_C(x)
</MACRO>
<MACRO>
<NAME>inline</NAME>
#define inline __inline
</MACRO>
<TYPEDEF>
<NAME>orc_int8</NAME>
typedef int8_t orc_int8;
</TYPEDEF>
<TYPEDEF>
<NAME>orc_int16</NAME>
typedef int16_t orc_int16;
</TYPEDEF>
<TYPEDEF>
<NAME>orc_int32</NAME>
typedef int32_t orc_int32;
</TYPEDEF>
<TYPEDEF>
<NAME>orc_int64</NAME>
typedef int64_t orc_int64;
</TYPEDEF>
<TYPEDEF>
<NAME>orc_uint8</NAME>
typedef uint8_t orc_uint8;
</TYPEDEF>
<TYPEDEF>
<NAME>orc_uint16</NAME>
typedef uint16_t orc_uint16;
</TYPEDEF>
<TYPEDEF>
<NAME>orc_uint32</NAME>
typedef uint32_t orc_uint32;
</TYPEDEF>
<TYPEDEF>
<NAME>orc_uint64</NAME>
typedef uint64_t orc_uint64;
</TYPEDEF>
<MACRO>
<NAME>ORC_UINT64_C</NAME>
#define ORC_UINT64_C(x) UINT64_C(x)
</MACRO>
<MACRO>
<NAME>inline</NAME>
#define inline __inline
</MACRO>
<STRUCT>
<NAME>gst_riff_avih</NAME>
typedef struct _gst_riff_avih {
  guint32 us_frame;          /* microsec per frame */
  guint32 max_bps;           /* byte/s overall */
  guint32 pad_gran;          /* pad_granularity */
  guint32 flags;
/* flags values */
#define GST_RIFF_AVIH_HASINDEX       0x00000010 /* has idx1 chunk */
#define GST_RIFF_AVIH_MUSTUSEINDEX   0x00000020 /* must use idx1 chunk to determine order */
#define GST_RIFF_AVIH_ISINTERLEAVED  0x00000100 /* AVI file is interleaved */
#define GST_RIFF_AVIH_TRUSTCKTYPE    0x00000800 /* Use CKType to find key frames */
#define GST_RIFF_AVIH_WASCAPTUREFILE 0x00010000 /* specially allocated used for capturing real time video */
#define GST_RIFF_AVIH_COPYRIGHTED    0x00020000 /* contains copyrighted data */
  guint32 tot_frames;        /* # of frames (all) */
  guint32 init_frames;       /* initial frames (???) */
  guint32 streams;
  guint32 bufsize;           /* suggested buffer size */
  guint32 width;
  guint32 height;
  guint32 scale;
  guint32 rate;
  guint32 start;
  guint32 length;
} gst_riff_avih;
</STRUCT>
<MACRO>
<NAME>GST_RIFF_TAG_vprp</NAME>
#define GST_RIFF_TAG_vprp GST_MAKE_FOURCC ('v','p','r','p')
</MACRO>
<MACRO>
<NAME>GST_RIFF_DXSB</NAME>
#define GST_RIFF_DXSB GST_MAKE_FOURCC ('D','X','S','B')
</MACRO>
<MACRO>
<NAME>GST_RIFF_VPRP_VIDEO_FIELDS</NAME>
#define GST_RIFF_VPRP_VIDEO_FIELDS        (2)
</MACRO>
<STRUCT>
<NAME>gst_riff_vprp_video_field_desc</NAME>
typedef struct _gst_riff_vprp_video_field_desc {
  guint32 compressed_bm_height;
  guint32 compressed_bm_width;
  guint32 valid_bm_height;
  guint32 valid_bm_width;
  guint32 valid_bm_x_offset;
  guint32 valid_bm_y_offset;
  guint32 video_x_t_offset;
  guint32 video_y_start;
} gst_riff_vprp_video_field_desc;
</STRUCT>
<STRUCT>
<NAME>gst_riff_vprp</NAME>
typedef struct _gst_riff_vprp {
  guint32 format_token;      /* whether fields defined by standard */
  guint32 standard;          /* video display standard, UNKNOWN, PAL, etc */
  guint32 vert_rate;         /* vertical refresh rate */
  guint32 hor_t_total;       /* width */
  guint32 vert_lines;        /* height */
  guint32 aspect;            /* aspect ratio high word:low word */
  guint32 width;             /* active width */
  guint32 height;            /* active height */
  guint32 fields;            /* field count */
  gst_riff_vprp_video_field_desc field_info[GST_RIFF_VPRP_VIDEO_FIELDS];
} gst_riff_vprp;
</STRUCT>
<FUNCTION>
<NAME>fastrand</NAME>
<RETURNS>guint </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_WAVPACK_PARSE</NAME>
#define GST_TYPE_WAVPACK_PARSE \
  (gst_wavpack_parse_get_type())
</MACRO>
<MACRO>
<NAME>GST_WAVPACK_PARSE</NAME>
#define GST_WAVPACK_PARSE(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj), GST_TYPE_WAVPACK_PARSE, GstWavpackParse))
</MACRO>
<MACRO>
<NAME>GST_WAVPACK_PARSE_CLASS</NAME>
#define GST_WAVPACK_PARSE_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass), GST_TYPE_WAVPACK_PARSE, GstWavpackParseClass))
</MACRO>
<MACRO>
<NAME>GST_IS_WAVPACK_PARSE</NAME>
#define GST_IS_WAVPACK_PARSE(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj), GST_TYPE_WAVPACK_PARSE))
</MACRO>
<MACRO>
<NAME>GST_IS_WAVPACK_PARSE_CLASS</NAME>
#define GST_IS_WAVPACK_PARSE_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass), GST_TYPE_WAVPACK_PARSE))
</MACRO>
<MACRO>
<NAME>ID_UNIQUE</NAME>
#define ID_UNIQUE               0x3f
</MACRO>
<MACRO>
<NAME>ID_OPTIONAL_DATA</NAME>
#define ID_OPTIONAL_DATA        0x20
</MACRO>
<MACRO>
<NAME>ID_ODD_SIZE</NAME>
#define ID_ODD_SIZE             0x40
</MACRO>
<MACRO>
<NAME>ID_LARGE</NAME>
#define ID_LARGE                0x80
</MACRO>
<MACRO>
<NAME>ID_DUMMY</NAME>
#define ID_DUMMY                0x0
</MACRO>
<MACRO>
<NAME>ID_ENCODER_INFO</NAME>
#define ID_ENCODER_INFO         0x1
</MACRO>
<MACRO>
<NAME>ID_DECORR_TERMS</NAME>
#define ID_DECORR_TERMS         0x2
</MACRO>
<MACRO>
<NAME>ID_DECORR_WEIGHTS</NAME>
#define ID_DECORR_WEIGHTS       0x3
</MACRO>
<MACRO>
<NAME>ID_DECORR_SAMPLES</NAME>
#define ID_DECORR_SAMPLES       0x4
</MACRO>
<MACRO>
<NAME>ID_ENTROPY_VARS</NAME>
#define ID_ENTROPY_VARS         0x5
</MACRO>
<MACRO>
<NAME>ID_HYBRID_PROFILE</NAME>
#define ID_HYBRID_PROFILE       0x6
</MACRO>
<MACRO>
<NAME>ID_SHAPING_WEIGHTS</NAME>
#define ID_SHAPING_WEIGHTS      0x7
</MACRO>
<MACRO>
<NAME>ID_FLOAT_INFO</NAME>
#define ID_FLOAT_INFO           0x8
</MACRO>
<MACRO>
<NAME>ID_INT32_INFO</NAME>
#define ID_INT32_INFO           0x9
</MACRO>
<MACRO>
<NAME>ID_WV_BITSTREAM</NAME>
#define ID_WV_BITSTREAM         0xa
</MACRO>
<MACRO>
<NAME>ID_WVC_BITSTREAM</NAME>
#define ID_WVC_BITSTREAM        0xb
</MACRO>
<MACRO>
<NAME>ID_WVX_BITSTREAM</NAME>
#define ID_WVX_BITSTREAM        0xc
</MACRO>
<MACRO>
<NAME>ID_CHANNEL_INFO</NAME>
#define ID_CHANNEL_INFO         0xd
</MACRO>
<MACRO>
<NAME>ID_RIFF_HEADER</NAME>
#define ID_RIFF_HEADER          (ID_OPTIONAL_DATA | 0x1)
</MACRO>
<MACRO>
<NAME>ID_RIFF_TRAILER</NAME>
#define ID_RIFF_TRAILER         (ID_OPTIONAL_DATA | 0x2)
</MACRO>
<MACRO>
<NAME>ID_REPLAY_GAIN</NAME>
#define ID_REPLAY_GAIN          (ID_OPTIONAL_DATA | 0x3)
</MACRO>
<MACRO>
<NAME>ID_CUESHEET</NAME>
#define ID_CUESHEET             (ID_OPTIONAL_DATA | 0x4)
</MACRO>
<MACRO>
<NAME>ID_CONFIG_BLOCK</NAME>
#define ID_CONFIG_BLOCK         (ID_OPTIONAL_DATA | 0x5)
</MACRO>
<MACRO>
<NAME>ID_MD5_CHECKSUM</NAME>
#define ID_MD5_CHECKSUM         (ID_OPTIONAL_DATA | 0x6)
</MACRO>
<MACRO>
<NAME>ID_SAMPLE_RATE</NAME>
#define ID_SAMPLE_RATE          (ID_OPTIONAL_DATA | 0x7)
</MACRO>
<MACRO>
<NAME>FLAG_FINAL_BLOCK</NAME>
#define FLAG_FINAL_BLOCK        (1 << 12)
</MACRO>
<STRUCT>
<NAME>WavpackHeader</NAME>
typedef struct {
  char ckID [4];             /* "wvpk" */
  guint32 ckSize;            /* size of entire block (minus 8, of course) */
  guint16 version;           /* 0x402 to 0x410 are currently valid for decode */
  guchar track_no;           /* track number (0 if not used, like now) */
  guchar index_no;           /* track sub-index (0 if not used, like now) */
  guint32 total_samples;     /* total samples for entire file, but this is
                              * only valid if block_index == 0 and a value of
                              * -1 indicates unknown length */
  guint32 block_index;       /* index of first sample in block relative to
                              * beginning of file (normally this would start
                              * at 0 for the first block) */
  guint32 block_samples;     /* number of samples in this block (0 = no audio) */
  guint32 flags;             /* various flags for id and decoding */
  guint32 crc;               /* crc for actual decoded data */
} WavpackHeader;
</STRUCT>
<STRUCT>
<NAME>WavpackInfo</NAME>
typedef struct {
  gboolean correction;
  guint rate;
  guint width;
  guint channels;
  guint channel_mask;
} WavpackInfo;
</STRUCT>
<STRUCT>
<NAME>GstWavpackParse</NAME>
struct _GstWavpackParse {
  GstBaseParse baseparse;

  /*< private >*/
  gint          sample_rate;
  gint          channels;
  gint          width;
  gint          channel_mask;

  guint         total_samples;

  gboolean      sent_codec_tag;
};
</STRUCT>
<STRUCT>
<NAME>GstWavpackParseClass</NAME>
struct _GstWavpackParseClass {
  GstBaseParseClass baseparse_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_wavpack_parse_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_SBC_PARSE</NAME>
#define GST_TYPE_SBC_PARSE            (gst_sbc_parse_get_type())
</MACRO>
<MACRO>
<NAME>GST_SBC_PARSE</NAME>
#define GST_SBC_PARSE(obj)            (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_SBC_PARSE,GstSbcParse))
</MACRO>
<MACRO>
<NAME>GST_SBC_PARSE_CLASS</NAME>
#define GST_SBC_PARSE_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_SBC_PARSE,GstSbcParseClass))
</MACRO>
<MACRO>
<NAME>GST_SBC_PARSE_GET_CLASS</NAME>
#define GST_SBC_PARSE_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS((obj),GST_TYPE_SBC_PARSE,GstSbcParseClass))
</MACRO>
<MACRO>
<NAME>GST_IS_SBC_PARSE</NAME>
#define GST_IS_SBC_PARSE(obj)         (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_SBC_PARSE))
</MACRO>
<MACRO>
<NAME>GST_IS_SBC_PARSE_CLASS</NAME>
#define GST_IS_SBC_PARSE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_SBC_PARSE))
</MACRO>
<MACRO>
<NAME>GST_SBC_PARSE_CAST</NAME>
#define GST_SBC_PARSE_CAST(obj)       ((GstSbcParse *)(obj))
</MACRO>
<ENUM>
<NAME>GstSbcChannelMode</NAME>
typedef enum {
  GST_SBC_CHANNEL_MODE_INVALID = -1,
  GST_SBC_CHANNEL_MODE_MONO = 0,
  GST_SBC_CHANNEL_MODE_DUAL = 1,
  GST_SBC_CHANNEL_MODE_STEREO = 2,
  GST_SBC_CHANNEL_MODE_JOINT_STEREO = 3
} GstSbcChannelMode;
</ENUM>
<ENUM>
<NAME>GstSbcAllocationMethod</NAME>
typedef enum {
  GST_SBC_ALLOCATION_METHOD_INVALID = -1,
  GST_SBC_ALLOCATION_METHOD_LOUDNESS = 0,
  GST_SBC_ALLOCATION_METHOD_SNR = 1
} GstSbcAllocationMethod;
</ENUM>
<STRUCT>
<NAME>GstSbcParse</NAME>
struct _GstSbcParse {
  GstBaseParse baseparse;

  /* current output format */
  GstSbcAllocationMethod  alloc_method;
  GstSbcChannelMode       ch_mode;
  gint                    rate;
  gint                    n_blocks;
  gint                    n_subbands;
  gint                    bitpool;

  gboolean                sent_codec_tag;
};
</STRUCT>
<STRUCT>
<NAME>GstSbcParseClass</NAME>
struct _GstSbcParseClass {
  GstBaseParseClass baseparse_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_sbc_parse_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_CAT_DEFAULT</NAME>
#define GST_CAT_DEFAULT autodetect_debug
</MACRO>
<MACRO>
<NAME>GST_TYPE_AUTO_DETECT</NAME>
#define GST_TYPE_AUTO_DETECT (gst_auto_detect_get_type ())
</MACRO>
<MACRO>
<NAME>GST_AUTO_DETECT</NAME>
#define GST_AUTO_DETECT(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST ((obj), GST_TYPE_AUTO_DETECT, GstAutoDetect))
</MACRO>
<MACRO>
<NAME>GST_AUTO_DETECT_CLASS</NAME>
#define GST_AUTO_DETECT_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST ((klass), GST_TYPE_AUTO_DETECT, GstAutoDetectClass))
</MACRO>
<MACRO>
<NAME>GST_IS_AUTO_DETECT</NAME>
#define GST_IS_AUTO_DETECT(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GST_TYPE_AUTO_DETECT))
</MACRO>
<MACRO>
<NAME>GST_IS_AUTO_DETECT_CLASS</NAME>
#define GST_IS_AUTO_DETECT_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE ((klass), GST_TYPE_AUTO_DETECT))
</MACRO>
<MACRO>
<NAME>GST_AUTO_DETECT_GET_CLASS</NAME>
#define GST_AUTO_DETECT_GET_CLASS(obj) \
  (G_TYPE_INSTANCE_GET_CLASS ((obj), GST_TYPE_AUTO_DETECT, GstAutoDetectClass))
</MACRO>
<STRUCT>
<NAME>GstAutoDetect</NAME>
typedef struct _GstAutoDetect {
  GstBin parent;
  
  /* configuration for subclasses */
  const gchar *media_klass; /* Audio/Video/... */
  GstElementFlags flag; /* GST_ELEMENT_FLAG_{SINK/SOURCE} */

  /* explicit pointers to stuff used */
  GstPad *pad;
  GstCaps *filter_caps;
  gboolean sync;

  /* < private > */ 
  GstElement *kid;
  gboolean has_sync;
  const gchar *type_klass; /* Source/Sink */
  const gchar *media_klass_lc, *type_klass_lc; /* lower case versions */

} GstAutoDetect;
</STRUCT>
<STRUCT>
<NAME>GstAutoDetectClass</NAME>
typedef struct _GstAutoDetectClass {
  GstBinClass parent_class;
  
  /*< private >*/
  /* virtual methods for subclasses */
  void (*configure)(GstAutoDetect *self, GstElement *kid);
  GstElement * (*create_fake_element) (GstAutoDetect * autodetect);
} GstAutoDetectClass;
</STRUCT>
<FUNCTION>
<NAME>gst_auto_detect_get_type</NAME>
<RETURNS>GType    </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>zoomFilterVisualFXWrapper_create</NAME>
<RETURNS>void  </RETURNS>
VisualFX *fx
</FUNCTION>
<STRUCT>
<NAME>ZOOM_FILTER_DATA</NAME>
struct _ZOOM_FILTER_DATA
{
	int     vitesse;           /* 128 = vitesse nule... * * 256 = en arriere 
	                            * hyper vite.. * * 0 = en avant hype vite. */
	unsigned char pertedec;
	unsigned char sqrtperte;
	int     middleX, middleY;  /* milieu de l'effet */
	char    reverse;           /* inverse la vitesse */
	char    mode;              /* type d'effet  appliquer (cf les #define) */
	/** @since June 2001 */
	int     hPlaneEffect;      /* deviation horitontale */
	int     vPlaneEffect;      /* deviation verticale */
	/** @since April 2002 */
	int     waveEffect;        /* applique une "surcouche" de wave effect */
	int     hypercosEffect;    /* applique une "surcouche de hypercos effect */

	char    noisify;           /* ajoute un bruit a la transformation */
};
</STRUCT>
<MACRO>
<NAME>NORMAL_MODE</NAME>
#define NORMAL_MODE 0
</MACRO>
<MACRO>
<NAME>WAVE_MODE</NAME>
#define WAVE_MODE 1
</MACRO>
<MACRO>
<NAME>CRYSTAL_BALL_MODE</NAME>
#define CRYSTAL_BALL_MODE 2
</MACRO>
<MACRO>
<NAME>SCRUNCH_MODE</NAME>
#define SCRUNCH_MODE 3
</MACRO>
<MACRO>
<NAME>AMULETTE_MODE</NAME>
#define AMULETTE_MODE 4
</MACRO>
<MACRO>
<NAME>WATER_MODE</NAME>
#define WATER_MODE 5
</MACRO>
<MACRO>
<NAME>HYPERCOS1_MODE</NAME>
#define HYPERCOS1_MODE 6
</MACRO>
<MACRO>
<NAME>HYPERCOS2_MODE</NAME>
#define HYPERCOS2_MODE 7
</MACRO>
<MACRO>
<NAME>YONLY_MODE</NAME>
#define YONLY_MODE 8
</MACRO>
<MACRO>
<NAME>SPEEDWAY_MODE</NAME>
#define SPEEDWAY_MODE 9
</MACRO>
<FUNCTION>
<NAME>pointFilter</NAME>
<RETURNS>void  </RETURNS>
PluginInfo *goomInfo, Pixel * pix1, Color c, float t1, float t2, float t3, float t4, guint32 cycle
</FUNCTION>
<FUNCTION>
<NAME>zoomFilterFastRGB</NAME>
<RETURNS>void  </RETURNS>
PluginInfo *goomInfo, Pixel * pix1, Pixel * pix2, ZoomFilterData * zf, guint32 resx, guint32 resy, int switchIncr, float switchMult
</FUNCTION>
<STRUCT>
<NAME>v3d</NAME>
typedef struct {
    float x,y,z;
} v3d;
</STRUCT>
<STRUCT>
<NAME>v2d</NAME>
typedef struct {
    int x,y;
} v2d;
</STRUCT>
<STRUCT>
<NAME>v2g</NAME>
typedef struct {
    double x,y;
} v2g;
</STRUCT>
<MACRO>
<NAME>V3D_TO_V2D</NAME>
#define V3D_TO_V2D(v3,v2,width,height,distance) \
{ \
  int Xp, Yp; \
  if (v3.z > 2) { \
	 F2I((distance * v3.x / v3.z),Xp) ; \
 	 F2I((distance * v3.y / v3.z),Yp) ; \
 	 v2.x = Xp + (width>>1); \
	 v2.y = -Yp + (height>>1); \
  } \
  else v2.x=v2.y=-666; \
}
</MACRO>
<FUNCTION>
<NAME>v3d_to_v2d</NAME>
<RETURNS>void  </RETURNS>
v3d *src, int nbvertex, int width, int height, float distance, v2d *v2_array
</FUNCTION>
<MACRO>
<NAME>Y_ROTATE_V3D</NAME>
#define Y_ROTATE_V3D(vi,vf,sina,cosa)\
{\
 vf.x = vi.x * cosa - vi.z * sina;\
 vf.z = vi.x * sina + vi.z * cosa;\
 vf.y = vi.y;\
}
</MACRO>
<MACRO>
<NAME>TRANSLATE_V3D</NAME>
#define TRANSLATE_V3D(vsrc,vdest)\
{\
 vdest.x += vsrc.x;\
 vdest.y += vsrc.y;\
 vdest.z += vsrc.z;\
}
</MACRO>
<MACRO>
<NAME>MUL_V3D</NAME>
#define MUL_V3D(lf,v) {v.x*=lf;v.y*=lf;v.z*=lf;}
</MACRO>
<MACRO>
<NAME>COLOR_ARGB</NAME>
#define COLOR_ARGB
</MACRO>
<MACRO>
<NAME>COLOR_BGRA</NAME>
#define COLOR_BGRA
</MACRO>
<MACRO>
<NAME>BLEU</NAME>
    #define BLEU 0
</MACRO>
<MACRO>
<NAME>VERT</NAME>
    #define VERT 1
</MACRO>
<MACRO>
<NAME>ROUGE</NAME>
    #define ROUGE 2
</MACRO>
<MACRO>
<NAME>ALPHA</NAME>
    #define ALPHA 3
</MACRO>
<MACRO>
<NAME>HAVE_MMX</NAME>
#define HAVE_MMX
</MACRO>
<STRUCT>
<NAME>GMUNITPOINTER</NAME>
struct _GMUNITPOINTER
{
	float   x;
	float   y;
	float   angle;
};
</STRUCT>
<STRUCT>
<NAME>GMLINE</NAME>
struct _GMLINE
{

	GMUnitPointer *points;
	GMUnitPointer *points2;
	int     IDdest;
	float   param;
	float   amplitudeF;
	float   amplitude;

	int     nbPoints;
	guint32 color;     /* pour l'instant je stocke la couleur a terme, on stockera le mode couleur et l'on animera */
	guint32 color2;

	int     screenX;
	int     screenY;

	float   power;
	float   powinc;

	PluginInfo *goomInfo;
};
</STRUCT>
<MACRO>
<NAME>GML_CIRCLE</NAME>
#define GML_CIRCLE 0
</MACRO>
<MACRO>
<NAME>GML_HLINE</NAME>
#define GML_HLINE 1
</MACRO>
<MACRO>
<NAME>GML_VLINE</NAME>
#define GML_VLINE 2
</MACRO>
<MACRO>
<NAME>GML_BLEUBLANC</NAME>
#define GML_BLEUBLANC 0
</MACRO>
<MACRO>
<NAME>GML_RED</NAME>
#define GML_RED 1
</MACRO>
<MACRO>
<NAME>GML_ORANGE_V</NAME>
#define GML_ORANGE_V 2
</MACRO>
<MACRO>
<NAME>GML_ORANGE_J</NAME>
#define GML_ORANGE_J 3
</MACRO>
<MACRO>
<NAME>GML_VERT</NAME>
#define GML_VERT 4
</MACRO>
<MACRO>
<NAME>GML_BLEU</NAME>
#define GML_BLEU 5
</MACRO>
<MACRO>
<NAME>GML_BLACK</NAME>
#define GML_BLACK 6
</MACRO>
<FUNCTION>
<NAME>goom_lines_init</NAME>
<RETURNS>GMLine  *</RETURNS>
PluginInfo *goomInfo, int rx, int ry, int IDsrc, float paramS, int modeCoulSrc, int IDdest, float paramD, int modeCoulDest
</FUNCTION>
<FUNCTION>
<NAME>goom_lines_switch_to</NAME>
<RETURNS>void     </RETURNS>
GMLine * gml, int IDdest, float param, float amplitude, int modeCoul
</FUNCTION>
<FUNCTION>
<NAME>goom_lines_set_res</NAME>
<RETURNS>void     </RETURNS>
GMLine * gml, int rx, int ry
</FUNCTION>
<FUNCTION>
<NAME>goom_lines_free</NAME>
<RETURNS>void     </RETURNS>
GMLine ** gml
</FUNCTION>
<FUNCTION>
<NAME>goom_lines_draw</NAME>
<RETURNS>void     </RETURNS>
PluginInfo *plugInfo, GMLine * gml, gint16 data[512], Pixel *p
</FUNCTION>
<STRUCT>
<NAME>surf3d</NAME>
typedef struct {
	v3d *vertex;
	v3d *svertex;
	int nbvertex;

	v3d center;
} surf3d;
</STRUCT>
<STRUCT>
<NAME>grid3d</NAME>
typedef struct {
	surf3d surf;
	
	int defx;
	int sizex;
	int defz;
	int sizez;
	int mode;
} grid3d;
</STRUCT>
<FUNCTION>
<NAME>grid3d_new</NAME>
<RETURNS>grid3d  *</RETURNS>
int sizex, int defx, int sizez, int defz, v3d center
</FUNCTION>
<FUNCTION>
<NAME>grid3d_free</NAME>
<RETURNS>void  </RETURNS>
grid3d *g
</FUNCTION>
<FUNCTION>
<NAME>grid3d_update</NAME>
<RETURNS>void  </RETURNS>
grid3d *s, float angle, float *vals, float dist
</FUNCTION>
<FUNCTION>
<NAME>surf3d_draw</NAME>
<RETURNS>void  </RETURNS>
surf3d *s, int color, int dist, int *buf, int *back, int W,int H
</FUNCTION>
<FUNCTION>
<NAME>grid3d_draw</NAME>
<RETURNS>void  </RETURNS>
PluginInfo *plug, grid3d *g, int color, int colorlow, int dist, Pixel *buf, Pixel *back, int W,int H
</FUNCTION>
<FUNCTION>
<NAME>surf3d_rotate</NAME>
<RETURNS>void  </RETURNS>
surf3d *s, float angle
</FUNCTION>
<FUNCTION>
<NAME>surf3d_translate</NAME>
<RETURNS>void  </RETURNS>
surf3d *s
</FUNCTION>
<MACRO>
<NAME>iexp_</NAME>
#define iexp_				0
</MACRO>
<MACRO>
<NAME>iman_</NAME>
#define iman_				1
</MACRO>
<MACRO>
<NAME>F2I</NAME>
#define F2I(dbl,i) i=(int)dbl;
</MACRO>
<MACRO>
<NAME>SINCOS</NAME>
#define SINCOS(f,s,c) \
  __asm__ __volatile__ ("fsincos" : "=t" (c), "=u" (s) : "0" (f))
</MACRO>
<FUNCTION>
<NAME>evaluate_sound</NAME>
<RETURNS>void  </RETURNS>
gint16 data[2][512], SoundInfo *sndInfo
</FUNCTION>
<TYPEDEF>
<NAME>Uint</NAME>
typedef unsigned int Uint;
</TYPEDEF>
<VARIABLE>
<NAME>BLACK</NAME>
extern const Color BLACK;
</VARIABLE>
<VARIABLE>
<NAME>WHITE</NAME>
extern const Color WHITE;
</VARIABLE>
<VARIABLE>
<NAME>RED</NAME>
extern const Color RED;
</VARIABLE>
<VARIABLE>
<NAME>BLUE</NAME>
extern const Color BLUE;
</VARIABLE>
<VARIABLE>
<NAME>GREEN</NAME>
extern const Color GREEN;
</VARIABLE>
<VARIABLE>
<NAME>YELLOW</NAME>
extern const Color YELLOW;
</VARIABLE>
<VARIABLE>
<NAME>ORANGE</NAME>
extern const Color ORANGE;
</VARIABLE>
<VARIABLE>
<NAME>VIOLET</NAME>
extern const Color VIOLET;
</VARIABLE>
<MACRO>
<NAME>B_CHANNEL</NAME>
#define B_CHANNEL 0xFF000000
</MACRO>
<MACRO>
<NAME>G_CHANNEL</NAME>
#define G_CHANNEL 0x00FF0000
</MACRO>
<MACRO>
<NAME>R_CHANNEL</NAME>
#define R_CHANNEL 0x0000FF00
</MACRO>
<MACRO>
<NAME>A_CHANNEL</NAME>
#define A_CHANNEL 0x000000FF
</MACRO>
<MACRO>
<NAME>B_OFFSET</NAME>
#define B_OFFSET  24
</MACRO>
<MACRO>
<NAME>G_OFFSET</NAME>
#define G_OFFSET  16
</MACRO>
<MACRO>
<NAME>R_OFFSET</NAME>
#define R_OFFSET  8
</MACRO>
<MACRO>
<NAME>A_OFFSET</NAME>
#define A_OFFSET  0
</MACRO>
<UNION>
<NAME>Pixel</NAME>
typedef union _PIXEL {
  struct {
    unsigned char b;
    unsigned char g;
    unsigned char r;
    unsigned char a;
  } channels;
  unsigned int val;
  unsigned char cop[4];
} Pixel;
</UNION>
<TYPEDEF>
<NAME>PluginInfo</NAME>
typedef struct _PLUGIN_INFO PluginInfo;
</TYPEDEF>
<TYPEDEF>
<NAME>SoundInfo</NAME>
typedef struct _SOUND_INFO SoundInfo;
</TYPEDEF>
<TYPEDEF>
<NAME>GMLine</NAME>
typedef struct _GMLINE GMLine;
</TYPEDEF>
<TYPEDEF>
<NAME>GMUnitPointer</NAME>
typedef struct _GMUNITPOINTER GMUnitPointer;
</TYPEDEF>
<TYPEDEF>
<NAME>ZoomFilterData</NAME>
typedef struct _ZOOM_FILTER_DATA ZoomFilterData;
</TYPEDEF>
<TYPEDEF>
<NAME>VisualFX</NAME>
typedef struct _VISUAL_FX VisualFX;
</TYPEDEF>
<FUNCTION>
<NAME>convolve_create</NAME>
<RETURNS>void  </RETURNS>
VisualFX *vfx
</FUNCTION>
<FUNCTION>
<NAME>flying_star_create</NAME>
<RETURNS>void  </RETURNS>
VisualFX *vfx
</FUNCTION>
<FUNCTION>
<NAME>zoom_filter_c</NAME>
<RETURNS>void  </RETURNS>
int sizeX, int sizeY, Pixel *src, Pixel *dest, int *brutS, int *brutD, int buffratio, int precalCoef[16][16]
</FUNCTION>
<FUNCTION>
<NAME>ppc_zoom_generic</NAME>
<RETURNS>void  </RETURNS>
int sizeX, int sizeY, Pixel *src, Pixel *dest, int *brutS, int *brutD, int buffratio, int precalCoef[16][16]
</FUNCTION>
<FUNCTION>
<NAME>ppc_zoom_G4</NAME>
<RETURNS>void  </RETURNS>
int sizeX, int sizeY, Pixel *src, Pixel *dest, int *brutS, int *brutD, int buffratio, int precalCoef[16][16]
</FUNCTION>
<ENUM>
<NAME>ParamType</NAME>
typedef enum {
  PARAM_INTVAL,
  PARAM_FLOATVAL,
  PARAM_BOOLVAL,
  PARAM_STRVAL,
  PARAM_LISTVAL,
} ParamType;
</ENUM>
<STRUCT>
<NAME>IntVal</NAME>
struct IntVal {
  int value;
  int min;
  int max;
  int step;
};
</STRUCT>
<STRUCT>
<NAME>FloatVal</NAME>
struct FloatVal {
  float value;
  float min;
  float max;
  float step;
};
</STRUCT>
<STRUCT>
<NAME>StrVal</NAME>
struct StrVal {
  char *value;
};
</STRUCT>
<STRUCT>
<NAME>ListVal</NAME>
struct ListVal {
  char *value;
  int nbChoices;
  char **choices;
};
</STRUCT>
<STRUCT>
<NAME>BoolVal</NAME>
struct BoolVal {
  int value;
};
</STRUCT>
<STRUCT>
<NAME>PluginParam</NAME>
typedef struct _PARAM {
  const char *name;
  const char *desc;
  char rw;
  ParamType type;
  union {
    struct IntVal ival;
    struct FloatVal fval;
    struct StrVal sval;
    struct ListVal slist;
    struct BoolVal bval;
  } param;
  
  /* used by the core to inform the GUI of a change */
  void (*change_listener)(struct _PARAM *_this);

  /* used by the GUI to inform the core of a change */
  void (*changed)(struct _PARAM *_this);
  
  void *user_data; /* can be used by the GUI */
} PluginParam;
</STRUCT>
<MACRO>
<NAME>IVAL</NAME>
#define IVAL(p) ((p).param.ival.value)
</MACRO>
<MACRO>
<NAME>SVAL</NAME>
#define SVAL(p) ((p).param.sval.value)
</MACRO>
<MACRO>
<NAME>FVAL</NAME>
#define FVAL(p) ((p).param.fval.value)
</MACRO>
<MACRO>
<NAME>BVAL</NAME>
#define BVAL(p) ((p).param.bval.value)
</MACRO>
<MACRO>
<NAME>LVAL</NAME>
#define LVAL(p) ((p).param.slist.value)
</MACRO>
<MACRO>
<NAME>FMIN</NAME>
#define FMIN(p) ((p).param.fval.min)
</MACRO>
<MACRO>
<NAME>FMAX</NAME>
#define FMAX(p) ((p).param.fval.max)
</MACRO>
<MACRO>
<NAME>FSTEP</NAME>
#define FSTEP(p) ((p).param.fval.step)
</MACRO>
<MACRO>
<NAME>IMIN</NAME>
#define IMIN(p) ((p).param.ival.min)
</MACRO>
<MACRO>
<NAME>IMAX</NAME>
#define IMAX(p) ((p).param.ival.max)
</MACRO>
<MACRO>
<NAME>ISTEP</NAME>
#define ISTEP(p) ((p).param.ival.step)
</MACRO>
<FUNCTION>
<NAME>goom_secure_param</NAME>
<RETURNS>void  </RETURNS>
PluginParam *p
</FUNCTION>
<FUNCTION>
<NAME>goom_secure_f_param</NAME>
<RETURNS>void  </RETURNS>
PluginParam *p, const char *name
</FUNCTION>
<FUNCTION>
<NAME>goom_secure_i_param</NAME>
<RETURNS>void  </RETURNS>
PluginParam *p, const char *name
</FUNCTION>
<FUNCTION>
<NAME>goom_secure_b_param</NAME>
<RETURNS>void  </RETURNS>
PluginParam *p, const char *name, int value
</FUNCTION>
<FUNCTION>
<NAME>goom_secure_s_param</NAME>
<RETURNS>void  </RETURNS>
PluginParam *p, const char *name
</FUNCTION>
<FUNCTION>
<NAME>goom_secure_f_feedback</NAME>
<RETURNS>void  </RETURNS>
PluginParam *p, const char *name
</FUNCTION>
<FUNCTION>
<NAME>goom_secure_i_feedback</NAME>
<RETURNS>void  </RETURNS>
PluginParam *p, const char *name
</FUNCTION>
<FUNCTION>
<NAME>goom_set_str_param_value</NAME>
<RETURNS>void  </RETURNS>
PluginParam *p, const char *str
</FUNCTION>
<FUNCTION>
<NAME>goom_set_list_param_value</NAME>
<RETURNS>void  </RETURNS>
PluginParam *p, const char *str
</FUNCTION>
<STRUCT>
<NAME>PluginParameters</NAME>
typedef struct _PARAMETERS {
  const char *name;
  const char *desc;
  int nbParams;
  PluginParam **params;
} PluginParameters;
</STRUCT>
<FUNCTION>
<NAME>goom_plugin_parameters</NAME>
<RETURNS>void  </RETURNS>
PluginParameters *p, const char *name, int nb
</FUNCTION>
<FUNCTION>
<NAME>goom_plugin_parameters_free</NAME>
<RETURNS>void  </RETURNS>
PluginParameters *p
</FUNCTION>
<MACRO>
<NAME>secure_param</NAME>
#define secure_param goom_secure_param
</MACRO>
<MACRO>
<NAME>secure_f_param</NAME>
#define secure_f_param goom_secure_f_param
</MACRO>
<MACRO>
<NAME>secure_i_param</NAME>
#define secure_i_param goom_secure_i_param
</MACRO>
<MACRO>
<NAME>secure_b_param</NAME>
#define secure_b_param goom_secure_b_param
</MACRO>
<MACRO>
<NAME>secure_s_param</NAME>
#define secure_s_param goom_secure_s_param
</MACRO>
<MACRO>
<NAME>secure_f_feedback</NAME>
#define secure_f_feedback goom_secure_f_feedback
</MACRO>
<MACRO>
<NAME>secure_i_feedback</NAME>
#define secure_i_feedback goom_secure_i_feedback
</MACRO>
<MACRO>
<NAME>set_list_param_value</NAME>
#define set_list_param_value goom_set_list_param_value
</MACRO>
<MACRO>
<NAME>set_str_param_value</NAME>
#define set_str_param_value goom_set_str_param_value
</MACRO>
<MACRO>
<NAME>plugin_parameters</NAME>
#define plugin_parameters goom_plugin_parameters
</MACRO>
<MACRO>
<NAME>NB_FX</NAME>
#define NB_FX 10
</MACRO>
<FUNCTION>
<NAME>goom_init</NAME>
<RETURNS>PluginInfo  *</RETURNS>
guint32 resx, guint32 resy
</FUNCTION>
<FUNCTION>
<NAME>goom_set_resolution</NAME>
<RETURNS>void  </RETURNS>
PluginInfo *goomInfo, guint32 resx, guint32 resy
</FUNCTION>
<FUNCTION>
<NAME>goom_update</NAME>
<RETURNS>guint32  *</RETURNS>
PluginInfo *goomInfo, gint16 data[2][512], int forceMode, float fps
</FUNCTION>
<FUNCTION>
<NAME>goom_set_screenbuffer</NAME>
<RETURNS>int  </RETURNS>
PluginInfo *goomInfo, void *buffer
</FUNCTION>
<FUNCTION>
<NAME>goom_close</NAME>
<RETURNS>void  </RETURNS>
PluginInfo *goomInfo
</FUNCTION>
<MACRO>
<NAME>GOOM_NB_RAND</NAME>
#define GOOM_NB_RAND 0x10000
</MACRO>
<STRUCT>
<NAME>GoomRandom</NAME>
typedef struct _GOOM_RANDOM {
	int array[GOOM_NB_RAND];
	unsigned short pos;
} GoomRandom;
</STRUCT>
<FUNCTION>
<NAME>goom_random_init</NAME>
<RETURNS>GoomRandom  *</RETURNS>
int i
</FUNCTION>
<FUNCTION>
<NAME>goom_random_free</NAME>
<RETURNS>void  </RETURNS>
GoomRandom *grandom
</FUNCTION>
<FUNCTION>
<NAME>goom_random_update_array</NAME>
<RETURNS>void  </RETURNS>
GoomRandom *grandom, int numberOfValuesToChange
</FUNCTION>
<FUNCTION>
<NAME>ppc_brightness_generic</NAME>
<RETURNS>void  </RETURNS>
Pixel *src, Pixel *dest, int size, int coeff
</FUNCTION>
<FUNCTION>
<NAME>ppc_brightness_G4</NAME>
<RETURNS>void  </RETURNS>
Pixel *src, Pixel *dest, int size, int coeff
</FUNCTION>
<FUNCTION>
<NAME>ppc_brightness_G5</NAME>
<RETURNS>void  </RETURNS>
Pixel *src, Pixel *dest, int size, int coeff
</FUNCTION>
<FUNCTION>
<NAME>ifs_visualfx_create</NAME>
<RETURNS>void  </RETURNS>
VisualFX *vfx
</FUNCTION>
<FUNCTION>
<NAME>draw_line</NAME>
<RETURNS>void  </RETURNS>
Pixel *data, int x1, int y1, int x2, int y2, int col, int screenx, int screeny
</FUNCTION>
<STRUCT>
<NAME>GoomState</NAME>
typedef struct {
	char drawIFS;
	char drawPoints;
	char drawTentacle;

	char drawScope;
	int farScope;

	int rangemin;
	int rangemax;
} GoomState;
</STRUCT>
<MACRO>
<NAME>STATES_MAX_NB</NAME>
#define STATES_MAX_NB 128
</MACRO>
<STRUCT>
<NAME>SOUND_INFO</NAME>
struct _SOUND_INFO {

	/* nota : a Goom is just a sound event... */

	int timeSinceLastGoom;   /* >= 0 */
	float goomPower;         /* power of the last Goom [0..1] */

	int timeSinceLastBigGoom;   /* >= 0 */

	float volume;     /* [0..1] */
	short samples[2][512];

	/* other "internal" datas for the sound_tester */
	float goom_limit; /* auto-updated limit of goom_detection */
	float bigGoomLimit;
	float accelvar;   /* acceleration of the sound - [0..1] */
	float speedvar;   /* speed of the sound - [0..100] */
	int allTimesMax;
	int totalgoom;    /* number of goom since last reset
			   * (a reset every 64 cycles) */

	float prov_max;   /* accel max since last reset */

	int cycle;

	/* private */
	PluginParam volume_p;
	PluginParam speed_p;
	PluginParam accel_p;
	PluginParam goom_limit_p;
        PluginParam goom_power_p;
	PluginParam last_goom_p;
	PluginParam last_biggoom_p;
	PluginParam biggoom_speed_limit_p;
	PluginParam biggoom_factor_p;

	PluginParameters params; /* contains the previously defined parameters. */
};
</STRUCT>
<STRUCT>
<NAME>PLUGIN_INFO</NAME>
struct _PLUGIN_INFO {

	/* public datas */

	int nbParams;
	PluginParameters *params;

	/* private datas */

	struct _SIZE_TYPE {
		int width;
		int height;
		int size;   /* == screen.height * screen.width. */
	} screen;

	SoundInfo sound;

	int nbVisuals;
	VisualFX **visuals; /* pointers on all the visual fx */

	/** The known FX */
	VisualFX convolve_fx;
	VisualFX star_fx;
	VisualFX zoomFilter_fx;
	VisualFX tentacles_fx;
	VisualFX ifs_fx;

	/** image buffers */
	guint32 *pixel;
	guint32 *back;
	Pixel *p1, *p2;
	Pixel *conv;
  Pixel *outputBuf;

	/** state of goom */
	guint32 cycle;
	GoomState states[STATES_MAX_NB];
	int statesNumber;
	int statesRangeMax;

	GoomState *curGState;

	/** effet de ligne.. */
	GMLine *gmline1;
	GMLine *gmline2;

	/** sinus table */
	int sintable[0x10000];

	/* INTERNALS */
	
	/** goom_update internals.
	 * I took all static variables from goom_update and put them here.. for the moment.
	 */
	struct {
		int lockvar;               /* pour empecher de nouveaux changements */
		int goomvar;               /* boucle des gooms */
		int loopvar;               /* mouvement des points */
		int stop_lines;
		int ifs_incr;              /* dessiner l'ifs (0 = non: > = increment) */
		int decay_ifs;             /* disparition de l'ifs */
		int recay_ifs;             /* dedisparition de l'ifs */
		int cyclesSinceLastChange; /* nombre de Cycle Depuis Dernier Changement */
		int drawLinesDuration;     /* duree de la transition entre afficher les lignes ou pas */
		int lineMode;              /* l'effet lineaire a dessiner */
		float switchMultAmount;    /* SWITCHMULT (29.0f/30.0f) */
		int switchIncrAmount;      /* 0x7f */
		float switchMult;          /* 1.0f */
		int switchIncr;            /*  = SWITCHINCR; */
		int stateSelectionRnd;
		int stateSelectionBlocker;
		int previousZoomSpeed;
		ZoomFilterData zoomFilterData;                
	} update;

	struct {
		void (*draw_line) (Pixel *data, int x1, int y1, int x2, int y2, int col, int screenx, int screeny);
		void (*zoom_filter) (int sizeX, int sizeY, Pixel *src, Pixel *dest, int *brutS, int *brutD, int buffratio, int precalCoef[16][16]);
	} methods;
	
	GoomRandom *gRandom;
};
</STRUCT>
<FUNCTION>
<NAME>plugin_info_init</NAME>
<RETURNS>void  </RETURNS>
PluginInfo *p, int nbVisual
</FUNCTION>
<FUNCTION>
<NAME>plugin_info_free</NAME>
<RETURNS>void  </RETURNS>
PluginInfo *p
</FUNCTION>
<FUNCTION>
<NAME>plugin_info_add_visual</NAME>
<RETURNS>void  </RETURNS>
PluginInfo *p, int i, VisualFX *visual
</FUNCTION>
<FUNCTION>
<NAME>tentacle_fx_create</NAME>
<RETURNS>void  </RETURNS>
VisualFX *fx
</FUNCTION>
<STRUCT>
<NAME>VISUAL_FX</NAME>
struct _VISUAL_FX {
  void (*init) (struct _VISUAL_FX *_this, PluginInfo *info);
  void (*free) (struct _VISUAL_FX *_this);
  void (*apply) (struct _VISUAL_FX *_this, Pixel *src, Pixel *dest, PluginInfo *info);
  void *fx_data;

  PluginParameters *params;
};
</STRUCT>
<FUNCTION>
<NAME>rg_analysis_new</NAME>
<RETURNS>RgAnalysisCtx  *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>rg_analysis_set_sample_rate</NAME>
<RETURNS>gboolean  </RETURNS>
RgAnalysisCtx * ctx, gint sample_rate
</FUNCTION>
<FUNCTION>
<NAME>rg_analysis_analyze_mono_float</NAME>
<RETURNS>void  </RETURNS>
RgAnalysisCtx * ctx, gconstpointer data, gsize size, guint depth
</FUNCTION>
<FUNCTION>
<NAME>rg_analysis_analyze_stereo_float</NAME>
<RETURNS>void  </RETURNS>
RgAnalysisCtx * ctx, gconstpointer data, gsize size, guint depth
</FUNCTION>
<FUNCTION>
<NAME>rg_analysis_analyze_mono_int16</NAME>
<RETURNS>void  </RETURNS>
RgAnalysisCtx * ctx, gconstpointer data, gsize size, guint depth
</FUNCTION>
<FUNCTION>
<NAME>rg_analysis_analyze_stereo_int16</NAME>
<RETURNS>void  </RETURNS>
RgAnalysisCtx * ctx, gconstpointer data, gsize size, guint depth
</FUNCTION>
<FUNCTION>
<NAME>rg_analysis_analyze</NAME>
<RETURNS>void  </RETURNS>
RgAnalysisCtx * ctx, const gfloat * samples_l, const gfloat * samples_r, guint n_samples
</FUNCTION>
<FUNCTION>
<NAME>rg_analysis_track_result</NAME>
<RETURNS>gboolean  </RETURNS>
RgAnalysisCtx * ctx, gdouble * gain, gdouble * peak
</FUNCTION>
<FUNCTION>
<NAME>rg_analysis_album_result</NAME>
<RETURNS>gboolean  </RETURNS>
RgAnalysisCtx * ctx, gdouble * gain, gdouble * peak
</FUNCTION>
<FUNCTION>
<NAME>rg_analysis_init_silence_detection</NAME>
<RETURNS>void  </RETURNS>
 RgAnalysisCtx * ctx, void (*post_message) (gpointer analysis, GstClockTime timestamp, GstClockTime duration, gdouble rglevel), gpointer analysis
</FUNCTION>
<FUNCTION>
<NAME>rg_analysis_start_buffer</NAME>
<RETURNS>void  </RETURNS>
RgAnalysisCtx * ctx, GstClockTime buffer_timestamp
</FUNCTION>
<FUNCTION>
<NAME>rg_analysis_reset_album</NAME>
<RETURNS>void  </RETURNS>
RgAnalysisCtx * ctx
</FUNCTION>
<FUNCTION>
<NAME>rg_analysis_reset</NAME>
<RETURNS>void  </RETURNS>
RgAnalysisCtx * ctx
</FUNCTION>
<FUNCTION>
<NAME>rg_analysis_destroy</NAME>
<RETURNS>void  </RETURNS>
RgAnalysisCtx * ctx
</FUNCTION>
<STRUCT>
<NAME>RgAnalysisCtx</NAME>
</STRUCT>
<MACRO>
<NAME>RG_REFERENCE_LEVEL</NAME>
#define RG_REFERENCE_LEVEL 89.
</MACRO>
<FUNCTION>
<NAME>goom_lines</NAME>
<RETURNS>void  </RETURNS>
GoomData *goomdata, gint16 data [2][512], unsigned int ID,unsigned int* p, guint32 power
</FUNCTION>
<TYPEDEF>
<NAME>Uint</NAME>
typedef unsigned int Uint;
</TYPEDEF>
<VARIABLE>
<NAME>BLACK</NAME>
extern const Color BLACK;
</VARIABLE>
<VARIABLE>
<NAME>WHITE</NAME>
extern const Color WHITE;
</VARIABLE>
<VARIABLE>
<NAME>RED</NAME>
extern const Color RED;
</VARIABLE>
<VARIABLE>
<NAME>BLUE</NAME>
extern const Color BLUE;
</VARIABLE>
<VARIABLE>
<NAME>GREEN</NAME>
extern const Color GREEN;
</VARIABLE>
<VARIABLE>
<NAME>YELLOW</NAME>
extern const Color YELLOW;
</VARIABLE>
<VARIABLE>
<NAME>ORANGE</NAME>
extern const Color ORANGE;
</VARIABLE>
<VARIABLE>
<NAME>VIOLET</NAME>
extern const Color VIOLET;
</VARIABLE>
<MACRO>
<NAME>NORMAL_MODE</NAME>
#define NORMAL_MODE 0
</MACRO>
<MACRO>
<NAME>WAVE_MODE</NAME>
#define WAVE_MODE 1
</MACRO>
<MACRO>
<NAME>CRYSTAL_BALL_MODE</NAME>
#define CRYSTAL_BALL_MODE 2
</MACRO>
<MACRO>
<NAME>SCRUNCH_MODE</NAME>
#define SCRUNCH_MODE 3
</MACRO>
<MACRO>
<NAME>AMULETTE_MODE</NAME>
#define AMULETTE_MODE 4
</MACRO>
<MACRO>
<NAME>WATER_MODE</NAME>
#define WATER_MODE 5
</MACRO>
<STRUCT>
<NAME>ZoomFilterData</NAME>
struct ZoomFilterData
{
  int vitesse;
  unsigned char pertedec;
  unsigned char sqrtperte;
  int middleX;
  int middleY;
  char reverse;
  char mode;
        /** @since June 2001 */
  int hPlaneEffect;
  int vPlaneEffect;
  char noisify;

  guint32 res_x;
  guint32 res_y;
  guint32 buffsize;

  guint32 *buffer;
  guint32 *pos10;
  guint32 *c[4];
  int     *firedec;

  int     wave;
  int     wavesp;
};
</STRUCT>
<FUNCTION>
<NAME>pointFilter</NAME>
<RETURNS>void  </RETURNS>
GoomData *goomdata, Color c, float t1, float t2, float t3, float t4, guint32 cycle
</FUNCTION>
<FUNCTION>
<NAME>zoomFilterNew</NAME>
<RETURNS>ZoomFilterData  *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>zoomFilterDestroy</NAME>
<RETURNS>void  </RETURNS>
ZoomFilterData *zf
</FUNCTION>
<FUNCTION>
<NAME>zoomFilterFastRGB</NAME>
<RETURNS>void  </RETURNS>
GoomData *goomdata, ZoomFilterData *zf, int zfd_update
</FUNCTION>
<MACRO>
<NAME>SIN_MUL</NAME>
#define SIN_MUL 1
</MACRO>
<MACRO>
<NAME>SIN_ADD</NAME>
#define SIN_ADD 2
</MACRO>
<MACRO>
<NAME>NB_RAND</NAME>
#define NB_RAND 0x10000
</MACRO>
<MACRO>
<NAME>RAND_INIT</NAME>
#define RAND_INIT(gd,i) \
        srand (i); \
        if (gd->rand_tab == NULL) \
                gd->rand_tab = g_malloc (NB_RAND * sizeof(gint)) ;\
        gd->rand_pos = 0; \
        while (gd->rand_pos < NB_RAND) \
                gd->rand_tab [gd->rand_pos++] = rand ();
</MACRO>
<MACRO>
<NAME>RAND</NAME>
#define RAND(gd) \
        (gd->rand_tab[gd->rand_pos = ((gd->rand_pos + 1) % NB_RAND)])
</MACRO>
<MACRO>
<NAME>RAND_CLOSE</NAME>
#define RAND_CLOSE(gd) \
        g_free (gd->rand_tab); \
        gd->rand_tab = NULL;
</MACRO>
<MACRO>
<NAME>iRAND</NAME>
#define iRAND(gd,i) (RAND(gd) % i)
</MACRO>
<TYPEDEF>
<NAME>ZoomFilterData</NAME>
typedef struct ZoomFilterData ZoomFilterData;
</TYPEDEF>
<FUNCTION>
<NAME>goom_init</NAME>
<RETURNS>void  </RETURNS>
GoomData *goomdata, guint32 resx, guint32 resy
</FUNCTION>
<FUNCTION>
<NAME>goom_set_resolution</NAME>
<RETURNS>void  </RETURNS>
GoomData *goomdata, guint32 resx, guint32 resy
</FUNCTION>
<FUNCTION>
<NAME>goom_update</NAME>
<RETURNS>guint32  *</RETURNS>
GoomData *goomdata, gint16 data [2][512]
</FUNCTION>
<FUNCTION>
<NAME>goom_close</NAME>
<RETURNS>void  </RETURNS>
GoomData *goomdata
</FUNCTION>
<TYPEDEF>
<NAME>orc_int8</NAME>
typedef int8_t orc_int8;
</TYPEDEF>
<TYPEDEF>
<NAME>orc_int16</NAME>
typedef int16_t orc_int16;
</TYPEDEF>
<TYPEDEF>
<NAME>orc_int32</NAME>
typedef int32_t orc_int32;
</TYPEDEF>
<TYPEDEF>
<NAME>orc_int64</NAME>
typedef int64_t orc_int64;
</TYPEDEF>
<TYPEDEF>
<NAME>orc_uint8</NAME>
typedef uint8_t orc_uint8;
</TYPEDEF>
<TYPEDEF>
<NAME>orc_uint16</NAME>
typedef uint16_t orc_uint16;
</TYPEDEF>
<TYPEDEF>
<NAME>orc_uint32</NAME>
typedef uint32_t orc_uint32;
</TYPEDEF>
<TYPEDEF>
<NAME>orc_uint64</NAME>
typedef uint64_t orc_uint64;
</TYPEDEF>
<MACRO>
<NAME>ORC_UINT64_C</NAME>
#define ORC_UINT64_C(x) UINT64_C(x)
</MACRO>
<MACRO>
<NAME>inline</NAME>
#define inline __inline
</MACRO>
<TYPEDEF>
<NAME>orc_int8</NAME>
typedef int8_t orc_int8;
</TYPEDEF>
<TYPEDEF>
<NAME>orc_int16</NAME>
typedef int16_t orc_int16;
</TYPEDEF>
<TYPEDEF>
<NAME>orc_int32</NAME>
typedef int32_t orc_int32;
</TYPEDEF>
<TYPEDEF>
<NAME>orc_int64</NAME>
typedef int64_t orc_int64;
</TYPEDEF>
<TYPEDEF>
<NAME>orc_uint8</NAME>
typedef uint8_t orc_uint8;
</TYPEDEF>
<TYPEDEF>
<NAME>orc_uint16</NAME>
typedef uint16_t orc_uint16;
</TYPEDEF>
<TYPEDEF>
<NAME>orc_uint32</NAME>
typedef uint32_t orc_uint32;
</TYPEDEF>
<TYPEDEF>
<NAME>orc_uint64</NAME>
typedef uint64_t orc_uint64;
</TYPEDEF>
<MACRO>
<NAME>ORC_UINT64_C</NAME>
#define ORC_UINT64_C(x) UINT64_C(x)
</MACRO>
<MACRO>
<NAME>inline</NAME>
#define inline __inline
</MACRO>
<MACRO>
<NAME>GST_TYPE_AUDIO_FX_BASE_IIR_FILTER</NAME>
#define GST_TYPE_AUDIO_FX_BASE_IIR_FILTER            (gst_audio_fx_base_iir_filter_get_type())
</MACRO>
<MACRO>
<NAME>GST_AUDIO_FX_BASE_IIR_FILTER</NAME>
#define GST_AUDIO_FX_BASE_IIR_FILTER(obj)            (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_AUDIO_FX_BASE_IIR_FILTER,GstAudioFXBaseIIRFilter))
</MACRO>
<MACRO>
<NAME>GST_IS_AUDIO_FX_BASE_IIR_FILTER</NAME>
#define GST_IS_AUDIO_FX_BASE_IIR_FILTER(obj)         (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_AUDIO_FX_BASE_IIR_FILTER))
</MACRO>
<MACRO>
<NAME>GST_AUDIO_FX_BASE_IIR_FILTER_CLASS</NAME>
#define GST_AUDIO_FX_BASE_IIR_FILTER_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST((klass) ,GST_TYPE_AUDIO_FX_BASE_IIR_FILTER,GstAudioFXBaseIIRFilterClass))
</MACRO>
<MACRO>
<NAME>GST_IS_AUDIO_FX_BASE_IIR_FILTER_CLASS</NAME>
#define GST_IS_AUDIO_FX_BASE_IIR_FILTER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE((klass) ,GST_TYPE_AUDIO_FX_BASE_IIR_FILTER))
</MACRO>
<MACRO>
<NAME>GST_AUDIO_FX_BASE_IIR_FILTER_GET_CLASS</NAME>
#define GST_AUDIO_FX_BASE_IIR_FILTER_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS((obj) ,GST_TYPE_AUDIO_FX_BASE_IIR_FILTER,GstAudioFXBaseIIRFilterClass))
</MACRO>
<USER_FUNCTION>
<NAME>GstAudioFXBaseIIRFilterProcessFunc</NAME>
<RETURNS>void </RETURNS>
GstAudioFXBaseIIRFilter *, guint8 *, guint
</USER_FUNCTION>
<STRUCT>
<NAME>GstAudioFXBaseIIRFilter</NAME>
struct _GstAudioFXBaseIIRFilter
{
  GstAudioFilter audiofilter;

  /* < private > */
  GstAudioFXBaseIIRFilterProcessFunc process;

  gdouble *a;
  guint na;
  gdouble *b;
  guint nb;
  GstAudioFXBaseIIRFilterChannelCtx *channels;
  guint nchannels;

  GMutex lock;
};
</STRUCT>
<STRUCT>
<NAME>GstAudioFXBaseIIRFilterClass</NAME>
struct _GstAudioFXBaseIIRFilterClass
{
  GstAudioFilterClass parent;
};
</STRUCT>
<FUNCTION>
<NAME>gst_audio_fx_base_iir_filter_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_audio_fx_base_iir_filter_set_coefficients</NAME>
<RETURNS>void  </RETURNS>
GstAudioFXBaseIIRFilter *filter, gdouble *a, guint na, gdouble *b, guint nb
</FUNCTION>
<FUNCTION>
<NAME>gst_audio_fx_base_iir_filter_calculate_gain</NAME>
<RETURNS>gdouble  </RETURNS>
gdouble *a, guint na, gdouble *b, guint nb, gdouble zr, gdouble zi
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_AUDIO_FX_BASE_FIR_FILTER</NAME>
#define GST_TYPE_AUDIO_FX_BASE_FIR_FILTER \
  (gst_audio_fx_base_fir_filter_get_type())
</MACRO>
<MACRO>
<NAME>GST_AUDIO_FX_BASE_FIR_FILTER</NAME>
#define GST_AUDIO_FX_BASE_FIR_FILTER(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_AUDIO_FX_BASE_FIR_FILTER,GstAudioFXBaseFIRFilter))
</MACRO>
<MACRO>
<NAME>GST_AUDIO_FX_BASE_FIR_FILTER_CLASS</NAME>
#define GST_AUDIO_FX_BASE_FIR_FILTER_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_AUDIO_FX_BASE_FIR_FILTER,GstAudioFXBaseFIRFilterClass))
</MACRO>
<MACRO>
<NAME>GST_IS_AUDIO_FX_BASE_FIR_FILTER</NAME>
#define GST_IS_AUDIO_FX_BASE_FIR_FILTER(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_AUDIO_FX_BASE_FIR_FILTER))
</MACRO>
<MACRO>
<NAME>GST_IS_AUDIO_FX_BASE_FIR_FILTER_CLASS</NAME>
#define GST_IS_AUDIO_FX_BASE_FIR_FILTER_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_AUDIO_FX_BASE_FIR_FILTER))
</MACRO>
<USER_FUNCTION>
<NAME>GstAudioFXBaseFIRFilterProcessFunc</NAME>
<RETURNS>guint </RETURNS>
GstAudioFXBaseFIRFilter *, const guint8 *, guint8 *, guint
</USER_FUNCTION>
<STRUCT>
<NAME>GstAudioFXBaseFIRFilter</NAME>
struct _GstAudioFXBaseFIRFilter {
  GstAudioFilter element;

  /* properties */
  gdouble *kernel;              /* filter kernel -- time domain */
  guint kernel_length;          /* length of the filter kernel -- time domain */

  guint64 latency;              /* pre-latency of the filter kernel */
  gboolean low_latency;         /* work in slower low latency mode */

  gboolean drain_on_changes;    /* If the filter should be drained when
                                 * coeficients change */

  /* < private > */
  GstAudioFXBaseFIRFilterProcessFunc process;

  gdouble *buffer;              /* buffer for storing samples of previous buffers */
  guint buffer_fill;            /* fill level of buffer */
  guint buffer_length;          /* length of the buffer -- meaning depends on processing mode */

  /* FFT convolution specific data */
  GstFFTF64 *fft;
  GstFFTF64 *ifft;
  GstFFTF64Complex *frequency_response;  /* filter kernel -- frequency domain */
  guint frequency_response_length;       /* length of filter kernel -- frequency domain */
  GstFFTF64Complex *fft_buffer;          /* FFT buffer, has the length of the frequency response */
  guint block_length;                    /* Length of the processing blocks -- time domain */

  GstClockTime start_ts;        /* start timestamp after a discont */
  guint64 start_off;            /* start offset after a discont */
  guint64 nsamples_out;         /* number of output samples since last discont */
  guint64 nsamples_in;          /* number of input samples since last discont */

  GMutex lock;
};
</STRUCT>
<STRUCT>
<NAME>GstAudioFXBaseFIRFilterClass</NAME>
struct _GstAudioFXBaseFIRFilterClass {
  GstAudioFilterClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_audio_fx_base_fir_filter_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_audio_fx_base_fir_filter_set_kernel</NAME>
<RETURNS>void  </RETURNS>
GstAudioFXBaseFIRFilter *filter, gdouble *kernel, guint kernel_length, guint64 latency, const GstAudioInfo * info
</FUNCTION>
<FUNCTION>
<NAME>gst_audio_fx_base_fir_filter_push_residue</NAME>
<RETURNS>void  </RETURNS>
GstAudioFXBaseFIRFilter *filter
</FUNCTION>
<FUNCTION>
<NAME>asinh</NAME>
<RETURNS>gdouble </RETURNS>
gdouble x
</FUNCTION>
<FUNCTION>
<NAME>sinh</NAME>
<RETURNS>gdouble </RETURNS>
gdouble x
</FUNCTION>
<FUNCTION>
<NAME>cosh</NAME>
<RETURNS>gdouble </RETURNS>
gdouble x
</FUNCTION>
<MACRO>
<NAME>AMF0_NUMBER_MARKER</NAME>
#define AMF0_NUMBER_MARKER 0x0
</MACRO>
<MACRO>
<NAME>AMF0_BOOLEAN_MARKER</NAME>
#define AMF0_BOOLEAN_MARKER 0x1
</MACRO>
<MACRO>
<NAME>AMF0_STRING_MARKER</NAME>
#define AMF0_STRING_MARKER 0x2
</MACRO>
<MACRO>
<NAME>AMF0_OBJECT_MARKER</NAME>
#define AMF0_OBJECT_MARKER 0x3
</MACRO>
<MACRO>
<NAME>AMF0_MOVIECLIP_MARKER</NAME>
#define AMF0_MOVIECLIP_MARKER 0x4 /* Reserved, not supported */
</MACRO>
<MACRO>
<NAME>AMF0_NULL_MARKER</NAME>
#define AMF0_NULL_MARKER 0x5
</MACRO>
<MACRO>
<NAME>AMF0_UNDEFINED_MARKER</NAME>
#define AMF0_UNDEFINED_MARKER 0x6
</MACRO>
<MACRO>
<NAME>AMF0_REFERENCE_MARKER</NAME>
#define AMF0_REFERENCE_MARKER 0x7
</MACRO>
<MACRO>
<NAME>AMF0_ECMA_ARRAY_MARKER</NAME>
#define AMF0_ECMA_ARRAY_MARKER 0x8
</MACRO>
<MACRO>
<NAME>AMF0_OBJECT_END_MARKER</NAME>
#define AMF0_OBJECT_END_MARKER 0x9
</MACRO>
<MACRO>
<NAME>AMF0_STRICT_ARRAY_MARKER</NAME>
#define AMF0_STRICT_ARRAY_MARKER 0xA
</MACRO>
<MACRO>
<NAME>AMF0_DATE_MARKER</NAME>
#define AMF0_DATE_MARKER 0xB
</MACRO>
<MACRO>
<NAME>AMF0_LONG_STRING_MARKER</NAME>
#define AMF0_LONG_STRING_MARKER 0xC
</MACRO>
<MACRO>
<NAME>AMF0_UNSUPPORTED_MARKER</NAME>
#define AMF0_UNSUPPORTED_MARKER 0xD
</MACRO>
<MACRO>
<NAME>AMF0_RECORDSET_MARKER</NAME>
#define AMF0_RECORDSET_MARKER 0xE /* Reserved, not supported */
</MACRO>
<MACRO>
<NAME>AMF0_XML_DOCUMENT_MARKER</NAME>
#define AMF0_XML_DOCUMENT_MARKER 0xF
</MACRO>
<MACRO>
<NAME>AMF0_TYPED_OBJECT_MARKER</NAME>
#define AMF0_TYPED_OBJECT_MARKER 0x10
</MACRO>
<MACRO>
<NAME>GST_TYPE_INDEX</NAME>
#define GST_TYPE_INDEX                  (gst_index_get_type ())
</MACRO>
<MACRO>
<NAME>GST_INDEX</NAME>
#define GST_INDEX(obj)                  (G_TYPE_CHECK_INSTANCE_CAST ((obj), GST_TYPE_INDEX, GstIndex))
</MACRO>
<MACRO>
<NAME>GST_IS_INDEX</NAME>
#define GST_IS_INDEX(obj)               (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GST_TYPE_INDEX))
</MACRO>
<MACRO>
<NAME>GST_INDEX_CLASS</NAME>
#define GST_INDEX_CLASS(klass)          (G_TYPE_CHECK_CLASS_CAST ((klass), GST_TYPE_INDEX, GstIndexClass))
</MACRO>
<MACRO>
<NAME>GST_IS_INDEX_CLASS</NAME>
#define GST_IS_INDEX_CLASS(klass)       (G_TYPE_CHECK_CLASS_TYPE ((klass), GST_TYPE_INDEX))
</MACRO>
<MACRO>
<NAME>GST_INDEX_GET_CLASS</NAME>
#define GST_INDEX_GET_CLASS(obj)        (G_TYPE_INSTANCE_GET_CLASS ((obj), GST_TYPE_INDEX, GstIndexClass))
</MACRO>
<MACRO>
<NAME>GST_TYPE_INDEX_ENTRY</NAME>
#define GST_TYPE_INDEX_ENTRY            (gst_index_entry_get_type())
</MACRO>
<ENUM>
<NAME>GstIndexCertainty</NAME>
typedef enum {
  GST_INDEX_UNKNOWN,
  GST_INDEX_CERTAIN,
  GST_INDEX_FUZZY
} GstIndexCertainty;
</ENUM>
<ENUM>
<NAME>GstIndexEntryType</NAME>
typedef enum {
  GST_INDEX_ENTRY_ID,
  GST_INDEX_ENTRY_ASSOCIATION,
  GST_INDEX_ENTRY_OBJECT,
  GST_INDEX_ENTRY_FORMAT
} GstIndexEntryType;
</ENUM>
<ENUM>
<NAME>GstIndexLookupMethod</NAME>
typedef enum {
  GST_INDEX_LOOKUP_EXACT,
  GST_INDEX_LOOKUP_BEFORE,
  GST_INDEX_LOOKUP_AFTER
} GstIndexLookupMethod;
</ENUM>
<MACRO>
<NAME>GST_INDEX_NASSOCS</NAME>
#define GST_INDEX_NASSOCS(entry)                ((entry)->data.assoc.nassocs)
</MACRO>
<MACRO>
<NAME>GST_INDEX_ASSOC_FLAGS</NAME>
#define GST_INDEX_ASSOC_FLAGS(entry)            ((entry)->data.assoc.flags)
</MACRO>
<MACRO>
<NAME>GST_INDEX_ASSOC_FORMAT</NAME>
#define GST_INDEX_ASSOC_FORMAT(entry,i)         ((entry)->data.assoc.assocs[(i)].format)
</MACRO>
<MACRO>
<NAME>GST_INDEX_ASSOC_VALUE</NAME>
#define GST_INDEX_ASSOC_VALUE(entry,i)          ((entry)->data.assoc.assocs[(i)].value)
</MACRO>
<STRUCT>
<NAME>GstIndexAssociation</NAME>
struct _GstIndexAssociation {
  GstFormat     format;
  gint64        value;
};
</STRUCT>
<ENUM>
<NAME>GstIndexAssociationFlags</NAME>
typedef enum {
  GST_INDEX_ASSOCIATION_FLAG_NONE       = 0,
  GST_INDEX_ASSOCIATION_FLAG_KEY_UNIT   = (1 << 0),
  GST_INDEX_ASSOCIATION_FLAG_DELTA_UNIT = (1 << 1),

  /* new flags should start here */
  GST_INDEX_ASSOCIATION_FLAG_LAST     = (1 << 8)
} GstIndexAssociationFlags;
</ENUM>
<MACRO>
<NAME>GST_INDEX_FORMAT_FORMAT</NAME>
#define GST_INDEX_FORMAT_FORMAT(entry)          ((entry)->data.format.format)
</MACRO>
<MACRO>
<NAME>GST_INDEX_FORMAT_KEY</NAME>
#define GST_INDEX_FORMAT_KEY(entry)             ((entry)->data.format.key)
</MACRO>
<MACRO>
<NAME>GST_INDEX_ID_INVALID</NAME>
#define GST_INDEX_ID_INVALID                    (-1)
</MACRO>
<MACRO>
<NAME>GST_INDEX_ID_DESCRIPTION</NAME>
#define GST_INDEX_ID_DESCRIPTION(entry)         ((entry)->data.id.description)
</MACRO>
<STRUCT>
<NAME>GstIndexEntry</NAME>
struct _GstIndexEntry {
  /*< private >*/
  GstIndexEntryType      type;
  gint                   id;

  union {
    struct {
      gchar             *description;
    } id;
    struct {
      gint               nassocs;
      GstIndexAssociation
                        *assocs;
      GstIndexAssociationFlags      flags;
    } assoc;
    struct {
      gchar             *key;
      GType              type;
      gpointer           object;
    } object;
    struct {
      GstFormat          format;
      const gchar       *key;
    } format;
  } data;
};
</STRUCT>
<STRUCT>
<NAME>GstIndexGroup</NAME>
struct _GstIndexGroup {
  /*< private >*/
  /* unique ID of group in index */
  gint groupnum;

  /* list of entries */
  GList *entries;

  /* the certainty level of the group */
  GstIndexCertainty certainty;

  /* peer group that contains more certain entries */
  gint peergroup;
};
</STRUCT>
<USER_FUNCTION>
<NAME>GstIndexFilter</NAME>
<RETURNS>gboolean </RETURNS>
GstIndex *index,
                                                         GstIndexEntry *entry,
                                                         gpointer user_data
</USER_FUNCTION>
<ENUM>
<NAME>GstIndexResolverMethod</NAME>
typedef enum {
  GST_INDEX_RESOLVER_CUSTOM,
  GST_INDEX_RESOLVER_GTYPE,
  GST_INDEX_RESOLVER_PATH
} GstIndexResolverMethod;
</ENUM>
<USER_FUNCTION>
<NAME>GstIndexResolver</NAME>
<RETURNS>gboolean </RETURNS>
GstIndex *index,
                                                         GstObject *writer,
                                                         gchar **writer_string,
                                                         gpointer user_data
</USER_FUNCTION>
<ENUM>
<NAME>GstIndexFlags</NAME>
typedef enum {
  GST_INDEX_WRITABLE    = (GST_OBJECT_FLAG_LAST << 0),
  GST_INDEX_READABLE    = (GST_OBJECT_FLAG_LAST << 1),

  GST_INDEX_FLAG_LAST   = (GST_OBJECT_FLAG_LAST << 8)
} GstIndexFlags;
</ENUM>
<MACRO>
<NAME>GST_INDEX_IS_READABLE</NAME>
#define GST_INDEX_IS_READABLE(obj)    (GST_OBJECT_FLAG_IS_SET (obj, GST_INDEX_READABLE))
</MACRO>
<MACRO>
<NAME>GST_INDEX_IS_WRITABLE</NAME>
#define GST_INDEX_IS_WRITABLE(obj)    (GST_OBJECT_FLAG_IS_SET (obj, GST_INDEX_WRITABLE))
</MACRO>
<STRUCT>
<NAME>GstIndex</NAME>
struct _GstIndex {
  GstObject              object;

  /*< private >*/
  GList                 *groups;
  GstIndexGroup         *curgroup;
  gint                   maxgroup;

  GstIndexResolverMethod method;
  GstIndexResolver       resolver;
  gpointer               resolver_user_data;
  GDestroyNotify         resolver_user_data_destroy;

  GstIndexFilter         filter;
  gpointer               filter_user_data;
  GDestroyNotify         filter_user_data_destroy;

  GHashTable            *writers;
  gint                   last_id;

  /*< private >*/
  gpointer _gst_reserved[GST_PADDING];
};
</STRUCT>
<STRUCT>
<NAME>GstIndexClass</NAME>
struct _GstIndexClass {
  GstObjectClass parent_class;

  /*< protected >*/
  gboolean      (*get_writer_id)        (GstIndex *index, gint *id, gchar *writer);

  void          (*commit)               (GstIndex *index, gint id);

  /* abstract methods */
  void          (*add_entry)            (GstIndex *index, GstIndexEntry *entry);

  GstIndexEntry* (*get_assoc_entry)     (GstIndex *index, gint id,
                                         GstIndexLookupMethod method, GstIndexAssociationFlags flags,
                                         GstFormat format, gint64 value,
                                         GCompareDataFunc func,
                                         gpointer user_data);
  /* signals */
  void          (*entry_added)          (GstIndex *index, GstIndexEntry *entry);

  /*< private >*/
  gpointer _gst_reserved[GST_PADDING];
};
</STRUCT>
<FUNCTION>
<NAME>gst_index_get_type</NAME>
<RETURNS>GType                    </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_index_new</NAME>
<RETURNS>GstIndex *               </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_index_commit</NAME>
<RETURNS>void                     </RETURNS>
GstIndex *index, gint id
</FUNCTION>
<FUNCTION>
<NAME>gst_index_get_group</NAME>
<RETURNS>gint                     </RETURNS>
GstIndex *index
</FUNCTION>
<FUNCTION>
<NAME>gst_index_new_group</NAME>
<RETURNS>gint                     </RETURNS>
GstIndex *index
</FUNCTION>
<FUNCTION>
<NAME>gst_index_set_group</NAME>
<RETURNS>gboolean                 </RETURNS>
GstIndex *index, gint groupnum
</FUNCTION>
<FUNCTION>
<NAME>gst_index_set_certainty</NAME>
<RETURNS>void                     </RETURNS>
GstIndex *index, GstIndexCertainty certainty
</FUNCTION>
<FUNCTION>
<NAME>gst_index_get_certainty</NAME>
<RETURNS>GstIndexCertainty        </RETURNS>
GstIndex *index
</FUNCTION>
<FUNCTION>
<NAME>gst_index_set_filter</NAME>
<RETURNS>void                     </RETURNS>
GstIndex *index, GstIndexFilter filter, gpointer user_data
</FUNCTION>
<FUNCTION>
<NAME>gst_index_set_filter_full</NAME>
<RETURNS>void                     </RETURNS>
GstIndex *index, GstIndexFilter filter, gpointer user_data, GDestroyNotify user_data_destroy
</FUNCTION>
<FUNCTION>
<NAME>gst_index_set_resolver</NAME>
<RETURNS>void                     </RETURNS>
GstIndex *index, GstIndexResolver resolver, gpointer user_data
</FUNCTION>
<FUNCTION>
<NAME>gst_index_set_resolver_full</NAME>
<RETURNS>void                     </RETURNS>
GstIndex *index, GstIndexResolver resolver, gpointer user_data, GDestroyNotify user_data_destroy
</FUNCTION>
<FUNCTION>
<NAME>gst_index_get_writer_id</NAME>
<RETURNS>gboolean                 </RETURNS>
GstIndex *index, GstObject *writer, gint *id
</FUNCTION>
<FUNCTION>
<NAME>gst_index_add_format</NAME>
<RETURNS>GstIndexEntry *          </RETURNS>
GstIndex *index, gint id, GstFormat format
</FUNCTION>
<FUNCTION>
<NAME>gst_index_add_associationv</NAME>
<RETURNS>GstIndexEntry *          </RETURNS>
GstIndex * index, gint id, GstIndexAssociationFlags flags, gint n, const GstIndexAssociation * list
</FUNCTION>
<FUNCTION>
<NAME>gst_index_add_association</NAME>
<RETURNS>GstIndexEntry *          </RETURNS>
GstIndex *index, gint id, GstIndexAssociationFlags flags, GstFormat format, gint64 value, ...) GstIndexEntry*          gst_index_add_object            (GstIndex *index, gint id, gchar *key, GType type, gpointer object
</FUNCTION>
<FUNCTION>
<NAME>gst_index_add_id</NAME>
<RETURNS>GstIndexEntry *          </RETURNS>
GstIndex *index, gint id, gchar *description
</FUNCTION>
<FUNCTION>
<NAME>gst_index_get_assoc_entry</NAME>
<RETURNS>GstIndexEntry *          </RETURNS>
GstIndex *index, gint id, GstIndexLookupMethod method, GstIndexAssociationFlags flags, GstFormat format, gint64 value
</FUNCTION>
<FUNCTION>
<NAME>gst_index_get_assoc_entry_full</NAME>
<RETURNS>GstIndexEntry *          </RETURNS>
GstIndex *index, gint id, GstIndexLookupMethod method, GstIndexAssociationFlags flags, GstFormat format, gint64 value, GCompareDataFunc func, gpointer user_data
</FUNCTION>
<FUNCTION>
<NAME>gst_index_entry_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_index_entry_copy</NAME>
<RETURNS>GstIndexEntry  *         </RETURNS>
GstIndexEntry *entry
</FUNCTION>
<FUNCTION>
<NAME>gst_index_entry_free</NAME>
<RETURNS>void                     </RETURNS>
GstIndexEntry *entry
</FUNCTION>
<FUNCTION>
<NAME>gst_index_entry_assoc_map</NAME>
<RETURNS>gboolean                 </RETURNS>
GstIndexEntry *entry, GstFormat format, gint64 *value
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_RTP_RTX_QUEUE</NAME>
#define GST_TYPE_RTP_RTX_QUEUE (gst_rtp_rtx_queue_get_type())
</MACRO>
<MACRO>
<NAME>GST_RTP_RTX_QUEUE</NAME>
#define GST_RTP_RTX_QUEUE(obj) (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_RTP_RTX_QUEUE, GstRTPRtxQueue))
</MACRO>
<MACRO>
<NAME>GST_RTP_RTX_QUEUE_CLASS</NAME>
#define GST_RTP_RTX_QUEUE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_RTP_RTX_QUEUE, GstRTPRtxQueueClass))
</MACRO>
<MACRO>
<NAME>GST_RTP_RTX_QUEUE_GET_CLASS</NAME>
#define GST_RTP_RTX_QUEUE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), GST_TYPE_RTP_RTX_QUEUE, GstRTPRtxQueueClass))
</MACRO>
<MACRO>
<NAME>GST_IS_RTP_RTX_QUEUE</NAME>
#define GST_IS_RTP_RTX_QUEUE(obj) (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_RTP_RTX_QUEUE))
</MACRO>
<MACRO>
<NAME>GST_IS_RTP_RTX_QUEUE_CLASS</NAME>
#define GST_IS_RTP_RTX_QUEUE_CLASS(obj) (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_RTP_RTX_QUEUE))
</MACRO>
<STRUCT>
<NAME>GstRTPRtxQueue</NAME>
struct _GstRTPRtxQueue
{
  GstElement element;

  /* pad */
  GstPad *sinkpad;
  GstPad *srcpad;

  GMutex lock;
  GQueue *queue;
  GList *pending;

  guint max_size_time;
  guint max_size_packets;

  GstSegment head_segment;
  GstSegment tail_segment;

  /* Statistics */
  guint n_requests;
  guint n_fulfilled_requests;
};
</STRUCT>
<STRUCT>
<NAME>GstRTPRtxQueueClass</NAME>
struct _GstRTPRtxQueueClass
{
  GstElementClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_rtp_rtx_queue_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_rtp_rtx_queue_plugin_init</NAME>
<RETURNS>gboolean  </RETURNS>
GstPlugin * plugin
</FUNCTION>
<STRUCT>
<NAME>RTPSenderReport</NAME>
typedef struct {
  gboolean is_valid;
  guint64 ntptime;
  guint32 rtptime;
  guint32 packet_count;
  guint32 octet_count;
  GstClockTime time;
} RTPSenderReport;
</STRUCT>
<STRUCT>
<NAME>RTPReceiverReport</NAME>
typedef struct {
  gboolean is_valid;
  guint32 ssrc; /* who the report is from */
  guint8  fractionlost;
  guint32 packetslost;
  guint32 exthighestseq;
  guint32 jitter;
  guint32 lsr;
  guint32 dlsr;
  guint32 round_trip;
} RTPReceiverReport;
</STRUCT>
<STRUCT>
<NAME>RTPPacketInfo</NAME>
typedef struct {
  gboolean      send;
  gboolean      rtp;
  gboolean      is_list;
  gpointer      data;
  GSocketAddress *address;
  GstClockTime  current_time;
  GstClockTime  running_time;
  guint64       ntpnstime;
  guint         header_len;
  guint         bytes;
  guint         packets;
  guint         payload_len;
  guint32       ssrc;
  guint16       seqnum;
  guint8        pt;
  guint32       rtptime;
  guint32       csrc_count;
  guint32       csrcs[16];
} RTPPacketInfo;
</STRUCT>
<STRUCT>
<NAME>RTPSourceStats</NAME>
typedef struct {
  guint64      packets_received;
  guint64      octets_received;
  guint64      bytes_received;

  guint32      prev_expected;
  guint32      prev_received;

  guint16      max_seq;
  guint64      cycles;
  guint32      base_seq;
  guint32      bad_seq;
  guint32      transit;
  guint32      jitter;

  guint64      packets_sent;
  guint64      octets_sent;

  guint        sent_pli_count;
  guint        recv_pli_count;
  guint        sent_fir_count;
  guint        recv_fir_count;
  guint        sent_nack_count;
  guint        recv_nack_count;

  /* when we received stuff */
  GstClockTime prev_rtptime;
  GstClockTime prev_rtcptime;
  GstClockTime last_rtptime;
  GstClockTime last_rtcptime;

  /* sender and receiver reports */
  gint              curr_rr;
  RTPReceiverReport rr[2];
  gint              curr_sr;
  RTPSenderReport   sr[2];
} RTPSourceStats;
</STRUCT>
<MACRO>
<NAME>RTP_STATS_BANDWIDTH</NAME>
#define RTP_STATS_BANDWIDTH           64000
</MACRO>
<MACRO>
<NAME>RTP_STATS_RTCP_FRACTION</NAME>
#define RTP_STATS_RTCP_FRACTION       0.05
</MACRO>
<MACRO>
<NAME>RTP_STATS_MIN_INTERVAL</NAME>
#define RTP_STATS_MIN_INTERVAL      5.0
</MACRO>
<MACRO>
<NAME>RTP_STATS_SENDER_FRACTION</NAME>
#define RTP_STATS_SENDER_FRACTION       (0.25)
</MACRO>
<MACRO>
<NAME>RTP_STATS_RECEIVER_FRACTION</NAME>
#define RTP_STATS_RECEIVER_FRACTION     (1.0 - RTP_STATS_SENDER_FRACTION)
</MACRO>
<MACRO>
<NAME>RTP_STATS_BYE_TIMEOUT</NAME>
#define RTP_STATS_BYE_TIMEOUT           (2 * GST_SECOND)
</MACRO>
<MACRO>
<NAME>RTP_DEF_DROPOUT</NAME>
#define RTP_DEF_DROPOUT      3000
</MACRO>
<MACRO>
<NAME>RTP_MIN_DROPOUT</NAME>
#define RTP_MIN_DROPOUT      30
</MACRO>
<MACRO>
<NAME>RTP_DEF_MISORDER</NAME>
#define RTP_DEF_MISORDER     100
</MACRO>
<MACRO>
<NAME>RTP_MIN_MISORDER</NAME>
#define RTP_MIN_MISORDER     10
</MACRO>
<STRUCT>
<NAME>RTPPacketRateCtx</NAME>
typedef struct {
  gboolean probed;
  guint32 clock_rate;
  guint16 last_seqnum;
  guint64 last_ts;
  guint32 avg_packet_rate;
} RTPPacketRateCtx;
</STRUCT>
<FUNCTION>
<NAME>gst_rtp_packet_rate_ctx_reset</NAME>
<RETURNS>void  </RETURNS>
RTPPacketRateCtx * ctx, guint32 clock_rate
</FUNCTION>
<FUNCTION>
<NAME>gst_rtp_packet_rate_ctx_update</NAME>
<RETURNS>guint32  </RETURNS>
RTPPacketRateCtx *ctx, guint16 seqnum, guint32 ts
</FUNCTION>
<FUNCTION>
<NAME>gst_rtp_packet_rate_ctx_get</NAME>
<RETURNS>guint32  </RETURNS>
RTPPacketRateCtx *ctx
</FUNCTION>
<FUNCTION>
<NAME>gst_rtp_packet_rate_ctx_get_max_dropout</NAME>
<RETURNS>guint32  </RETURNS>
RTPPacketRateCtx *ctx, gint32 time_ms
</FUNCTION>
<FUNCTION>
<NAME>gst_rtp_packet_rate_ctx_get_max_misorder</NAME>
<RETURNS>guint32  </RETURNS>
RTPPacketRateCtx *ctx, gint32 time_ms
</FUNCTION>
<STRUCT>
<NAME>RTPSessionStats</NAME>
typedef struct {
  guint         bandwidth;
  guint         rtcp_bandwidth;
  gdouble       sender_fraction;
  gdouble       receiver_fraction;
  gdouble       min_interval;
  GstClockTime  bye_timeout;
  guint         internal_sources;
  guint         sender_sources;
  guint         internal_sender_sources;
  guint         active_sources;
  guint         avg_rtcp_packet_size;
  guint         bye_members;
  guint         nacks_dropped;
  guint         nacks_sent;
  guint         nacks_received;
} RTPSessionStats;
</STRUCT>
<FUNCTION>
<NAME>rtp_stats_init_defaults</NAME>
<RETURNS>void            </RETURNS>
RTPSessionStats *stats
</FUNCTION>
<FUNCTION>
<NAME>rtp_stats_set_bandwidths</NAME>
<RETURNS>void            </RETURNS>
RTPSessionStats *stats, guint rtp_bw, gdouble rtcp_bw, guint rs, guint rr
</FUNCTION>
<FUNCTION>
<NAME>rtp_stats_calculate_rtcp_interval</NAME>
<RETURNS>GstClockTime    </RETURNS>
RTPSessionStats *stats, gboolean sender, GstRTPProfile profile, gboolean ptp, gboolean first
</FUNCTION>
<FUNCTION>
<NAME>rtp_stats_add_rtcp_jitter</NAME>
<RETURNS>GstClockTime    </RETURNS>
RTPSessionStats *stats, GstClockTime interval
</FUNCTION>
<FUNCTION>
<NAME>rtp_stats_calculate_bye_interval</NAME>
<RETURNS>GstClockTime    </RETURNS>
RTPSessionStats *stats
</FUNCTION>
<FUNCTION>
<NAME>rtp_stats_get_packets_lost</NAME>
<RETURNS>gint64          </RETURNS>
const RTPSourceStats *stats
</FUNCTION>
<FUNCTION>
<NAME>rtp_stats_set_min_interval</NAME>
<RETURNS>void            </RETURNS>
RTPSessionStats *stats, gdouble min_interval
</FUNCTION>
<MACRO>
<NAME>RTP_NO_PROBATION</NAME>
#define RTP_NO_PROBATION        0
</MACRO>
<MACRO>
<NAME>RTP_DEFAULT_PROBATION</NAME>
#define RTP_DEFAULT_PROBATION   2
</MACRO>
<MACRO>
<NAME>RTP_SEQ_MOD</NAME>
#define RTP_SEQ_MOD          (1 << 16)
</MACRO>
<MACRO>
<NAME>RTP_TYPE_SOURCE</NAME>
#define RTP_TYPE_SOURCE             (rtp_source_get_type())
</MACRO>
<MACRO>
<NAME>RTP_SOURCE</NAME>
#define RTP_SOURCE(src)             (G_TYPE_CHECK_INSTANCE_CAST((src),RTP_TYPE_SOURCE,RTPSource))
</MACRO>
<MACRO>
<NAME>RTP_SOURCE_CLASS</NAME>
#define RTP_SOURCE_CLASS(klass)     (G_TYPE_CHECK_CLASS_CAST((klass),RTP_TYPE_SOURCE,RTPSourceClass))
</MACRO>
<MACRO>
<NAME>RTP_IS_SOURCE</NAME>
#define RTP_IS_SOURCE(src)          (G_TYPE_CHECK_INSTANCE_TYPE((src),RTP_TYPE_SOURCE))
</MACRO>
<MACRO>
<NAME>RTP_IS_SOURCE_CLASS</NAME>
#define RTP_IS_SOURCE_CLASS(klass)  (G_TYPE_CHECK_CLASS_TYPE((klass),RTP_TYPE_SOURCE))
</MACRO>
<MACRO>
<NAME>RTP_SOURCE_CAST</NAME>
#define RTP_SOURCE_CAST(src)        ((RTPSource *)(src))
</MACRO>
<MACRO>
<NAME>RTP_SOURCE_IS_ACTIVE</NAME>
#define RTP_SOURCE_IS_ACTIVE(src)  (src->validated && !src->marked_bye)
</MACRO>
<MACRO>
<NAME>RTP_SOURCE_IS_SENDER</NAME>
#define RTP_SOURCE_IS_SENDER(src)  (src->is_sender)
</MACRO>
<MACRO>
<NAME>RTP_SOURCE_IS_MARKED_BYE</NAME>
#define RTP_SOURCE_IS_MARKED_BYE(src)  (src->marked_bye)
</MACRO>
<USER_FUNCTION>
<NAME>RTPSourcePushRTP</NAME>
<RETURNS>GstFlowReturn </RETURNS>
RTPSource *src, gpointer data,
	gpointer user_data
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>RTPSourceClockRate</NAME>
<RETURNS>gint </RETURNS>
RTPSource *src, guint8 payload, gpointer user_data
</USER_FUNCTION>
<STRUCT>
<NAME>RTPSourceCallbacks</NAME>
typedef struct {
  RTPSourcePushRTP     push_rtp;
  RTPSourceClockRate   clock_rate;
} RTPSourceCallbacks;
</STRUCT>
<STRUCT>
<NAME>RTPConflictingAddress</NAME>
typedef struct {
  GSocketAddress *address;
  GstClockTime time;
} RTPConflictingAddress;
</STRUCT>
<STRUCT>
<NAME>RTPSource</NAME>
struct _RTPSource {
  GObject       object;

  /*< private >*/
  guint32       ssrc;

  guint16       generation;
  GHashTable    *reported_in_sr_of;     /* set of SSRCs */

  guint         probation;
  guint         curr_probation;
  gboolean      validated;
  gboolean      internal;
  gboolean      is_csrc;
  gboolean      is_sender;
  gboolean      closing;

  GstStructure  *sdes;

  gboolean      marked_bye;
  gchar        *bye_reason;
  gboolean      sent_bye;

  GSocketAddress *rtp_from;
  GSocketAddress *rtcp_from;

  gint          payload;
  GstCaps      *caps;
  gint          clock_rate;
  gint32        seqnum_offset;

  GstClockTime  bye_time;
  GstClockTime  last_activity;
  GstClockTime  last_rtp_activity;

  GstClockTime  last_rtime;
  GstClockTime  last_rtptime;

  /* for bitrate estimation */
  guint64       bitrate;
  GstClockTime  prev_rtime;
  guint64       bytes_sent;
  guint64       bytes_received;

  GQueue       *packets;
  RTPPacketRateCtx packet_rate_ctx;
  guint32       max_dropout_time;
  guint32       max_misorder_time;

  RTPSourceCallbacks callbacks;
  gpointer           user_data;

  RTPSourceStats stats;
  RTPReceiverReport last_rr;

  GList         *conflicting_addresses;

  GQueue        *retained_feedback;

  gboolean     send_pli;
  gboolean     send_fir;
  guint8       current_send_fir_seqnum;
  gint         last_fir_count;
  GstClockTime last_keyframe_request;

  gboolean     send_nack;
  GArray      *nacks;

  gboolean      pt_set;
  guint8        pt;
};
</STRUCT>
<STRUCT>
<NAME>RTPSourceClass</NAME>
struct _RTPSourceClass {
  GObjectClass   parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>rtp_source_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>rtp_source_new</NAME>
<RETURNS>RTPSource *      </RETURNS>
guint32 ssrc
</FUNCTION>
<FUNCTION>
<NAME>rtp_source_set_callbacks</NAME>
<RETURNS>void             </RETURNS>
RTPSource *src, RTPSourceCallbacks *cb, gpointer data
</FUNCTION>
<FUNCTION>
<NAME>rtp_source_get_ssrc</NAME>
<RETURNS>guint32          </RETURNS>
RTPSource *src
</FUNCTION>
<FUNCTION>
<NAME>rtp_source_set_as_csrc</NAME>
<RETURNS>void             </RETURNS>
RTPSource *src
</FUNCTION>
<FUNCTION>
<NAME>rtp_source_is_as_csrc</NAME>
<RETURNS>gboolean         </RETURNS>
RTPSource *src
</FUNCTION>
<FUNCTION>
<NAME>rtp_source_is_active</NAME>
<RETURNS>gboolean         </RETURNS>
RTPSource *src
</FUNCTION>
<FUNCTION>
<NAME>rtp_source_is_validated</NAME>
<RETURNS>gboolean         </RETURNS>
RTPSource *src
</FUNCTION>
<FUNCTION>
<NAME>rtp_source_is_sender</NAME>
<RETURNS>gboolean         </RETURNS>
RTPSource *src
</FUNCTION>
<FUNCTION>
<NAME>rtp_source_mark_bye</NAME>
<RETURNS>void             </RETURNS>
RTPSource *src, const gchar *reason
</FUNCTION>
<FUNCTION>
<NAME>rtp_source_is_marked_bye</NAME>
<RETURNS>gboolean         </RETURNS>
RTPSource *src
</FUNCTION>
<FUNCTION>
<NAME>rtp_source_get_bye_reason</NAME>
<RETURNS>gchar  *         </RETURNS>
RTPSource *src
</FUNCTION>
<FUNCTION>
<NAME>rtp_source_update_caps</NAME>
<RETURNS>void             </RETURNS>
RTPSource *src, GstCaps *caps
</FUNCTION>
<FUNCTION>
<NAME>rtp_source_get_sdes_struct</NAME>
<RETURNS>const GstStructure  *</RETURNS>
RTPSource * src
</FUNCTION>
<FUNCTION>
<NAME>rtp_source_set_sdes_struct</NAME>
<RETURNS>gboolean         </RETURNS>
RTPSource * src, GstStructure *sdes
</FUNCTION>
<FUNCTION>
<NAME>rtp_source_set_rtp_from</NAME>
<RETURNS>void             </RETURNS>
RTPSource *src, GSocketAddress *address
</FUNCTION>
<FUNCTION>
<NAME>rtp_source_set_rtcp_from</NAME>
<RETURNS>void             </RETURNS>
RTPSource *src, GSocketAddress *address
</FUNCTION>
<FUNCTION>
<NAME>rtp_source_process_rtp</NAME>
<RETURNS>GstFlowReturn    </RETURNS>
RTPSource *src, RTPPacketInfo *pinfo
</FUNCTION>
<FUNCTION>
<NAME>rtp_source_send_rtp</NAME>
<RETURNS>GstFlowReturn    </RETURNS>
RTPSource *src, RTPPacketInfo *pinfo
</FUNCTION>
<FUNCTION>
<NAME>rtp_source_process_sr</NAME>
<RETURNS>void             </RETURNS>
RTPSource *src, GstClockTime time, guint64 ntptime, guint32 rtptime, guint32 packet_count, guint32 octet_count
</FUNCTION>
<FUNCTION>
<NAME>rtp_source_process_rb</NAME>
<RETURNS>void             </RETURNS>
RTPSource *src, guint64 ntpnstime, guint8 fractionlost, gint32 packetslost, guint32 exthighestseq, guint32 jitter, guint32 lsr, guint32 dlsr
</FUNCTION>
<FUNCTION>
<NAME>rtp_source_get_new_sr</NAME>
<RETURNS>gboolean         </RETURNS>
RTPSource *src, guint64 ntpnstime, GstClockTime running_time, guint64 *ntptime, guint32 *rtptime, guint32 *packet_count, guint32 *octet_count
</FUNCTION>
<FUNCTION>
<NAME>rtp_source_get_new_rb</NAME>
<RETURNS>gboolean         </RETURNS>
RTPSource *src, GstClockTime time, guint8 *fractionlost, gint32 *packetslost, guint32 *exthighestseq, guint32 *jitter, guint32 *lsr, guint32 *dlsr
</FUNCTION>
<FUNCTION>
<NAME>rtp_source_get_last_sr</NAME>
<RETURNS>gboolean         </RETURNS>
RTPSource *src, GstClockTime *time, guint64 *ntptime, guint32 *rtptime, guint32 *packet_count, guint32 *octet_count
</FUNCTION>
<FUNCTION>
<NAME>rtp_source_get_last_rb</NAME>
<RETURNS>gboolean         </RETURNS>
RTPSource *src, guint8 *fractionlost, gint32 *packetslost, guint32 *exthighestseq, guint32 *jitter, guint32 *lsr, guint32 *dlsr, guint32 *round_trip
</FUNCTION>
<FUNCTION>
<NAME>rtp_source_reset</NAME>
<RETURNS>void             </RETURNS>
RTPSource * src
</FUNCTION>
<FUNCTION>
<NAME>rtp_source_find_conflicting_address</NAME>
<RETURNS>gboolean         </RETURNS>
RTPSource * src, GSocketAddress *address, GstClockTime time
</FUNCTION>
<FUNCTION>
<NAME>rtp_source_add_conflicting_address</NAME>
<RETURNS>void             </RETURNS>
RTPSource * src, GSocketAddress *address, GstClockTime time
</FUNCTION>
<FUNCTION>
<NAME>find_conflicting_address</NAME>
<RETURNS>gboolean         </RETURNS>
GList * conflicting_address, GSocketAddress * address, GstClockTime time
</FUNCTION>
<FUNCTION>
<NAME>add_conflicting_address</NAME>
<RETURNS>GList  *         </RETURNS>
GList * conflicting_addresses, GSocketAddress * address, GstClockTime time
</FUNCTION>
<FUNCTION>
<NAME>timeout_conflicting_addresses</NAME>
<RETURNS>GList  *         </RETURNS>
GList * conflicting_addresses, GstClockTime current_time
</FUNCTION>
<FUNCTION>
<NAME>rtp_conflicting_address_free</NAME>
<RETURNS>void             </RETURNS>
RTPConflictingAddress * addr
</FUNCTION>
<FUNCTION>
<NAME>rtp_source_timeout</NAME>
<RETURNS>void             </RETURNS>
RTPSource * src, GstClockTime current_time, GstClockTime feedback_retention_window
</FUNCTION>
<FUNCTION>
<NAME>rtp_source_retain_rtcp_packet</NAME>
<RETURNS>void             </RETURNS>
RTPSource * src, GstRTCPPacket *pkt, GstClockTime running_time
</FUNCTION>
<FUNCTION>
<NAME>rtp_source_has_retained</NAME>
<RETURNS>gboolean         </RETURNS>
RTPSource * src, GCompareFunc func, gconstpointer data
</FUNCTION>
<FUNCTION>
<NAME>rtp_source_register_nack</NAME>
<RETURNS>void             </RETURNS>
RTPSource * src, guint16 seqnum
</FUNCTION>
<FUNCTION>
<NAME>rtp_source_get_nacks</NAME>
<RETURNS>guint32  *       </RETURNS>
RTPSource * src, guint *n_nacks
</FUNCTION>
<FUNCTION>
<NAME>rtp_source_clear_nacks</NAME>
<RETURNS>void             </RETURNS>
RTPSource * src
</FUNCTION>
<MACRO>
<NAME>RTP_TYPE_SESSION</NAME>
#define RTP_TYPE_SESSION             (rtp_session_get_type())
</MACRO>
<MACRO>
<NAME>RTP_SESSION</NAME>
#define RTP_SESSION(sess)            (G_TYPE_CHECK_INSTANCE_CAST((sess),RTP_TYPE_SESSION,RTPSession))
</MACRO>
<MACRO>
<NAME>RTP_SESSION_CLASS</NAME>
#define RTP_SESSION_CLASS(klass)     (G_TYPE_CHECK_CLASS_CAST((klass),RTP_TYPE_SESSION,RTPSessionClass))
</MACRO>
<MACRO>
<NAME>RTP_IS_SESSION</NAME>
#define RTP_IS_SESSION(sess)         (G_TYPE_CHECK_INSTANCE_TYPE((sess),RTP_TYPE_SESSION))
</MACRO>
<MACRO>
<NAME>RTP_IS_SESSION_CLASS</NAME>
#define RTP_IS_SESSION_CLASS(klass)  (G_TYPE_CHECK_CLASS_TYPE((klass),RTP_TYPE_SESSION))
</MACRO>
<MACRO>
<NAME>RTP_SESSION_CAST</NAME>
#define RTP_SESSION_CAST(sess)       ((RTPSession *)(sess))
</MACRO>
<MACRO>
<NAME>RTP_SESSION_LOCK</NAME>
#define RTP_SESSION_LOCK(sess)     (g_mutex_lock (&(sess)->lock))
</MACRO>
<MACRO>
<NAME>RTP_SESSION_UNLOCK</NAME>
#define RTP_SESSION_UNLOCK(sess)   (g_mutex_unlock (&(sess)->lock))
</MACRO>
<USER_FUNCTION>
<NAME>RTPSessionProcessRTP</NAME>
<RETURNS>GstFlowReturn </RETURNS>
RTPSession *sess, RTPSource *src, GstBuffer *buffer, gpointer user_data
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>RTPSessionSendRTP</NAME>
<RETURNS>GstFlowReturn </RETURNS>
RTPSession *sess, RTPSource *src, gpointer data, gpointer user_data
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>RTPSessionSendRTCP</NAME>
<RETURNS>GstFlowReturn </RETURNS>
RTPSession *sess, RTPSource *src, GstBuffer *buffer,
    gboolean eos, gpointer user_data
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>RTPSessionSyncRTCP</NAME>
<RETURNS>GstFlowReturn </RETURNS>
RTPSession *sess, GstBuffer *buffer, gpointer user_data
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>RTPSessionClockRate</NAME>
<RETURNS>gint </RETURNS>
RTPSession *sess, guint8 payload, gpointer user_data
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>RTPSessionReconsider</NAME>
<RETURNS>void </RETURNS>
RTPSession *sess, gpointer user_data
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>RTPSessionRequestKeyUnit</NAME>
<RETURNS>void </RETURNS>
RTPSession *sess, guint32 ssrc,
    gboolean all_headers, gpointer user_data
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>RTPSessionRequestTime</NAME>
<RETURNS>GstClockTime </RETURNS>
RTPSession *sess,
    gpointer user_data
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>RTPSessionNotifyNACK</NAME>
<RETURNS>void </RETURNS>
RTPSession *sess,
    guint16 seqnum, guint16 blp, guint32 ssrc, gpointer user_data
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>RTPSessionReconfigure</NAME>
<RETURNS>void </RETURNS>
RTPSession *sess, gpointer user_data
</USER_FUNCTION>
<STRUCT>
<NAME>RTPSessionCallbacks</NAME>
typedef struct {
  RTPSessionProcessRTP  process_rtp;
  RTPSessionSendRTP     send_rtp;
  RTPSessionSyncRTCP    sync_rtcp;
  RTPSessionSendRTCP    send_rtcp;
  RTPSessionClockRate   clock_rate;
  RTPSessionReconsider  reconsider;
  RTPSessionRequestKeyUnit request_key_unit;
  RTPSessionRequestTime request_time;
  RTPSessionNotifyNACK  notify_nack;
  RTPSessionReconfigure reconfigure;
} RTPSessionCallbacks;
</STRUCT>
<STRUCT>
<NAME>RTPSession</NAME>
struct _RTPSession {
  GObject       object;

  GMutex        lock;

  guint         header_len;
  guint         mtu;

  GstStructure *sdes;

  guint         probation;
  guint32       max_dropout_time;
  guint32       max_misorder_time;

  GstRTPProfile rtp_profile;

  gboolean      reduced_size_rtcp;

  /* bandwidths */
  gboolean     recalc_bandwidth;
  guint        bandwidth;
  gdouble      rtcp_bandwidth;
  guint        rtcp_rr_bandwidth;
  guint        rtcp_rs_bandwidth;

  guint32       suggested_ssrc;
  gboolean      internal_ssrc_set;
  gboolean      internal_ssrc_from_caps_or_property;

  /* for sender/receiver counting */
  guint32       key;
  guint32       mask_idx;
  guint32       mask;
  GHashTable   *ssrcs[32];
  guint         total_sources;

  guint16       generation;
  GstClockTime  next_rtcp_check_time; /* tn */
  GstClockTime  last_rtcp_check_time; /* tp */
  GstClockTime  last_rtcp_send_time;  /* t_rr_last */
  GstClockTime  last_rtcp_interval;   /* T_rr */
  GstClockTime  start_time;
  gboolean      first_rtcp;
  gboolean      allow_early;

  GstClockTime  next_early_rtcp_time;

  gboolean      scheduled_bye;

  RTPSessionCallbacks   callbacks;
  gpointer              process_rtp_user_data;
  gpointer              send_rtp_user_data;
  gpointer              send_rtcp_user_data;
  gpointer              sync_rtcp_user_data;
  gpointer              clock_rate_user_data;
  gpointer              reconsider_user_data;
  gpointer              request_key_unit_user_data;
  gpointer              request_time_user_data;
  gpointer              notify_nack_user_data;
  gpointer              reconfigure_user_data;

  RTPSessionStats stats;
  RTPSessionStats bye_stats;

  gboolean      favor_new;
  GstClockTime  rtcp_feedback_retention_window;
  guint         rtcp_immediate_feedback_threshold;

  gboolean      is_doing_ptp;

  GList         *conflicting_addresses;
};
</STRUCT>
<STRUCT>
<NAME>RTPSessionClass</NAME>
struct _RTPSessionClass {
  GObjectClass   parent_class;

  /* action signals */
  RTPSource* (*get_source_by_ssrc) (RTPSession *sess, guint32 ssrc);

  /* signals */
  void (*on_new_ssrc)       (RTPSession *sess, RTPSource *source);
  void (*on_ssrc_collision) (RTPSession *sess, RTPSource *source);
  void (*on_ssrc_validated) (RTPSession *sess, RTPSource *source);
  void (*on_ssrc_active)    (RTPSession *sess, RTPSource *source);
  void (*on_ssrc_sdes)      (RTPSession *sess, RTPSource *source);
  void (*on_bye_ssrc)       (RTPSession *sess, RTPSource *source);
  void (*on_bye_timeout)    (RTPSession *sess, RTPSource *source);
  void (*on_timeout)        (RTPSession *sess, RTPSource *source);
  void (*on_sender_timeout) (RTPSession *sess, RTPSource *source);
  gboolean (*on_sending_rtcp) (RTPSession *sess, GstBuffer *buffer,
      gboolean early);
  void (*on_app_rtcp)       (RTPSession *sess, guint subtype, guint ssrc,
      const gchar *name, GstBuffer *data);
  void (*on_feedback_rtcp)  (RTPSession *sess, guint type, guint fbtype,
      guint sender_ssrc, guint media_ssrc, GstBuffer *fci);
  gboolean (*send_rtcp)     (RTPSession *sess, GstClockTime max_delay);
  void (*on_receiving_rtcp) (RTPSession *sess, GstBuffer *buffer);
  void (*on_new_sender_ssrc)     (RTPSession *sess, RTPSource *source);
  void (*on_sender_ssrc_active)  (RTPSession *sess, RTPSource *source);
};
</STRUCT>
<FUNCTION>
<NAME>rtp_session_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>rtp_session_new</NAME>
<RETURNS>RTPSession *     </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>rtp_session_set_callbacks</NAME>
<RETURNS>void             </RETURNS>
RTPSession *sess, RTPSessionCallbacks *callbacks, gpointer user_data
</FUNCTION>
<FUNCTION>
<NAME>rtp_session_set_process_rtp_callback</NAME>
<RETURNS>void             </RETURNS>
RTPSession * sess, RTPSessionProcessRTP callback, gpointer user_data
</FUNCTION>
<FUNCTION>
<NAME>rtp_session_set_send_rtp_callback</NAME>
<RETURNS>void             </RETURNS>
RTPSession * sess, RTPSessionSendRTP callback, gpointer user_data
</FUNCTION>
<FUNCTION>
<NAME>rtp_session_set_send_rtcp_callback</NAME>
<RETURNS>void             </RETURNS>
RTPSession * sess, RTPSessionSendRTCP callback, gpointer user_data
</FUNCTION>
<FUNCTION>
<NAME>rtp_session_set_sync_rtcp_callback</NAME>
<RETURNS>void             </RETURNS>
RTPSession * sess, RTPSessionSyncRTCP callback, gpointer user_data
</FUNCTION>
<FUNCTION>
<NAME>rtp_session_set_clock_rate_callback</NAME>
<RETURNS>void             </RETURNS>
RTPSession * sess, RTPSessionClockRate callback, gpointer user_data
</FUNCTION>
<FUNCTION>
<NAME>rtp_session_set_reconsider_callback</NAME>
<RETURNS>void             </RETURNS>
RTPSession * sess, RTPSessionReconsider callback, gpointer user_data
</FUNCTION>
<FUNCTION>
<NAME>rtp_session_set_request_time_callback</NAME>
<RETURNS>void             </RETURNS>
RTPSession * sess, RTPSessionRequestTime callback, gpointer user_data
</FUNCTION>
<FUNCTION>
<NAME>rtp_session_set_bandwidth</NAME>
<RETURNS>void             </RETURNS>
RTPSession *sess, gdouble bandwidth
</FUNCTION>
<FUNCTION>
<NAME>rtp_session_get_bandwidth</NAME>
<RETURNS>gdouble          </RETURNS>
RTPSession *sess
</FUNCTION>
<FUNCTION>
<NAME>rtp_session_set_rtcp_fraction</NAME>
<RETURNS>void             </RETURNS>
RTPSession *sess, gdouble fraction
</FUNCTION>
<FUNCTION>
<NAME>rtp_session_get_rtcp_fraction</NAME>
<RETURNS>gdouble          </RETURNS>
RTPSession *sess
</FUNCTION>
<FUNCTION>
<NAME>rtp_session_get_sdes_struct</NAME>
<RETURNS>GstStructure  *  </RETURNS>
RTPSession *sess
</FUNCTION>
<FUNCTION>
<NAME>rtp_session_set_sdes_struct</NAME>
<RETURNS>void             </RETURNS>
RTPSession *sess, const GstStructure *sdes
</FUNCTION>
<FUNCTION>
<NAME>rtp_session_suggest_ssrc</NAME>
<RETURNS>guint32          </RETURNS>
RTPSession *sess, gboolean *is_random
</FUNCTION>
<FUNCTION>
<NAME>rtp_session_add_source</NAME>
<RETURNS>gboolean         </RETURNS>
RTPSession *sess, RTPSource *src
</FUNCTION>
<FUNCTION>
<NAME>rtp_session_get_num_sources</NAME>
<RETURNS>guint            </RETURNS>
RTPSession *sess
</FUNCTION>
<FUNCTION>
<NAME>rtp_session_get_num_active_sources</NAME>
<RETURNS>guint            </RETURNS>
RTPSession *sess
</FUNCTION>
<FUNCTION>
<NAME>rtp_session_get_source_by_ssrc</NAME>
<RETURNS>RTPSource *      </RETURNS>
RTPSession *sess, guint32 ssrc
</FUNCTION>
<FUNCTION>
<NAME>rtp_session_create_source</NAME>
<RETURNS>RTPSource *      </RETURNS>
RTPSession *sess
</FUNCTION>
<FUNCTION>
<NAME>rtp_session_process_rtp</NAME>
<RETURNS>GstFlowReturn    </RETURNS>
RTPSession *sess, GstBuffer *buffer, GstClockTime current_time, GstClockTime running_time, guint64 ntpnstime
</FUNCTION>
<FUNCTION>
<NAME>rtp_session_process_rtcp</NAME>
<RETURNS>GstFlowReturn    </RETURNS>
RTPSession *sess, GstBuffer *buffer, GstClockTime current_time, guint64 ntpnstime
</FUNCTION>
<FUNCTION>
<NAME>rtp_session_update_send_caps</NAME>
<RETURNS>void             </RETURNS>
RTPSession *sess, GstCaps *caps
</FUNCTION>
<FUNCTION>
<NAME>rtp_session_send_rtp</NAME>
<RETURNS>GstFlowReturn    </RETURNS>
RTPSession *sess, gpointer data, gboolean is_list, GstClockTime current_time, GstClockTime running_time
</FUNCTION>
<FUNCTION>
<NAME>rtp_session_mark_all_bye</NAME>
<RETURNS>void             </RETURNS>
RTPSession *sess, const gchar *reason
</FUNCTION>
<FUNCTION>
<NAME>rtp_session_schedule_bye</NAME>
<RETURNS>GstFlowReturn    </RETURNS>
RTPSession *sess, GstClockTime current_time
</FUNCTION>
<FUNCTION>
<NAME>rtp_session_next_timeout</NAME>
<RETURNS>GstClockTime     </RETURNS>
RTPSession *sess, GstClockTime current_time
</FUNCTION>
<FUNCTION>
<NAME>rtp_session_on_timeout</NAME>
<RETURNS>GstFlowReturn    </RETURNS>
RTPSession *sess, GstClockTime current_time, guint64 ntpnstime, GstClockTime running_time
</FUNCTION>
<FUNCTION>
<NAME>rtp_session_request_early_rtcp</NAME>
<RETURNS>gboolean         </RETURNS>
RTPSession * sess, GstClockTime current_time, GstClockTime max_delay
</FUNCTION>
<FUNCTION>
<NAME>rtp_session_request_key_unit</NAME>
<RETURNS>gboolean         </RETURNS>
RTPSession * sess, guint32 ssrc, gboolean fir, gint count
</FUNCTION>
<FUNCTION>
<NAME>rtp_session_request_nack</NAME>
<RETURNS>gboolean         </RETURNS>
RTPSession * sess, guint32 ssrc, guint16 seqnum, GstClockTime max_delay
</FUNCTION>
<MACRO>
<NAME>RTP_TYPE_JITTER_BUFFER</NAME>
#define RTP_TYPE_JITTER_BUFFER             (rtp_jitter_buffer_get_type())
</MACRO>
<MACRO>
<NAME>RTP_JITTER_BUFFER</NAME>
#define RTP_JITTER_BUFFER(src)             (G_TYPE_CHECK_INSTANCE_CAST((src),RTP_TYPE_JITTER_BUFFER,RTPJitterBuffer))
</MACRO>
<MACRO>
<NAME>RTP_JITTER_BUFFER_CLASS</NAME>
#define RTP_JITTER_BUFFER_CLASS(klass)     (G_TYPE_CHECK_CLASS_CAST((klass),RTP_TYPE_JITTER_BUFFER,RTPJitterBufferClass))
</MACRO>
<MACRO>
<NAME>RTP_IS_JITTER_BUFFER</NAME>
#define RTP_IS_JITTER_BUFFER(src)          (G_TYPE_CHECK_INSTANCE_TYPE((src),RTP_TYPE_JITTER_BUFFER))
</MACRO>
<MACRO>
<NAME>RTP_IS_JITTER_BUFFER_CLASS</NAME>
#define RTP_IS_JITTER_BUFFER_CLASS(klass)  (G_TYPE_CHECK_CLASS_TYPE((klass),RTP_TYPE_JITTER_BUFFER))
</MACRO>
<MACRO>
<NAME>RTP_JITTER_BUFFER_CAST</NAME>
#define RTP_JITTER_BUFFER_CAST(src)        ((RTPJitterBuffer *)(src))
</MACRO>
<ENUM>
<NAME>RTPJitterBufferMode</NAME>
typedef enum {
  RTP_JITTER_BUFFER_MODE_NONE    = 0,
  RTP_JITTER_BUFFER_MODE_SLAVE   = 1,
  RTP_JITTER_BUFFER_MODE_BUFFER  = 2,
  /* FIXME 3 is missing because it was used for 'auto' in jitterbuffer */
  RTP_JITTER_BUFFER_MODE_SYNCED  = 4,
  RTP_JITTER_BUFFER_MODE_LAST
} RTPJitterBufferMode;
</ENUM>
<MACRO>
<NAME>RTP_TYPE_JITTER_BUFFER_MODE</NAME>
#define RTP_TYPE_JITTER_BUFFER_MODE (rtp_jitter_buffer_mode_get_type())
</MACRO>
<FUNCTION>
<NAME>rtp_jitter_buffer_mode_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>RTP_JITTER_BUFFER_MAX_WINDOW</NAME>
#define RTP_JITTER_BUFFER_MAX_WINDOW 512
</MACRO>
<STRUCT>
<NAME>RTPJitterBuffer</NAME>
struct _RTPJitterBuffer {
  GObject        object;

  GQueue        *packets;

  RTPJitterBufferMode mode;

  GstClockTime   delay;

  /* for buffering */
  gboolean          buffering;
  guint64           low_level;
  guint64           high_level;

  /* for calculating skew */
  gboolean       need_resync;
  GstClockTime   base_time;
  GstClockTime   base_rtptime;
  GstClockTime   media_clock_base_time;
  guint32        clock_rate;
  GstClockTime   base_extrtp;
  GstClockTime   prev_out_time;
  guint64        ext_rtptime;
  guint64        last_rtptime;
  gint64         window[RTP_JITTER_BUFFER_MAX_WINDOW];
  guint          window_pos;
  guint          window_size;
  gboolean       window_filling;
  gint64         window_min;
  gint64         skew;
  gint64         prev_send_diff;
  gboolean       buffering_disabled;

  GMutex         clock_lock;
  GstClock      *pipeline_clock;
  GstClock      *media_clock;
  gulong         media_clock_synced_id;
  guint64        media_clock_offset;

  gboolean       rfc7273_sync;
};
</STRUCT>
<STRUCT>
<NAME>RTPJitterBufferClass</NAME>
struct _RTPJitterBufferClass {
  GObjectClass   parent_class;
};
</STRUCT>
<STRUCT>
<NAME>RTPJitterBufferItem</NAME>
struct _RTPJitterBufferItem {
  gpointer data;
  GList *next;
  GList *prev;
  guint type;
  GstClockTime dts;
  GstClockTime pts;
  guint seqnum;
  guint count;
  guint rtptime;
};
</STRUCT>
<FUNCTION>
<NAME>rtp_jitter_buffer_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>rtp_jitter_buffer_new</NAME>
<RETURNS>RTPJitterBuffer *      </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>rtp_jitter_buffer_get_mode</NAME>
<RETURNS>RTPJitterBufferMode    </RETURNS>
RTPJitterBuffer *jbuf
</FUNCTION>
<FUNCTION>
<NAME>rtp_jitter_buffer_set_mode</NAME>
<RETURNS>void                   </RETURNS>
RTPJitterBuffer *jbuf, RTPJitterBufferMode mode
</FUNCTION>
<FUNCTION>
<NAME>rtp_jitter_buffer_get_delay</NAME>
<RETURNS>GstClockTime           </RETURNS>
RTPJitterBuffer *jbuf
</FUNCTION>
<FUNCTION>
<NAME>rtp_jitter_buffer_set_delay</NAME>
<RETURNS>void                   </RETURNS>
RTPJitterBuffer *jbuf, GstClockTime delay
</FUNCTION>
<FUNCTION>
<NAME>rtp_jitter_buffer_set_clock_rate</NAME>
<RETURNS>void                   </RETURNS>
RTPJitterBuffer *jbuf, guint32 clock_rate
</FUNCTION>
<FUNCTION>
<NAME>rtp_jitter_buffer_get_clock_rate</NAME>
<RETURNS>guint32                </RETURNS>
RTPJitterBuffer *jbuf
</FUNCTION>
<FUNCTION>
<NAME>rtp_jitter_buffer_set_media_clock</NAME>
<RETURNS>void                   </RETURNS>
RTPJitterBuffer *jbuf, GstClock * clock, guint64 clock_offset
</FUNCTION>
<FUNCTION>
<NAME>rtp_jitter_buffer_set_pipeline_clock</NAME>
<RETURNS>void                   </RETURNS>
RTPJitterBuffer *jbuf, GstClock * clock
</FUNCTION>
<FUNCTION>
<NAME>rtp_jitter_buffer_get_rfc7273_sync</NAME>
<RETURNS>gboolean               </RETURNS>
RTPJitterBuffer *jbuf
</FUNCTION>
<FUNCTION>
<NAME>rtp_jitter_buffer_set_rfc7273_sync</NAME>
<RETURNS>void                   </RETURNS>
RTPJitterBuffer *jbuf, gboolean rfc7273_sync
</FUNCTION>
<FUNCTION>
<NAME>rtp_jitter_buffer_reset_skew</NAME>
<RETURNS>void                   </RETURNS>
RTPJitterBuffer *jbuf
</FUNCTION>
<FUNCTION>
<NAME>rtp_jitter_buffer_insert</NAME>
<RETURNS>gboolean               </RETURNS>
RTPJitterBuffer *jbuf, RTPJitterBufferItem *item, gboolean *head, gint *percent
</FUNCTION>
<FUNCTION>
<NAME>rtp_jitter_buffer_disable_buffering</NAME>
<RETURNS>void                   </RETURNS>
RTPJitterBuffer *jbuf, gboolean disabled
</FUNCTION>
<FUNCTION>
<NAME>rtp_jitter_buffer_peek</NAME>
<RETURNS>RTPJitterBufferItem  * </RETURNS>
RTPJitterBuffer *jbuf
</FUNCTION>
<FUNCTION>
<NAME>rtp_jitter_buffer_pop</NAME>
<RETURNS>RTPJitterBufferItem  * </RETURNS>
RTPJitterBuffer *jbuf, gint *percent
</FUNCTION>
<FUNCTION>
<NAME>rtp_jitter_buffer_flush</NAME>
<RETURNS>void                   </RETURNS>
RTPJitterBuffer *jbuf, GFunc free_func, gpointer user_data
</FUNCTION>
<FUNCTION>
<NAME>rtp_jitter_buffer_is_buffering</NAME>
<RETURNS>gboolean               </RETURNS>
RTPJitterBuffer * jbuf
</FUNCTION>
<FUNCTION>
<NAME>rtp_jitter_buffer_set_buffering</NAME>
<RETURNS>void                   </RETURNS>
RTPJitterBuffer * jbuf, gboolean buffering
</FUNCTION>
<FUNCTION>
<NAME>rtp_jitter_buffer_get_percent</NAME>
<RETURNS>gint                   </RETURNS>
RTPJitterBuffer * jbuf
</FUNCTION>
<FUNCTION>
<NAME>rtp_jitter_buffer_num_packets</NAME>
<RETURNS>guint                  </RETURNS>
RTPJitterBuffer *jbuf
</FUNCTION>
<FUNCTION>
<NAME>rtp_jitter_buffer_get_ts_diff</NAME>
<RETURNS>guint32                </RETURNS>
RTPJitterBuffer *jbuf
</FUNCTION>
<FUNCTION>
<NAME>rtp_jitter_buffer_get_sync</NAME>
<RETURNS>void                   </RETURNS>
RTPJitterBuffer *jbuf, guint64 *rtptime, guint64 *timestamp, guint32 *clock_rate, guint64 *last_rtptime
</FUNCTION>
<FUNCTION>
<NAME>rtp_jitter_buffer_calculate_pts</NAME>
<RETURNS>GstClockTime           </RETURNS>
RTPJitterBuffer * jbuf, GstClockTime dts, gboolean estimated_dts, guint32 rtptime, GstClockTime base_time
</FUNCTION>
<MACRO>
<NAME>LZO_INPUT_DEPLETED</NAME>
#define LZO_INPUT_DEPLETED 1
</MACRO>
<MACRO>
<NAME>LZO_OUTPUT_FULL</NAME>
#define LZO_OUTPUT_FULL 2
</MACRO>
<MACRO>
<NAME>LZO_INVALID_BACKPTR</NAME>
#define LZO_INVALID_BACKPTR 4
</MACRO>
<MACRO>
<NAME>LZO_ERROR</NAME>
#define LZO_ERROR 8
</MACRO>
<MACRO>
<NAME>LZO_INPUT_PADDING</NAME>
#define LZO_INPUT_PADDING 8
</MACRO>
<MACRO>
<NAME>LZO_OUTPUT_PADDING</NAME>
#define LZO_OUTPUT_PADDING 12
</MACRO>
<FUNCTION>
<NAME>lzo1x_decode</NAME>
<RETURNS>int  </RETURNS>
void *out, int *outlen, const void *in, int *inlen
</FUNCTION>
<ENUM>
<NAME>GstMatroskaReadState</NAME>
typedef enum {
  GST_MATROSKA_READ_STATE_START,
  GST_MATROSKA_READ_STATE_SEGMENT,
  GST_MATROSKA_READ_STATE_HEADER,
  GST_MATROSKA_READ_STATE_DATA,
  GST_MATROSKA_READ_STATE_SEEK,
  GST_MATROSKA_READ_STATE_SCANNING
} GstMatroskaReadState;
</ENUM>
<STRUCT>
<NAME>GstMatroskaReadCommon</NAME>
typedef struct _GstMatroskaReadCommon {
#if 0
  GstIndex                *element_index;
  gint                     element_index_writer_id;
#endif

  /* pads */
  GstPad                  *sinkpad;
  GPtrArray               *src;
  guint                    num_streams;

  /* metadata */
  gchar                   *muxing_app;
  gchar                   *writing_app;
  gint64                   created;

  /* state */
  GstMatroskaReadState     state;

  /* stream type */
  gboolean                 is_webm;
  gboolean                 has_video;

  /* did we parse cues/tracks/segmentinfo already? */
  gboolean                 index_parsed;
  gboolean                 segmentinfo_parsed;
  gboolean                 attachments_parsed;
  gboolean                 chapters_parsed;
  GList                   *tags_parsed;

  /* chapters stuff */
  GstToc                  *toc;
  gboolean                toc_updated;

  /* start-of-segment and length */
  guint64                  ebml_segment_start;
  guint64                  ebml_segment_length;

  /* a cue (index) table */
  GArray                  *index;

  /* timescale in the file */
  guint64                  time_scale;

  /* keeping track of playback position */
  GstSegment               segment;

  GstTagList              *global_tags;
  gboolean                 global_tags_changed;

  /* pull mode caching */
  GstBuffer *cached_buffer;
  guint8 *cached_data;
  GstMapInfo cached_map;

  /* push and pull mode */
  guint64                  offset;

  guint64                  start_resync_offset;

  /* state to restore after scanning for invalid data */
  gint                     state_to_restore;

  /* push based mode usual suspects */
  GstAdapter              *adapter;

  /* cache for track tags that forward-reference their tracks */
  GHashTable *cached_track_taglists ;
 
} GstMatroskaReadCommon;
</STRUCT>
<FUNCTION>
<NAME>gst_matroska_decode_content_encodings</NAME>
<RETURNS>GstFlowReturn  </RETURNS>
GArray * encodings
</FUNCTION>
<FUNCTION>
<NAME>gst_matroska_decode_data</NAME>
<RETURNS>gboolean  </RETURNS>
GArray * encodings, gpointer * data_out, gsize * size_out, GstMatroskaTrackEncodingScope scope, gboolean free
</FUNCTION>
<FUNCTION>
<NAME>gst_matroska_index_seek_find</NAME>
<RETURNS>gint  </RETURNS>
GstMatroskaIndex * i1, GstClockTime * time, gpointer user_data
</FUNCTION>
<FUNCTION>
<NAME>gst_matroska_read_common_do_index_seek</NAME>
<RETURNS>GstMatroskaIndex  * </RETURNS>
 GstMatroskaReadCommon * common, GstMatroskaTrackContext * track, gint64 seek_pos, GArray ** _index, gint * _entry_index, GstSearchMode snap_dir
</FUNCTION>
<FUNCTION>
<NAME>gst_matroska_read_common_found_global_tag</NAME>
<RETURNS>void  </RETURNS>
GstMatroskaReadCommon * common, GstElement * el, GstTagList * taglist
</FUNCTION>
<FUNCTION>
<NAME>gst_matroska_read_common_get_length</NAME>
<RETURNS>gint64  </RETURNS>
GstMatroskaReadCommon * common
</FUNCTION>
<FUNCTION>
<NAME>gst_matroska_read_common_get_seek_track</NAME>
<RETURNS>GstMatroskaTrackContext  * </RETURNS>
 GstMatroskaReadCommon * common, GstMatroskaTrackContext * track
</FUNCTION>
<FUNCTION>
<NAME>gst_matroska_read_common_parse_index</NAME>
<RETURNS>GstFlowReturn  </RETURNS>
GstMatroskaReadCommon * common, GstEbmlRead * ebml
</FUNCTION>
<FUNCTION>
<NAME>gst_matroska_read_common_parse_info</NAME>
<RETURNS>GstFlowReturn  </RETURNS>
GstMatroskaReadCommon * common, GstElement * el, GstEbmlRead * ebml
</FUNCTION>
<FUNCTION>
<NAME>gst_matroska_read_common_parse_attachments</NAME>
<RETURNS>GstFlowReturn  </RETURNS>
 GstMatroskaReadCommon * common, GstElement * el, GstEbmlRead * ebml
</FUNCTION>
<FUNCTION>
<NAME>gst_matroska_read_common_parse_chapters</NAME>
<RETURNS>GstFlowReturn  </RETURNS>
GstMatroskaReadCommon * common, GstEbmlRead * ebml
</FUNCTION>
<FUNCTION>
<NAME>gst_matroska_read_common_parse_header</NAME>
<RETURNS>GstFlowReturn  </RETURNS>
GstMatroskaReadCommon * common, GstEbmlRead * ebml
</FUNCTION>
<FUNCTION>
<NAME>gst_matroska_read_common_parse_metadata</NAME>
<RETURNS>GstFlowReturn  </RETURNS>
GstMatroskaReadCommon * common, GstElement * el, GstEbmlRead * ebml
</FUNCTION>
<FUNCTION>
<NAME>gst_matroska_read_common_parse_skip</NAME>
<RETURNS>GstFlowReturn  </RETURNS>
GstMatroskaReadCommon * common, GstEbmlRead * ebml, const gchar * parent_name, guint id
</FUNCTION>
<FUNCTION>
<NAME>gst_matroska_read_common_peek_bytes</NAME>
<RETURNS>GstFlowReturn  </RETURNS>
GstMatroskaReadCommon * common, guint64 offset, guint size, GstBuffer ** p_buf, guint8 ** bytes
</FUNCTION>
<FUNCTION>
<NAME>gst_matroska_read_common_peek_id_length_pull</NAME>
<RETURNS>GstFlowReturn  </RETURNS>
GstMatroskaReadCommon * common, GstElement * el, guint32 * _id, guint64 * _length, guint * _needed
</FUNCTION>
<FUNCTION>
<NAME>gst_matroska_read_common_peek_id_length_push</NAME>
<RETURNS>GstFlowReturn  </RETURNS>
GstMatroskaReadCommon * common, GstElement * el, guint32 * _id, guint64 * _length, guint * _needed
</FUNCTION>
<FUNCTION>
<NAME>gst_matroska_read_common_stream_from_num</NAME>
<RETURNS>gint  </RETURNS>
GstMatroskaReadCommon * common, guint track_num
</FUNCTION>
<FUNCTION>
<NAME>gst_matroska_read_common_read_track_encodings</NAME>
<RETURNS>GstFlowReturn  </RETURNS>
 GstMatroskaReadCommon * common, GstEbmlRead * ebml, GstMatroskaTrackContext * context
</FUNCTION>
<FUNCTION>
<NAME>gst_matroska_read_common_reset_streams</NAME>
<RETURNS>void  </RETURNS>
GstMatroskaReadCommon * common, GstClockTime time, gboolean full
</FUNCTION>
<FUNCTION>
<NAME>gst_matroska_read_common_free_parsed_el</NAME>
<RETURNS>void  </RETURNS>
gpointer mem, gpointer user_data
</FUNCTION>
<FUNCTION>
<NAME>gst_matroska_read_common_init</NAME>
<RETURNS>void  </RETURNS>
GstMatroskaReadCommon * ctx
</FUNCTION>
<FUNCTION>
<NAME>gst_matroska_read_common_finalize</NAME>
<RETURNS>void  </RETURNS>
GstMatroskaReadCommon * ctx
</FUNCTION>
<FUNCTION>
<NAME>gst_matroska_read_common_reset</NAME>
<RETURNS>void  </RETURNS>
GstElement * element, GstMatroskaReadCommon * ctx
</FUNCTION>
<FUNCTION>
<NAME>gst_matroska_read_common_tracknumber_unique</NAME>
<RETURNS>gboolean  </RETURNS>
GstMatroskaReadCommon * common, guint64 num
</FUNCTION>
<MACRO>
<NAME>GST_EBML_VERSION</NAME>
#define GST_EBML_VERSION 1
</MACRO>
<MACRO>
<NAME>GST_EBML_SIZE_UNKNOWN</NAME>
#define GST_EBML_SIZE_UNKNOWN          G_GINT64_CONSTANT(0x00ffffffffffffff)
</MACRO>
<MACRO>
<NAME>GST_EBML_ID_HEADER</NAME>
#define GST_EBML_ID_HEADER             0x1A45DFA3
</MACRO>
<MACRO>
<NAME>GST_EBML_ID_EBMLVERSION</NAME>
#define GST_EBML_ID_EBMLVERSION        0x4286
</MACRO>
<MACRO>
<NAME>GST_EBML_ID_EBMLREADVERSION</NAME>
#define GST_EBML_ID_EBMLREADVERSION    0x42F7
</MACRO>
<MACRO>
<NAME>GST_EBML_ID_EBMLMAXIDLENGTH</NAME>
#define GST_EBML_ID_EBMLMAXIDLENGTH    0x42F2
</MACRO>
<MACRO>
<NAME>GST_EBML_ID_EBMLMAXSIZELENGTH</NAME>
#define GST_EBML_ID_EBMLMAXSIZELENGTH  0x42F3
</MACRO>
<MACRO>
<NAME>GST_EBML_ID_DOCTYPE</NAME>
#define GST_EBML_ID_DOCTYPE            0x4282
</MACRO>
<MACRO>
<NAME>GST_EBML_ID_DOCTYPEVERSION</NAME>
#define GST_EBML_ID_DOCTYPEVERSION     0x4287
</MACRO>
<MACRO>
<NAME>GST_EBML_ID_DOCTYPEREADVERSION</NAME>
#define GST_EBML_ID_DOCTYPEREADVERSION 0x4285
</MACRO>
<MACRO>
<NAME>GST_EBML_ID_VOID</NAME>
#define GST_EBML_ID_VOID               0xEC
</MACRO>
<MACRO>
<NAME>GST_EBML_ID_CRC32</NAME>
#define GST_EBML_ID_CRC32              0xBF
</MACRO>
<MACRO>
<NAME>GST_EBML_DATE_OFFSET</NAME>
#define GST_EBML_DATE_OFFSET           978307200
</MACRO>
<MACRO>
<NAME>GST_TYPE_MATROSKA_PARSE</NAME>
#define GST_TYPE_MATROSKA_PARSE \
  (gst_matroska_parse_get_type ())
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_PARSE</NAME>
#define GST_MATROSKA_PARSE(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST ((obj), GST_TYPE_MATROSKA_PARSE, GstMatroskaParse))
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_PARSE_CLASS</NAME>
#define GST_MATROSKA_PARSE_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST ((klass), GST_TYPE_MATROSKA_PARSE, GstMatroskaParseClass))
</MACRO>
<MACRO>
<NAME>GST_IS_MATROSKA_PARSE</NAME>
#define GST_IS_MATROSKA_PARSE(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GST_TYPE_MATROSKA_PARSE))
</MACRO>
<MACRO>
<NAME>GST_IS_MATROSKA_PARSE_CLASS</NAME>
#define GST_IS_MATROSKA_PARSE_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE ((klass), GST_TYPE_MATROSKA_PARSE))
</MACRO>
<STRUCT>
<NAME>GstMatroskaParse</NAME>
typedef struct _GstMatroskaParse {
  GstElement              parent;

  /* < private > */

  GstMatroskaReadCommon    common;

  /* pads */
  GstPad                  *srcpad;
  GstClock                *clock;
  guint                    num_v_streams;
  guint                    num_a_streams;
  guint                    num_t_streams;

  GstBuffer *streamheader;
  gboolean pushed_headers;
  GstClockTime last_timestamp;

  /* state */
  //gboolean                 streaming;
  guint64                  seek_block;
  gboolean                 seek_first;

  /* did we parse cues/tracks/segmentinfo already? */
  gboolean                 tracks_parsed;
  GList                   *seek_parsed;

  /* keeping track of playback position */
  gboolean                 segment_running;
  GstClockTime             last_stop_end;

  GstEvent                *close_segment;
  GstEvent                *new_segment;

  /* some state saving */
  GstClockTime             cluster_time;
  guint64                  cluster_offset;
  guint64                  first_cluster_offset;
  guint64                  next_cluster_offset;

  /* index stuff */
  gboolean                 seekable;
  gboolean                 building_index;
  guint64                  index_offset;
  GstEvent                *seek_event;
  gboolean                 need_newsegment;

  /* reverse playback */
  GArray                  *seek_index;
  gint                     seek_entry;
} GstMatroskaParse;
</STRUCT>
<STRUCT>
<NAME>GstMatroskaParseClass</NAME>
typedef struct _GstMatroskaParseClass {
  GstElementClass parent;
} GstMatroskaParseClass;
</STRUCT>
<FUNCTION>
<NAME>gst_matroska_parse_plugin_init</NAME>
<RETURNS>gboolean  </RETURNS>
GstPlugin *plugin
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_EBML_WRITE</NAME>
#define GST_TYPE_EBML_WRITE \
  (gst_ebml_write_get_type ())
</MACRO>
<MACRO>
<NAME>GST_EBML_WRITE</NAME>
#define GST_EBML_WRITE(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST ((obj), GST_TYPE_EBML_WRITE, GstEbmlWrite))
</MACRO>
<MACRO>
<NAME>GST_EBML_WRITE_CLASS</NAME>
#define GST_EBML_WRITE_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST ((klass), GST_TYPE_EBML_WRITE, GstEbmlWriteClass))
</MACRO>
<MACRO>
<NAME>GST_IS_EBML_WRITE</NAME>
#define GST_IS_EBML_WRITE(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GST_TYPE_EBML_WRITE))
</MACRO>
<MACRO>
<NAME>GST_IS_EBML_WRITE_CLASS</NAME>
#define GST_IS_EBML_WRITE_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE ((klass), GST_TYPE_EBML_WRITE))
</MACRO>
<MACRO>
<NAME>GST_EBML_WRITE_GET_CLASS</NAME>
#define GST_EBML_WRITE_GET_CLASS(obj) \
  (G_TYPE_INSTANCE_GET_CLASS ((obj), GST_TYPE_EBML_WRITE, GstEbmlWriteClass))
</MACRO>
<STRUCT>
<NAME>GstEbmlWrite</NAME>
typedef struct _GstEbmlWrite {
  GstObject object;

  GstPad *srcpad;
  guint64 pos;
  guint64 last_pos;
  GstClockTime timestamp;

  GstByteWriter *cache;
  guint64 cache_pos;

  GstFlowReturn last_write_result;

  gboolean writing_streamheader;
  GstByteWriter *streamheader;
  guint64 streamheader_pos;

  GstCaps *caps;

  gboolean streamable;
} GstEbmlWrite;
</STRUCT>
<STRUCT>
<NAME>GstEbmlWriteClass</NAME>
typedef struct _GstEbmlWriteClass {
  GstObjectClass parent;
} GstEbmlWriteClass;
</STRUCT>
<FUNCTION>
<NAME>gst_ebml_write_get_type</NAME>
<RETURNS>GType    </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_ebml_write_new</NAME>
<RETURNS>GstEbmlWrite  *</RETURNS>
GstPad *srcpad
</FUNCTION>
<FUNCTION>
<NAME>gst_ebml_write_reset</NAME>
<RETURNS>void     </RETURNS>
GstEbmlWrite *ebml
</FUNCTION>
<FUNCTION>
<NAME>gst_ebml_last_write_result</NAME>
<RETURNS>GstFlowReturn  </RETURNS>
GstEbmlWrite *ebml
</FUNCTION>
<FUNCTION>
<NAME>gst_ebml_start_streamheader</NAME>
<RETURNS>void     </RETURNS>
GstEbmlWrite *ebml
</FUNCTION>
<FUNCTION>
<NAME>gst_ebml_stop_streamheader</NAME>
<RETURNS>GstBuffer *    </RETURNS>
GstEbmlWrite *ebml
</FUNCTION>
<FUNCTION>
<NAME>gst_ebml_write_set_cache</NAME>
<RETURNS>void     </RETURNS>
GstEbmlWrite *ebml, guint         size
</FUNCTION>
<FUNCTION>
<NAME>gst_ebml_write_flush_cache</NAME>
<RETURNS>void     </RETURNS>
GstEbmlWrite *ebml, gboolean is_keyframe, GstClockTime timestamp
</FUNCTION>
<FUNCTION>
<NAME>gst_ebml_write_seek</NAME>
<RETURNS>void     </RETURNS>
GstEbmlWrite *ebml, guint64       pos
</FUNCTION>
<FUNCTION>
<NAME>gst_ebml_write_uint</NAME>
<RETURNS>void     </RETURNS>
GstEbmlWrite *ebml, guint32       id, guint64       num
</FUNCTION>
<FUNCTION>
<NAME>gst_ebml_write_sint</NAME>
<RETURNS>void     </RETURNS>
GstEbmlWrite *ebml, guint32       id, gint64        num
</FUNCTION>
<FUNCTION>
<NAME>gst_ebml_write_float</NAME>
<RETURNS>void     </RETURNS>
GstEbmlWrite *ebml, guint32       id, gdouble       num
</FUNCTION>
<FUNCTION>
<NAME>gst_ebml_write_ascii</NAME>
<RETURNS>void     </RETURNS>
GstEbmlWrite *ebml, guint32       id, const gchar  *str
</FUNCTION>
<FUNCTION>
<NAME>gst_ebml_write_utf8</NAME>
<RETURNS>void     </RETURNS>
GstEbmlWrite *ebml, guint32       id, const gchar  *str
</FUNCTION>
<FUNCTION>
<NAME>gst_ebml_write_date</NAME>
<RETURNS>void     </RETURNS>
GstEbmlWrite *ebml, guint32       id, gint64        date
</FUNCTION>
<FUNCTION>
<NAME>gst_ebml_write_master_start</NAME>
<RETURNS>guint64  </RETURNS>
GstEbmlWrite *ebml, guint32       id
</FUNCTION>
<FUNCTION>
<NAME>gst_ebml_write_master_finish</NAME>
<RETURNS>void     </RETURNS>
GstEbmlWrite *ebml, guint64       startpos
</FUNCTION>
<FUNCTION>
<NAME>gst_ebml_write_master_finish_full</NAME>
<RETURNS>void     </RETURNS>
GstEbmlWrite * ebml, guint64 startpos, guint64 extra_size
</FUNCTION>
<FUNCTION>
<NAME>gst_ebml_write_binary</NAME>
<RETURNS>void     </RETURNS>
GstEbmlWrite *ebml, guint32       id, guchar       *binary, guint64       length
</FUNCTION>
<FUNCTION>
<NAME>gst_ebml_write_header</NAME>
<RETURNS>void     </RETURNS>
GstEbmlWrite *ebml, const gchar  *doctype, guint         version
</FUNCTION>
<FUNCTION>
<NAME>gst_ebml_write_buffer_header</NAME>
<RETURNS>void     </RETURNS>
GstEbmlWrite *ebml, guint32       id, guint64       length
</FUNCTION>
<FUNCTION>
<NAME>gst_ebml_write_buffer</NAME>
<RETURNS>void     </RETURNS>
GstEbmlWrite *ebml, GstBuffer    *data
</FUNCTION>
<FUNCTION>
<NAME>gst_ebml_replace_uint</NAME>
<RETURNS>void     </RETURNS>
GstEbmlWrite *ebml, guint64       pos, guint64       num
</FUNCTION>
<MACRO>
<NAME>GST_MATROSKA_DOCTYPE_MATROSKA</NAME>
#define GST_MATROSKA_DOCTYPE_MATROSKA              "matroska"
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_DOCTYPE_WEBM</NAME>
#define GST_MATROSKA_DOCTYPE_WEBM                  "webm"
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_ID_SEGMENT</NAME>
#define GST_MATROSKA_ID_SEGMENT                    0x18538067
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_ID_SEGMENTINFO</NAME>
#define GST_MATROSKA_ID_SEGMENTINFO                0x1549A966
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_ID_TRACKS</NAME>
#define GST_MATROSKA_ID_TRACKS                     0x1654AE6B
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_ID_CUES</NAME>
#define GST_MATROSKA_ID_CUES                       0x1C53BB6B
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_ID_TAGS</NAME>
#define GST_MATROSKA_ID_TAGS                       0x1254C367
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_ID_SEEKHEAD</NAME>
#define GST_MATROSKA_ID_SEEKHEAD                   0x114D9B74
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_ID_CLUSTER</NAME>
#define GST_MATROSKA_ID_CLUSTER                    0x1F43B675
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_ID_ATTACHMENTS</NAME>
#define GST_MATROSKA_ID_ATTACHMENTS                0x1941A469
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_ID_CHAPTERS</NAME>
#define GST_MATROSKA_ID_CHAPTERS                   0x1043A770
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_ID_TIMECODESCALE</NAME>
#define GST_MATROSKA_ID_TIMECODESCALE              0x2AD7B1
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_ID_DURATION</NAME>
#define GST_MATROSKA_ID_DURATION                   0x4489
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_ID_WRITINGAPP</NAME>
#define GST_MATROSKA_ID_WRITINGAPP                 0x5741
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_ID_MUXINGAPP</NAME>
#define GST_MATROSKA_ID_MUXINGAPP                  0x4D80
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_ID_DATEUTC</NAME>
#define GST_MATROSKA_ID_DATEUTC                    0x4461
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_ID_SEGMENTUID</NAME>
#define GST_MATROSKA_ID_SEGMENTUID                 0x73A4
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_ID_SEGMENTFILENAME</NAME>
#define GST_MATROSKA_ID_SEGMENTFILENAME            0x7384
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_ID_PREVUID</NAME>
#define GST_MATROSKA_ID_PREVUID                    0x3CB923
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_ID_PREVFILENAME</NAME>
#define GST_MATROSKA_ID_PREVFILENAME               0x3C83AB
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_ID_NEXTUID</NAME>
#define GST_MATROSKA_ID_NEXTUID                    0x3EB923
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_ID_NEXTFILENAME</NAME>
#define GST_MATROSKA_ID_NEXTFILENAME               0x3E83BB
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_ID_TITLE</NAME>
#define GST_MATROSKA_ID_TITLE                      0x7BA9
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_ID_SEGMENTFAMILY</NAME>
#define GST_MATROSKA_ID_SEGMENTFAMILY              0x4444
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_ID_CHAPTERTRANSLATE</NAME>
#define GST_MATROSKA_ID_CHAPTERTRANSLATE           0x6924
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_ID_CHAPTERTRANSLATEEDITIONUID</NAME>
#define GST_MATROSKA_ID_CHAPTERTRANSLATEEDITIONUID 0x69FC
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_ID_CHAPTERTRANSLATECODEC</NAME>
#define GST_MATROSKA_ID_CHAPTERTRANSLATECODEC      0x69BF
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_ID_CHAPTERTRANSLATEID</NAME>
#define GST_MATROSKA_ID_CHAPTERTRANSLATEID         0x69A5
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_ID_TRACKENTRY</NAME>
#define GST_MATROSKA_ID_TRACKENTRY                 0xAE
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_ID_TRACKNUMBER</NAME>
#define GST_MATROSKA_ID_TRACKNUMBER                0xD7
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_ID_TRACKUID</NAME>
#define GST_MATROSKA_ID_TRACKUID                   0x73C5
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_ID_TRACKTYPE</NAME>
#define GST_MATROSKA_ID_TRACKTYPE                  0x83
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_ID_TRACKAUDIO</NAME>
#define GST_MATROSKA_ID_TRACKAUDIO                 0xE1
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_ID_TRACKVIDEO</NAME>
#define GST_MATROSKA_ID_TRACKVIDEO                 0xE0
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_ID_CONTENTENCODINGS</NAME>
#define GST_MATROSKA_ID_CONTENTENCODINGS           0x6D80
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_ID_CODECID</NAME>
#define GST_MATROSKA_ID_CODECID                    0x86
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_ID_CODECPRIVATE</NAME>
#define GST_MATROSKA_ID_CODECPRIVATE               0x63A2
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_ID_CODECNAME</NAME>
#define GST_MATROSKA_ID_CODECNAME                  0x258688
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_ID_TRACKNAME</NAME>
#define GST_MATROSKA_ID_TRACKNAME                  0x536E
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_ID_TRACKLANGUAGE</NAME>
#define GST_MATROSKA_ID_TRACKLANGUAGE              0x22B59C
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_ID_TRACKFLAGENABLED</NAME>
#define GST_MATROSKA_ID_TRACKFLAGENABLED           0xB9
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_ID_TRACKFLAGDEFAULT</NAME>
#define GST_MATROSKA_ID_TRACKFLAGDEFAULT           0x88
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_ID_TRACKFLAGFORCED</NAME>
#define GST_MATROSKA_ID_TRACKFLAGFORCED            0x55AA
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_ID_TRACKFLAGLACING</NAME>
#define GST_MATROSKA_ID_TRACKFLAGLACING            0x9C
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_ID_TRACKMINCACHE</NAME>
#define GST_MATROSKA_ID_TRACKMINCACHE              0x6DE7
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_ID_TRACKMAXCACHE</NAME>
#define GST_MATROSKA_ID_TRACKMAXCACHE              0x6DF8
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_ID_TRACKDEFAULTDURATION</NAME>
#define GST_MATROSKA_ID_TRACKDEFAULTDURATION       0x23E383
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_ID_TRACKTIMECODESCALE</NAME>
#define GST_MATROSKA_ID_TRACKTIMECODESCALE         0x23314F
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_ID_MAXBLOCKADDITIONID</NAME>
#define GST_MATROSKA_ID_MAXBLOCKADDITIONID         0x55EE
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_ID_TRACKATTACHMENTLINK</NAME>
#define GST_MATROSKA_ID_TRACKATTACHMENTLINK        0x7446
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_ID_TRACKOVERLAY</NAME>
#define GST_MATROSKA_ID_TRACKOVERLAY               0x6FAB
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_ID_TRACKTRANSLATE</NAME>
#define GST_MATROSKA_ID_TRACKTRANSLATE             0x6624
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_ID_TRACKOFFSET</NAME>
#define GST_MATROSKA_ID_TRACKOFFSET                0x537F
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_ID_CODECSETTINGS</NAME>
#define GST_MATROSKA_ID_CODECSETTINGS              0x3A9697
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_ID_CODECINFOURL</NAME>
#define GST_MATROSKA_ID_CODECINFOURL               0x3B4040
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_ID_CODECDOWNLOADURL</NAME>
#define GST_MATROSKA_ID_CODECDOWNLOADURL           0x26B240
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_ID_CODECDECODEALL</NAME>
#define GST_MATROSKA_ID_CODECDECODEALL             0xAA
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_ID_SEEKPREROLL</NAME>
#define GST_MATROSKA_ID_SEEKPREROLL                0x56BB
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_ID_CODECDELAY</NAME>
#define GST_MATROSKA_ID_CODECDELAY                 0x56AA
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_ID_TRACKTRANSLATEEDITIONUID</NAME>
#define GST_MATROSKA_ID_TRACKTRANSLATEEDITIONUID   0x66FC
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_ID_TRACKTRANSLATECODEC</NAME>
#define GST_MATROSKA_ID_TRACKTRANSLATECODEC        0x66BF
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_ID_TRACKTRANSLATETRACKID</NAME>
#define GST_MATROSKA_ID_TRACKTRANSLATETRACKID      0x66A5
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_ID_VIDEOFRAMERATE</NAME>
#define GST_MATROSKA_ID_VIDEOFRAMERATE             0x2383E3
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_ID_VIDEODISPLAYWIDTH</NAME>
#define GST_MATROSKA_ID_VIDEODISPLAYWIDTH          0x54B0
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_ID_VIDEODISPLAYHEIGHT</NAME>
#define GST_MATROSKA_ID_VIDEODISPLAYHEIGHT         0x54BA
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_ID_VIDEODISPLAYUNIT</NAME>
#define GST_MATROSKA_ID_VIDEODISPLAYUNIT           0x54B2
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_ID_VIDEOPIXELWIDTH</NAME>
#define GST_MATROSKA_ID_VIDEOPIXELWIDTH            0xB0
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_ID_VIDEOPIXELHEIGHT</NAME>
#define GST_MATROSKA_ID_VIDEOPIXELHEIGHT           0xBA
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_ID_VIDEOPIXELCROPBOTTOM</NAME>
#define GST_MATROSKA_ID_VIDEOPIXELCROPBOTTOM       0x54AA
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_ID_VIDEOPIXELCROPTOP</NAME>
#define GST_MATROSKA_ID_VIDEOPIXELCROPTOP          0x54BB
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_ID_VIDEOPIXELCROPLEFT</NAME>
#define GST_MATROSKA_ID_VIDEOPIXELCROPLEFT         0x54CC
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_ID_VIDEOPIXELCROPRIGHT</NAME>
#define GST_MATROSKA_ID_VIDEOPIXELCROPRIGHT        0x54DD
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_ID_VIDEOFLAGINTERLACED</NAME>
#define GST_MATROSKA_ID_VIDEOFLAGINTERLACED        0x9A
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_ID_VIDEOSTEREOMODE</NAME>
#define GST_MATROSKA_ID_VIDEOSTEREOMODE            0x53B8
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_ID_VIDEOASPECTRATIOTYPE</NAME>
#define GST_MATROSKA_ID_VIDEOASPECTRATIOTYPE       0x54B3
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_ID_VIDEOCOLOURSPACE</NAME>
#define GST_MATROSKA_ID_VIDEOCOLOURSPACE           0x2EB524
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_ID_VIDEOGAMMAVALUE</NAME>
#define GST_MATROSKA_ID_VIDEOGAMMAVALUE            0x2FB523
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_ID_AUDIOSAMPLINGFREQ</NAME>
#define GST_MATROSKA_ID_AUDIOSAMPLINGFREQ          0xB5
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_ID_AUDIOBITDEPTH</NAME>
#define GST_MATROSKA_ID_AUDIOBITDEPTH              0x6264
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_ID_AUDIOCHANNELS</NAME>
#define GST_MATROSKA_ID_AUDIOCHANNELS              0x9F
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_ID_AUDIOCHANNELPOSITIONS</NAME>
#define GST_MATROSKA_ID_AUDIOCHANNELPOSITIONS      0x7D7B
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_ID_AUDIOOUTPUTSAMPLINGFREQ</NAME>
#define GST_MATROSKA_ID_AUDIOOUTPUTSAMPLINGFREQ    0x78B5
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_ID_CONTENTENCODING</NAME>
#define GST_MATROSKA_ID_CONTENTENCODING            0x6240
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_ID_CONTENTENCODINGORDER</NAME>
#define GST_MATROSKA_ID_CONTENTENCODINGORDER       0x5031
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_ID_CONTENTENCODINGSCOPE</NAME>
#define GST_MATROSKA_ID_CONTENTENCODINGSCOPE       0x5032
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_ID_CONTENTENCODINGTYPE</NAME>
#define GST_MATROSKA_ID_CONTENTENCODINGTYPE        0x5033
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_ID_CONTENTCOMPRESSION</NAME>
#define GST_MATROSKA_ID_CONTENTCOMPRESSION         0x5034
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_ID_CONTENTENCRYPTION</NAME>
#define GST_MATROSKA_ID_CONTENTENCRYPTION          0x5035
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_ID_CONTENTCOMPALGO</NAME>
#define GST_MATROSKA_ID_CONTENTCOMPALGO            0x4254
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_ID_CONTENTCOMPSETTINGS</NAME>
#define GST_MATROSKA_ID_CONTENTCOMPSETTINGS        0x4255
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_ID_CONTENTENCALGO</NAME>
#define GST_MATROSKA_ID_CONTENTENCALGO             0x47E1
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_ID_CONTENTENCKEYID</NAME>
#define GST_MATROSKA_ID_CONTENTENCKEYID            0x47E2
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_ID_CONTENTSIGNATURE</NAME>
#define GST_MATROSKA_ID_CONTENTSIGNATURE           0x47E3
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_ID_CONTENTSIGKEYID</NAME>
#define GST_MATROSKA_ID_CONTENTSIGKEYID            0x47E4
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_ID_CONTENTSIGALGO</NAME>
#define GST_MATROSKA_ID_CONTENTSIGALGO             0x47E5
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_ID_CONTENTSIGHASHALGO</NAME>
#define GST_MATROSKA_ID_CONTENTSIGHASHALGO         0x47E6
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_ID_POINTENTRY</NAME>
#define GST_MATROSKA_ID_POINTENTRY                 0xBB
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_ID_CUETIME</NAME>
#define GST_MATROSKA_ID_CUETIME                    0xB3
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_ID_CUETRACKPOSITIONS</NAME>
#define GST_MATROSKA_ID_CUETRACKPOSITIONS          0xB7
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_ID_CUETRACK</NAME>
#define GST_MATROSKA_ID_CUETRACK                   0xF7
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_ID_CUECLUSTERPOSITION</NAME>
#define GST_MATROSKA_ID_CUECLUSTERPOSITION         0xF1
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_ID_CUEBLOCKNUMBER</NAME>
#define GST_MATROSKA_ID_CUEBLOCKNUMBER             0x5378
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_ID_CUECODECSTATE</NAME>
#define GST_MATROSKA_ID_CUECODECSTATE              0xEA
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_ID_CUEREFERENCE</NAME>
#define GST_MATROSKA_ID_CUEREFERENCE               0xDB
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_ID_CUEREFTIME</NAME>
#define GST_MATROSKA_ID_CUEREFTIME                 0x96
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_ID_CUEREFCLUSTER</NAME>
#define GST_MATROSKA_ID_CUEREFCLUSTER              0x97
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_ID_CUEREFNUMBER</NAME>
#define GST_MATROSKA_ID_CUEREFNUMBER               0x535F
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_ID_CUEREFCODECSTATE</NAME>
#define GST_MATROSKA_ID_CUEREFCODECSTATE           0xEB
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_ID_TAG</NAME>
#define GST_MATROSKA_ID_TAG                        0x7373
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_ID_SIMPLETAG</NAME>
#define GST_MATROSKA_ID_SIMPLETAG                  0x67C8
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_ID_TARGETS</NAME>
#define GST_MATROSKA_ID_TARGETS                    0x63C0
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_ID_TAGNAME</NAME>
#define GST_MATROSKA_ID_TAGNAME                    0x45A3
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_ID_TAGSTRING</NAME>
#define GST_MATROSKA_ID_TAGSTRING                  0x4487
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_ID_TAGLANGUAGE</NAME>
#define GST_MATROSKA_ID_TAGLANGUAGE                0x447A
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_ID_TAGDEFAULT</NAME>
#define GST_MATROSKA_ID_TAGDEFAULT                 0x4484
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_ID_TAGBINARY</NAME>
#define GST_MATROSKA_ID_TAGBINARY                  0x4485
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_ID_TARGETTYPEVALUE</NAME>
#define GST_MATROSKA_ID_TARGETTYPEVALUE            0x68CA
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_ID_TARGETTYPE</NAME>
#define GST_MATROSKA_ID_TARGETTYPE                 0x63CA
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_ID_TARGETTRACKUID</NAME>
#define GST_MATROSKA_ID_TARGETTRACKUID             0x63C5
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_ID_TARGETEDITIONUID</NAME>
#define GST_MATROSKA_ID_TARGETEDITIONUID           0x63C9
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_ID_TARGETCHAPTERUID</NAME>
#define GST_MATROSKA_ID_TARGETCHAPTERUID           0x63C4
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_ID_TARGETATTACHMENTUID</NAME>
#define GST_MATROSKA_ID_TARGETATTACHMENTUID        0x63C6
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_ID_SEEKENTRY</NAME>
#define GST_MATROSKA_ID_SEEKENTRY                  0x4DBB
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_ID_SEEKID</NAME>
#define GST_MATROSKA_ID_SEEKID                     0x53AB
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_ID_SEEKPOSITION</NAME>
#define GST_MATROSKA_ID_SEEKPOSITION               0x53AC
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_ID_CLUSTERTIMECODE</NAME>
#define GST_MATROSKA_ID_CLUSTERTIMECODE            0xE7
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_ID_BLOCKGROUP</NAME>
#define GST_MATROSKA_ID_BLOCKGROUP                 0xA0
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_ID_SIMPLEBLOCK</NAME>
#define GST_MATROSKA_ID_SIMPLEBLOCK                0xA3
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_ID_REFERENCEBLOCK</NAME>
#define GST_MATROSKA_ID_REFERENCEBLOCK             0xFB
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_ID_POSITION</NAME>
#define GST_MATROSKA_ID_POSITION                   0xA7
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_ID_PREVSIZE</NAME>
#define GST_MATROSKA_ID_PREVSIZE                   0xAB
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_ID_ENCRYPTEDBLOCK</NAME>
#define GST_MATROSKA_ID_ENCRYPTEDBLOCK             0xAF
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_ID_SILENTTRACKS</NAME>
#define GST_MATROSKA_ID_SILENTTRACKS               0x5854
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_ID_SILENTTRACKNUMBER</NAME>
#define GST_MATROSKA_ID_SILENTTRACKNUMBER          0x58D7
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_ID_BLOCK</NAME>
#define GST_MATROSKA_ID_BLOCK                      0xA1
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_ID_BLOCKDURATION</NAME>
#define GST_MATROSKA_ID_BLOCKDURATION              0x9B
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_ID_BLOCKVIRTUAL</NAME>
#define GST_MATROSKA_ID_BLOCKVIRTUAL               0xA2
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_ID_BLOCKADDITIONS</NAME>
#define GST_MATROSKA_ID_BLOCKADDITIONS             0x75A1
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_ID_REFERENCEPRIORITY</NAME>
#define GST_MATROSKA_ID_REFERENCEPRIORITY          0xFA
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_ID_REFERENCEVIRTUAL</NAME>
#define GST_MATROSKA_ID_REFERENCEVIRTUAL           0xFD
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_ID_CODECSTATE</NAME>
#define GST_MATROSKA_ID_CODECSTATE                 0xA4
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_ID_SLICES</NAME>
#define GST_MATROSKA_ID_SLICES                     0x8E
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_ID_DISCARDPADDING</NAME>
#define GST_MATROSKA_ID_DISCARDPADDING             0x75A2
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_ID_BLOCKMORE</NAME>
#define GST_MATROSKA_ID_BLOCKMORE                  0xA6
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_ID_BLOCKADDID</NAME>
#define GST_MATROSKA_ID_BLOCKADDID                 0xEE
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_ID_BLOCKADDITIONAL</NAME>
#define GST_MATROSKA_ID_BLOCKADDITIONAL            0xA5
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_ID_TIMESLICE</NAME>
#define GST_MATROSKA_ID_TIMESLICE                  0xE8
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_ID_LACENUMBER</NAME>
#define GST_MATROSKA_ID_LACENUMBER                 0xCC
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_ID_FRAMENUMBER</NAME>
#define GST_MATROSKA_ID_FRAMENUMBER                0xCD
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_ID_BLOCKADDITIONID</NAME>
#define GST_MATROSKA_ID_BLOCKADDITIONID            0xCB
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_ID_TIMESLICEDELAY</NAME>
#define GST_MATROSKA_ID_TIMESLICEDELAY             0xCE
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_ID_TIMESLICEDURATION</NAME>
#define GST_MATROSKA_ID_TIMESLICEDURATION          0xCF
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_ID_ATTACHEDFILE</NAME>
#define GST_MATROSKA_ID_ATTACHEDFILE               0x61A7
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_ID_FILEDESCRIPTION</NAME>
#define GST_MATROSKA_ID_FILEDESCRIPTION            0x467E
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_ID_FILENAME</NAME>
#define GST_MATROSKA_ID_FILENAME                   0x466E
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_ID_FILEMIMETYPE</NAME>
#define GST_MATROSKA_ID_FILEMIMETYPE               0x4660
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_ID_FILEDATA</NAME>
#define GST_MATROSKA_ID_FILEDATA                   0x465C
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_ID_FILEUID</NAME>
#define GST_MATROSKA_ID_FILEUID                    0x46AE
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_ID_FILEREFERRAL</NAME>
#define GST_MATROSKA_ID_FILEREFERRAL               0x4675
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_ID_EDITIONENTRY</NAME>
#define GST_MATROSKA_ID_EDITIONENTRY               0x45B9
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_ID_EDITIONUID</NAME>
#define GST_MATROSKA_ID_EDITIONUID                 0x45BC
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_ID_EDITIONFLAGHIDDEN</NAME>
#define GST_MATROSKA_ID_EDITIONFLAGHIDDEN          0x45BD
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_ID_EDITIONFLAGDEFAULT</NAME>
#define GST_MATROSKA_ID_EDITIONFLAGDEFAULT         0x45DB
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_ID_EDITIONFLAGORDERED</NAME>
#define GST_MATROSKA_ID_EDITIONFLAGORDERED         0x45DD
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_ID_CHAPTERATOM</NAME>
#define GST_MATROSKA_ID_CHAPTERATOM                0xB6
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_ID_CHAPTERUID</NAME>
#define GST_MATROSKA_ID_CHAPTERUID                 0x73C4
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_ID_CHAPTERTIMESTART</NAME>
#define GST_MATROSKA_ID_CHAPTERTIMESTART           0x91
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_ID_CHAPTERTIMESTOP</NAME>
#define GST_MATROSKA_ID_CHAPTERTIMESTOP            0x92
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_ID_CHAPTERFLAGHIDDEN</NAME>
#define GST_MATROSKA_ID_CHAPTERFLAGHIDDEN          0x98
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_ID_CHAPTERFLAGENABLED</NAME>
#define GST_MATROSKA_ID_CHAPTERFLAGENABLED         0x4598
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_ID_CHAPTERSEGMENTUID</NAME>
#define GST_MATROSKA_ID_CHAPTERSEGMENTUID          0x6E67
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_ID_CHAPTERSEGMENTEDITIONUID</NAME>
#define GST_MATROSKA_ID_CHAPTERSEGMENTEDITIONUID   0x6EBC
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_ID_CHAPTERPHYSICALEQUIV</NAME>
#define GST_MATROSKA_ID_CHAPTERPHYSICALEQUIV       0x63C3
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_ID_CHAPTERTRACK</NAME>
#define GST_MATROSKA_ID_CHAPTERTRACK               0x8F
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_ID_CHAPTERDISPLAY</NAME>
#define GST_MATROSKA_ID_CHAPTERDISPLAY             0x80
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_ID_CHAPPROCESS</NAME>
#define GST_MATROSKA_ID_CHAPPROCESS                0x6944
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_ID_CHAPPROCESSCODECID</NAME>
#define GST_MATROSKA_ID_CHAPPROCESSCODECID         0x6955
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_ID_CHAPPROCESSPRIVATE</NAME>
#define GST_MATROSKA_ID_CHAPPROCESSPRIVATE         0x450D
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_ID_CHAPPROCESSCOMMAND</NAME>
#define GST_MATROSKA_ID_CHAPPROCESSCOMMAND         0x6911
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_ID_CHAPPROCESSTIME</NAME>
#define GST_MATROSKA_ID_CHAPPROCESSTIME            0x6922
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_ID_CHAPPROCESSDATA</NAME>
#define GST_MATROSKA_ID_CHAPPROCESSDATA            0x6933
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_ID_CHAPSTRING</NAME>
#define GST_MATROSKA_ID_CHAPSTRING                 0x85
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_ID_CHAPLANGUAGE</NAME>
#define GST_MATROSKA_ID_CHAPLANGUAGE               0x437C
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_ID_CHAPCOUNTRY</NAME>
#define GST_MATROSKA_ID_CHAPCOUNTRY                0x437E
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_ID_CHAPTERTRACKNUMBER</NAME>
#define GST_MATROSKA_ID_CHAPTERTRACKNUMBER         0x89
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_CODEC_ID_VIDEO_VFW_FOURCC</NAME>
#define GST_MATROSKA_CODEC_ID_VIDEO_VFW_FOURCC   "V_MS/VFW/FOURCC"
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_CODEC_ID_VIDEO_UNCOMPRESSED</NAME>
#define GST_MATROSKA_CODEC_ID_VIDEO_UNCOMPRESSED "V_UNCOMPRESSED"
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_CODEC_ID_VIDEO_MPEG4_SP</NAME>
#define GST_MATROSKA_CODEC_ID_VIDEO_MPEG4_SP     "V_MPEG4/ISO/SP"
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_CODEC_ID_VIDEO_MPEG4_ASP</NAME>
#define GST_MATROSKA_CODEC_ID_VIDEO_MPEG4_ASP    "V_MPEG4/ISO/ASP"
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_CODEC_ID_VIDEO_MPEG4_AP</NAME>
#define GST_MATROSKA_CODEC_ID_VIDEO_MPEG4_AP     "V_MPEG4/ISO/AP"
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_CODEC_ID_VIDEO_MPEG4_AVC</NAME>
#define GST_MATROSKA_CODEC_ID_VIDEO_MPEG4_AVC    "V_MPEG4/ISO/AVC"
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_CODEC_ID_VIDEO_MSMPEG4V3</NAME>
#define GST_MATROSKA_CODEC_ID_VIDEO_MSMPEG4V3    "V_MPEG4/MS/V3"
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_CODEC_ID_VIDEO_MPEG1</NAME>
#define GST_MATROSKA_CODEC_ID_VIDEO_MPEG1        "V_MPEG1"
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_CODEC_ID_VIDEO_MPEG2</NAME>
#define GST_MATROSKA_CODEC_ID_VIDEO_MPEG2        "V_MPEG2"
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_CODEC_ID_VIDEO_MJPEG</NAME>
#define GST_MATROSKA_CODEC_ID_VIDEO_MJPEG        "V_MJPEG"
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_CODEC_ID_VIDEO_REALVIDEO1</NAME>
#define GST_MATROSKA_CODEC_ID_VIDEO_REALVIDEO1   "V_REAL/RV10"
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_CODEC_ID_VIDEO_REALVIDEO2</NAME>
#define GST_MATROSKA_CODEC_ID_VIDEO_REALVIDEO2   "V_REAL/RV20"
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_CODEC_ID_VIDEO_REALVIDEO3</NAME>
#define GST_MATROSKA_CODEC_ID_VIDEO_REALVIDEO3   "V_REAL/RV30"
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_CODEC_ID_VIDEO_REALVIDEO4</NAME>
#define GST_MATROSKA_CODEC_ID_VIDEO_REALVIDEO4   "V_REAL/RV40"
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_CODEC_ID_VIDEO_THEORA</NAME>
#define GST_MATROSKA_CODEC_ID_VIDEO_THEORA       "V_THEORA"
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_CODEC_ID_VIDEO_QUICKTIME</NAME>
#define GST_MATROSKA_CODEC_ID_VIDEO_QUICKTIME    "V_QUICKTIME"
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_CODEC_ID_VIDEO_SNOW</NAME>
#define GST_MATROSKA_CODEC_ID_VIDEO_SNOW         "V_SNOW"
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_CODEC_ID_VIDEO_DIRAC</NAME>
#define GST_MATROSKA_CODEC_ID_VIDEO_DIRAC        "V_DIRAC"
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_CODEC_ID_VIDEO_VP8</NAME>
#define GST_MATROSKA_CODEC_ID_VIDEO_VP8          "V_VP8"
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_CODEC_ID_VIDEO_VP9</NAME>
#define GST_MATROSKA_CODEC_ID_VIDEO_VP9          "V_VP9"
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_CODEC_ID_VIDEO_MPEGH_HEVC</NAME>
#define GST_MATROSKA_CODEC_ID_VIDEO_MPEGH_HEVC   "V_MPEGH/ISO/HEVC"
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_CODEC_ID_VIDEO_PRORES</NAME>
#define GST_MATROSKA_CODEC_ID_VIDEO_PRORES       "V_PRORES"
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_CODEC_ID_AUDIO_MPEG1_L1</NAME>
#define GST_MATROSKA_CODEC_ID_AUDIO_MPEG1_L1       "A_MPEG/L1"
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_CODEC_ID_AUDIO_MPEG1_L2</NAME>
#define GST_MATROSKA_CODEC_ID_AUDIO_MPEG1_L2       "A_MPEG/L2"
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_CODEC_ID_AUDIO_MPEG1_L3</NAME>
#define GST_MATROSKA_CODEC_ID_AUDIO_MPEG1_L3       "A_MPEG/L3"
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_CODEC_ID_AUDIO_PCM_INT_BE</NAME>
#define GST_MATROSKA_CODEC_ID_AUDIO_PCM_INT_BE     "A_PCM/INT/BIG"
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_CODEC_ID_AUDIO_PCM_INT_LE</NAME>
#define GST_MATROSKA_CODEC_ID_AUDIO_PCM_INT_LE     "A_PCM/INT/LIT"
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_CODEC_ID_AUDIO_PCM_FLOAT</NAME>
#define GST_MATROSKA_CODEC_ID_AUDIO_PCM_FLOAT      "A_PCM/FLOAT/IEEE"
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_CODEC_ID_AUDIO_AC3</NAME>
#define GST_MATROSKA_CODEC_ID_AUDIO_AC3            "A_AC3"
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_CODEC_ID_AUDIO_AC3_BSID9</NAME>
#define GST_MATROSKA_CODEC_ID_AUDIO_AC3_BSID9      "A_AC3/BSID9"
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_CODEC_ID_AUDIO_AC3_BSID10</NAME>
#define GST_MATROSKA_CODEC_ID_AUDIO_AC3_BSID10     "A_AC3/BSID10"
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_CODEC_ID_AUDIO_EAC3</NAME>
#define GST_MATROSKA_CODEC_ID_AUDIO_EAC3           "A_EAC3"
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_CODEC_ID_AUDIO_TRUEHD</NAME>
#define GST_MATROSKA_CODEC_ID_AUDIO_TRUEHD         "A_TRUEHD"
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_CODEC_ID_AUDIO_DTS</NAME>
#define GST_MATROSKA_CODEC_ID_AUDIO_DTS            "A_DTS"
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_CODEC_ID_AUDIO_VORBIS</NAME>
#define GST_MATROSKA_CODEC_ID_AUDIO_VORBIS         "A_VORBIS"
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_CODEC_ID_AUDIO_FLAC</NAME>
#define GST_MATROSKA_CODEC_ID_AUDIO_FLAC           "A_FLAC"
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_CODEC_ID_AUDIO_SPEEX</NAME>
#define GST_MATROSKA_CODEC_ID_AUDIO_SPEEX          "A_SPEEX"
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_CODEC_ID_AUDIO_ACM</NAME>
#define GST_MATROSKA_CODEC_ID_AUDIO_ACM            "A_MS/ACM"
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_CODEC_ID_AUDIO_TTA</NAME>
#define GST_MATROSKA_CODEC_ID_AUDIO_TTA            "A_TTA1"
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_CODEC_ID_AUDIO_WAVPACK4</NAME>
#define GST_MATROSKA_CODEC_ID_AUDIO_WAVPACK4       "A_WAVPACK4"
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_CODEC_ID_AUDIO_REAL_14_4</NAME>
#define GST_MATROSKA_CODEC_ID_AUDIO_REAL_14_4      "A_REAL/14_4"
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_CODEC_ID_AUDIO_REAL_28_8</NAME>
#define GST_MATROSKA_CODEC_ID_AUDIO_REAL_28_8      "A_REAL/28_8"
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_CODEC_ID_AUDIO_REAL_COOK</NAME>
#define GST_MATROSKA_CODEC_ID_AUDIO_REAL_COOK      "A_REAL/COOK"
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_CODEC_ID_AUDIO_REAL_SIPR</NAME>
#define GST_MATROSKA_CODEC_ID_AUDIO_REAL_SIPR      "A_REAL/SIPR"
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_CODEC_ID_AUDIO_REAL_RALF</NAME>
#define GST_MATROSKA_CODEC_ID_AUDIO_REAL_RALF      "A_REAL/RALF"
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_CODEC_ID_AUDIO_REAL_ATRC</NAME>
#define GST_MATROSKA_CODEC_ID_AUDIO_REAL_ATRC      "A_REAL/ATRC"
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_CODEC_ID_AUDIO_AAC</NAME>
#define GST_MATROSKA_CODEC_ID_AUDIO_AAC            "A_AAC"
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_CODEC_ID_AUDIO_AAC_MPEG2</NAME>
#define GST_MATROSKA_CODEC_ID_AUDIO_AAC_MPEG2      "A_AAC/MPEG2/"
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_CODEC_ID_AUDIO_AAC_MPEG4</NAME>
#define GST_MATROSKA_CODEC_ID_AUDIO_AAC_MPEG4      "A_AAC/MPEG4/"
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_CODEC_ID_AUDIO_QUICKTIME_QDMC</NAME>
#define GST_MATROSKA_CODEC_ID_AUDIO_QUICKTIME_QDMC "A_QUICKTIME/QDMC"
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_CODEC_ID_AUDIO_QUICKTIME_QDM2</NAME>
#define GST_MATROSKA_CODEC_ID_AUDIO_QUICKTIME_QDM2 "A_QUICKTIME/QDM2"
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_CODEC_ID_AUDIO_OPUS</NAME>
#define GST_MATROSKA_CODEC_ID_AUDIO_OPUS           "A_OPUS"
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_CODEC_ID_SUBTITLE_ASCII</NAME>
#define GST_MATROSKA_CODEC_ID_SUBTITLE_ASCII     "S_TEXT/ASCII"
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_CODEC_ID_SUBTITLE_UTF8</NAME>
#define GST_MATROSKA_CODEC_ID_SUBTITLE_UTF8      "S_TEXT/UTF8"
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_CODEC_ID_SUBTITLE_SSA</NAME>
#define GST_MATROSKA_CODEC_ID_SUBTITLE_SSA       "S_TEXT/SSA"
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_CODEC_ID_SUBTITLE_ASS</NAME>
#define GST_MATROSKA_CODEC_ID_SUBTITLE_ASS       "S_TEXT/ASS" 
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_CODEC_ID_SUBTITLE_USF</NAME>
#define GST_MATROSKA_CODEC_ID_SUBTITLE_USF       "S_TEXT/USF"
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_CODEC_ID_SUBTITLE_VOBSUB</NAME>
#define GST_MATROSKA_CODEC_ID_SUBTITLE_VOBSUB    "S_VOBSUB"
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_CODEC_ID_SUBTITLE_HDMVPGS</NAME>
#define GST_MATROSKA_CODEC_ID_SUBTITLE_HDMVPGS   "S_HDMV/PGS"
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_CODEC_ID_SUBTITLE_BMP</NAME>
#define GST_MATROSKA_CODEC_ID_SUBTITLE_BMP       "S_IMAGE/BMP"
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_CODEC_ID_SUBTITLE_KATE</NAME>
#define GST_MATROSKA_CODEC_ID_SUBTITLE_KATE      "S_KATE"
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_TAG_ID_TITLE</NAME>
#define GST_MATROSKA_TAG_ID_TITLE    "TITLE"
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_TAG_ID_AUTHOR</NAME>
#define GST_MATROSKA_TAG_ID_AUTHOR   "AUTHOR"
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_TAG_ID_ARTIST</NAME>
#define GST_MATROSKA_TAG_ID_ARTIST   "ARTIST"
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_TAG_ID_ALBUM</NAME>
#define GST_MATROSKA_TAG_ID_ALBUM    "ALBUM"
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_TAG_ID_COMMENTS</NAME>
#define GST_MATROSKA_TAG_ID_COMMENTS "COMMENTS"
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_TAG_ID_COMMENT</NAME>
#define GST_MATROSKA_TAG_ID_COMMENT  "COMMENT"
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_TAG_ID_BITSPS</NAME>
#define GST_MATROSKA_TAG_ID_BITSPS   "BITSPS"
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_TAG_ID_BPS</NAME>
#define GST_MATROSKA_TAG_ID_BPS      "BPS"
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_TAG_ID_ENCODER</NAME>
#define GST_MATROSKA_TAG_ID_ENCODER  "ENCODER"
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_TAG_ID_ISRC</NAME>
#define GST_MATROSKA_TAG_ID_ISRC     "ISRC"
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_TAG_ID_COPYRIGHT</NAME>
#define GST_MATROSKA_TAG_ID_COPYRIGHT "COPYRIGHT"
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_TAG_ID_BPM</NAME>
#define GST_MATROSKA_TAG_ID_BPM       "BPM"
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_TAG_ID_TERMS_OF_USE</NAME>
#define GST_MATROSKA_TAG_ID_TERMS_OF_USE "TERMS_OF_USE"
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_TAG_ID_DATE</NAME>
#define GST_MATROSKA_TAG_ID_DATE      "DATE"
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_TAG_ID_COMPOSER</NAME>
#define GST_MATROSKA_TAG_ID_COMPOSER  "COMPOSER"
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_TAG_ID_LEAD_PERFORMER</NAME>
#define GST_MATROSKA_TAG_ID_LEAD_PERFORMER  "LEAD_PERFOMER"
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_TAG_ID_GENRE</NAME>
#define GST_MATROSKA_TAG_ID_GENRE     "GENRE"
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_TAG_ID_TOTAL_PARTS</NAME>
#define GST_MATROSKA_TAG_ID_TOTAL_PARTS "TOTAL_PARTS"
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_TAG_ID_PART_NUMBER</NAME>
#define GST_MATROSKA_TAG_ID_PART_NUMBER "PART_NUMBER"
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_TAG_ID_SUBTITLE</NAME>
#define GST_MATROSKA_TAG_ID_SUBTITLE "SUBTITLE"
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_TAG_ID_ACCOMPANIMENT</NAME>
#define GST_MATROSKA_TAG_ID_ACCOMPANIMENT "ACCOMPANIMENT"
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_TAG_ID_LYRICS</NAME>
#define GST_MATROSKA_TAG_ID_LYRICS "LYRICS"
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_TAG_ID_CONDUCTOR</NAME>
#define GST_MATROSKA_TAG_ID_CONDUCTOR "CONDUCTOR"
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_TAG_ID_ENCODED_BY</NAME>
#define GST_MATROSKA_TAG_ID_ENCODED_BY "ENCODED_BY"
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_TAG_ID_DESCRIPTION</NAME>
#define GST_MATROSKA_TAG_ID_DESCRIPTION "DESCRIPTION"
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_TAG_ID_KEYWORDS</NAME>
#define GST_MATROSKA_TAG_ID_KEYWORDS "KEYWORDS"
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_TAG_ID_DATE_RELEASED</NAME>
#define GST_MATROSKA_TAG_ID_DATE_RELEASED "DATE_RELEASED"
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_TAG_ID_DATE_RECORDED</NAME>
#define GST_MATROSKA_TAG_ID_DATE_RECORDED "DATE_RECORDED"
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_TAG_ID_DATE_ENCODED</NAME>
#define GST_MATROSKA_TAG_ID_DATE_ENCODED "DATE_ENCODED"
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_TAG_ID_DATE_TAGGED</NAME>
#define GST_MATROSKA_TAG_ID_DATE_TAGGED "DATE_TAGGED"
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_TAG_ID_DATE_DIGITIZED</NAME>
#define GST_MATROSKA_TAG_ID_DATE_DIGITIZED "DATE_DIGITIZED"
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_TAG_ID_DATE_WRITTEN</NAME>
#define GST_MATROSKA_TAG_ID_DATE_WRITTEN "DATE_WRITTEN"
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_TAG_ID_DATE_PURCHASED</NAME>
#define GST_MATROSKA_TAG_ID_DATE_PURCHASED "DATE_PURCHASED"
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_TAG_ID_RECORDING_LOCATION</NAME>
#define GST_MATROSKA_TAG_ID_RECORDING_LOCATION "RECORDING_LOCATION"
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_TAG_ID_PRODUCTION_COPYRIGHT</NAME>
#define GST_MATROSKA_TAG_ID_PRODUCTION_COPYRIGHT "PRODUCTION_COPYRIGHT"
</MACRO>
<MACRO>
<NAME>GST_MATROSKA_TAG_ID_LICENSE</NAME>
#define GST_MATROSKA_TAG_ID_LICENSE "LICENSE"
</MACRO>
<ENUM>
<NAME>GstMatroskaTrackType</NAME>
typedef enum {
  GST_MATROSKA_TRACK_TYPE_VIDEO    = 0x1,
  GST_MATROSKA_TRACK_TYPE_AUDIO    = 0x2,
  GST_MATROSKA_TRACK_TYPE_COMPLEX  = 0x3,
  GST_MATROSKA_TRACK_TYPE_LOGO     = 0x10,
  GST_MATROSKA_TRACK_TYPE_SUBTITLE = 0x11,
  GST_MATROSKA_TRACK_TYPE_BUTTONS  = 0x12,
  GST_MATROSKA_TRACK_TYPE_CONTROL  = 0x20,
} GstMatroskaTrackType;
</ENUM>
<ENUM>
<NAME>GstMatroskaAspectRatioMode</NAME>
typedef enum {
  GST_MATROSKA_ASPECT_RATIO_MODE_FREE  = 0x0,
  GST_MATROSKA_ASPECT_RATIO_MODE_KEEP  = 0x1,
  GST_MATROSKA_ASPECT_RATIO_MODE_FIXED = 0x2,
} GstMatroskaAspectRatioMode;
</ENUM>
<ENUM>
<NAME>GstMatroskaTrackFlags</NAME>
typedef enum {
  GST_MATROSKA_TRACK_ENABLED = (1<<0),
  GST_MATROSKA_TRACK_DEFAULT = (1<<1),
  GST_MATROSKA_TRACK_LACING  = (1<<2),
  GST_MATROSKA_TRACK_FORCED  = (1<<3),
  GST_MATROSKA_TRACK_SHIFT   = (1<<16)
} GstMatroskaTrackFlags;
</ENUM>
<ENUM>
<NAME>GstMatroskaVideoTrackFlags</NAME>
typedef enum {
  GST_MATROSKA_VIDEOTRACK_INTERLACED = (GST_MATROSKA_TRACK_SHIFT<<0)
} GstMatroskaVideoTrackFlags;
</ENUM>
<ENUM>
<NAME>GstMatroskaStereoMode</NAME>
typedef enum {
  GST_MATROSKA_STEREO_MODE_SBS_LR      = 0x1,
  GST_MATROSKA_STEREO_MODE_TB_RL       = 0x2,
  GST_MATROSKA_STEREO_MODE_TB_LR       = 0x3,
  GST_MATROSKA_STEREO_MODE_CHECKER_RL  = 0x4,
  GST_MATROSKA_STEREO_MODE_CHECKER_LR  = 0x5,
  GST_MATROSKA_STEREO_MODE_SBS_RL      = 0x9,
  GST_MATROSKA_STEREO_MODE_FBF_LR      = 0xD,
  GST_MATROSKA_STEREO_MODE_FBF_RL      = 0xE
} GstMatroskaStereoMode;
</ENUM>
<STRUCT>
<NAME>GstMatroskaTrackContext</NAME>
struct _GstMatroskaTrackContext {
  GstPad       *pad;
  GstCaps      *caps;
  guint         index;
  /* reverse playback */
  GstClockTime  from_time;
  gint64                   from_offset;
  gint64                   to_offset;

  GArray       *index_table;

  gint          index_writer_id;

  /* some often-used info */
  gchar        *codec_id, *codec_name, *name, *language;
  gpointer      codec_priv;
  gsize         codec_priv_size;
  gpointer      codec_state;
  gsize         codec_state_size;
  GstMatroskaTrackType type;
  guint64       uid, num;
  GstMatroskaTrackFlags flags;
  guint64       default_duration;
  guint64       pos;
  gdouble       timecodescale;
  guint64       seek_preroll;
  guint64       codec_delay;

  gboolean      set_discont; /* TRUE = set DISCONT flag on next buffer */

  /* Stream header buffer, to put into caps and send before any other buffers */
  GstBufferList * stream_headers;
  gboolean        send_stream_headers;

  /* Special flag for VobSub, for which we have to send colour table info
   * (if available) first before sending any data, and just testing
   * for time == 0 is not enough to detect that. Used by demuxer */
  gboolean      send_dvd_event;

  /* Special counter for muxer to skip the first N vorbis/theora headers -
   * they are put into codec private data, not muxed into the stream */
  guint         xiph_headers_to_skip;

  /* Used for postprocessing a frame before it is pushed from the demuxer */
  GstFlowReturn (*postprocess_frame) (GstElement *element,
                                      GstMatroskaTrackContext *context,
				      GstBuffer **buffer);

  /* List of tags for this stream */
  GstTagList   *tags;
  /* Tags changed and should be pushed again */
  gboolean      tags_changed;

  /* A GArray of GstMatroskaTrackEncoding structures which contain the
   * encoding (compression/encryption) settings for this track, if any */
  GArray       *encodings;

  /* Whether the stream is EOS */
  gboolean      eos;

  /* any alignment we need our output buffers to have */
  gint          alignment;
  
  /* for compatibility with VFW files, where timestamp represents DTS */
  gboolean      dts_only;
  
  /* indicate that the track is raw (jpeg,raw variants) and so pts=dts */
  gboolean		intra_only;
};
</STRUCT>
<STRUCT>
<NAME>GstMatroskaTrackVideoContext</NAME>
typedef struct _GstMatroskaTrackVideoContext {
  GstMatroskaTrackContext parent;

  guint         pixel_width, pixel_height;
  guint         display_width, display_height;
  gdouble       default_fps;
  GstMatroskaAspectRatioMode asr_mode;
  guint32       fourcc;

  GstVideoMultiviewMode multiview_mode;
  GstVideoMultiviewFlags multiview_flags;

  /* QoS */
  GstClockTime  earliest_time;

  GstBuffer     *dirac_unit;
} GstMatroskaTrackVideoContext;
</STRUCT>
<STRUCT>
<NAME>GstMatroskaTrackAudioContext</NAME>
typedef struct _GstMatroskaTrackAudioContext {
  GstMatroskaTrackContext parent;

  guint         samplerate, channels, bitdepth;

  guint32       wvpk_block_index;
} GstMatroskaTrackAudioContext;
</STRUCT>
<STRUCT>
<NAME>GstMatroskaTrackSubtitleContext</NAME>
typedef struct _GstMatroskaTrackSubtitleContext {
  GstMatroskaTrackContext parent;

  gboolean    check_utf8;     /* buffers should be valid UTF-8 */
  gboolean    check_markup;   /* check if buffers contain markup
                               * or plaintext and escape characters */
  gboolean    invalid_utf8;   /* work around broken files      */
  gboolean    seen_markup_tag;  /* markup found in text */
} GstMatroskaTrackSubtitleContext;
</STRUCT>
<STRUCT>
<NAME>GstMatroskaIndex</NAME>
typedef struct _GstMatroskaIndex {
  guint64        pos;      /* of the corresponding *cluster*! */
  guint16        track;    /* reference to 'num' */
  GstClockTime   time;     /* in nanoseconds */
  guint32        block;    /* number of the block in the cluster */
} GstMatroskaIndex;
</STRUCT>
<STRUCT>
<NAME>Wavpack4Header</NAME>
typedef struct _Wavpack4Header {
  guchar  ck_id [4];     /* "wvpk"                                         */
  guint32 ck_size;       /* size of entire frame (minus 8, of course)      */
  guint16 version;       /* 0x403 for now                                  */
  guint8  track_no;      /* track number (0 if not used, like now)         */
  guint8  index_no;      /* remember these? (0 if not used, like now)      */
  guint32 total_samples; /* for entire file (-1 if unknown)                */
  guint32 block_index;   /* index of first sample in block (to file begin) */
  guint32 block_samples; /* # samples in this block                        */
  guint32 flags;         /* various flags for id and decoding              */
  guint32 crc;           /* crc for actual decoded data                    */
} Wavpack4Header;
</STRUCT>
<ENUM>
<NAME>GstMatroskaTrackEncodingScope</NAME>
typedef enum {
  GST_MATROSKA_TRACK_ENCODING_SCOPE_FRAME = (1<<0),
  GST_MATROSKA_TRACK_ENCODING_SCOPE_CODEC_DATA = (1<<1),
  GST_MATROSKA_TRACK_ENCODING_SCOPE_NEXT_CONTENT_ENCODING = (1<<2)
} GstMatroskaTrackEncodingScope;
</ENUM>
<ENUM>
<NAME>GstMatroskaTrackCompressionAlgorithm</NAME>
typedef enum {
  GST_MATROSKA_TRACK_COMPRESSION_ALGORITHM_ZLIB = 0,
  GST_MATROSKA_TRACK_COMPRESSION_ALGORITHM_BZLIB = 1,
  GST_MATROSKA_TRACK_COMPRESSION_ALGORITHM_LZO1X = 2,
  GST_MATROSKA_TRACK_COMPRESSION_ALGORITHM_HEADERSTRIP = 3
} GstMatroskaTrackCompressionAlgorithm;
</ENUM>
<STRUCT>
<NAME>GstMatroskaTrackEncoding</NAME>
typedef struct _GstMatroskaTrackEncoding {
  guint   order;
  guint   scope     : 3;
  guint   type      : 1;
  guint   comp_algo : 2;
  guint8 *comp_settings;
  guint   comp_settings_length;
} GstMatroskaTrackEncoding;
</STRUCT>
<FUNCTION>
<NAME>gst_matroska_track_init_video_context</NAME>
<RETURNS>gboolean  </RETURNS>
GstMatroskaTrackContext ** p_context
</FUNCTION>
<FUNCTION>
<NAME>gst_matroska_track_init_audio_context</NAME>
<RETURNS>gboolean  </RETURNS>
GstMatroskaTrackContext ** p_context
</FUNCTION>
<FUNCTION>
<NAME>gst_matroska_track_init_subtitle_context</NAME>
<RETURNS>gboolean  </RETURNS>
GstMatroskaTrackContext ** p_context
</FUNCTION>
<FUNCTION>
<NAME>gst_matroska_register_tags</NAME>
<RETURNS>void  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_matroska_parse_xiph_stream_headers</NAME>
<RETURNS>GstBufferList  * </RETURNS>
gpointer codec_data, gsize codec_data_size
</FUNCTION>
<FUNCTION>
<NAME>gst_matroska_parse_speex_stream_headers</NAME>
<RETURNS>GstBufferList  * </RETURNS>
gpointer codec_data, gsize codec_data_size
</FUNCTION>
<FUNCTION>
<NAME>gst_matroska_parse_opus_stream_headers</NAME>
<RETURNS>GstBufferList  * </RETURNS>
gpointer codec_data, gsize codec_data_size
</FUNCTION>
<FUNCTION>
<NAME>gst_matroska_parse_flac_stream_headers</NAME>
<RETURNS>GstBufferList  * </RETURNS>
gpointer codec_data, gsize codec_data_size
</FUNCTION>
<FUNCTION>
<NAME>gst_matroska_track_free</NAME>
<RETURNS>void  </RETURNS>
GstMatroskaTrackContext * track
</FUNCTION>
<FUNCTION>
<NAME>gst_matroska_track_get_buffer_timestamp</NAME>
<RETURNS>GstClockTime  </RETURNS>
GstMatroskaTrackContext * track, GstBuffer *buf
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_EBML_READ</NAME>
#define GST_TYPE_EBML_READ \
  (gst_ebml_read_get_type ())
</MACRO>
<MACRO>
<NAME>GST_EBML_READ</NAME>
#define GST_EBML_READ(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST ((obj), GST_TYPE_EBML_READ, GstEbmlRead))
</MACRO>
<MACRO>
<NAME>GST_EBML_READ_CLASS</NAME>
#define GST_EBML_READ_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST ((klass), GST_TYPE_EBML_READ, GstEbmlReadClass))
</MACRO>
<MACRO>
<NAME>GST_IS_EBML_READ</NAME>
#define GST_IS_EBML_READ(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GST_TYPE_EBML_READ))
</MACRO>
<MACRO>
<NAME>GST_IS_EBML_READ_CLASS</NAME>
#define GST_IS_EBML_READ_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE ((klass), GST_TYPE_EBML_READ))
</MACRO>
<MACRO>
<NAME>GST_EBML_READ_GET_CLASS</NAME>
#define GST_EBML_READ_GET_CLASS(obj) \
  (G_TYPE_INSTANCE_GET_CLASS ((obj), GST_TYPE_EBML_READ, GstEbmlReadClass))
</MACRO>
<MACRO>
<NAME>GST_FLOW_PARSE</NAME>
#define  GST_FLOW_PARSE  GST_FLOW_CUSTOM_ERROR
</MACRO>
<STRUCT>
<NAME>GstEbmlMaster</NAME>
typedef struct _GstEbmlMaster {
  guint64       offset;
  GstByteReader br;
} GstEbmlMaster;
</STRUCT>
<STRUCT>
<NAME>GstEbmlRead</NAME>
typedef struct _GstEbmlRead {
  GstElement *el;

  GstBuffer *buf;
  guint64 offset;
  GstMapInfo map;

  GArray *readers;
} GstEbmlRead;
</STRUCT>
<USER_FUNCTION>
<NAME>GstPeekData</NAME>
<RETURNS>GstFlowReturn </RETURNS>
gpointer * context, guint peek, const guint8 ** data
</USER_FUNCTION>
<FUNCTION>
<NAME>gst_ebml_peek_id_length</NAME>
<RETURNS>GstFlowReturn  </RETURNS>
guint32 * _id, guint64 * _length, guint * _needed, GstPeekData peek, gpointer * ctx, GstElement * el, guint64 offset
</FUNCTION>
<FUNCTION>
<NAME>gst_ebml_read_init</NAME>
<RETURNS>void           </RETURNS>
GstEbmlRead * ebml, GstElement * el, GstBuffer * buf, guint64 offset
</FUNCTION>
<FUNCTION>
<NAME>gst_ebml_read_clear</NAME>
<RETURNS>void           </RETURNS>
GstEbmlRead * ebml
</FUNCTION>
<FUNCTION>
<NAME>gst_ebml_peek_id</NAME>
<RETURNS>GstFlowReturn  </RETURNS>
GstEbmlRead * ebml, guint32 * id
</FUNCTION>
<FUNCTION>
<NAME>gst_ebml_read_skip</NAME>
<RETURNS>GstFlowReturn  </RETURNS>
GstEbmlRead *ebml
</FUNCTION>
<FUNCTION>
<NAME>gst_ebml_read_buffer</NAME>
<RETURNS>GstFlowReturn  </RETURNS>
GstEbmlRead *ebml, guint32     *id, GstBuffer  **buf
</FUNCTION>
<FUNCTION>
<NAME>gst_ebml_read_uint</NAME>
<RETURNS>GstFlowReturn  </RETURNS>
GstEbmlRead *ebml, guint32     *id, guint64     *num
</FUNCTION>
<FUNCTION>
<NAME>gst_ebml_read_sint</NAME>
<RETURNS>GstFlowReturn  </RETURNS>
GstEbmlRead *ebml, guint32     *id, gint64      *num
</FUNCTION>
<FUNCTION>
<NAME>gst_ebml_read_float</NAME>
<RETURNS>GstFlowReturn  </RETURNS>
GstEbmlRead *ebml, guint32     *id, gdouble     *num
</FUNCTION>
<FUNCTION>
<NAME>gst_ebml_read_ascii</NAME>
<RETURNS>GstFlowReturn  </RETURNS>
GstEbmlRead *ebml, guint32     *id, gchar      **str
</FUNCTION>
<FUNCTION>
<NAME>gst_ebml_read_utf8</NAME>
<RETURNS>GstFlowReturn  </RETURNS>
GstEbmlRead *ebml, guint32     *id, gchar      **str
</FUNCTION>
<FUNCTION>
<NAME>gst_ebml_read_date</NAME>
<RETURNS>GstFlowReturn  </RETURNS>
GstEbmlRead *ebml, guint32     *id, gint64      *date
</FUNCTION>
<FUNCTION>
<NAME>gst_ebml_read_master</NAME>
<RETURNS>GstFlowReturn  </RETURNS>
GstEbmlRead *ebml, guint32     *id
</FUNCTION>
<FUNCTION>
<NAME>gst_ebml_read_pop_master</NAME>
<RETURNS>GstFlowReturn  </RETURNS>
GstEbmlRead *ebml
</FUNCTION>
<FUNCTION>
<NAME>gst_ebml_read_binary</NAME>
<RETURNS>GstFlowReturn  </RETURNS>
GstEbmlRead *ebml, guint32     *id, guint8     **binary, guint64     *length
</FUNCTION>
<FUNCTION>
<NAME>gst_ebml_read_header</NAME>
<RETURNS>GstFlowReturn  </RETURNS>
GstEbmlRead *read, gchar      **doctype, guint       *version
</FUNCTION>
<FUNCTION>
<NAME>gst_ebml_read_get_pos</NAME>
<RETURNS>guint64 </RETURNS>
GstEbmlRead * ebml
</FUNCTION>
<FUNCTION>
<NAME>gst_ebml_read_get_offset</NAME>
<RETURNS>guint64 </RETURNS>
GstEbmlRead * ebml
</FUNCTION>
<FUNCTION>
<NAME>gst_ebml_read_br</NAME>
<RETURNS>GstByteReader  *</RETURNS>
GstEbmlRead * ebml
</FUNCTION>
<FUNCTION>
<NAME>gst_ebml_read_has_remaining</NAME>
<RETURNS>gboolean </RETURNS>
GstEbmlRead * ebml, guint64 bytes_needed, gboolean auto_pop
</FUNCTION>
<USER_FUNCTION>
<NAME>GstMaskDrawFunc</NAME>
<RETURNS>void </RETURNS>
GstMask *mask
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GstMaskDestroyFunc</NAME>
<RETURNS>void </RETURNS>
GstMask *mask
</USER_FUNCTION>
<STRUCT>
<NAME>GstMaskDefinition</NAME>
struct _GstMaskDefinition {
  gint                   type;
  const gchar           *short_name;
  const gchar           *long_name;
  GstMaskDrawFunc        draw_func;
  GstMaskDestroyFunc     destroy_func;
  gconstpointer          user_data;
};
</STRUCT>
<STRUCT>
<NAME>GstMask</NAME>
struct _GstMask {
  gint                   type;
  guint32               *data;
  gconstpointer          user_data;

  gint                   width;
  gint                   height;
  gint                   bpp;

  GstMaskDestroyFunc     destroy_func;
};
</STRUCT>
<FUNCTION>
<NAME>gst_mask_get_definitions</NAME>
<RETURNS>const GList *            </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_mask_factory_new</NAME>
<RETURNS>GstMask *                </RETURNS>
gint type, gboolean invert, gint bpp, gint width, gint height
</FUNCTION>
<FUNCTION>
<NAME>gst_mask_destroy</NAME>
<RETURNS>void                     </RETURNS>
GstMask *mask
</FUNCTION>
<FUNCTION>
<NAME>gst_smpte_paint_vbox</NAME>
<RETURNS>void     </RETURNS>
guint32 *dest, gint stride, gint x0, gint y0, gint c0, gint x1, gint y1, gint c1
</FUNCTION>
<FUNCTION>
<NAME>gst_smpte_paint_hbox</NAME>
<RETURNS>void     </RETURNS>
guint32 *dest, gint stride, gint x0, gint y0, gint c0, gint x1, gint y1, gint c1
</FUNCTION>
<FUNCTION>
<NAME>gst_smpte_paint_triangle_linear</NAME>
<RETURNS>void     </RETURNS>
guint32 *dest, gint stride, gint x0, gint y0, gint c0, gint x1, gint y1, gint c1, gint x2, gint y2, gint c2
</FUNCTION>
<FUNCTION>
<NAME>gst_smpte_paint_triangle_clock</NAME>
<RETURNS>void     </RETURNS>
guint32 *dest, gint stride, gint x0, gint y0, gint c0, gint x1, gint y1, gint c1, gint x2, gint y2, gint c2
</FUNCTION>
<FUNCTION>
<NAME>gst_smpte_paint_box_clock</NAME>
<RETURNS>void     </RETURNS>
guint32 *dest, gint stride, gint x0, gint y0, gint c0, gint x1, gint y1, gint c1, gint x2, gint y2, gint c2
</FUNCTION>
<ENUM>
<NAME>MatchMode</NAME>
typedef enum
{
  MATCH_MODE_AUTO = 0,
  MATCH_MODE_UTF8,
  MATCH_MODE_RAW
} MatchMode;
</ENUM>
<FUNCTION>
<NAME>pattern_spec_new</NAME>
<RETURNS>PatternSpec  * </RETURNS>
const gchar  * pattern, MatchMode      match_mode
</FUNCTION>
<FUNCTION>
<NAME>pattern_spec_free</NAME>
<RETURNS>void           </RETURNS>
PatternSpec  * pspec
</FUNCTION>
<FUNCTION>
<NAME>pattern_match_string</NAME>
<RETURNS>gboolean       </RETURNS>
PatternSpec  * pspec, const gchar  * string
</FUNCTION>
<STRUCT>
<NAME>PatternSpec</NAME>
</STRUCT>
<MACRO>
<NAME>GST_TYPE_SPLITMUX_PART_READER</NAME>
#define GST_TYPE_SPLITMUX_PART_READER \
  (gst_splitmux_part_reader_get_type())
</MACRO>
<MACRO>
<NAME>GST_SPLITMUX_PART_READER</NAME>
#define GST_SPLITMUX_PART_READER(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_SPLITMUX_PART_READER,GstSplitMuxSrc))
</MACRO>
<MACRO>
<NAME>GST_SPLITMUX_PART_READER_CLASS</NAME>
#define GST_SPLITMUX_PART_READER_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_SPLITMUX_PART_READER,GstSplitMuxSrcClass))
</MACRO>
<MACRO>
<NAME>GST_IS_SPLITMUX_PART_READER</NAME>
#define GST_IS_SPLITMUX_PART_READER(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_SPLITMUX_PART_READER))
</MACRO>
<MACRO>
<NAME>GST_IS_SPLITMUX_PART_READER_CLASS</NAME>
#define GST_IS_SPLITMUX_PART_READER_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_SPLITMUX_PART_READER))
</MACRO>
<ENUM>
<NAME>GstSplitMuxPartState</NAME>
typedef enum
{
  PART_STATE_NULL,
  PART_STATE_PREPARING_COLLECT_STREAMS,
  PART_STATE_PREPARING_MEASURE_STREAMS,
  PART_STATE_PREPARING_RESET_FOR_READY,
  PART_STATE_READY,
  PART_STATE_FAILED,
} GstSplitMuxPartState;
</ENUM>
<USER_FUNCTION>
<NAME>GstSplitMuxPartReaderPadCb</NAME>
<RETURNS>GstPad *</RETURNS>
GstSplitMuxPartReader *reader, GstPad *src_pad, gpointer cb_data
</USER_FUNCTION>
<STRUCT>
<NAME>GstSplitMuxPartReader</NAME>
struct _GstSplitMuxPartReader
{
  GstPipeline parent;

  GstSplitMuxPartState prep_state;

  gchar *path;

  GstElement *src;
  GstElement *typefind;
  GstElement *demux;

  gboolean active;
  gboolean running;
  gboolean prepared;
  gboolean flushing;
  gboolean no_more_pads;

  GstClockTime duration;
  GstClockTime start_offset;

  GList *pads;

  GCond inactive_cond;
  GMutex lock;
  GMutex type_lock;

  GstSplitMuxPartReaderPadCb get_pad_cb;
  gpointer cb_data;
};
</STRUCT>
<STRUCT>
<NAME>GstSplitMuxPartReaderClass</NAME>
struct _GstSplitMuxPartReaderClass
{
  GstPipelineClass parent_class;

  void (*prepared)  (GstSplitMuxPartReader *reader);
  void (*end_of_part) (GstSplitMuxPartReader *reader);
};
</STRUCT>
<FUNCTION>
<NAME>gst_splitmux_part_reader_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_splitmux_part_reader_set_callbacks</NAME>
<RETURNS>void  </RETURNS>
GstSplitMuxPartReader *reader, gpointer cb_data, GstSplitMuxPartReaderPadCb get_pad_cb
</FUNCTION>
<FUNCTION>
<NAME>gst_splitmux_part_reader_prepare</NAME>
<RETURNS>gboolean  </RETURNS>
GstSplitMuxPartReader *part
</FUNCTION>
<FUNCTION>
<NAME>gst_splitmux_part_reader_unprepare</NAME>
<RETURNS>void  </RETURNS>
GstSplitMuxPartReader *part
</FUNCTION>
<FUNCTION>
<NAME>gst_splitmux_part_reader_set_location</NAME>
<RETURNS>void  </RETURNS>
GstSplitMuxPartReader *reader, const gchar *path
</FUNCTION>
<FUNCTION>
<NAME>gst_splitmux_part_is_eos</NAME>
<RETURNS>gboolean  </RETURNS>
GstSplitMuxPartReader *reader
</FUNCTION>
<FUNCTION>
<NAME>gst_splitmux_part_reader_activate</NAME>
<RETURNS>gboolean  </RETURNS>
GstSplitMuxPartReader *part, GstSegment *seg, GstSeekFlags extra_flags
</FUNCTION>
<FUNCTION>
<NAME>gst_splitmux_part_reader_deactivate</NAME>
<RETURNS>void  </RETURNS>
GstSplitMuxPartReader *part
</FUNCTION>
<FUNCTION>
<NAME>gst_splitmux_part_reader_is_active</NAME>
<RETURNS>gboolean  </RETURNS>
GstSplitMuxPartReader *part
</FUNCTION>
<FUNCTION>
<NAME>gst_splitmux_part_reader_src_query</NAME>
<RETURNS>gboolean  </RETURNS>
GstSplitMuxPartReader *part, GstPad *src_pad, GstQuery * query
</FUNCTION>
<FUNCTION>
<NAME>gst_splitmux_part_reader_set_start_offset</NAME>
<RETURNS>void  </RETURNS>
GstSplitMuxPartReader *part, GstClockTime offset
</FUNCTION>
<FUNCTION>
<NAME>gst_splitmux_part_reader_get_start_offset</NAME>
<RETURNS>GstClockTime  </RETURNS>
GstSplitMuxPartReader *part
</FUNCTION>
<FUNCTION>
<NAME>gst_splitmux_part_reader_get_end_offset</NAME>
<RETURNS>GstClockTime  </RETURNS>
GstSplitMuxPartReader *part
</FUNCTION>
<FUNCTION>
<NAME>gst_splitmux_part_reader_get_duration</NAME>
<RETURNS>GstClockTime  </RETURNS>
GstSplitMuxPartReader * reader
</FUNCTION>
<FUNCTION>
<NAME>gst_splitmux_part_reader_lookup_pad</NAME>
<RETURNS>GstPad  *</RETURNS>
GstSplitMuxPartReader *reader, GstPad *target
</FUNCTION>
<FUNCTION>
<NAME>gst_splitmux_part_reader_pop</NAME>
<RETURNS>GstFlowReturn  </RETURNS>
GstSplitMuxPartReader *reader, GstPad *part_pad, GstDataQueueItem ** item
</FUNCTION>
<STRUCT>
<NAME>SplitMuxSrcPad</NAME>
</STRUCT>
<STRUCT>
<NAME>SplitMuxSrcPadClass</NAME>
</STRUCT>
<MACRO>
<NAME>DEFAULT_PATTERN_MATCH_MODE</NAME>
#define DEFAULT_PATTERN_MATCH_MODE MATCH_MODE_UTF8
</MACRO>
<FUNCTION>
<NAME>gst_split_util_find_files</NAME>
<RETURNS>gchar  **</RETURNS>
const gchar * dirname, const gchar * basename, GError ** err
</FUNCTION>
<TYPEDEF>
<NAME>convolve_state</NAME>
typedef struct _struct_convolve_state convolve_state;
</TYPEDEF>
<FUNCTION>
<NAME>convolve_init</NAME>
<RETURNS>convolve_state  *</RETURNS>
int depth
</FUNCTION>
<FUNCTION>
<NAME>convolve_close</NAME>
<RETURNS>void  </RETURNS>
convolve_state * state
</FUNCTION>
<FUNCTION>
<NAME>convolve_match</NAME>
<RETURNS>int  </RETURNS>
const int * lastchoice, const short int * input, convolve_state * state
</FUNCTION>
<MACRO>
<NAME>convolver_depth</NAME>
#define convolver_depth 8
</MACRO>
<MACRO>
<NAME>convolver_small</NAME>
#define convolver_small (1 << convolver_depth)
</MACRO>
<MACRO>
<NAME>convolver_big</NAME>
#define convolver_big (2 << convolver_depth)
</MACRO>
<MACRO>
<NAME>scope_width</NAME>
#define scope_width 256
</MACRO>
<MACRO>
<NAME>scope_height</NAME>
#define scope_height 128
</MACRO>
<STRUCT>
<NAME>monoscope_state</NAME>
struct monoscope_state {
  short copyEq[convolver_big];
  int avgEq[convolver_small];      /* a running average of the last few. */
  int avgMax;                     /* running average of max sample. */
  guint32 display[scope_width * scope_height];

  convolve_state *cstate;
  guint32 colors[scope_height / 2];
};
</STRUCT>
<FUNCTION>
<NAME>monoscope_init</NAME>
<RETURNS>struct monoscope_state  * </RETURNS>
guint32 resx, guint32 resy
</FUNCTION>
<FUNCTION>
<NAME>monoscope_update</NAME>
<RETURNS>guint32  * </RETURNS>
struct monoscope_state * stateptr, gint16 data [convolver_big]
</FUNCTION>
<FUNCTION>
<NAME>monoscope_close</NAME>
<RETURNS>void  </RETURNS>
struct monoscope_state * stateptr
</FUNCTION>
<MACRO>
<NAME>FlxHeaderSize</NAME>
#define FlxHeaderSize 128
</MACRO>
<MACRO>
<NAME>FlxFrameChunkSize</NAME>
#define FlxFrameChunkSize 6
</MACRO>
<MACRO>
<NAME>FlxFrameTypeSize</NAME>
#define FlxFrameTypeSize 10
</MACRO>
<ENUM>
<NAME>FlxColorSpaceType</NAME>
typedef enum {
  FLX_COLORSPACE_RGB8,
  FLX_COLORSPACE_RGB32,
} FlxColorSpaceType;
</ENUM>
<STRUCT>
<NAME>FlxColorSpaceConverter</NAME>
struct _FlxColorSpaceConverter {
  guint      width;
  guint      height;
  guchar      palvec[768];
};
</STRUCT>
<FUNCTION>
<NAME>flx_colorspace_converter_destroy</NAME>
<RETURNS>void  </RETURNS>
FlxColorSpaceConverter *flxpal
</FUNCTION>
<FUNCTION>
<NAME>flx_colorspace_convert</NAME>
<RETURNS>void  </RETURNS>
FlxColorSpaceConverter *flxpal, guchar *src, guchar *dest
</FUNCTION>
<FUNCTION>
<NAME>flx_colorspace_converter_new</NAME>
<RETURNS>FlxColorSpaceConverter  * </RETURNS>
gint width, gint height
</FUNCTION>
<FUNCTION>
<NAME>flx_set_palette_vector</NAME>
<RETURNS>void  </RETURNS>
FlxColorSpaceConverter *flxpal, guint start, guint num, guchar *newpal, gint scale
</FUNCTION>
<FUNCTION>
<NAME>flx_set_color</NAME>
<RETURNS>void  </RETURNS>
FlxColorSpaceConverter *flxpal, guint colr, guint red, guint green, guint blue, gint scale
</FUNCTION>
<MACRO>
<NAME>MIN_INTER_DIGIT_INTERVAL</NAME>
#define MIN_INTER_DIGIT_INTERVAL 100     /* ms */
</MACRO>
<MACRO>
<NAME>MIN_PULSE_DURATION</NAME>
#define MIN_PULSE_DURATION       250     /* ms */
</MACRO>
<MACRO>
<NAME>MIN_VOLUME</NAME>
#define MIN_VOLUME               0
</MACRO>
<MACRO>
<NAME>MAX_VOLUME</NAME>
#define MAX_VOLUME               36
</MACRO>
<MACRO>
<NAME>MIN_EVENT</NAME>
#define MIN_EVENT                0
</MACRO>
<MACRO>
<NAME>MAX_EVENT</NAME>
#define MAX_EVENT                15
</MACRO>
<MACRO>
<NAME>MIN_EVENT_STRING</NAME>
#define MIN_EVENT_STRING         "0"
</MACRO>
<MACRO>
<NAME>MAX_EVENT_STRING</NAME>
#define MAX_EVENT_STRING         "15"
</MACRO>
<FUNCTION>
<NAME>mulaw_encode</NAME>
<RETURNS>void </RETURNS>
gint16* in, guint8* out, gint numsamples
</FUNCTION>
<FUNCTION>
<NAME>mulaw_decode</NAME>
<RETURNS>void </RETURNS>
guint8* in,gint16* out,gint numsamples
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_NAVIGATIONTEST</NAME>
#define GST_TYPE_NAVIGATIONTEST \
  (gst_navigationtest_get_type())
</MACRO>
<MACRO>
<NAME>GST_NAVIGATIONTEST</NAME>
#define GST_NAVIGATIONTEST(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_NAVIGATIONTEST,GstNavigationtest))
</MACRO>
<MACRO>
<NAME>GST_NAVIGATIONTEST_CLASS</NAME>
#define GST_NAVIGATIONTEST_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_NAVIGATIONTEST,GstNavigationtestClass))
</MACRO>
<MACRO>
<NAME>GST_IS_NAVIGATIONTEST</NAME>
#define GST_IS_NAVIGATIONTEST(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_NAVIGATIONTEST))
</MACRO>
<MACRO>
<NAME>GST_IS_NAVIGATIONTEST_CLASS</NAME>
#define GST_IS_NAVIGATIONTEST_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_NAVIGATIONTEST))
</MACRO>
<STRUCT>
<NAME>GstNavigationtest</NAME>
struct _GstNavigationtest
{
  GstVideoFilter videofilter;

  gdouble x, y;
  GSList *clicks;
};
</STRUCT>
<STRUCT>
<NAME>GstNavigationtestClass</NAME>
struct _GstNavigationtestClass
{
  GstVideoFilterClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_navigationtest_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_CPU_REPORT</NAME>
#define GST_TYPE_CPU_REPORT \
  (gst_cpu_report_get_type())
</MACRO>
<MACRO>
<NAME>GST_CPU_REPORT</NAME>
#define GST_CPU_REPORT(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_CPU_REPORT,GstCpuReport))
</MACRO>
<MACRO>
<NAME>GST_CPU_REPORT_CLASS</NAME>
#define GST_CPU_REPORT_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_CPU_REPORT,GstCpuReportClass))
</MACRO>
<MACRO>
<NAME>GST_IS_CPU_REPORT</NAME>
#define GST_IS_CPU_REPORT(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_CPU_REPORT))
</MACRO>
<MACRO>
<NAME>GST_IS_CPU_REPORT_CLASS</NAME>
#define GST_IS_CPU_REPORT_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_CPU_REPORT))
</MACRO>
<STRUCT>
<NAME>GstCpuReport</NAME>
struct _GstCpuReport
{
  GstBaseTransform basetransform;

  GTimeVal start_time;
  GTimeVal last_time;
  clock_t last_cpu_time;
};
</STRUCT>
<STRUCT>
<NAME>GstCpuReportClass</NAME>
struct _GstCpuReportClass
{
  GstBaseTransformClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_cpu_report_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_PUSH_FILE_SRC</NAME>
#define GST_TYPE_PUSH_FILE_SRC \
  (gst_push_file_src_get_type())
</MACRO>
<MACRO>
<NAME>GST_PUSH_FILE_SRC</NAME>
#define GST_PUSH_FILE_SRC(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_PUSH_FILE_SRC,GstPushFileSrc))
</MACRO>
<MACRO>
<NAME>GST_PUSH_FILE_SRC_CLASS</NAME>
#define GST_PUSH_FILE_SRC_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_PUSH_FILE_SRC,GstPushFileSrcClass))
</MACRO>
<MACRO>
<NAME>GST_IS_PUSH_FILE_SRC</NAME>
#define GST_IS_PUSH_FILE_SRC(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_PUSH_FILE_SRC))
</MACRO>
<MACRO>
<NAME>GST_IS_PUSH_FILE_SRC_CLASS</NAME>
#define GST_IS_PUSH_FILE_SRC_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_PUSH_FILE_SRC))
</MACRO>
<STRUCT>
<NAME>GstPushFileSrc</NAME>
struct _GstPushFileSrc
{
  GstBin parent;

  /*< private > */
  GstElement *filesrc;
  GstPad *srcpad;

  gboolean time_segment;
  gboolean seen_first_buffer;
  gint64 stream_time;
  gint64 start_time;
  guint64 initial_timestamp;
  gdouble rate;
  gdouble applied_rate;
};
</STRUCT>
<STRUCT>
<NAME>GstPushFileSrcClass</NAME>
struct _GstPushFileSrcClass
{
  GstBinClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_push_file_src_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_NAVSEEK</NAME>
#define GST_TYPE_NAVSEEK \
  (gst_navseek_get_type())
</MACRO>
<MACRO>
<NAME>GST_NAVSEEK</NAME>
#define GST_NAVSEEK(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_NAVSEEK,GstNavSeek))
</MACRO>
<MACRO>
<NAME>GST_NAVSEEK_CLASS</NAME>
#define GST_NAVSEEK_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_NAVSEEK,GstNavSeekClass))
</MACRO>
<MACRO>
<NAME>GST_IS_NAVSEEK</NAME>
#define GST_IS_NAVSEEK(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_NAVSEEK))
</MACRO>
<MACRO>
<NAME>GST_IS_NAVSEEK_CLASS</NAME>
#define GST_IS_NAVSEEK_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_NAVSEEK))
</MACRO>
<STRUCT>
<NAME>GstNavSeek</NAME>
struct _GstNavSeek
{
  GstBaseTransform basetransform;

  gdouble seek_offset;
  gboolean loop;
  gboolean grab_seg_start;
  gboolean grab_seg_end;
  GstClockTime segment_start;
  GstClockTime segment_end;
};
</STRUCT>
<STRUCT>
<NAME>GstNavSeekClass</NAME>
struct _GstNavSeekClass
{
  GstBaseTransformClass parent_class;
};
</STRUCT>
<STRUCT>
<NAME>GstTestInfo</NAME>
struct _GstTestInfo
{
  GParamSpec *(*get_spec) (const GstTestInfo * info, gboolean compare_value);
    gpointer (*new) (const GstTestInfo * info);
  void (*add) (gpointer test, GstBuffer * buffer);
    gboolean (*finish) (gpointer test, GValue * value);
  void (*get_value) (gpointer test, GValue * value);
  void (*free) (gpointer test);
};
</STRUCT>
<MACRO>
<NAME>TESTS_COUNT</NAME>
#define TESTS_COUNT (4)
</MACRO>
<MACRO>
<NAME>GST_TYPE_CAPS_DEBUG</NAME>
#define GST_TYPE_CAPS_DEBUG   (gst_caps_debug_get_type())
</MACRO>
<MACRO>
<NAME>GST_CAPS_DEBUG</NAME>
#define GST_CAPS_DEBUG(obj)   (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_CAPS_DEBUG,GstCapsDebug))
</MACRO>
<MACRO>
<NAME>GST_CAPS_DEBUG_CLASS</NAME>
#define GST_CAPS_DEBUG_CLASS(klass)   (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_CAPS_DEBUG,GstCapsDebugClass))
</MACRO>
<MACRO>
<NAME>GST_IS_CAPS_DEBUG</NAME>
#define GST_IS_CAPS_DEBUG(obj)   (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_CAPS_DEBUG))
</MACRO>
<MACRO>
<NAME>GST_IS_CAPS_DEBUG_CLASS</NAME>
#define GST_IS_CAPS_DEBUG_CLASS(obj)   (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_CAPS_DEBUG))
</MACRO>
<STRUCT>
<NAME>GstCapsDebug</NAME>
struct _GstCapsDebug
{
  GstElement base_capsdebug;

  GstPad *srcpad;
  GstPad *sinkpad;

};
</STRUCT>
<STRUCT>
<NAME>GstCapsDebugClass</NAME>
struct _GstCapsDebugClass
{
  GstElementClass base_capsdebug_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_caps_debug_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_VIDEO_MEDIAN</NAME>
#define GST_TYPE_VIDEO_MEDIAN \
  (gst_video_median_get_type())
</MACRO>
<MACRO>
<NAME>GST_VIDEO_MEDIAN</NAME>
#define GST_VIDEO_MEDIAN(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_VIDEO_MEDIAN,GstVideoMedian))
</MACRO>
<MACRO>
<NAME>GST_VIDEO_MEDIAN_CLASS</NAME>
#define GST_VIDEO_MEDIAN_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_VIDEO_MEDIAN,GstVideoMedianClass))
</MACRO>
<MACRO>
<NAME>GST_IS_VIDEO_MEDIAN</NAME>
#define GST_IS_VIDEO_MEDIAN(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_VIDEO_MEDIAN))
</MACRO>
<MACRO>
<NAME>GST_IS_VIDEO_MEDIAN_CLASS</NAME>
#define GST_IS_VIDEO_MEDIAN_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_VIDEO_MEDIAN))
</MACRO>
<ENUM>
<NAME>GstVideoMedianSize</NAME>
typedef enum
{
  GST_VIDEO_MEDIAN_SIZE_5 = 5,
  GST_VIDEO_MEDIAN_SIZE_9 = 9
} GstVideoMedianSize;
</ENUM>
<STRUCT>
<NAME>GstVideoMedian</NAME>
struct _GstVideoMedian {
  GstVideoFilter parent;

  GstVideoMedianSize filtersize;
  gboolean lum_only;
};
</STRUCT>
<STRUCT>
<NAME>GstVideoMedianClass</NAME>
struct _GstVideoMedianClass {
  GstVideoFilterClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_video_median_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<STRUCT>
<NAME>GstRTSPExtensionList</NAME>
struct _GstRTSPExtensionList
{
  GList *extensions;
};
</STRUCT>
<FUNCTION>
<NAME>gst_rtsp_ext_list_init</NAME>
<RETURNS>void                     </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_rtsp_ext_list_get</NAME>
<RETURNS>GstRTSPExtensionList  *  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_rtsp_ext_list_free</NAME>
<RETURNS>void                     </RETURNS>
GstRTSPExtensionList *ext
</FUNCTION>
<FUNCTION>
<NAME>gst_rtsp_ext_list_detect_server</NAME>
<RETURNS>gboolean       </RETURNS>
GstRTSPExtensionList *ext, GstRTSPMessage *resp
</FUNCTION>
<FUNCTION>
<NAME>gst_rtsp_ext_list_before_send</NAME>
<RETURNS>GstRTSPResult  </RETURNS>
GstRTSPExtensionList *ext, GstRTSPMessage *req
</FUNCTION>
<FUNCTION>
<NAME>gst_rtsp_ext_list_after_send</NAME>
<RETURNS>GstRTSPResult  </RETURNS>
GstRTSPExtensionList *ext, GstRTSPMessage *req, GstRTSPMessage *resp
</FUNCTION>
<FUNCTION>
<NAME>gst_rtsp_ext_list_parse_sdp</NAME>
<RETURNS>GstRTSPResult  </RETURNS>
GstRTSPExtensionList *ext, GstSDPMessage *sdp, GstStructure *s
</FUNCTION>
<FUNCTION>
<NAME>gst_rtsp_ext_list_setup_media</NAME>
<RETURNS>GstRTSPResult  </RETURNS>
GstRTSPExtensionList *ext, GstSDPMedia *media
</FUNCTION>
<FUNCTION>
<NAME>gst_rtsp_ext_list_configure_stream</NAME>
<RETURNS>gboolean       </RETURNS>
GstRTSPExtensionList *ext, GstCaps *caps
</FUNCTION>
<FUNCTION>
<NAME>gst_rtsp_ext_list_get_transports</NAME>
<RETURNS>GstRTSPResult  </RETURNS>
GstRTSPExtensionList *ext, GstRTSPLowerTrans protocols, gchar **transport
</FUNCTION>
<FUNCTION>
<NAME>gst_rtsp_ext_list_stream_select</NAME>
<RETURNS>GstRTSPResult  </RETURNS>
GstRTSPExtensionList *ext, GstRTSPUrl *url
</FUNCTION>
<FUNCTION>
<NAME>gst_rtsp_ext_list_connect</NAME>
<RETURNS>void           </RETURNS>
GstRTSPExtensionList *ext, const gchar *detailed_signal, GCallback c_handler, gpointer data
</FUNCTION>
<FUNCTION>
<NAME>gst_rtsp_ext_list_receive_request</NAME>
<RETURNS>GstRTSPResult  </RETURNS>
GstRTSPExtensionList *ext, GstRTSPMessage *req
</FUNCTION>
<TYPEDEF>
<NAME>orc_int8</NAME>
typedef int8_t orc_int8;
</TYPEDEF>
<TYPEDEF>
<NAME>orc_int16</NAME>
typedef int16_t orc_int16;
</TYPEDEF>
<TYPEDEF>
<NAME>orc_int32</NAME>
typedef int32_t orc_int32;
</TYPEDEF>
<TYPEDEF>
<NAME>orc_int64</NAME>
typedef int64_t orc_int64;
</TYPEDEF>
<TYPEDEF>
<NAME>orc_uint8</NAME>
typedef uint8_t orc_uint8;
</TYPEDEF>
<TYPEDEF>
<NAME>orc_uint16</NAME>
typedef uint16_t orc_uint16;
</TYPEDEF>
<TYPEDEF>
<NAME>orc_uint32</NAME>
typedef uint32_t orc_uint32;
</TYPEDEF>
<TYPEDEF>
<NAME>orc_uint64</NAME>
typedef uint64_t orc_uint64;
</TYPEDEF>
<MACRO>
<NAME>ORC_UINT64_C</NAME>
#define ORC_UINT64_C(x) UINT64_C(x)
</MACRO>
<MACRO>
<NAME>inline</NAME>
#define inline __inline
</MACRO>
<TYPEDEF>
<NAME>orc_int8</NAME>
typedef int8_t orc_int8;
</TYPEDEF>
<TYPEDEF>
<NAME>orc_int16</NAME>
typedef int16_t orc_int16;
</TYPEDEF>
<TYPEDEF>
<NAME>orc_int32</NAME>
typedef int32_t orc_int32;
</TYPEDEF>
<TYPEDEF>
<NAME>orc_int64</NAME>
typedef int64_t orc_int64;
</TYPEDEF>
<TYPEDEF>
<NAME>orc_uint8</NAME>
typedef uint8_t orc_uint8;
</TYPEDEF>
<TYPEDEF>
<NAME>orc_uint16</NAME>
typedef uint16_t orc_uint16;
</TYPEDEF>
<TYPEDEF>
<NAME>orc_uint32</NAME>
typedef uint32_t orc_uint32;
</TYPEDEF>
<TYPEDEF>
<NAME>orc_uint64</NAME>
typedef uint64_t orc_uint64;
</TYPEDEF>
<MACRO>
<NAME>ORC_UINT64_C</NAME>
#define ORC_UINT64_C(x) UINT64_C(x)
</MACRO>
<MACRO>
<NAME>inline</NAME>
#define inline __inline
</MACRO>
<MACRO>
<NAME>GST_TYPE_RTP_OPUS_PAY</NAME>
#define GST_TYPE_RTP_OPUS_PAY \
  (gst_rtp_opus_pay_get_type())
</MACRO>
<MACRO>
<NAME>GST_RTP_OPUS_PAY</NAME>
#define GST_RTP_OPUS_PAY(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_RTP_OPUS_PAY,GstRtpOPUSPay))
</MACRO>
<MACRO>
<NAME>GST_RTP_OPUS_PAY_CLASS</NAME>
#define GST_RTP_OPUS_PAY_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_RTP_OPUS_PAY,GstRtpOPUSPayClass))
</MACRO>
<MACRO>
<NAME>GST_IS_RTP_OPUS_PAY</NAME>
#define GST_IS_RTP_OPUS_PAY(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_RTP_OPUS_PAY))
</MACRO>
<MACRO>
<NAME>GST_IS_RTP_OPUS_PAY_CLASS</NAME>
#define GST_IS_RTP_OPUS_PAY_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_RTP_OPUS_PAY))
</MACRO>
<STRUCT>
<NAME>GstRtpOPUSPay</NAME>
struct _GstRtpOPUSPay
{
  GstRTPBasePayload payload;
};
</STRUCT>
<STRUCT>
<NAME>GstRtpOPUSPayClass</NAME>
struct _GstRtpOPUSPayClass
{
  GstRTPBasePayloadClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_rtp_opus_pay_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_rtp_opus_pay_plugin_init</NAME>
<RETURNS>gboolean  </RETURNS>
GstPlugin * plugin
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_RTP_AMR_PAY</NAME>
#define GST_TYPE_RTP_AMR_PAY \
  (gst_rtp_amr_pay_get_type())
</MACRO>
<MACRO>
<NAME>GST_RTP_AMR_PAY</NAME>
#define GST_RTP_AMR_PAY(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_RTP_AMR_PAY,GstRtpAMRPay))
</MACRO>
<MACRO>
<NAME>GST_RTP_AMR_PAY_CLASS</NAME>
#define GST_RTP_AMR_PAY_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_RTP_AMR_PAY,GstRtpAMRPayClass))
</MACRO>
<MACRO>
<NAME>GST_IS_RTP_AMR_PAY</NAME>
#define GST_IS_RTP_AMR_PAY(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_RTP_AMR_PAY))
</MACRO>
<MACRO>
<NAME>GST_IS_RTP_AMR_PAY_CLASS</NAME>
#define GST_IS_RTP_AMR_PAY_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_RTP_AMR_PAY))
</MACRO>
<ENUM>
<NAME>GstRtpAMRPayMode</NAME>
typedef enum {
  GST_RTP_AMR_P_MODE_INVALID = 0,
  GST_RTP_AMR_P_MODE_NB      = 1,
  GST_RTP_AMR_P_MODE_WB      = 2
} GstRtpAMRPayMode;
</ENUM>
<STRUCT>
<NAME>GstRtpAMRPay</NAME>
struct _GstRtpAMRPay
{
  GstRTPBasePayload payload;

  GstRtpAMRPayMode mode;
  GstClockTime first_ts;
  guint32 first_rtp_time;
  guint32 next_rtp_time;
};
</STRUCT>
<STRUCT>
<NAME>GstRtpAMRPayClass</NAME>
struct _GstRtpAMRPayClass
{
  GstRTPBasePayloadClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_rtp_amr_pay_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_rtp_amr_pay_plugin_init</NAME>
<RETURNS>gboolean  </RETURNS>
GstPlugin * plugin
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_RTP_G723_PAY</NAME>
#define GST_TYPE_RTP_G723_PAY \
  (gst_rtp_g723_pay_get_type())
</MACRO>
<MACRO>
<NAME>GST_RTP_G723_PAY</NAME>
#define GST_RTP_G723_PAY(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_RTP_G723_PAY,GstRTPG723Pay))
</MACRO>
<MACRO>
<NAME>GST_RTP_G723_PAY_CLASS</NAME>
#define GST_RTP_G723_PAY_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_RTP_G723_PAY,GstRTPG723PayClass))
</MACRO>
<MACRO>
<NAME>GST_IS_RTP_G723_PAY</NAME>
#define GST_IS_RTP_G723_PAY(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_RTP_G723_PAY))
</MACRO>
<MACRO>
<NAME>GST_IS_RTP_G723_PAY_CLASS</NAME>
#define GST_IS_RTP_G723_PAY_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_RTP_G723_PAY))
</MACRO>
<STRUCT>
<NAME>GstRTPG723Pay</NAME>
struct _GstRTPG723Pay
{
  GstRTPBasePayload payload;

  GstAdapter  *adapter;
  GstClockTime duration;
  GstClockTime timestamp;
  gboolean discont;
};
</STRUCT>
<STRUCT>
<NAME>GstRTPG723PayClass</NAME>
struct _GstRTPG723PayClass
{
  GstRTPBasePayloadClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_rtp_g723_pay_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_rtp_g723_pay_plugin_init</NAME>
<RETURNS>gboolean  </RETURNS>
GstPlugin * plugin
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_RTP_SPEEX_DEPAY</NAME>
#define GST_TYPE_RTP_SPEEX_DEPAY \
  (gst_rtp_speex_depay_get_type())
</MACRO>
<MACRO>
<NAME>GST_RTP_SPEEX_DEPAY</NAME>
#define GST_RTP_SPEEX_DEPAY(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_RTP_SPEEX_DEPAY,GstRtpSPEEXDepay))
</MACRO>
<MACRO>
<NAME>GST_RTP_SPEEX_DEPAY_CLASS</NAME>
#define GST_RTP_SPEEX_DEPAY_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_RTP_SPEEX_DEPAY,GstRtpSPEEXDepayClass))
</MACRO>
<MACRO>
<NAME>GST_IS_RTP_SPEEX_DEPAY</NAME>
#define GST_IS_RTP_SPEEX_DEPAY(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_RTP_SPEEX_DEPAY))
</MACRO>
<MACRO>
<NAME>GST_IS_RTP_SPEEX_DEPAY_CLASS</NAME>
#define GST_IS_RTP_SPEEX_DEPAY_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_RTP_SPEEX_DEPAY))
</MACRO>
<STRUCT>
<NAME>GstRtpSPEEXDepay</NAME>
struct _GstRtpSPEEXDepay
{
  GstRTPBaseDepayload depayload;
};
</STRUCT>
<STRUCT>
<NAME>GstRtpSPEEXDepayClass</NAME>
struct _GstRtpSPEEXDepayClass
{
  GstRTPBaseDepayloadClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_rtp_speex_depay_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_rtp_speex_depay_plugin_init</NAME>
<RETURNS>gboolean  </RETURNS>
GstPlugin * plugin
</FUNCTION>
<FUNCTION>
<NAME>fnv1_hash_32_new</NAME>
<RETURNS>guint32  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>fnv1_hash_32_update</NAME>
<RETURNS>guint32  </RETURNS>
guint32 hash, const guchar *data, guint length
</FUNCTION>
<FUNCTION>
<NAME>fnv1_hash_32_to_24</NAME>
<RETURNS>guint32  </RETURNS>
guint32 hash
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_RTP_G729_DEPAY</NAME>
#define GST_TYPE_RTP_G729_DEPAY \
  (gst_rtp_g729_depay_get_type())
</MACRO>
<MACRO>
<NAME>GST_RTP_G729_DEPAY</NAME>
#define GST_RTP_G729_DEPAY(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_RTP_G729_DEPAY,GstRtpG729Depay))
</MACRO>
<MACRO>
<NAME>GST_RTP_G729_DEPAY_CLASS</NAME>
#define GST_RTP_G729_DEPAY_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_RTP_G729_DEPAY,GstRtpG729DepayClass))
</MACRO>
<MACRO>
<NAME>GST_IS_RTP_G729_DEPAY</NAME>
#define GST_IS_RTP_G729_DEPAY(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_RTP_G729_DEPAY))
</MACRO>
<MACRO>
<NAME>GST_IS_RTP_G729_DEPAY_CLASS</NAME>
#define GST_IS_RTP_G729_DEPAY_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_RTP_G729_DEPAY))
</MACRO>
<STRUCT>
<NAME>GstRtpG729Depay</NAME>
struct _GstRtpG729Depay
{
  GstRTPBaseDepayload depayload;
};
</STRUCT>
<STRUCT>
<NAME>GstRtpG729DepayClass</NAME>
struct _GstRtpG729DepayClass
{
  GstRTPBaseDepayloadClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_rtp_g729_depay_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_rtp_g729_depay_plugin_init</NAME>
<RETURNS>gboolean  </RETURNS>
GstPlugin * plugin
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_RTP_VORBIS_PAY</NAME>
#define GST_TYPE_RTP_VORBIS_PAY \
  (gst_rtp_vorbis_pay_get_type())
</MACRO>
<MACRO>
<NAME>GST_RTP_VORBIS_PAY</NAME>
#define GST_RTP_VORBIS_PAY(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_RTP_VORBIS_PAY,GstRtpVorbisPay))
</MACRO>
<MACRO>
<NAME>GST_RTP_VORBIS_PAY_CLASS</NAME>
#define GST_RTP_VORBIS_PAY_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_RTP_VORBIS_PAY,GstRtpVorbisPayClass))
</MACRO>
<MACRO>
<NAME>GST_IS_RTP_VORBIS_PAY</NAME>
#define GST_IS_RTP_VORBIS_PAY(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_RTP_VORBIS_PAY))
</MACRO>
<MACRO>
<NAME>GST_IS_RTP_VORBIS_PAY_CLASS</NAME>
#define GST_IS_RTP_VORBIS_PAY_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_RTP_VORBIS_PAY))
</MACRO>
<STRUCT>
<NAME>GstRtpVorbisPay</NAME>
struct _GstRtpVorbisPay
{
  GstRTPBasePayload payload;

  /* the headers */
  gboolean      need_headers;
  GList        *headers;

  /* queues of buffers along with some stats. */
  GstBuffer    *packet;
  GList        *packet_buffers;
  guint         payload_pos;
  guint         payload_left;
  guint32       payload_ident;
  guint8        payload_F;
  guint8        payload_VDT;
  guint         payload_pkts;
  GstClockTime  payload_timestamp;
  GstClockTime  payload_duration;

  /* config (re-sending) */
  guint8       *config_data;
  guint         config_size;
  guint         config_extra_len;
  guint         config_interval;
  GstClockTime  last_config;

  gint          rate;
  gint          channels;
};
</STRUCT>
<STRUCT>
<NAME>GstRtpVorbisPayClass</NAME>
struct _GstRtpVorbisPayClass
{
  GstRTPBasePayloadClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_rtp_vorbis_pay_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_rtp_vorbis_pay_plugin_init</NAME>
<RETURNS>gboolean  </RETURNS>
GstPlugin * plugin
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_RTP_GST_PAY</NAME>
#define GST_TYPE_RTP_GST_PAY \
  (gst_rtp_gst_pay_get_type())
</MACRO>
<MACRO>
<NAME>GST_RTP_GST_PAY</NAME>
#define GST_RTP_GST_PAY(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_RTP_GST_PAY,GstRtpGSTPay))
</MACRO>
<MACRO>
<NAME>GST_RTP_GST_PAY_CLASS</NAME>
#define GST_RTP_GST_PAY_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_RTP_GST_PAY,GstRtpGSTPayClass))
</MACRO>
<MACRO>
<NAME>GST_IS_RTP_GST_PAY</NAME>
#define GST_IS_RTP_GST_PAY(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_RTP_GST_PAY))
</MACRO>
<MACRO>
<NAME>GST_IS_RTP_GST_PAY_CLASS</NAME>
#define GST_IS_RTP_GST_PAY_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_RTP_GST_PAY))
</MACRO>
<STRUCT>
<NAME>GstRtpGSTPay</NAME>
struct _GstRtpGSTPay
{
  GstRTPBasePayload payload;

  GList *pending_buffers; /* GstBufferList */
  GstAdapter *adapter;
  guint8 flags;
  guint8 etype;

  guint8 current_CV; /* CV field of incoming caps*/
  guint8 next_CV;

  gchar *stream_id;
  GstTagList *taglist;
  guint config_interval;
  GstClockTime last_config;
};
</STRUCT>
<STRUCT>
<NAME>GstRtpGSTPayClass</NAME>
struct _GstRtpGSTPayClass
{
  GstRTPBasePayloadClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_rtp_gst_pay_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_rtp_gst_pay_plugin_init</NAME>
<RETURNS>gboolean  </RETURNS>
GstPlugin * plugin
</FUNCTION>
<MACRO>
<NAME>channel_orders</NAME>
#define channel_orders gst_rtp_channel_orders
</MACRO>
<FUNCTION>
<NAME>gst_rtp_channels_get_by_pos</NAME>
<RETURNS>const GstRTPChannelOrder  *   </RETURNS>
gint channels, const GstAudioChannelPosition *pos
</FUNCTION>
<FUNCTION>
<NAME>gst_rtp_channels_get_by_order</NAME>
<RETURNS>const GstRTPChannelOrder  *   </RETURNS>
gint channels, const gchar *order
</FUNCTION>
<FUNCTION>
<NAME>gst_rtp_channels_get_by_index</NAME>
<RETURNS>const GstRTPChannelOrder  *   </RETURNS>
gint channels, guint idx
</FUNCTION>
<FUNCTION>
<NAME>gst_rtp_channels_create_default</NAME>
<RETURNS>void                          </RETURNS>
gint channels, GstAudioChannelPosition *pos
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_RTP_G723_DEPAY</NAME>
#define GST_TYPE_RTP_G723_DEPAY \
  (gst_rtp_g723_depay_get_type())
</MACRO>
<MACRO>
<NAME>GST_RTP_G723_DEPAY</NAME>
#define GST_RTP_G723_DEPAY(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_RTP_G723_DEPAY,GstRtpG723Depay))
</MACRO>
<MACRO>
<NAME>GST_RTP_G723_DEPAY_CLASS</NAME>
#define GST_RTP_G723_DEPAY_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_RTP_G723_DEPAY,GstRtpG723DepayClass))
</MACRO>
<MACRO>
<NAME>GST_IS_RTP_G723_DEPAY</NAME>
#define GST_IS_RTP_G723_DEPAY(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_RTP_G723_DEPAY))
</MACRO>
<MACRO>
<NAME>GST_IS_RTP_G723_DEPAY_CLASS</NAME>
#define GST_IS_RTP_G723_DEPAY_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_RTP_G723_DEPAY))
</MACRO>
<STRUCT>
<NAME>GstRtpG723Depay</NAME>
struct _GstRtpG723Depay
{
  GstRTPBaseDepayload depayload;
};
</STRUCT>
<STRUCT>
<NAME>GstRtpG723DepayClass</NAME>
struct _GstRtpG723DepayClass
{
  GstRTPBaseDepayloadClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_rtp_g723_depay_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_rtp_g723_depay_plugin_init</NAME>
<RETURNS>gboolean  </RETURNS>
GstPlugin * plugin
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_RTP_L16_DEPAY</NAME>
#define GST_TYPE_RTP_L16_DEPAY \
  (gst_rtp_L16_depay_get_type())
</MACRO>
<MACRO>
<NAME>GST_RTP_L16_DEPAY</NAME>
#define GST_RTP_L16_DEPAY(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_RTP_L16_DEPAY,GstRtpL16Depay))
</MACRO>
<MACRO>
<NAME>GST_RTP_L16_DEPAY_CLASS</NAME>
#define GST_RTP_L16_DEPAY_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_RTP_L16_DEPAY,GstRtpL16DepayClass))
</MACRO>
<MACRO>
<NAME>GST_IS_RTP_L16_DEPAY</NAME>
#define GST_IS_RTP_L16_DEPAY(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_RTP_L16_DEPAY))
</MACRO>
<MACRO>
<NAME>GST_IS_RTP_L16_DEPAY_CLASS</NAME>
#define GST_IS_RTP_L16_DEPAY_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_RTP_L16_DEPAY))
</MACRO>
<STRUCT>
<NAME>GstRtpL16Depay</NAME>
struct _GstRtpL16Depay
{
  GstRTPBaseDepayload depayload;

  GstAudioInfo info;
  const GstRTPChannelOrder *order;
};
</STRUCT>
<STRUCT>
<NAME>GstRtpL16DepayClass</NAME>
struct _GstRtpL16DepayClass
{
  GstRTPBaseDepayloadClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_rtp_L16_depay_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_rtp_L16_depay_plugin_init</NAME>
<RETURNS>gboolean  </RETURNS>
GstPlugin * plugin
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_RTP_MP4A_PAY</NAME>
#define GST_TYPE_RTP_MP4A_PAY \
  (gst_rtp_mp4a_pay_get_type())
</MACRO>
<MACRO>
<NAME>GST_RTP_MP4A_PAY</NAME>
#define GST_RTP_MP4A_PAY(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_RTP_MP4A_PAY,GstRtpMP4APay))
</MACRO>
<MACRO>
<NAME>GST_RTP_MP4A_PAY_CLASS</NAME>
#define GST_RTP_MP4A_PAY_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_RTP_MP4A_PAY,GstRtpMP4APayClass))
</MACRO>
<MACRO>
<NAME>GST_IS_RTP_MP4A_PAY</NAME>
#define GST_IS_RTP_MP4A_PAY(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_RTP_MP4A_PAY))
</MACRO>
<MACRO>
<NAME>GST_IS_RTP_MP4A_PAY_CLASS</NAME>
#define GST_IS_RTP_MP4A_PAY_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_RTP_MP4A_PAY))
</MACRO>
<STRUCT>
<NAME>GstRtpMP4APay</NAME>
struct _GstRtpMP4APay
{
  GstRTPBasePayload    payload;

  gint          rate;
  gchar        *params;
  gchar        *profile;
  const gchar  *streamtype;
  GstBuffer    *config;
};
</STRUCT>
<STRUCT>
<NAME>GstRtpMP4APayClass</NAME>
struct _GstRtpMP4APayClass
{
  GstRTPBasePayloadClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_rtp_mp4a_pay_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_rtp_mp4a_pay_plugin_init</NAME>
<RETURNS>gboolean  </RETURNS>
GstPlugin * plugin
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_RTP_MP4V_DEPAY</NAME>
#define GST_TYPE_RTP_MP4V_DEPAY \
  (gst_rtp_mp4v_depay_get_type())
</MACRO>
<MACRO>
<NAME>GST_RTP_MP4V_DEPAY</NAME>
#define GST_RTP_MP4V_DEPAY(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_RTP_MP4V_DEPAY,GstRtpMP4VDepay))
</MACRO>
<MACRO>
<NAME>GST_RTP_MP4V_DEPAY_CLASS</NAME>
#define GST_RTP_MP4V_DEPAY_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_RTP_MP4V_DEPAY,GstRtpMP4VDepayClass))
</MACRO>
<MACRO>
<NAME>GST_IS_RTP_MP4V_DEPAY</NAME>
#define GST_IS_RTP_MP4V_DEPAY(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_RTP_MP4V_DEPAY))
</MACRO>
<MACRO>
<NAME>GST_IS_RTP_MP4V_DEPAY_CLASS</NAME>
#define GST_IS_RTP_MP4V_DEPAY_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_RTP_MP4V_DEPAY))
</MACRO>
<STRUCT>
<NAME>GstRtpMP4VDepay</NAME>
struct _GstRtpMP4VDepay
{
  GstRTPBaseDepayload depayload;
  
  GstAdapter *adapter;
};
</STRUCT>
<STRUCT>
<NAME>GstRtpMP4VDepayClass</NAME>
struct _GstRtpMP4VDepayClass
{
  GstRTPBaseDepayloadClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_rtp_mp4v_depay_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_rtp_mp4v_depay_plugin_init</NAME>
<RETURNS>gboolean  </RETURNS>
GstPlugin * plugin
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_RTP_CELT_PAY</NAME>
#define GST_TYPE_RTP_CELT_PAY \
  (gst_rtp_celt_pay_get_type())
</MACRO>
<MACRO>
<NAME>GST_RTP_CELT_PAY</NAME>
#define GST_RTP_CELT_PAY(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_RTP_CELT_PAY,GstRtpCELTPay))
</MACRO>
<MACRO>
<NAME>GST_RTP_CELT_PAY_CLASS</NAME>
#define GST_RTP_CELT_PAY_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_RTP_CELT_PAY,GstRtpCELTPayClass))
</MACRO>
<MACRO>
<NAME>GST_IS_RTP_CELT_PAY</NAME>
#define GST_IS_RTP_CELT_PAY(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_RTP_CELT_PAY))
</MACRO>
<MACRO>
<NAME>GST_IS_RTP_CELT_PAY_CLASS</NAME>
#define GST_IS_RTP_CELT_PAY_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_RTP_CELT_PAY))
</MACRO>
<STRUCT>
<NAME>GstRtpCELTPay</NAME>
struct _GstRtpCELTPay
{
  GstRTPBasePayload payload;

  guint64 packet;

  /* queue to hold packets */
  GQueue      *queue;
  guint        sbytes;    /* bytes queued for sizes */
  guint        bytes;     /* bytes queued for data */
  GstClockTime qduration; /* queued duration */
};
</STRUCT>
<STRUCT>
<NAME>GstRtpCELTPayClass</NAME>
struct _GstRtpCELTPayClass
{
  GstRTPBasePayloadClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_rtp_celt_pay_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_rtp_celt_pay_plugin_init</NAME>
<RETURNS>gboolean  </RETURNS>
GstPlugin * plugin
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_RTP_H264_DEPAY</NAME>
#define GST_TYPE_RTP_H264_DEPAY \
  (gst_rtp_h264_depay_get_type())
</MACRO>
<MACRO>
<NAME>GST_RTP_H264_DEPAY</NAME>
#define GST_RTP_H264_DEPAY(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_RTP_H264_DEPAY,GstRtpH264Depay))
</MACRO>
<MACRO>
<NAME>GST_RTP_H264_DEPAY_CLASS</NAME>
#define GST_RTP_H264_DEPAY_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_RTP_H264_DEPAY,GstRtpH264DepayClass))
</MACRO>
<MACRO>
<NAME>GST_IS_RTP_H264_DEPAY</NAME>
#define GST_IS_RTP_H264_DEPAY(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_RTP_H264_DEPAY))
</MACRO>
<MACRO>
<NAME>GST_IS_RTP_H264_DEPAY_CLASS</NAME>
#define GST_IS_RTP_H264_DEPAY_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_RTP_H264_DEPAY))
</MACRO>
<STRUCT>
<NAME>GstRtpH264Depay</NAME>
struct _GstRtpH264Depay
{
  GstRTPBaseDepayload depayload;

  gboolean    byte_stream;

  GstBuffer  *codec_data;
  GstAdapter *adapter;
  gboolean    wait_start;

  /* nal merging */
  gboolean    merge;
  GstAdapter *picture_adapter;
  gboolean    picture_start;
  GstClockTime last_ts;
  gboolean    last_keyframe;

  /* Work around broken payloaders wrt. FU-A & FU-B */
  guint8 current_fu_type;
  GstClockTime fu_timestamp;
  gboolean fu_marker;

  /* misc */
  GPtrArray *sps;
  GPtrArray *pps;
  gboolean new_codec_data;
};
</STRUCT>
<STRUCT>
<NAME>GstRtpH264DepayClass</NAME>
struct _GstRtpH264DepayClass
{
  GstRTPBaseDepayloadClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_rtp_h264_depay_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_rtp_h264_depay_plugin_init</NAME>
<RETURNS>gboolean  </RETURNS>
GstPlugin * plugin
</FUNCTION>
<FUNCTION>
<NAME>gst_rtp_h264_add_sps_pps</NAME>
<RETURNS>gboolean  </RETURNS>
GstElement * rtph264, GPtrArray * sps, GPtrArray * pps, GstBuffer * nal
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_RTP_MPA_DEPAY</NAME>
#define GST_TYPE_RTP_MPA_DEPAY \
  (gst_rtp_mpa_depay_get_type())
</MACRO>
<MACRO>
<NAME>GST_RTP_MPA_DEPAY</NAME>
#define GST_RTP_MPA_DEPAY(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_RTP_MPA_DEPAY,GstRtpMPADepay))
</MACRO>
<MACRO>
<NAME>GST_RTP_MPA_DEPAY_CLASS</NAME>
#define GST_RTP_MPA_DEPAY_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_RTP_MPA_DEPAY,GstRtpMPADepayClass))
</MACRO>
<MACRO>
<NAME>GST_IS_RTP_MPA_DEPAY</NAME>
#define GST_IS_RTP_MPA_DEPAY(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_RTP_MPA_DEPAY))
</MACRO>
<MACRO>
<NAME>GST_IS_RTP_MPA_DEPAY_CLASS</NAME>
#define GST_IS_RTP_MPA_DEPAY_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_RTP_MPA_DEPAY))
</MACRO>
<STRUCT>
<NAME>GstRtpMPADepay</NAME>
struct _GstRtpMPADepay
{
  GstRTPBaseDepayload depayload;
};
</STRUCT>
<STRUCT>
<NAME>GstRtpMPADepayClass</NAME>
struct _GstRtpMPADepayClass
{
  GstRTPBaseDepayloadClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_rtp_mpa_depay_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_rtp_mpa_depay_plugin_init</NAME>
<RETURNS>gboolean  </RETURNS>
GstPlugin * plugin
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_RTP_H263P_PAY</NAME>
#define GST_TYPE_RTP_H263P_PAY \
  (gst_rtp_h263p_pay_get_type())
</MACRO>
<MACRO>
<NAME>GST_RTP_H263P_PAY</NAME>
#define GST_RTP_H263P_PAY(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_RTP_H263P_PAY,GstRtpH263PPay))
</MACRO>
<MACRO>
<NAME>GST_RTP_H263P_PAY_CLASS</NAME>
#define GST_RTP_H263P_PAY_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_RTP_H263P_PAY,GstRtpH263PPayClass))
</MACRO>
<MACRO>
<NAME>GST_IS_RTP_H263P_PAY</NAME>
#define GST_IS_RTP_H263P_PAY(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_RTP_H263P_PAY))
</MACRO>
<MACRO>
<NAME>GST_IS_RTP_H263P_PAY_CLASS</NAME>
#define GST_IS_RTP_H263P_PAY_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_RTP_H263P_PAY))
</MACRO>
<ENUM>
<NAME>GstFragmentationMode</NAME>
typedef enum
{
  GST_FRAGMENTATION_MODE_NORMAL = 0,
  GST_FRAGMENTATION_MODE_SYNC   = 1
} GstFragmentationMode;
</ENUM>
<STRUCT>
<NAME>GstRtpH263PPay</NAME>
struct _GstRtpH263PPay
{
  GstRTPBasePayload    payload;

  GstAdapter          *adapter;
  GstClockTime         first_timestamp;
  GstClockTime         first_duration;
  GstFragmentationMode fragmentation_mode;
};
</STRUCT>
<STRUCT>
<NAME>GstRtpH263PPayClass</NAME>
struct _GstRtpH263PPayClass
{
  GstRTPBasePayloadClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_rtp_h263p_pay_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_rtp_h263p_pay_plugin_init</NAME>
<RETURNS>gboolean  </RETURNS>
GstPlugin * plugin
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_RTP_SPEEX_PAY</NAME>
#define GST_TYPE_RTP_SPEEX_PAY \
  (gst_rtp_speex_pay_get_type())
</MACRO>
<MACRO>
<NAME>GST_RTP_SPEEX_PAY</NAME>
#define GST_RTP_SPEEX_PAY(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_RTP_SPEEX_PAY,GstRtpSPEEXPay))
</MACRO>
<MACRO>
<NAME>GST_RTP_SPEEX_PAY_CLASS</NAME>
#define GST_RTP_SPEEX_PAY_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_RTP_SPEEX_PAY,GstRtpSPEEXPayClass))
</MACRO>
<MACRO>
<NAME>GST_IS_RTP_SPEEX_PAY</NAME>
#define GST_IS_RTP_SPEEX_PAY(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_RTP_SPEEX_PAY))
</MACRO>
<MACRO>
<NAME>GST_IS_RTP_SPEEX_PAY_CLASS</NAME>
#define GST_IS_RTP_SPEEX_PAY_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_RTP_SPEEX_PAY))
</MACRO>
<STRUCT>
<NAME>GstRtpSPEEXPay</NAME>
struct _GstRtpSPEEXPay
{
  GstRTPBasePayload payload;

  guint64 packet;
};
</STRUCT>
<STRUCT>
<NAME>GstRtpSPEEXPayClass</NAME>
struct _GstRtpSPEEXPayClass
{
  GstRTPBasePayloadClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_rtp_speex_pay_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_rtp_speex_pay_plugin_init</NAME>
<RETURNS>gboolean  </RETURNS>
GstPlugin * plugin
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_RTP_MP4G_PAY</NAME>
#define GST_TYPE_RTP_MP4G_PAY \
  (gst_rtp_mp4g_pay_get_type())
</MACRO>
<MACRO>
<NAME>GST_RTP_MP4G_PAY</NAME>
#define GST_RTP_MP4G_PAY(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_RTP_MP4G_PAY,GstRtpMP4GPay))
</MACRO>
<MACRO>
<NAME>GST_RTP_MP4G_PAY_CLASS</NAME>
#define GST_RTP_MP4G_PAY_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_RTP_MP4G_PAY,GstRtpMP4GPayClass))
</MACRO>
<MACRO>
<NAME>GST_IS_RTP_MP4G_PAY</NAME>
#define GST_IS_RTP_MP4G_PAY(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_RTP_MP4G_PAY))
</MACRO>
<MACRO>
<NAME>GST_IS_RTP_MP4G_PAY_CLASS</NAME>
#define GST_IS_RTP_MP4G_PAY_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_RTP_MP4G_PAY))
</MACRO>
<STRUCT>
<NAME>GstRtpMP4GPay</NAME>
struct _GstRtpMP4GPay
{
  GstRTPBasePayload    payload;

  GstAdapter   *adapter;
  GstClockTime  first_timestamp;
  GstClockTime  first_duration;
  gboolean      discont;

  gint          rate;
  gchar        *params;
  gchar        *profile;
  const gchar  *streamtype;
  const gchar  *mode;
  GstBuffer    *config;
  guint         frame_len;
};
</STRUCT>
<STRUCT>
<NAME>GstRtpMP4GPayClass</NAME>
struct _GstRtpMP4GPayClass
{
  GstRTPBasePayloadClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_rtp_mp4g_pay_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_rtp_mp4g_pay_plugin_init</NAME>
<RETURNS>gboolean  </RETURNS>
GstPlugin * plugin
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_RTP_MPV_PAY</NAME>
#define GST_TYPE_RTP_MPV_PAY \
  (gst_rtp_mpv_pay_get_type())
</MACRO>
<MACRO>
<NAME>GST_RTP_MPV_PAY</NAME>
#define GST_RTP_MPV_PAY(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_RTP_MPV_PAY,GstRTPMPVPay))
</MACRO>
<MACRO>
<NAME>GST_RTP_MPV_PAY_CLASS</NAME>
#define GST_RTP_MPV_PAY_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_RTP_MPV_PAY,GstRTPMPVPayClass))
</MACRO>
<MACRO>
<NAME>GST_IS_RTP_MPV_PAY</NAME>
#define GST_IS_RTP_MPV_PAY(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_RTP_MPV_PAY))
</MACRO>
<MACRO>
<NAME>GST_IS_RTP_MPV_PAY_CLASS</NAME>
#define GST_IS_RTP_MPV_PAY_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_RTP_MPV_PAY))
</MACRO>
<STRUCT>
<NAME>GstRTPMPVPay</NAME>
struct _GstRTPMPVPay
{
  GstRTPBasePayload payload;

  GstAdapter  *adapter;
  GstClockTime first_ts;
  GstClockTime duration;
};
</STRUCT>
<STRUCT>
<NAME>GstRTPMPVPayClass</NAME>
struct _GstRTPMPVPayClass
{
  GstRTPBasePayloadClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_rtp_mpv_pay_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_rtp_mpv_pay_plugin_init</NAME>
<RETURNS>gboolean  </RETURNS>
GstPlugin * plugin
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_RTP_VP8_PAY</NAME>
#define GST_TYPE_RTP_VP8_PAY \
  (gst_rtp_vp8_pay_get_type())
</MACRO>
<MACRO>
<NAME>GST_RTP_VP8_PAY</NAME>
#define GST_RTP_VP8_PAY(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj), GST_TYPE_RTP_VP8_PAY, GstRtpVP8Pay))
</MACRO>
<MACRO>
<NAME>GST_RTP_VP8_PAY_CLASS</NAME>
#define GST_RTP_VP8_PAY_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass), GST_TYPE_RTP_VP8_PAY, GstRtpVP8PayClass))
</MACRO>
<MACRO>
<NAME>GST_IS_RTP_VP8_PAY</NAME>
#define GST_IS_RTP_VP8_PAY(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj), GST_TYPE_RTP_VP8_PAY))
</MACRO>
<MACRO>
<NAME>GST_IS_RTP_VP8_PAY_CLASS</NAME>
#define GST_IS_RTP_VP8_PAY_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass), GST_TYPE_RTP_VP8_PAY))
</MACRO>
<MACRO>
<NAME>GST_RTP_VP8_PAY_GET_CLASS</NAME>
#define GST_RTP_VP8_PAY_GET_CLASS(obj) \
  (G_TYPE_INSTANCE_GET_CLASS ((obj), GST_TYPE_RTP_VP8_PAY, GstRtpVP8PayClass))
</MACRO>
<ENUM>
<NAME>PictureIDMode</NAME>
enum PictureIDMode {
  VP8_PAY_NO_PICTURE_ID,
  VP8_PAY_PICTURE_ID_7BITS,
  VP8_PAY_PICTURE_ID_15BITS,
};
</ENUM>
<STRUCT>
<NAME>GstRtpVP8PayClass</NAME>
struct _GstRtpVP8PayClass
{
  GstRTPBasePayloadClass parent_class;
};
</STRUCT>
<STRUCT>
<NAME>GstRtpVP8Pay</NAME>
struct _GstRtpVP8Pay
{
  GstRTPBasePayload parent;
  gboolean is_keyframe;
  gint n_partitions;
  /* Treat frame header & tag & partition size block as the first partition,
   * folowed by max. 8 data partitions. last offset is the end of the buffer */
  guint partition_offset[10];
  guint partition_size[9];
  PictureIDMode picture_id_mode;
  guint16 picture_id;
};
</STRUCT>
<FUNCTION>
<NAME>gst_rtp_vp8_pay_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_rtp_vp8_pay_plugin_init</NAME>
<RETURNS>gboolean  </RETURNS>
GstPlugin * plugin
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_RTP_MP2T_DEPAY</NAME>
#define GST_TYPE_RTP_MP2T_DEPAY \
  (gst_rtp_mp2t_depay_get_type())
</MACRO>
<MACRO>
<NAME>GST_RTP_MP2T_DEPAY</NAME>
#define GST_RTP_MP2T_DEPAY(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_RTP_MP2T_DEPAY,GstRtpMP2TDepay))
</MACRO>
<MACRO>
<NAME>GST_RTP_MP2T_DEPAY_CLASS</NAME>
#define GST_RTP_MP2T_DEPAY_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_RTP_MP2T_DEPAY,GstRtpMP2TDepayClass))
</MACRO>
<MACRO>
<NAME>GST_IS_RTP_MP2T_DEPAY</NAME>
#define GST_IS_RTP_MP2T_DEPAY(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_RTP_MP2T_DEPAY))
</MACRO>
<MACRO>
<NAME>GST_IS_RTP_MP2T_DEPAY_CLASS</NAME>
#define GST_IS_RTP_MP2T_DEPAY_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_RTP_MP2T_DEPAY))
</MACRO>
<STRUCT>
<NAME>GstRtpMP2TDepay</NAME>
struct _GstRtpMP2TDepay
{
  GstRTPBaseDepayload depayload;

  guint8 skip_first_bytes;
};
</STRUCT>
<STRUCT>
<NAME>GstRtpMP2TDepayClass</NAME>
struct _GstRtpMP2TDepayClass
{
  GstRTPBaseDepayloadClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_rtp_mp2t_depay_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_rtp_mp2t_depay_plugin_init</NAME>
<RETURNS>gboolean  </RETURNS>
GstPlugin * plugin
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_RTP_J2K_DEPAY</NAME>
#define GST_TYPE_RTP_J2K_DEPAY \
  (gst_rtp_j2k_depay_get_type())
</MACRO>
<MACRO>
<NAME>GST_RTP_J2K_DEPAY</NAME>
#define GST_RTP_J2K_DEPAY(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_RTP_J2K_DEPAY,GstRtpJ2KDepay))
</MACRO>
<MACRO>
<NAME>GST_RTP_J2K_DEPAY_CLASS</NAME>
#define GST_RTP_J2K_DEPAY_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_RTP_J2K_DEPAY,GstRtpJ2KDepayClass))
</MACRO>
<MACRO>
<NAME>GST_IS_RTP_J2K_DEPAY</NAME>
#define GST_IS_RTP_J2K_DEPAY(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_RTP_J2K_DEPAY))
</MACRO>
<MACRO>
<NAME>GST_IS_RTP_J2K_DEPAY_CLASS</NAME>
#define GST_IS_RTP_J2K_DEPAY_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_RTP_J2K_DEPAY))
</MACRO>
<STRUCT>
<NAME>GstRtpJ2KDepay</NAME>
struct _GstRtpJ2KDepay
{
  GstRTPBaseDepayload depayload;

  guint64 last_rtptime;
  guint last_mh_id;
  guint last_tile;

  GstBuffer *MH[8];

  guint pu_MHF;
  GstAdapter *pu_adapter;
  GstAdapter *t_adapter;
  GstAdapter *f_adapter;

  guint next_frag;
  gboolean have_sync;

  gint width, height;
};
</STRUCT>
<STRUCT>
<NAME>GstRtpJ2KDepayClass</NAME>
struct _GstRtpJ2KDepayClass
{
  GstRTPBaseDepayloadClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_rtp_j2k_depay_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_rtp_j2k_depay_plugin_init</NAME>
<RETURNS>gboolean  </RETURNS>
GstPlugin * plugin
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_RTP_MP2T_PAY</NAME>
#define GST_TYPE_RTP_MP2T_PAY \
  (gst_rtp_mp2t_pay_get_type())
</MACRO>
<MACRO>
<NAME>GST_RTP_MP2T_PAY</NAME>
#define GST_RTP_MP2T_PAY(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_RTP_MP2T_PAY,GstRTPMP2TPay))
</MACRO>
<MACRO>
<NAME>GST_RTP_MP2T_PAY_CLASS</NAME>
#define GST_RTP_MP2T_PAY_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_RTP_MP2T_PAY,GstRTPMP2TPayClass))
</MACRO>
<MACRO>
<NAME>GST_IS_RTP_MP2T_PAY</NAME>
#define GST_IS_RTP_MP2T_PAY(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_RTP_MP2T_PAY))
</MACRO>
<MACRO>
<NAME>GST_IS_RTP_MP2T_PAY_CLASS</NAME>
#define GST_IS_RTP_MP2T_PAY_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_RTP_MP2T_PAY))
</MACRO>
<STRUCT>
<NAME>GstRTPMP2TPay</NAME>
struct _GstRTPMP2TPay
{
  GstRTPBasePayload payload;
  
  GstAdapter  *adapter;
  GstClockTime first_ts;
  GstClockTime duration;
};
</STRUCT>
<STRUCT>
<NAME>GstRTPMP2TPayClass</NAME>
struct _GstRTPMP2TPayClass
{
  GstRTPBasePayloadClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_rtp_mp2t_pay_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_rtp_mp2t_pay_plugin_init</NAME>
<RETURNS>gboolean  </RETURNS>
GstPlugin * plugin
</FUNCTION>
<TYPEDEF>
<NAME>VP8_BD_VALUE</NAME>
typedef size_t VP8_BD_VALUE;
</TYPEDEF>
<MACRO>
<NAME>VP8_BD_VALUE_SIZE</NAME>
# define VP8_BD_VALUE_SIZE ((int)sizeof(VP8_BD_VALUE)*CHAR_BIT)
</MACRO>
<MACRO>
<NAME>VP8_LOTS_OF_BITS</NAME>
# define VP8_LOTS_OF_BITS (0x40000000)
</MACRO>
<FUNCTION>
<NAME>vp8dx_start_decode</NAME>
<RETURNS>int  </RETURNS>
BOOL_DECODER *br, const unsigned char *source, unsigned int source_sz
</FUNCTION>
<FUNCTION>
<NAME>vp8dx_bool_decoder_fill</NAME>
<RETURNS>void  </RETURNS>
BOOL_DECODER *br
</FUNCTION>
<MACRO>
<NAME>VP8DX_BOOL_DECODER_FILL</NAME>
#define VP8DX_BOOL_DECODER_FILL(_count,_value,_bufptr,_bufend) \
    do \
    { \
        int shift = VP8_BD_VALUE_SIZE - 8 - ((_count) + 8); \
        int loop_end, x; \
        size_t bits_left = ((_bufend)-(_bufptr))*CHAR_BIT; \
        \
        x = shift + CHAR_BIT - bits_left; \
        loop_end = 0; \
        if(x >= 0) \
        { \
            (_count) += VP8_LOTS_OF_BITS; \
            loop_end = x; \
            if(!bits_left) break; \
        } \
        while(shift >= loop_end) \
        { \
            (_count) += CHAR_BIT; \
            (_value) |= (VP8_BD_VALUE)*(_bufptr)++ << shift; \
            shift -= CHAR_BIT; \
        } \
    } \
    while(0) \


static int vp8dx_decode_bool(BOOL_DECODER *br, int probability) {
</MACRO>
<VARIABLE>
<NAME>bit</NAME>
    unsigned int bit = 0;
</VARIABLE>
<VARIABLE>
<NAME>z</NAME>
    int z = 0;
</VARIABLE>
<MACRO>
<NAME>GST_TYPE_RTP_G722_PAY</NAME>
#define GST_TYPE_RTP_G722_PAY \
  (gst_rtp_g722_pay_get_type())
</MACRO>
<MACRO>
<NAME>GST_RTP_G722_PAY</NAME>
#define GST_RTP_G722_PAY(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_RTP_G722_PAY,GstRtpG722Pay))
</MACRO>
<MACRO>
<NAME>GST_RTP_G722_PAY_CLASS</NAME>
#define GST_RTP_G722_PAY_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_RTP_G722_PAY,GstRtpG722PayClass))
</MACRO>
<MACRO>
<NAME>GST_IS_RTP_G722_PAY</NAME>
#define GST_IS_RTP_G722_PAY(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_RTP_G722_PAY))
</MACRO>
<MACRO>
<NAME>GST_IS_RTP_G722_PAY_CLASS</NAME>
#define GST_IS_RTP_G722_PAY_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_RTP_G722_PAY))
</MACRO>
<STRUCT>
<NAME>GstRtpG722Pay</NAME>
struct _GstRtpG722Pay
{
  GstRTPBaseAudioPayload payload;

  gint rate;
  gint channels;
};
</STRUCT>
<STRUCT>
<NAME>GstRtpG722PayClass</NAME>
struct _GstRtpG722PayClass
{
  GstRTPBaseAudioPayloadClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_rtp_g722_pay_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_rtp_g722_pay_plugin_init</NAME>
<RETURNS>gboolean  </RETURNS>
GstPlugin * plugin
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_RTP_GSM_DEPAY</NAME>
#define GST_TYPE_RTP_GSM_DEPAY \
  (gst_rtp_gsm_depay_get_type())
</MACRO>
<MACRO>
<NAME>GST_RTP_GSM_DEPAY</NAME>
#define GST_RTP_GSM_DEPAY(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_RTP_GSM_DEPAY,GstRTPGSMDepay))
</MACRO>
<MACRO>
<NAME>GST_RTP_GSM_DEPAY_CLASS</NAME>
#define GST_RTP_GSM_DEPAY_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_RTP_GSM_DEPAY,GstRTPGSMDepayClass))
</MACRO>
<MACRO>
<NAME>GST_IS_RTP_GSM_DEPAY</NAME>
#define GST_IS_RTP_GSM_DEPAY(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_RTP_GSM_DEPAY))
</MACRO>
<MACRO>
<NAME>GST_IS_RTP_GSM_DEPAY_CLASS</NAME>
#define GST_IS_RTP_GSM_DEPAY_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_RTP_GSM_DEPAY))
</MACRO>
<STRUCT>
<NAME>GstRTPGSMDepay</NAME>
struct _GstRTPGSMDepay
{
  GstRTPBaseDepayload _depayload;
};
</STRUCT>
<STRUCT>
<NAME>GstRTPGSMDepayClass</NAME>
struct _GstRTPGSMDepayClass
{
  GstRTPBaseDepayloadClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_rtp_gsm_depay_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_rtp_gsm_depay_plugin_init</NAME>
<RETURNS>gboolean  </RETURNS>
GstPlugin * plugin
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_RTP_G729_PAY</NAME>
#define GST_TYPE_RTP_G729_PAY \
  (gst_rtp_g729_pay_get_type())
</MACRO>
<MACRO>
<NAME>GST_RTP_G729_PAY</NAME>
#define GST_RTP_G729_PAY(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_RTP_G729_PAY,GstRTPG729Pay))
</MACRO>
<MACRO>
<NAME>GST_RTP_G729_PAY_CLASS</NAME>
#define GST_RTP_G729_PAY_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_RTP_G729_PAY,GstRTPG729PayClass))
</MACRO>
<MACRO>
<NAME>GST_IS_RTP_G729_PAY</NAME>
#define GST_IS_RTP_G729_PAY(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_RTP_G729_PAY))
</MACRO>
<MACRO>
<NAME>GST_IS_RTP_G729_PAY_CLASS</NAME>
#define GST_IS_RTP_G729_PAY_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_RTP_G729_PAY))
</MACRO>
<STRUCT>
<NAME>GstRTPG729Pay</NAME>
struct _GstRTPG729Pay
{
  GstRTPBasePayload payload;

  GstAdapter *adapter;
  GstClockTime next_ts;
  guint32 next_rtp_time;
  GstClockTime first_ts;
  guint32 first_rtp_time;
  gboolean discont;
};
</STRUCT>
<STRUCT>
<NAME>GstRTPG729PayClass</NAME>
struct _GstRTPG729PayClass
{
  GstRTPBasePayloadClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_rtp_g729_pay_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_rtp_g729_pay_plugin_init</NAME>
<RETURNS>gboolean  </RETURNS>
GstPlugin * plugin
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_RTP_VP8_DEPAY</NAME>
#define GST_TYPE_RTP_VP8_DEPAY \
  (gst_rtp_vp8_depay_get_type())
</MACRO>
<MACRO>
<NAME>GST_RTP_VP8_DEPAY</NAME>
#define GST_RTP_VP8_DEPAY(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj), GST_TYPE_RTP_VP8_DEPAY, GstRtpVP8Depay))
</MACRO>
<MACRO>
<NAME>GST_RTP_VP8_DEPAY_CLASS</NAME>
#define GST_RTP_VP8_DEPAY_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass), GST_TYPE_RTP_VP8_DEPAY, \
    GstRtpVP8DepayClass))
</MACRO>
<MACRO>
<NAME>GST_IS_RTP_VP8_DEPAY</NAME>
#define GST_IS_RTP_VP8_DEPAY(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj), GST_TYPE_RTP_VP8_DEPAY))
</MACRO>
<MACRO>
<NAME>GST_IS_RTP_VP8_DEPAY_CLASS</NAME>
#define GST_IS_RTP_VP8_DEPAY_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass), GST_TYPE_RTP_VP8_DEPAY))
</MACRO>
<MACRO>
<NAME>GST_RTP_VP8_DEPAY_GET_CLASS</NAME>
#define GST_RTP_VP8_DEPAY_GET_CLASS(obj) \
  (G_TYPE_INSTANCE_GET_CLASS ((obj), GST_TYPE_RTP_VP8_DEPAY, \
    GstRtpVP8DepayClass))
</MACRO>
<STRUCT>
<NAME>GstRtpVP8DepayClass</NAME>
struct _GstRtpVP8DepayClass
{
  GstRTPBaseDepayloadClass parent_class;
};
</STRUCT>
<STRUCT>
<NAME>GstRtpVP8Depay</NAME>
struct _GstRtpVP8Depay
{
  GstRTPBaseDepayload parent;
  GstAdapter *adapter;
  gboolean started;

  gboolean caps_sent;
  gint last_profile;
  gint last_width;
  gint last_height;
};
</STRUCT>
<FUNCTION>
<NAME>gst_rtp_vp8_depay_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_rtp_vp8_depay_plugin_init</NAME>
<RETURNS>gboolean  </RETURNS>
GstPlugin * plugin
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_RTP_PCMU_PAY</NAME>
#define GST_TYPE_RTP_PCMU_PAY \
  (gst_rtp_pcmu_pay_get_type())
</MACRO>
<MACRO>
<NAME>GST_RTP_PCMU_PAY</NAME>
#define GST_RTP_PCMU_PAY(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_RTP_PCMU_PAY,GstRtpPcmuPay))
</MACRO>
<MACRO>
<NAME>GST_RTP_PCMU_PAY_CLASS</NAME>
#define GST_RTP_PCMU_PAY_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_RTP_PCMU_PAY,GstRtpPcmuPayClass))
</MACRO>
<MACRO>
<NAME>GST_IS_RTP_PCMU_PAY</NAME>
#define GST_IS_RTP_PCMU_PAY(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_RTP_PCMU_PAY))
</MACRO>
<MACRO>
<NAME>GST_IS_RTP_PCMU_PAY_CLASS</NAME>
#define GST_IS_RTP_PCMU_PAY_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_RTP_PCMU_PAY))
</MACRO>
<STRUCT>
<NAME>GstRtpPcmuPay</NAME>
struct _GstRtpPcmuPay
{
  GstRTPBaseAudioPayload audiopayload;
};
</STRUCT>
<STRUCT>
<NAME>GstRtpPcmuPayClass</NAME>
struct _GstRtpPcmuPayClass
{
  GstRTPBaseAudioPayloadClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_rtp_pcmu_pay_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_rtp_pcmu_pay_plugin_init</NAME>
<RETURNS>gboolean  </RETURNS>
GstPlugin * plugin
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_RTP_VP9_DEPAY</NAME>
#define GST_TYPE_RTP_VP9_DEPAY \
  (gst_rtp_vp9_depay_get_type())
</MACRO>
<MACRO>
<NAME>GST_RTP_VP9_DEPAY</NAME>
#define GST_RTP_VP9_DEPAY(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj), GST_TYPE_RTP_VP9_DEPAY, GstRtpVP9Depay))
</MACRO>
<MACRO>
<NAME>GST_RTP_VP9_DEPAY_CLASS</NAME>
#define GST_RTP_VP9_DEPAY_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass), GST_TYPE_RTP_VP9_DEPAY, \
    GstRtpVP9DepayClass))
</MACRO>
<MACRO>
<NAME>GST_IS_RTP_VP9_DEPAY</NAME>
#define GST_IS_RTP_VP9_DEPAY(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj), GST_TYPE_RTP_VP9_DEPAY))
</MACRO>
<MACRO>
<NAME>GST_IS_RTP_VP9_DEPAY_CLASS</NAME>
#define GST_IS_RTP_VP9_DEPAY_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass), GST_TYPE_RTP_VP9_DEPAY))
</MACRO>
<MACRO>
<NAME>GST_RTP_VP9_DEPAY_GET_CLASS</NAME>
#define GST_RTP_VP9_DEPAY_GET_CLASS(obj) \
  (G_TYPE_INSTANCE_GET_CLASS ((obj), GST_TYPE_RTP_VP9_DEPAY, \
    GstRtpVP9DepayClass))
</MACRO>
<STRUCT>
<NAME>GstRtpVP9DepayClass</NAME>
struct _GstRtpVP9DepayClass
{
  GstRTPBaseDepayloadClass parent_class;
};
</STRUCT>
<STRUCT>
<NAME>GstRtpVP9Depay</NAME>
struct _GstRtpVP9Depay
{
  GstRTPBaseDepayload parent;
  GstAdapter *adapter;
  gboolean started;

  gint ss_width;
  gint ss_height;
  gint last_width;
  gint last_height;
  gboolean caps_sent;
};
</STRUCT>
<FUNCTION>
<NAME>gst_rtp_vp9_depay_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_rtp_vp9_depay_plugin_init</NAME>
<RETURNS>gboolean  </RETURNS>
GstPlugin * plugin
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_RTP_GSM_PAY</NAME>
#define GST_TYPE_RTP_GSM_PAY \
  (gst_rtp_gsm_pay_get_type())
</MACRO>
<MACRO>
<NAME>GST_RTP_GSM_PAY</NAME>
#define GST_RTP_GSM_PAY(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_RTP_GSM_PAY,GstRTPGSMPay))
</MACRO>
<MACRO>
<NAME>GST_RTP_GSM_PAY_CLASS</NAME>
#define GST_RTP_GSM_PAY_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_RTP_GSM_PAY,GstRTPGSMPayClass))
</MACRO>
<MACRO>
<NAME>GST_IS_RTP_GSM_PAY</NAME>
#define GST_IS_RTP_GSM_PAY(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_RTP_GSM_PAY))
</MACRO>
<MACRO>
<NAME>GST_IS_RTP_GSM_PAY_CLASS</NAME>
#define GST_IS_RTP_GSM_PAY_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_RTP_GSM_PAY))
</MACRO>
<STRUCT>
<NAME>GstRTPGSMPay</NAME>
struct _GstRTPGSMPay
{
  GstRTPBasePayload payload;
};
</STRUCT>
<STRUCT>
<NAME>GstRTPGSMPayClass</NAME>
struct _GstRTPGSMPayClass
{
  GstRTPBasePayloadClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_rtp_gsm_pay_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_rtp_gsm_pay_plugin_init</NAME>
<RETURNS>gboolean  </RETURNS>
GstPlugin * plugin
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_RTP_PCMU_DEPAY</NAME>
#define GST_TYPE_RTP_PCMU_DEPAY \
  (gst_rtp_pcmu_depay_get_type())
</MACRO>
<MACRO>
<NAME>GST_RTP_PCMU_DEPAY</NAME>
#define GST_RTP_PCMU_DEPAY(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_RTP_PCMU_DEPAY,GstRtpPcmuDepay))
</MACRO>
<MACRO>
<NAME>GST_RTP_PCMU_DEPAY_CLASS</NAME>
#define GST_RTP_PCMU_DEPAY_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_RTP_PCMU_DEPAY,GstRtpPcmuDepayClass))
</MACRO>
<MACRO>
<NAME>GST_IS_RTP_PCMU_DEPAY</NAME>
#define GST_IS_RTP_PCMU_DEPAY(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_RTP_PCMU_DEPAY))
</MACRO>
<MACRO>
<NAME>GST_IS_RTP_PCMU_DEPAY_CLASS</NAME>
#define GST_IS_RTP_PCMU_DEPAY_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_RTP_PCMU_DEPAY))
</MACRO>
<STRUCT>
<NAME>GstRtpPcmuDepay</NAME>
struct _GstRtpPcmuDepay
{
  GstRTPBaseDepayload depayload;
};
</STRUCT>
<STRUCT>
<NAME>GstRtpPcmuDepayClass</NAME>
struct _GstRtpPcmuDepayClass
{
  GstRTPBaseDepayloadClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_rtp_pcmu_depay_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_rtp_pcmu_depay_plugin_init</NAME>
<RETURNS>gboolean  </RETURNS>
GstPlugin * plugin
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_RTP_L16_PAY</NAME>
#define GST_TYPE_RTP_L16_PAY \
  (gst_rtp_L16_pay_get_type())
</MACRO>
<MACRO>
<NAME>GST_RTP_L16_PAY</NAME>
#define GST_RTP_L16_PAY(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_RTP_L16_PAY,GstRtpL16Pay))
</MACRO>
<MACRO>
<NAME>GST_RTP_L16_PAY_CLASS</NAME>
#define GST_RTP_L16_PAY_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_RTP_L16_PAY,GstRtpL16PayClass))
</MACRO>
<MACRO>
<NAME>GST_IS_RTP_L16_PAY</NAME>
#define GST_IS_RTP_L16_PAY(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_RTP_L16_PAY))
</MACRO>
<MACRO>
<NAME>GST_IS_RTP_L16_PAY_CLASS</NAME>
#define GST_IS_RTP_L16_PAY_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_RTP_L16_PAY))
</MACRO>
<STRUCT>
<NAME>GstRtpL16Pay</NAME>
struct _GstRtpL16Pay
{
  GstRTPBaseAudioPayload payload;

  GstAudioInfo info;
  const GstRTPChannelOrder *order;
};
</STRUCT>
<STRUCT>
<NAME>GstRtpL16PayClass</NAME>
struct _GstRtpL16PayClass
{
  GstRTPBaseAudioPayloadClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_rtp_L16_pay_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_rtp_L16_pay_plugin_init</NAME>
<RETURNS>gboolean  </RETURNS>
GstPlugin * plugin
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_RTP_VRAW_DEPAY</NAME>
#define GST_TYPE_RTP_VRAW_DEPAY \
  (gst_rtp_vraw_depay_get_type())
</MACRO>
<MACRO>
<NAME>GST_RTP_VRAW_DEPAY</NAME>
#define GST_RTP_VRAW_DEPAY(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_RTP_VRAW_DEPAY,GstRtpVRawDepay))
</MACRO>
<MACRO>
<NAME>GST_RTP_VRAW_DEPAY_CLASS</NAME>
#define GST_RTP_VRAW_DEPAY_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_RTP_VRAW_DEPAY,GstRtpVRawDepayClass))
</MACRO>
<MACRO>
<NAME>GST_IS_RTP_VRAW_DEPAY</NAME>
#define GST_IS_RTP_VRAW_DEPAY(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_RTP_VRAW_DEPAY))
</MACRO>
<MACRO>
<NAME>GST_IS_RTP_VRAW_DEPAY_CLASS</NAME>
#define GST_IS_RTP_VRAW_DEPAY_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_RTP_VRAW_DEPAY))
</MACRO>
<STRUCT>
<NAME>GstRtpVRawDepay</NAME>
struct _GstRtpVRawDepay
{
  GstRTPBaseDepayload payload;

  GstBufferPool *pool;
  GstVideoInfo vinfo;

  GstVideoFrame frame;
  GstBuffer *outbuf;
  guint32 timestamp;

  gint pgroup;
  gint xinc, yinc;
};
</STRUCT>
<STRUCT>
<NAME>GstRtpVRawDepayClass</NAME>
struct _GstRtpVRawDepayClass
{
  GstRTPBaseDepayloadClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_rtp_vraw_depay_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_rtp_vraw_depay_plugin_init</NAME>
<RETURNS>gboolean  </RETURNS>
GstPlugin * plugin
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_RTP_ILBC_DEPAY</NAME>
#define GST_TYPE_RTP_ILBC_DEPAY \
  (gst_rtp_ilbc_depay_get_type())
</MACRO>
<MACRO>
<NAME>GST_RTP_ILBC_DEPAY</NAME>
#define GST_RTP_ILBC_DEPAY(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_RTP_ILBC_DEPAY,GstRTPiLBCDepay))
</MACRO>
<MACRO>
<NAME>GST_RTP_ILBC_DEPAY_CLASS</NAME>
#define GST_RTP_ILBC_DEPAY_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_RTP_ILBC_DEPAY,GstRTPiLBCDepayClass))
</MACRO>
<MACRO>
<NAME>GST_IS_RTP_ILBC_DEPAY</NAME>
#define GST_IS_RTP_ILBC_DEPAY(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_RTP_ILBC_DEPAY))
</MACRO>
<MACRO>
<NAME>GST_IS_RTP_ILBC_DEPAY_CLASS</NAME>
#define GST_IS_RTP_ILBC_DEPAY_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_RTP_ILBC_DEPAY))
</MACRO>
<ENUM>
<NAME>GstiLBCMode</NAME>
typedef enum {
  GST_ILBC_MODE_20 = 20,
  GST_ILBC_MODE_30 = 30
} GstiLBCMode; 
</ENUM>
<STRUCT>
<NAME>GstRTPiLBCDepay</NAME>
struct _GstRTPiLBCDepay
{
  GstRTPBaseDepayload depayload;

  GstiLBCMode mode;
};
</STRUCT>
<STRUCT>
<NAME>GstRTPiLBCDepayClass</NAME>
struct _GstRTPiLBCDepayClass
{
  GstRTPBaseDepayloadClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_rtp_ilbc_depay_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_rtp_ilbc_depay_plugin_init</NAME>
<RETURNS>gboolean  </RETURNS>
GstPlugin * plugin
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_RTP_STREAM_PAY</NAME>
#define GST_TYPE_RTP_STREAM_PAY            (gst_rtp_stream_pay_get_type())
</MACRO>
<MACRO>
<NAME>GST_RTP_STREAM_PAY</NAME>
#define GST_RTP_STREAM_PAY(obj)            (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_RTP_STREAM_PAY,GstRtpStreamPay))
</MACRO>
<MACRO>
<NAME>GST_IS_RTP_STREAM_PAY</NAME>
#define GST_IS_RTP_STREAM_PAY(obj)         (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_RTP_STREAM_PAY))
</MACRO>
<MACRO>
<NAME>GST_RTP_STREAM_PAY_CLASS</NAME>
#define GST_RTP_STREAM_PAY_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST((klass) ,GST_TYPE_RTP_STREAM_PAY,GstRtpStreamPayClass))
</MACRO>
<MACRO>
<NAME>GST_IS_RTP_STREAM_PAY_CLASS</NAME>
#define GST_IS_RTP_STREAM_PAY_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE((klass) ,GST_TYPE_RTP_STREAM_PAY))
</MACRO>
<MACRO>
<NAME>GST_RTP_STREAM_PAY_GET_CLASS</NAME>
#define GST_RTP_STREAM_PAY_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS((obj) ,GST_TYPE_RTP_STREAM_PAY,GstRtpStreamPayClass))
</MACRO>
<STRUCT>
<NAME>GstRtpStreamPay</NAME>
struct _GstRtpStreamPay {
  GstElement parent;

  GstPad *srcpad, *sinkpad;
};
</STRUCT>
<STRUCT>
<NAME>GstRtpStreamPayClass</NAME>
struct _GstRtpStreamPayClass {
  GstElementClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_rtp_stream_pay_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_rtp_stream_pay_plugin_init</NAME>
<RETURNS>gboolean  </RETURNS>
GstPlugin * plugin
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_RTP_G726_PAY</NAME>
#define GST_TYPE_RTP_G726_PAY \
  (gst_rtp_g726_pay_get_type())
</MACRO>
<MACRO>
<NAME>GST_RTP_G726_PAY</NAME>
#define GST_RTP_G726_PAY(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_RTP_G726_PAY,GstRtpG726Pay))
</MACRO>
<MACRO>
<NAME>GST_RTP_G726_PAY_CLASS</NAME>
#define GST_RTP_G726_PAY_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_RTP_G726_PAY,GstRtpG726PayClass))
</MACRO>
<MACRO>
<NAME>GST_IS_RTP_G726_PAY</NAME>
#define GST_IS_RTP_G726_PAY(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_RTP_G726_PAY))
</MACRO>
<MACRO>
<NAME>GST_IS_RTP_G726_PAY_CLASS</NAME>
#define GST_IS_RTP_G726_PAY_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_RTP_G726_PAY))
</MACRO>
<STRUCT>
<NAME>GstRtpG726Pay</NAME>
struct _GstRtpG726Pay
{
  GstRTPBaseAudioPayload audiopayload;

  gboolean aal2;
  gboolean force_aal2;
  gint bitrate;
};
</STRUCT>
<STRUCT>
<NAME>GstRtpG726PayClass</NAME>
struct _GstRtpG726PayClass
{
  GstRTPBaseAudioPayloadClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_rtp_g726_pay_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_rtp_g726_pay_plugin_init</NAME>
<RETURNS>gboolean  </RETURNS>
GstPlugin * plugin
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_RTP_PCMA_DEPAY</NAME>
#define GST_TYPE_RTP_PCMA_DEPAY \
  (gst_rtp_pcma_depay_get_type())
</MACRO>
<MACRO>
<NAME>GST_RTP_PCMA_DEPAY</NAME>
#define GST_RTP_PCMA_DEPAY(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_RTP_PCMA_DEPAY,GstRtpPcmaDepay))
</MACRO>
<MACRO>
<NAME>GST_RTP_PCMA_DEPAY_CLASS</NAME>
#define GST_RTP_PCMA_DEPAY_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_RTP_PCMA_DEPAY,GstRtpPcmaDepayClass))
</MACRO>
<MACRO>
<NAME>GST_IS_RTP_PCMA_DEPAY</NAME>
#define GST_IS_RTP_PCMA_DEPAY(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_RTP_PCMA_DEPAY))
</MACRO>
<MACRO>
<NAME>GST_IS_RTP_PCMA_DEPAY_CLASS</NAME>
#define GST_IS_RTP_PCMA_DEPAY_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_RTP_PCMA_DEPAY))
</MACRO>
<STRUCT>
<NAME>GstRtpPcmaDepay</NAME>
struct _GstRtpPcmaDepay
{
  GstRTPBaseDepayload depayload;
};
</STRUCT>
<STRUCT>
<NAME>GstRtpPcmaDepayClass</NAME>
struct _GstRtpPcmaDepayClass
{
  GstRTPBaseDepayloadClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_rtp_pcma_depay_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_rtp_pcma_depay_plugin_init</NAME>
<RETURNS>gboolean  </RETURNS>
GstPlugin * plugin
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_RTP_MPA_ROBUST_DEPAY</NAME>
#define GST_TYPE_RTP_MPA_ROBUST_DEPAY \
  (gst_rtp_mpa_robust_depay_get_type())
</MACRO>
<MACRO>
<NAME>GST_RTP_MPA_ROBUST_DEPAY</NAME>
#define GST_RTP_MPA_ROBUST_DEPAY(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_RTP_MPA_ROBUST_DEPAY,GstRtpMPARobustDepay))
</MACRO>
<MACRO>
<NAME>GST_RTP_MPA_ROBUST_DEPAY_CLASS</NAME>
#define GST_RTP_MPA_ROBUST_DEPAY_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_RTP_MPA_ROBUST_DEPAY,GstRtpMPARobustDepayClass))
</MACRO>
<MACRO>
<NAME>GST_IS_RTP_MPA_ROBUST_DEPAY</NAME>
#define GST_IS_RTP_MPA_ROBUST_DEPAY(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_RTP_MPA_ROBUST_DEPAY))
</MACRO>
<MACRO>
<NAME>GST_IS_RTP_MPA_ROBUST_DEPAY_CLASS</NAME>
#define GST_IS_RTP_MPA_ROBUST_DEPAY_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_RTP_MPA_ROBUST_DEPAY))
</MACRO>
<STRUCT>
<NAME>GstRtpMPARobustDepay</NAME>
struct _GstRtpMPARobustDepay
{
  GstRTPBaseDepayload depayload;

  GstAdapter *adapter;
  gboolean    has_descriptor;

  /* last interleave index */
  gint        last_ii;
  /* last interleave cycle count */
  gint        last_icc;
  /* buffers pending deinterleaving */
  GstBuffer   *deinter[256];

  /* ADU buffers pending MP3 transformation */
  GQueue      *adu_frames;
  GList       *cur_adu_frame;
  gint         offset;
  gint         size;
  GstByteWriter *mp3_frame;
};
</STRUCT>
<STRUCT>
<NAME>GstRtpMPARobustDepayClass</NAME>
struct _GstRtpMPARobustDepayClass
{
  GstRTPBaseDepayloadClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_rtp_mpa_robust_depay_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_rtp_mpa_robust_depay_plugin_init</NAME>
<RETURNS>gboolean  </RETURNS>
GstPlugin * plugin
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_RTP_DV_DEPAY</NAME>
#define GST_TYPE_RTP_DV_DEPAY (gst_rtp_dv_depay_get_type())
</MACRO>
<MACRO>
<NAME>GST_RTP_DV_DEPAY</NAME>
#define GST_RTP_DV_DEPAY(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_RTP_DV_DEPAY,GstRTPDVDepay))
</MACRO>
<MACRO>
<NAME>GST_RTP_DV_DEPAY_CLASS</NAME>
#define GST_RTP_DV_DEPAY_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_RTP_DV_DEPAY,GstRTPDVDepay))
</MACRO>
<MACRO>
<NAME>GST_IS_RTP_DV_DEPAY</NAME>
#define GST_IS_RTP_DV_DEPAY(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_RTP_DV_DEPAY))
</MACRO>
<MACRO>
<NAME>GST_IS_RTP_DV_DEPAY_CLASS</NAME>
#define GST_IS_RTP_DV_DEPAY_CLASS(obj) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_RTP_DV_DEPAY))
</MACRO>
<STRUCT>
<NAME>GstRTPDVDepay</NAME>
struct _GstRTPDVDepay
{
  GstRTPBaseDepayload parent;

  GstBuffer *acc;
  guint frame_size;
  guint32 prev_ts;
  guint8 header_mask;

  gint width, height;
  gint rate_num, rate_denom;
};
</STRUCT>
<STRUCT>
<NAME>GstRTPDVDepayClass</NAME>
struct _GstRTPDVDepayClass
{
  GstRTPBaseDepayloadClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_rtp_dv_depay_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_rtp_dv_depay_plugin_init</NAME>
<RETURNS>gboolean  </RETURNS>
GstPlugin * plugin
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_RTP_L24_DEPAY</NAME>
#define GST_TYPE_RTP_L24_DEPAY \
  (gst_rtp_L24_depay_get_type())
</MACRO>
<MACRO>
<NAME>GST_RTP_L24_DEPAY</NAME>
#define GST_RTP_L24_DEPAY(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_RTP_L24_DEPAY,GstRtpL24Depay))
</MACRO>
<MACRO>
<NAME>GST_RTP_L24_DEPAY_CLASS</NAME>
#define GST_RTP_L24_DEPAY_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_RTP_L24_DEPAY,GstRtpL24DepayClass))
</MACRO>
<MACRO>
<NAME>GST_IS_RTP_L24_DEPAY</NAME>
#define GST_IS_RTP_L24_DEPAY(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_RTP_L24_DEPAY))
</MACRO>
<MACRO>
<NAME>GST_IS_RTP_L24_DEPAY_CLASS</NAME>
#define GST_IS_RTP_L24_DEPAY_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_RTP_L24_DEPAY))
</MACRO>
<STRUCT>
<NAME>GstRtpL24Depay</NAME>
struct _GstRtpL24Depay
{
  GstRTPBaseDepayload depayload;

  GstAudioInfo info;
  const GstRTPChannelOrder *order;
};
</STRUCT>
<STRUCT>
<NAME>GstRtpL24DepayClass</NAME>
struct _GstRtpL24DepayClass
{
  GstRTPBaseDepayloadClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_rtp_L24_depay_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_rtp_L24_depay_plugin_init</NAME>
<RETURNS>gboolean  </RETURNS>
GstPlugin * plugin
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_RTP_BV_PAY</NAME>
#define GST_TYPE_RTP_BV_PAY \
  (gst_rtp_bv_pay_get_type())
</MACRO>
<MACRO>
<NAME>GST_RTP_BV_PAY</NAME>
#define GST_RTP_BV_PAY(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_RTP_BV_PAY,GstRTPBVPay))
</MACRO>
<MACRO>
<NAME>GST_RTP_BV_PAY_CLASS</NAME>
#define GST_RTP_BV_PAY_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_RTP_BV_PAY,GstRTPBVPayClass))
</MACRO>
<MACRO>
<NAME>GST_IS_RTP_BV_PAY</NAME>
#define GST_IS_RTP_BV_PAY(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_RTP_BV_PAY))
</MACRO>
<MACRO>
<NAME>GST_IS_RTP_BV_PAY_CLASS</NAME>
#define GST_IS_RTP_BV_PAY_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_RTP_BV_PAY))
</MACRO>
<STRUCT>
<NAME>GstRTPBVPay</NAME>
struct _GstRTPBVPay
{
  GstRTPBaseAudioPayload audiopayload;

  gint mode;
};
</STRUCT>
<STRUCT>
<NAME>GstRTPBVPayClass</NAME>
struct _GstRTPBVPayClass
{
  GstRTPBaseAudioPayloadClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_rtp_bv_pay_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_rtp_bv_pay_plugin_init</NAME>
<RETURNS>gboolean  </RETURNS>
GstPlugin * plugin
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_RTP_MPA_PAY</NAME>
#define GST_TYPE_RTP_MPA_PAY \
  (gst_rtp_mpa_pay_get_type())
</MACRO>
<MACRO>
<NAME>GST_RTP_MPA_PAY</NAME>
#define GST_RTP_MPA_PAY(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_RTP_MPA_PAY,GstRtpMPAPay))
</MACRO>
<MACRO>
<NAME>GST_RTP_MPA_PAY_CLASS</NAME>
#define GST_RTP_MPA_PAY_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_RTP_MPA_PAY,GstRtpMPAPayClass))
</MACRO>
<MACRO>
<NAME>GST_IS_RTP_MPA_PAY</NAME>
#define GST_IS_RTP_MPA_PAY(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_RTP_MPA_PAY))
</MACRO>
<MACRO>
<NAME>GST_IS_RTP_MPA_PAY_CLASS</NAME>
#define GST_IS_RTP_MPA_PAY_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_RTP_MPA_PAY))
</MACRO>
<STRUCT>
<NAME>GstRtpMPAPay</NAME>
struct _GstRtpMPAPay
{
  GstRTPBasePayload payload;

  GstAdapter *adapter;
  GstClockTime first_ts;
  GstClockTime duration;
};
</STRUCT>
<STRUCT>
<NAME>GstRtpMPAPayClass</NAME>
struct _GstRtpMPAPayClass
{
  GstRTPBasePayloadClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_rtp_mpa_pay_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_rtp_mpa_pay_plugin_init</NAME>
<RETURNS>gboolean  </RETURNS>
GstPlugin * plugin
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_RTP_AC3_DEPAY</NAME>
#define GST_TYPE_RTP_AC3_DEPAY \
  (gst_rtp_ac3_depay_get_type())
</MACRO>
<MACRO>
<NAME>GST_RTP_AC3_DEPAY</NAME>
#define GST_RTP_AC3_DEPAY(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_RTP_AC3_DEPAY,GstRtpAC3Depay))
</MACRO>
<MACRO>
<NAME>GST_RTP_AC3_DEPAY_CLASS</NAME>
#define GST_RTP_AC3_DEPAY_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_RTP_AC3_DEPAY,GstRtpAC3DepayClass))
</MACRO>
<MACRO>
<NAME>GST_IS_RTP_AC3_DEPAY</NAME>
#define GST_IS_RTP_AC3_DEPAY(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_RTP_AC3_DEPAY))
</MACRO>
<MACRO>
<NAME>GST_IS_RTP_AC3_DEPAY_CLASS</NAME>
#define GST_IS_RTP_AC3_DEPAY_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_RTP_AC3_DEPAY))
</MACRO>
<STRUCT>
<NAME>GstRtpAC3Depay</NAME>
struct _GstRtpAC3Depay
{
  GstRTPBaseDepayload depayload;
};
</STRUCT>
<STRUCT>
<NAME>GstRtpAC3DepayClass</NAME>
struct _GstRtpAC3DepayClass
{
  GstRTPBaseDepayloadClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_rtp_ac3_depay_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_rtp_ac3_depay_plugin_init</NAME>
<RETURNS>gboolean  </RETURNS>
GstPlugin * plugin
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_RTP_SIREN_PAY</NAME>
#define GST_TYPE_RTP_SIREN_PAY \
  (gst_rtp_siren_pay_get_type())
</MACRO>
<MACRO>
<NAME>GST_RTP_SIREN_PAY</NAME>
#define GST_RTP_SIREN_PAY(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_RTP_SIREN_PAY,GstRTPSirenPay))
</MACRO>
<MACRO>
<NAME>GST_RTP_SIREN_PAY_CLASS</NAME>
#define GST_RTP_SIREN_PAY_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_RTP_SIREN_PAY,GstRTPSirenPayClass))
</MACRO>
<MACRO>
<NAME>GST_IS_RTP_SIREN_PAY</NAME>
#define GST_IS_RTP_SIREN_PAY(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_RTP_SIREN_PAY))
</MACRO>
<MACRO>
<NAME>GST_IS_RTP_SIREN_PAY_CLASS</NAME>
#define GST_IS_RTP_SIREN_PAY_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_RTP_SIREN_PAY))
</MACRO>
<STRUCT>
<NAME>GstRTPSirenPay</NAME>
struct _GstRTPSirenPay
{
  GstRTPBaseAudioPayload audiopayload;
};
</STRUCT>
<STRUCT>
<NAME>GstRTPSirenPayClass</NAME>
struct _GstRTPSirenPayClass
{
  GstRTPBaseAudioPayloadClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_rtp_siren_pay_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_rtp_siren_pay_plugin_init</NAME>
<RETURNS>gboolean  </RETURNS>
GstPlugin * plugin
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_RTP_DV_PAY</NAME>
#define GST_TYPE_RTP_DV_PAY \
  (gst_rtp_dv_pay_get_type())
</MACRO>
<MACRO>
<NAME>GST_RTP_DV_PAY</NAME>
#define GST_RTP_DV_PAY(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_RTP_DV_PAY,GstRTPDVPay))
</MACRO>
<MACRO>
<NAME>GST_RTP_DV_PAY_CLASS</NAME>
#define GST_RTP_DV_PAY_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_RTP_DV_PAY,GstRTPDVPay))
</MACRO>
<MACRO>
<NAME>GST_IS_RTP_DV_PAY</NAME>
#define GST_IS_RTP_DV_PAY(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_RTP_DV_PAY))
</MACRO>
<MACRO>
<NAME>GST_IS_RTP_DV_PAY_CLASS</NAME>
#define GST_IS_RTP_DV_PAY_CLASS(obj) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_RTP_DV_PAY))
</MACRO>
<ENUM>
<NAME>GstDVPayMode</NAME>
typedef enum
{
  GST_DV_PAY_MODE_VIDEO,
  GST_DV_PAY_MODE_BUNDLED,
  GST_DV_PAY_MODE_AUDIO
} GstDVPayMode;
</ENUM>
<STRUCT>
<NAME>GstRTPDVPay</NAME>
struct _GstRTPDVPay
{
  GstRTPBasePayload payload;

  gboolean negotiated;
  GstDVPayMode mode;
};
</STRUCT>
<STRUCT>
<NAME>GstRTPDVPayClass</NAME>
struct _GstRTPDVPayClass
{
  GstRTPBasePayloadClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_rtp_dv_pay_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_rtp_dv_pay_plugin_init</NAME>
<RETURNS>gboolean  </RETURNS>
GstPlugin * plugin
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_RTP_THEORA_PAY</NAME>
#define GST_TYPE_RTP_THEORA_PAY \
  (gst_rtp_theora_pay_get_type())
</MACRO>
<MACRO>
<NAME>GST_RTP_THEORA_PAY</NAME>
#define GST_RTP_THEORA_PAY(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_RTP_THEORA_PAY,GstRtpTheoraPay))
</MACRO>
<MACRO>
<NAME>GST_RTP_THEORA_PAY_CLASS</NAME>
#define GST_RTP_THEORA_PAY_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_RTP_THEORA_PAY,GstRtpTheoraPayClass))
</MACRO>
<MACRO>
<NAME>GST_IS_RTP_THEORA_PAY</NAME>
#define GST_IS_RTP_THEORA_PAY(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_RTP_THEORA_PAY))
</MACRO>
<MACRO>
<NAME>GST_IS_RTP_THEORA_PAY_CLASS</NAME>
#define GST_IS_RTP_THEORA_PAY_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_RTP_THEORA_PAY))
</MACRO>
<STRUCT>
<NAME>GstRtpTheoraPay</NAME>
struct _GstRtpTheoraPay
{
  GstRTPBasePayload payload;

  /* the headers */
  gboolean      need_headers;
  GList        *headers;

  /* queues of buffers along with some stats. */
  GstBuffer    *packet;
  GList        *packet_buffers;
  guint         payload_pos;
  guint         payload_left;
  guint32       payload_ident;
  guint8        payload_F;
  guint8        payload_TDT;
  guint         payload_pkts;
  GstClockTime  payload_timestamp;
  GstClockTime  payload_duration;

  /* config (re-sending) */
  guint8       *config_data;
  guint         config_size;
  guint         config_extra_len;
  guint         config_interval;
  GstClockTime  last_config;

  gint          pixel_format;
  gint          width;
  gint          height;
};
</STRUCT>
<STRUCT>
<NAME>GstRtpTheoraPayClass</NAME>
struct _GstRtpTheoraPayClass
{
  GstRTPBasePayloadClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_rtp_theora_pay_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_rtp_theora_pay_plugin_init</NAME>
<RETURNS>gboolean  </RETURNS>
GstPlugin * plugin
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_RTP_ILBC_PAY</NAME>
#define GST_TYPE_RTP_ILBC_PAY \
  (gst_rtp_ilbc_pay_get_type())
</MACRO>
<MACRO>
<NAME>GST_RTP_ILBC_PAY</NAME>
#define GST_RTP_ILBC_PAY(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_RTP_ILBC_PAY,GstRTPILBCPay))
</MACRO>
<MACRO>
<NAME>GST_RTP_ILBC_PAY_CLASS</NAME>
#define GST_RTP_ILBC_PAY_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_RTP_ILBC_PAY,GstRTPILBCPayClass))
</MACRO>
<MACRO>
<NAME>GST_IS_RTP_ILBC_PAY</NAME>
#define GST_IS_RTP_ILBC_PAY(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_RTP_ILBC_PAY))
</MACRO>
<MACRO>
<NAME>GST_IS_RTP_ILBC_PAY_CLASS</NAME>
#define GST_IS_RTP_ILBC_PAY_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_RTP_ILBC_PAY))
</MACRO>
<STRUCT>
<NAME>GstRTPILBCPay</NAME>
struct _GstRTPILBCPay
{
  GstRTPBaseAudioPayload audiopayload;

  gint mode;
};
</STRUCT>
<STRUCT>
<NAME>GstRTPILBCPayClass</NAME>
struct _GstRTPILBCPayClass
{
  GstRTPBaseAudioPayloadClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_rtp_ilbc_pay_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_rtp_ilbc_pay_plugin_init</NAME>
<RETURNS>gboolean  </RETURNS>
GstPlugin * plugin
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_RTP_MPV_DEPAY</NAME>
#define GST_TYPE_RTP_MPV_DEPAY \
  (gst_rtp_mpv_depay_get_type())
</MACRO>
<MACRO>
<NAME>GST_RTP_MPV_DEPAY</NAME>
#define GST_RTP_MPV_DEPAY(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_RTP_MPV_DEPAY,GstRtpMPVDepay))
</MACRO>
<MACRO>
<NAME>GST_RTP_MPV_DEPAY_CLASS</NAME>
#define GST_RTP_MPV_DEPAY_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_RTP_MPV_DEPAY,GstRtpMPVDepayClass))
</MACRO>
<MACRO>
<NAME>GST_IS_RTP_MPV_DEPAY</NAME>
#define GST_IS_RTP_MPV_DEPAY(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_RTP_MPV_DEPAY))
</MACRO>
<MACRO>
<NAME>GST_IS_RTP_MPV_DEPAY_CLASS</NAME>
#define GST_IS_RTP_MPV_DEPAY_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_RTP_MPV_DEPAY))
</MACRO>
<STRUCT>
<NAME>GstRtpMPVDepay</NAME>
struct _GstRtpMPVDepay
{
  GstRTPBaseDepayload depayload;
};
</STRUCT>
<STRUCT>
<NAME>GstRtpMPVDepayClass</NAME>
struct _GstRtpMPVDepayClass
{
  GstRTPBaseDepayloadClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_rtp_mpv_depay_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_rtp_mpv_depay_plugin_init</NAME>
<RETURNS>gboolean  </RETURNS>
GstPlugin * plugin
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_RTP_H261_DEPAY</NAME>
#define GST_TYPE_RTP_H261_DEPAY \
  (gst_rtp_h261_depay_get_type())
</MACRO>
<MACRO>
<NAME>GST_RTP_H261_DEPAY</NAME>
#define GST_RTP_H261_DEPAY(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_RTP_H261_DEPAY,GstRtpH261Depay))
</MACRO>
<MACRO>
<NAME>GST_RTP_H261_DEPAY_CLASS</NAME>
#define GST_RTP_H261_DEPAY_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_RTP_H261_DEPAY,GstRtpH261DepayClass))
</MACRO>
<MACRO>
<NAME>GST_IS_RTP_H261_DEPAY</NAME>
#define GST_IS_RTP_H261_DEPAY(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_RTP_H261_DEPAY))
</MACRO>
<MACRO>
<NAME>GST_IS_RTP_H261_DEPAY_CLASS</NAME>
#define GST_IS_RTP_H261_DEPAY_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_RTP_H261_DEPAY))
</MACRO>
<STRUCT>
<NAME>GstRtpH261Depay</NAME>
struct _GstRtpH261Depay
{
  GstRTPBaseDepayload depayload;

  GstAdapter *adapter;
  gboolean start;
  guint8 leftover;
};
</STRUCT>
<STRUCT>
<NAME>GstRtpH261DepayClass</NAME>
struct _GstRtpH261DepayClass
{
  GstRTPBaseDepayloadClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_rtp_h261_depay_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_rtp_h261_depay_plugin_init</NAME>
<RETURNS>gboolean  </RETURNS>
GstPlugin * plugin
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_RTP_VORBIS_DEPAY</NAME>
#define GST_TYPE_RTP_VORBIS_DEPAY \
  (gst_rtp_vorbis_depay_get_type())
</MACRO>
<MACRO>
<NAME>GST_RTP_VORBIS_DEPAY</NAME>
#define GST_RTP_VORBIS_DEPAY(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_RTP_VORBIS_DEPAY,GstRtpVorbisDepay))
</MACRO>
<MACRO>
<NAME>GST_RTP_VORBIS_DEPAY_CLASS</NAME>
#define GST_RTP_VORBIS_DEPAY_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_RTP_VORBIS_DEPAY,GstRtpVorbisDepayClass))
</MACRO>
<MACRO>
<NAME>GST_IS_RTP_VORBIS_DEPAY</NAME>
#define GST_IS_RTP_VORBIS_DEPAY(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_RTP_VORBIS_DEPAY))
</MACRO>
<MACRO>
<NAME>GST_IS_RTP_VORBIS_DEPAY_CLASS</NAME>
#define GST_IS_RTP_VORBIS_DEPAY_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_RTP_VORBIS_DEPAY))
</MACRO>
<STRUCT>
<NAME>GstRtpVorbisConfig</NAME>
typedef struct _GstRtpVorbisConfig {
  guint32  ident;
  GList   *headers;
} GstRtpVorbisConfig;
</STRUCT>
<STRUCT>
<NAME>GstRtpVorbisDepay</NAME>
struct _GstRtpVorbisDepay
{
  GstRTPBaseDepayload parent;

  GList              *configs;
  GstRtpVorbisConfig *config;

  GstAdapter         *adapter;
  gboolean            assembling;
};
</STRUCT>
<STRUCT>
<NAME>GstRtpVorbisDepayClass</NAME>
struct _GstRtpVorbisDepayClass
{
  GstRTPBaseDepayloadClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_rtp_vorbis_depay_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_rtp_vorbis_depay_plugin_init</NAME>
<RETURNS>gboolean  </RETURNS>
GstPlugin * plugin
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_RTP_VP9_PAY</NAME>
#define GST_TYPE_RTP_VP9_PAY \
  (gst_rtp_vp9_pay_get_type())
</MACRO>
<MACRO>
<NAME>GST_RTP_VP9_PAY</NAME>
#define GST_RTP_VP9_PAY(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj), GST_TYPE_RTP_VP9_PAY, GstRtpVP9Pay))
</MACRO>
<MACRO>
<NAME>GST_RTP_VP9_PAY_CLASS</NAME>
#define GST_RTP_VP9_PAY_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass), GST_TYPE_RTP_VP9_PAY, GstRtpVP9PayClass))
</MACRO>
<MACRO>
<NAME>GST_IS_RTP_VP9_PAY</NAME>
#define GST_IS_RTP_VP9_PAY(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj), GST_TYPE_RTP_VP9_PAY))
</MACRO>
<MACRO>
<NAME>GST_IS_RTP_VP9_PAY_CLASS</NAME>
#define GST_IS_RTP_VP9_PAY_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass), GST_TYPE_RTP_VP9_PAY))
</MACRO>
<MACRO>
<NAME>GST_RTP_VP9_PAY_GET_CLASS</NAME>
#define GST_RTP_VP9_PAY_GET_CLASS(obj) \
  (G_TYPE_INSTANCE_GET_CLASS ((obj), GST_TYPE_RTP_VP9_PAY, GstRtpVP9PayClass))
</MACRO>
<ENUM>
<NAME>VP9PictureIDMode</NAME>
enum VP9PictureIDMode {
  VP9_PAY_NO_PICTURE_ID,
  VP9_PAY_PICTURE_ID_7BITS,
  VP9_PAY_PICTURE_ID_15BITS,
};
</ENUM>
<STRUCT>
<NAME>GstRtpVP9PayClass</NAME>
struct _GstRtpVP9PayClass
{
  GstRTPBasePayloadClass parent_class;
};
</STRUCT>
<STRUCT>
<NAME>GstRtpVP9Pay</NAME>
struct _GstRtpVP9Pay
{
  GstRTPBasePayload parent;
  gboolean is_keyframe;
  guint width;
  guint height;
  VP9PictureIDMode picture_id_mode;
  guint16 picture_id;
};
</STRUCT>
<FUNCTION>
<NAME>gst_rtp_vp9_pay_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_rtp_vp9_pay_plugin_init</NAME>
<RETURNS>gboolean  </RETURNS>
GstPlugin * plugin
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_RTP_PCMA_PAY</NAME>
#define GST_TYPE_RTP_PCMA_PAY \
  (gst_rtp_pcma_pay_get_type())
</MACRO>
<MACRO>
<NAME>GST_RTP_PCMA_PAY</NAME>
#define GST_RTP_PCMA_PAY(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_RTP_PCMA_PAY,GstRtpPcmaPay))
</MACRO>
<MACRO>
<NAME>GST_RTP_PCMA_PAY_CLASS</NAME>
#define GST_RTP_PCMA_PAY_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_RTP_PCMA_PAY,GstRtpPcmaPayClass))
</MACRO>
<MACRO>
<NAME>GST_IS_RTP_PCMA_PAY</NAME>
#define GST_IS_RTP_PCMA_PAY(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_RTP_PCMA_PAY))
</MACRO>
<MACRO>
<NAME>GST_IS_RTP_PCMA_PAY_CLASS</NAME>
#define GST_IS_RTP_PCMA_PAY_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_RTP_PCMA_PAY))
</MACRO>
<STRUCT>
<NAME>GstRtpPcmaPay</NAME>
struct _GstRtpPcmaPay
{
  GstRTPBaseAudioPayload audiopayload;
};
</STRUCT>
<STRUCT>
<NAME>GstRtpPcmaPayClass</NAME>
struct _GstRtpPcmaPayClass
{
  GstRTPBaseAudioPayloadClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_rtp_pcma_pay_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_rtp_pcma_pay_plugin_init</NAME>
<RETURNS>gboolean  </RETURNS>
GstPlugin * plugin
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_RTP_H264_PAY</NAME>
#define GST_TYPE_RTP_H264_PAY \
  (gst_rtp_h264_pay_get_type())
</MACRO>
<MACRO>
<NAME>GST_RTP_H264_PAY</NAME>
#define GST_RTP_H264_PAY(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_RTP_H264_PAY,GstRtpH264Pay))
</MACRO>
<MACRO>
<NAME>GST_RTP_H264_PAY_CLASS</NAME>
#define GST_RTP_H264_PAY_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_RTP_H264_PAY,GstRtpH264PayClass))
</MACRO>
<MACRO>
<NAME>GST_IS_RTP_H264_PAY</NAME>
#define GST_IS_RTP_H264_PAY(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_RTP_H264_PAY))
</MACRO>
<MACRO>
<NAME>GST_IS_RTP_H264_PAY_CLASS</NAME>
#define GST_IS_RTP_H264_PAY_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_RTP_H264_PAY))
</MACRO>
<ENUM>
<NAME>GstH264StreamFormat</NAME>
typedef enum
{
  GST_H264_STREAM_FORMAT_UNKNOWN,
  GST_H264_STREAM_FORMAT_BYTESTREAM,
  GST_H264_STREAM_FORMAT_AVC
} GstH264StreamFormat;
</ENUM>
<ENUM>
<NAME>GstH264Alignment</NAME>
typedef enum
{
  GST_H264_ALIGNMENT_UNKNOWN,
  GST_H264_ALIGNMENT_NAL,
  GST_H264_ALIGNMENT_AU
} GstH264Alignment;
</ENUM>
<STRUCT>
<NAME>GstRtpH264Pay</NAME>
struct _GstRtpH264Pay
{
  GstRTPBasePayload payload;

  guint profile;
  GPtrArray *sps, *pps;

  GstH264StreamFormat stream_format;
  GstH264Alignment alignment;
  guint nal_length_size;
  GArray *queue;

  gchar *sprop_parameter_sets;
  gboolean update_caps;

  GstAdapter *adapter;

  gint spspps_interval;
  gboolean send_spspps;
  GstClockTime last_spspps;

  /* TRUE if the next NALU processed should have the DELTA_UNIT flag */
  gboolean delta_unit;
  /* TRUE if the next NALU processed should have the DISCONT flag */
  gboolean discont;
};
</STRUCT>
<STRUCT>
<NAME>GstRtpH264PayClass</NAME>
struct _GstRtpH264PayClass
{
  GstRTPBasePayloadClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_rtp_h264_pay_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_rtp_h264_pay_plugin_init</NAME>
<RETURNS>gboolean  </RETURNS>
GstPlugin * plugin
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_RTP_H265_PAY</NAME>
#define GST_TYPE_RTP_H265_PAY \
  (gst_rtp_h265_pay_get_type())
</MACRO>
<MACRO>
<NAME>GST_RTP_H265_PAY</NAME>
#define GST_RTP_H265_PAY(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_RTP_H265_PAY,GstRtpH265Pay))
</MACRO>
<MACRO>
<NAME>GST_RTP_H265_PAY_CLASS</NAME>
#define GST_RTP_H265_PAY_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_RTP_H265_PAY,GstRtpH265PayClass))
</MACRO>
<MACRO>
<NAME>GST_IS_RTP_H265_PAY</NAME>
#define GST_IS_RTP_H265_PAY(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_RTP_H265_PAY))
</MACRO>
<MACRO>
<NAME>GST_IS_RTP_H265_PAY_CLASS</NAME>
#define GST_IS_RTP_H265_PAY_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_RTP_H265_PAY))
</MACRO>
<ENUM>
<NAME>GstH265Alignment</NAME>
typedef enum
{
  GST_H265_ALIGNMENT_UNKNOWN,
  GST_H265_ALIGNMENT_NAL,
  GST_H265_ALIGNMENT_AU
} GstH265Alignment;
</ENUM>
<STRUCT>
<NAME>GstRtpH265Pay</NAME>
struct _GstRtpH265Pay
{
  GstRTPBasePayload payload;

  GPtrArray *sps, *pps, *vps;

  GstH265StreamFormat stream_format;
  GstH265Alignment alignment;
  guint nal_length_size;
  GArray *queue;

  GstAdapter *adapter;

  gint vps_sps_pps_interval;
  gboolean send_vps_sps_pps;
  GstClockTime last_vps_sps_pps;
};
</STRUCT>
<STRUCT>
<NAME>GstRtpH265PayClass</NAME>
struct _GstRtpH265PayClass
{
  GstRTPBasePayloadClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_rtp_h265_pay_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_rtp_h265_pay_plugin_init</NAME>
<RETURNS>gboolean  </RETURNS>
GstPlugin * plugin
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_RTP_JPEG_DEPAY</NAME>
#define GST_TYPE_RTP_JPEG_DEPAY \
  (gst_rtp_jpeg_depay_get_type())
</MACRO>
<MACRO>
<NAME>GST_RTP_JPEG_DEPAY</NAME>
#define GST_RTP_JPEG_DEPAY(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_RTP_JPEG_DEPAY,GstRtpJPEGDepay))
</MACRO>
<MACRO>
<NAME>GST_RTP_JPEG_DEPAY_CLASS</NAME>
#define GST_RTP_JPEG_DEPAY_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_RTP_JPEG_DEPAY,GstRtpJPEGDepayClass))
</MACRO>
<MACRO>
<NAME>GST_IS_RTP_JPEG_DEPAY</NAME>
#define GST_IS_RTP_JPEG_DEPAY(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_RTP_JPEG_DEPAY))
</MACRO>
<MACRO>
<NAME>GST_IS_RTP_JPEG_DEPAY_CLASS</NAME>
#define GST_IS_RTP_JPEG_DEPAY_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_RTP_JPEG_DEPAY))
</MACRO>
<STRUCT>
<NAME>GstRtpJPEGDepay</NAME>
struct _GstRtpJPEGDepay
{
  GstRTPBaseDepayload depayload;

  GstAdapter *adapter;
  gboolean    discont;

  /* cached quant tables */
  guint8 * qtables[255];
  gint frate_num;
  gint frate_denom;
  gint media_width;
  gint media_height;
  gint width, height;
};
</STRUCT>
<STRUCT>
<NAME>GstRtpJPEGDepayClass</NAME>
struct _GstRtpJPEGDepayClass
{
  GstRTPBaseDepayloadClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_rtp_jpeg_depay_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_rtp_jpeg_depay_plugin_init</NAME>
<RETURNS>gboolean  </RETURNS>
GstPlugin * plugin
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_RTP_BV_DEPAY</NAME>
#define GST_TYPE_RTP_BV_DEPAY \
  (gst_rtp_bv_depay_get_type())
</MACRO>
<MACRO>
<NAME>GST_RTP_BV_DEPAY</NAME>
#define GST_RTP_BV_DEPAY(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_RTP_BV_DEPAY,GstRTPBVDepay))
</MACRO>
<MACRO>
<NAME>GST_RTP_BV_DEPAY_CLASS</NAME>
#define GST_RTP_BV_DEPAY_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_RTP_BV_DEPAY,GstRTPBVDepayClass))
</MACRO>
<MACRO>
<NAME>GST_IS_RTP_BV_DEPAY</NAME>
#define GST_IS_RTP_BV_DEPAY(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_RTP_BV_DEPAY))
</MACRO>
<MACRO>
<NAME>GST_IS_RTP_BV_DEPAY_CLASS</NAME>
#define GST_IS_RTP_BV_DEPAY_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_RTP_BV_DEPAY))
</MACRO>
<STRUCT>
<NAME>GstRTPBVDepay</NAME>
struct _GstRTPBVDepay
{
  GstRTPBaseDepayload depayload;

  gint mode;
};
</STRUCT>
<STRUCT>
<NAME>GstRTPBVDepayClass</NAME>
struct _GstRTPBVDepayClass
{
  GstRTPBaseDepayloadClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_rtp_bv_depay_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_rtp_bv_depay_plugin_init</NAME>
<RETURNS>gboolean  </RETURNS>
GstPlugin * plugin
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_RTP_QDM2_DEPAY</NAME>
#define GST_TYPE_RTP_QDM2_DEPAY \
  (gst_rtp_qdm2_depay_get_type())
</MACRO>
<MACRO>
<NAME>GST_RTP_QDM2_DEPAY</NAME>
#define GST_RTP_QDM2_DEPAY(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_RTP_QDM2_DEPAY,GstRtpQDM2Depay))
</MACRO>
<MACRO>
<NAME>GST_RTP_QDM2_DEPAY_CLASS</NAME>
#define GST_RTP_QDM2_DEPAY_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_RTP_QDM2_DEPAY,GstRtpQDM2DepayClass))
</MACRO>
<MACRO>
<NAME>GST_IS_RTP_QDM2_DEPAY</NAME>
#define GST_IS_RTP_QDM2_DEPAY(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_RTP_QDM2_DEPAY))
</MACRO>
<MACRO>
<NAME>GST_IS_RTP_QDM2_DEPAY_CLASS</NAME>
#define GST_IS_RTP_QDM2_DEPAY_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_RTP_QDM2_DEPAY))
</MACRO>
<STRUCT>
<NAME>QDM2Packet</NAME>
typedef struct _QDM2Packet {
  guint8* data;
  guint offs;		/* Starts at 4 to give room for the prefix */
} QDM2Packet;
</STRUCT>
<MACRO>
<NAME>MAX_SCRAMBLED_PACKETS</NAME>
#define MAX_SCRAMBLED_PACKETS 64
</MACRO>
<STRUCT>
<NAME>GstRtpQDM2Depay</NAME>
struct _GstRtpQDM2Depay
{
  GstRTPBaseDepayload depayload;

  GstAdapter *adapter;

  guint16 nextseq;
  gboolean configured;

  GstClockTime timestamp; /* Timestamp of current incoming data */
  GstClockTime ptimestamp; /* Timestamp of data stored in the adapter */

  guint32 channs;
  guint32 samplerate;
  guint32 bitrate;
  guint32 blocksize;
  guint32 framesize;
  guint32 packetsize;

  guint nbpackets;	/* Number of packets to unscramble */

  QDM2Packet *packets[MAX_SCRAMBLED_PACKETS];
};
</STRUCT>
<STRUCT>
<NAME>GstRtpQDM2DepayClass</NAME>
struct _GstRtpQDM2DepayClass
{
  GstRTPBaseDepayloadClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_rtp_qdm2_depay_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_rtp_qdm2_depay_plugin_init</NAME>
<RETURNS>gboolean  </RETURNS>
GstPlugin * plugin
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_ASTERISK_H263</NAME>
#define GST_TYPE_ASTERISK_H263 \
  (gst_asteriskh263_get_type())
</MACRO>
<MACRO>
<NAME>GST_ASTERISK_H263</NAME>
#define GST_ASTERISK_H263(obj) \
 (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_ASTERISK_H263,GstAsteriskh263))
</MACRO>
<MACRO>
<NAME>GST_ASTERISK_H263_CLASS</NAME>
#define GST_ASTERISK_H263_CLASS(klass) \
 (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_ASTERISK_H263,GstAsteriskh263Class))
</MACRO>
<MACRO>
<NAME>GST_IS_ASTERISK_H263</NAME>
#define GST_IS_ASTERISK_H263(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_ASTERISK_H263))
</MACRO>
<MACRO>
<NAME>GST_IS_ASTERISK_H263_CLASS</NAME>
#define GST_IS_ASTERISK_H263_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_ASTERISK_H263))
</MACRO>
<STRUCT>
<NAME>GstAsteriskh263</NAME>
struct _GstAsteriskh263
{
  GstElement element;

  GstPad *sinkpad;
  GstPad *srcpad;

  GstAdapter *adapter;

  guint32 lastts;
};
</STRUCT>
<STRUCT>
<NAME>GstAsteriskh263Class</NAME>
struct _GstAsteriskh263Class
{
  GstElementClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_asteriskh263_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_asteriskh263_plugin_init</NAME>
<RETURNS>gboolean  </RETURNS>
GstPlugin * plugin
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_RTP_THEORA_DEPAY</NAME>
#define GST_TYPE_RTP_THEORA_DEPAY \
  (gst_rtp_theora_depay_get_type())
</MACRO>
<MACRO>
<NAME>GST_RTP_THEORA_DEPAY</NAME>
#define GST_RTP_THEORA_DEPAY(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_RTP_THEORA_DEPAY,GstRtpTheoraDepay))
</MACRO>
<MACRO>
<NAME>GST_RTP_THEORA_DEPAY_CLASS</NAME>
#define GST_RTP_THEORA_DEPAY_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_RTP_THEORA_DEPAY,GstRtpTheoraDepayClass))
</MACRO>
<MACRO>
<NAME>GST_IS_RTP_THEORA_DEPAY</NAME>
#define GST_IS_RTP_THEORA_DEPAY(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_RTP_THEORA_DEPAY))
</MACRO>
<MACRO>
<NAME>GST_IS_RTP_THEORA_DEPAY_CLASS</NAME>
#define GST_IS_RTP_THEORA_DEPAY_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_RTP_THEORA_DEPAY))
</MACRO>
<STRUCT>
<NAME>GstRtpTheoraConfig</NAME>
typedef struct _GstRtpTheoraConfig {
  guint32  ident;
  GList   *headers;
} GstRtpTheoraConfig;
</STRUCT>
<STRUCT>
<NAME>GstRtpTheoraDepay</NAME>
struct _GstRtpTheoraDepay
{
  GstRTPBaseDepayload parent;

  GList              *configs;
  GstRtpTheoraConfig *config;

  GstAdapter         *adapter;
  gboolean            assembling;

  gboolean            needs_keyframe;
};
</STRUCT>
<STRUCT>
<NAME>GstRtpTheoraDepayClass</NAME>
struct _GstRtpTheoraDepayClass
{
  GstRTPBaseDepayloadClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_rtp_theora_depay_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_rtp_theora_depay_plugin_init</NAME>
<RETURNS>gboolean  </RETURNS>
GstPlugin * plugin
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_RTP_QCELP_DEPAY</NAME>
#define GST_TYPE_RTP_QCELP_DEPAY \
  (gst_rtp_qcelp_depay_get_type())
</MACRO>
<MACRO>
<NAME>GST_RTP_QCELP_DEPAY</NAME>
#define GST_RTP_QCELP_DEPAY(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_RTP_QCELP_DEPAY,GstRtpQCELPDepay))
</MACRO>
<MACRO>
<NAME>GST_RTP_QCELP_DEPAY_CLASS</NAME>
#define GST_RTP_QCELP_DEPAY_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_RTP_QCELP_DEPAY,GstRtpQCELPDepayClass))
</MACRO>
<MACRO>
<NAME>GST_IS_RTP_QCELP_DEPAY</NAME>
#define GST_IS_RTP_QCELP_DEPAY(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_RTP_QCELP_DEPAY))
</MACRO>
<MACRO>
<NAME>GST_IS_RTP_QCELP_DEPAY_CLASS</NAME>
#define GST_IS_RTP_QCELP_DEPAY_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_RTP_QCELP_DEPAY))
</MACRO>
<STRUCT>
<NAME>GstRtpQCELPDepay</NAME>
struct _GstRtpQCELPDepay
{
  GstRTPBaseDepayload depayload;

  gboolean interleaved;
  guint bundling;
  GPtrArray *packets;
};
</STRUCT>
<STRUCT>
<NAME>GstRtpQCELPDepayClass</NAME>
struct _GstRtpQCELPDepayClass
{
  GstRTPBaseDepayloadClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_rtp_qcelp_depay_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_rtp_qcelp_depay_plugin_init</NAME>
<RETURNS>gboolean  </RETURNS>
GstPlugin * plugin
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_RTP_H265_DEPAY</NAME>
#define GST_TYPE_RTP_H265_DEPAY \
  (gst_rtp_h265_depay_get_type())
</MACRO>
<MACRO>
<NAME>GST_RTP_H265_DEPAY</NAME>
#define GST_RTP_H265_DEPAY(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_RTP_H265_DEPAY,GstRtpH265Depay))
</MACRO>
<MACRO>
<NAME>GST_RTP_H265_DEPAY_CLASS</NAME>
#define GST_RTP_H265_DEPAY_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_RTP_H265_DEPAY,GstRtpH265DepayClass))
</MACRO>
<MACRO>
<NAME>GST_IS_RTP_H265_DEPAY</NAME>
#define GST_IS_RTP_H265_DEPAY(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_RTP_H265_DEPAY))
</MACRO>
<MACRO>
<NAME>GST_IS_RTP_H265_DEPAY_CLASS</NAME>
#define GST_IS_RTP_H265_DEPAY_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_RTP_H265_DEPAY))
</MACRO>
<MACRO>
<NAME>GST_H265_VPS_NUT</NAME>
#define GST_H265_VPS_NUT 32
</MACRO>
<MACRO>
<NAME>GST_H265_SPS_NUT</NAME>
#define GST_H265_SPS_NUT 33
</MACRO>
<MACRO>
<NAME>GST_H265_PPS_NUT</NAME>
#define GST_H265_PPS_NUT 34
</MACRO>
<ENUM>
<NAME>GstH265StreamFormat</NAME>
typedef enum
{
  GST_H265_STREAM_FORMAT_UNKNOWN,
  GST_H265_STREAM_FORMAT_BYTESTREAM,
  GST_H265_STREAM_FORMAT_HVC1,
  GST_H265_STREAM_FORMAT_HEV1
} GstH265StreamFormat;
</ENUM>
<STRUCT>
<NAME>GstRtpH265Depay</NAME>
struct _GstRtpH265Depay
{
  GstRTPBaseDepayload depayload;

  gchar *stream_format;
  gboolean byte_stream;

  GstBuffer *codec_data;
  GstAdapter *adapter;
  gboolean wait_start;

  /* nal merging */
  gboolean merge;
  GstAdapter *picture_adapter;
  gboolean picture_start;
  GstClockTime last_ts;
  gboolean last_keyframe;

  /* Work around broken payloaders wrt. Fragmentation Units */
  guint8 current_fu_type;
  GstClockTime fu_timestamp;
  gboolean fu_marker;

  /* misc */
  GPtrArray *vps;
  GPtrArray *sps;
  GPtrArray *pps;
  gboolean new_codec_data;
};
</STRUCT>
<STRUCT>
<NAME>GstRtpH265DepayClass</NAME>
struct _GstRtpH265DepayClass
{
  GstRTPBaseDepayloadClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_rtp_h265_depay_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_rtp_h265_depay_plugin_init</NAME>
<RETURNS>gboolean  </RETURNS>
GstPlugin * plugin
</FUNCTION>
<FUNCTION>
<NAME>gst_rtp_h265_add_vps_sps_pps</NAME>
<RETURNS>gboolean  </RETURNS>
GstElement * rtph265, GPtrArray * vps, GPtrArray * sps, GPtrArray * pps, GstBuffer * nal
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_RTP_SIREN_DEPAY</NAME>
#define GST_TYPE_RTP_SIREN_DEPAY \
  (gst_rtp_siren_depay_get_type())
</MACRO>
<MACRO>
<NAME>GST_RTP_SIREN_DEPAY</NAME>
#define GST_RTP_SIREN_DEPAY(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_RTP_SIREN_DEPAY,GstRTPSirenDepay))
</MACRO>
<MACRO>
<NAME>GST_RTP_SIREN_DEPAY_CLASS</NAME>
#define GST_RTP_SIREN_DEPAY_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_RTP_SIREN_DEPAY,GstRTPSirenDepayClass))
</MACRO>
<MACRO>
<NAME>GST_IS_RTP_SIREN_DEPAY</NAME>
#define GST_IS_RTP_SIREN_DEPAY(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_RTP_SIREN_DEPAY))
</MACRO>
<MACRO>
<NAME>GST_IS_RTP_SIREN_DEPAY_CLASS</NAME>
#define GST_IS_RTP_SIREN_DEPAY_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_RTP_SIREN_DEPAY))
</MACRO>
<STRUCT>
<NAME>GstRTPSirenDepay</NAME>
struct _GstRTPSirenDepay
{
  GstRTPBaseDepayload depayload;

};
</STRUCT>
<STRUCT>
<NAME>GstRTPSirenDepayClass</NAME>
struct _GstRTPSirenDepayClass
{
  GstRTPBaseDepayloadClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_rtp_siren_depay_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_rtp_siren_depay_plugin_init</NAME>
<RETURNS>gboolean  </RETURNS>
GstPlugin * plugin
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_RTP_H263P_DEPAY</NAME>
#define GST_TYPE_RTP_H263P_DEPAY \
  (gst_rtp_h263p_depay_get_type())
</MACRO>
<MACRO>
<NAME>GST_RTP_H263P_DEPAY</NAME>
#define GST_RTP_H263P_DEPAY(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_RTP_H263P_DEPAY,GstRtpH263PDepay))
</MACRO>
<MACRO>
<NAME>GST_RTP_H263P_DEPAY_CLASS</NAME>
#define GST_RTP_H263P_DEPAY_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_RTP_H263P_DEPAY,GstRtpH263PDepayClass))
</MACRO>
<MACRO>
<NAME>GST_IS_RTP_H263P_DEPAY</NAME>
#define GST_IS_RTP_H263P_DEPAY(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_RTP_H263P_DEPAY))
</MACRO>
<MACRO>
<NAME>GST_IS_RTP_H263P_DEPAY_CLASS</NAME>
#define GST_IS_RTP_H263P_DEPAY_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_RTP_H263P_DEPAY))
</MACRO>
<STRUCT>
<NAME>GstRtpH263PDepay</NAME>
struct _GstRtpH263PDepay
{
  GstRTPBaseDepayload depayload;

  GstAdapter *adapter;
  gboolean    wait_start;
};
</STRUCT>
<STRUCT>
<NAME>GstRtpH263PDepayClass</NAME>
struct _GstRtpH263PDepayClass
{
  GstRTPBaseDepayloadClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_rtp_h263p_depay_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_rtp_h263p_depay_plugin_init</NAME>
<RETURNS>gboolean  </RETURNS>
GstPlugin * plugin
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_RTP_KLV_DEPAY</NAME>
#define GST_TYPE_RTP_KLV_DEPAY \
  (gst_rtp_klv_depay_get_type())
</MACRO>
<MACRO>
<NAME>GST_RTP_KLV_DEPAY</NAME>
#define GST_RTP_KLV_DEPAY(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_RTP_KLV_DEPAY,GstRtpKlvDepay))
</MACRO>
<MACRO>
<NAME>GST_RTP_KLV_DEPAY_CLASS</NAME>
#define GST_RTP_KLV_DEPAY_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_RTP_KLV_DEPAY,GstRtpKlvDepayClass))
</MACRO>
<MACRO>
<NAME>GST_IS_RTP_KLV_DEPAY</NAME>
#define GST_IS_RTP_KLV_DEPAY(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_RTP_KLV_DEPAY))
</MACRO>
<MACRO>
<NAME>GST_IS_RTP_KLV_DEPAY_CLASS</NAME>
#define GST_IS_RTP_KLV_DEPAY_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_RTP_KLV_DEPAY))
</MACRO>
<STRUCT>
<NAME>GstRtpKlvDepay</NAME>
struct _GstRtpKlvDepay
{
  GstRTPBaseDepayload depayload;

  GstAdapter *adapter;
  gboolean    resync;
  gint        last_marker_seq;   /* -1 if unset, otherwise 0-G_MAXUINT16 */
  gint64      last_rtp_ts;       /* -1 if unset, otherwise 0-G_MAXUINT32 */
};
</STRUCT>
<STRUCT>
<NAME>GstRtpKlvDepayClass</NAME>
struct _GstRtpKlvDepayClass
{
  GstRTPBaseDepayloadClass parent_class;
};
</STRUCT>
<MACRO>
<NAME>GST_TYPE_RTP_OPUS_DEPAY</NAME>
#define GST_TYPE_RTP_OPUS_DEPAY \
  (gst_rtp_opus_depay_get_type())
</MACRO>
<MACRO>
<NAME>GST_RTP_OPUS_DEPAY</NAME>
#define GST_RTP_OPUS_DEPAY(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_RTP_OPUS_DEPAY,GstRTPOpusDepay))
</MACRO>
<MACRO>
<NAME>GST_RTP_OPUS_DEPAY_CLASS</NAME>
#define GST_RTP_OPUS_DEPAY_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_RTP_OPUS_DEPAY,GstRTPOpusDepayClass))
</MACRO>
<MACRO>
<NAME>GST_IS_RTP_OPUS_DEPAY</NAME>
#define GST_IS_RTP_OPUS_DEPAY(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_RTP_OPUS_DEPAY))
</MACRO>
<MACRO>
<NAME>GST_IS_RTP_OPUS_DEPAY_CLASS</NAME>
#define GST_IS_RTP_OPUS_DEPAY_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_RTP_OPUS_DEPAY))
</MACRO>
<STRUCT>
<NAME>GstRTPOpusDepay</NAME>
struct _GstRTPOpusDepay
{
  GstRTPBaseDepayload depayload;

};
</STRUCT>
<STRUCT>
<NAME>GstRTPOpusDepayClass</NAME>
struct _GstRTPOpusDepayClass
{
  GstRTPBaseDepayloadClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_rtp_opus_depay_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_rtp_opus_depay_plugin_init</NAME>
<RETURNS>gboolean  </RETURNS>
GstPlugin * plugin
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_RTP_SV3V_DEPAY</NAME>
#define GST_TYPE_RTP_SV3V_DEPAY \
  (gst_rtp_sv3v_depay_get_type())
</MACRO>
<MACRO>
<NAME>GST_RTP_SV3V_DEPAY</NAME>
#define GST_RTP_SV3V_DEPAY(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_RTP_SV3V_DEPAY,GstRtpSV3VDepay))
</MACRO>
<MACRO>
<NAME>GST_RTP_SV3V_DEPAY_CLASS</NAME>
#define GST_RTP_SV3V_DEPAY_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_RTP_SV3V_DEPAY,GstRtpSV3VDepayClass))
</MACRO>
<MACRO>
<NAME>GST_IS_RTP_SV3V_DEPAY</NAME>
#define GST_IS_RTP_SV3V_DEPAY(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_RTP_SV3V_DEPAY))
</MACRO>
<MACRO>
<NAME>GST_IS_RTP_SV3V_DEPAY_CLASS</NAME>
#define GST_IS_RTP_SV3V_DEPAY_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_RTP_SV3V_DEPAY))
</MACRO>
<STRUCT>
<NAME>GstRtpSV3VDepay</NAME>
struct _GstRtpSV3VDepay
{
  GstRTPBaseDepayload depayload;

  GstAdapter *adapter;

  gboolean configured;
  
  guint16 nextseq;
  guint width;
  guint height;
};
</STRUCT>
<STRUCT>
<NAME>GstRtpSV3VDepayClass</NAME>
struct _GstRtpSV3VDepayClass
{
  GstRTPBaseDepayloadClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_rtp_sv3v_depay_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_rtp_sv3v_depay_plugin_init</NAME>
<RETURNS>gboolean  </RETURNS>
GstPlugin * plugin
</FUNCTION>
<FUNCTION>
<NAME>gst_rtp_copy_meta</NAME>
<RETURNS>void  </RETURNS>
GstElement * element, GstBuffer *outbuf, GstBuffer *inbuf, GQuark copy_tag
</FUNCTION>
<FUNCTION>
<NAME>gst_rtp_drop_meta</NAME>
<RETURNS>void  </RETURNS>
GstElement * element, GstBuffer *buf, GQuark keep_tag
</FUNCTION>
<FUNCTION>
<NAME>gst_rtp_read_golomb</NAME>
<RETURNS>gboolean  </RETURNS>
GstBitReader * br, guint32 * value
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_RTP_AC3_PAY</NAME>
#define GST_TYPE_RTP_AC3_PAY \
  (gst_rtp_ac3_pay_get_type())
</MACRO>
<MACRO>
<NAME>GST_RTP_AC3_PAY</NAME>
#define GST_RTP_AC3_PAY(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_RTP_AC3_PAY,GstRtpAC3Pay))
</MACRO>
<MACRO>
<NAME>GST_RTP_AC3_PAY_CLASS</NAME>
#define GST_RTP_AC3_PAY_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_RTP_AC3_PAY,GstRtpAC3PayClass))
</MACRO>
<MACRO>
<NAME>GST_IS_RTP_AC3_PAY</NAME>
#define GST_IS_RTP_AC3_PAY(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_RTP_AC3_PAY))
</MACRO>
<MACRO>
<NAME>GST_IS_RTP_AC3_PAY_CLASS</NAME>
#define GST_IS_RTP_AC3_PAY_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_RTP_AC3_PAY))
</MACRO>
<STRUCT>
<NAME>GstRtpAC3Pay</NAME>
struct _GstRtpAC3Pay
{
  GstRTPBasePayload payload;

  GstAdapter *adapter;
  GstClockTime first_ts;
  GstClockTime duration;
  guint NF;
};
</STRUCT>
<STRUCT>
<NAME>GstRtpAC3PayClass</NAME>
struct _GstRtpAC3PayClass
{
  GstRTPBasePayloadClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_rtp_ac3_pay_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_rtp_ac3_pay_plugin_init</NAME>
<RETURNS>gboolean  </RETURNS>
GstPlugin * plugin
</FUNCTION>
<MACRO>
<NAME>GST_RTP_J2K_RGB</NAME>
#define GST_RTP_J2K_RGB       "RGB"
</MACRO>
<MACRO>
<NAME>GST_RTP_J2K_BGR</NAME>
#define GST_RTP_J2K_BGR       "BGR"
</MACRO>
<MACRO>
<NAME>GST_RTP_J2K_RGBA</NAME>
#define GST_RTP_J2K_RGBA      "RGBA"
</MACRO>
<MACRO>
<NAME>GST_RTP_J2K_BGRA</NAME>
#define GST_RTP_J2K_BGRA      "BGRA"
</MACRO>
<MACRO>
<NAME>GST_RTP_J2K_YBRA</NAME>
#define GST_RTP_J2K_YBRA   	  "YCbCrA"
</MACRO>
<MACRO>
<NAME>GST_RTP_J2K_YBR444</NAME>
#define GST_RTP_J2K_YBR444    "YCbCr-4:4:4"
</MACRO>
<MACRO>
<NAME>GST_RTP_J2K_YBR422</NAME>
#define GST_RTP_J2K_YBR422    "YCbCr-4:2:2"
</MACRO>
<MACRO>
<NAME>GST_RTP_J2K_YBR420</NAME>
#define GST_RTP_J2K_YBR420    "YCbCr-4:2:0"
</MACRO>
<MACRO>
<NAME>GST_RTP_J2K_YBR410</NAME>
#define GST_RTP_J2K_YBR410    "YCbCr-4:1:0"
</MACRO>
<MACRO>
<NAME>GST_RTP_J2K_GRAYSCALE</NAME>
#define GST_RTP_J2K_GRAYSCALE "GRAYSCALE"
</MACRO>
<MACRO>
<NAME>GST_RTP_J2K_SAMPLING_LIST</NAME>
#define GST_RTP_J2K_SAMPLING_LIST "sampling = (string) {\"RGB\", \"BGR\", \"RGBA\", \"BGRA\", \"YCbCrA\", \"YCbCr-4:4:4\", \"YCbCr-4:2:2\", \"YCbCr-4:2:0\", \"YCbCr-4:1:1\", \"GRAYSCALE\"}"
</MACRO>
<ENUM>
<NAME>GstRtpSampling</NAME>
typedef enum
{

  GST_RTP_SAMPLING_NONE,
  GST_RTP_SAMPLING_RGB,
  GST_RTP_SAMPLING_BGR,
  GST_RTP_SAMPLING_RGBA,
  GST_RTP_SAMPLING_BGRA,
  GST_RTP_SAMPLING_YBRA,
  GST_RTP_SAMPLING_YBR444,
  GST_RTP_SAMPLING_YBR422,
  GST_RTP_SAMPLING_YBR420,
  GST_RTP_SAMPLING_YBR410,
  GST_RTP_SAMPLING_GRAYSCALE
} GstRtpSampling;
</ENUM>
<ENUM>
<NAME>GstRtpJ2KMarker</NAME>
typedef enum
{
  GST_J2K_MARKER = 0xFF,
  GST_J2K_MARKER_SOC = 0x4F,
  GST_J2K_MARKER_SOT = 0x90,
  GST_J2K_MARKER_SOP = 0x91,
  GST_J2K_MARKER_EPH = 0x92,
  GST_J2K_MARKER_SOD = 0x93,
  GST_J2K_MARKER_EOC = 0xD9
} GstRtpJ2KMarker;
</ENUM>
<MACRO>
<NAME>GST_RTP_J2K_HEADER_SIZE</NAME>
#define GST_RTP_J2K_HEADER_SIZE 8
</MACRO>
<MACRO>
<NAME>GST_TYPE_RTP_H261_PAY</NAME>
#define GST_TYPE_RTP_H261_PAY                   \
  (gst_rtp_h261_pay_get_type())
</MACRO>
<MACRO>
<NAME>GST_RTP_H261_PAY</NAME>
#define GST_RTP_H261_PAY(obj)                                           \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_RTP_H261_PAY,GstRtpH261Pay))
</MACRO>
<MACRO>
<NAME>GST_RTP_H261_PAY_CLASS</NAME>
#define GST_RTP_H261_PAY_CLASS(klass)                                   \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_RTP_H261_PAY,GstRtpH261PayClass))
</MACRO>
<MACRO>
<NAME>GST_IS_RTP_H261_PAY</NAME>
#define GST_IS_RTP_H261_PAY(obj)                            \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_RTP_H261_PAY))
</MACRO>
<MACRO>
<NAME>GST_IS_RTP_H261_PAY_CLASS</NAME>
#define GST_IS_RTP_H261_PAY_CLASS(klass)                    \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_RTP_H261_PAY))
</MACRO>
<STRUCT>
<NAME>GstRtpH261Pay</NAME>
struct _GstRtpH261Pay
{
  GstRTPBasePayload payload;

  GstAdapter *adapter;
  gint offset;
  GstClockTime timestamp;
};
</STRUCT>
<STRUCT>
<NAME>GstRtpH261PayClass</NAME>
struct _GstRtpH261PayClass
{
  GstRTPBasePayloadClass parent_class;
};
</STRUCT>
<MACRO>
<NAME>GST_RTP_H261_PAYLOAD_HEADER_LEN</NAME>
#define GST_RTP_H261_PAYLOAD_HEADER_LEN 4
</MACRO>
<FUNCTION>
<NAME>gst_rtp_h261_pay_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_rtp_h261_pay_plugin_init</NAME>
<RETURNS>gboolean  </RETURNS>
GstPlugin * plugin
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_RTP_H263_PAY</NAME>
#define GST_TYPE_RTP_H263_PAY \
  (gst_rtp_h263_pay_get_type())
</MACRO>
<MACRO>
<NAME>GST_RTP_H263_PAY</NAME>
#define GST_RTP_H263_PAY(obj) \
 (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_RTP_H263_PAY,GstRtpH263Pay))
</MACRO>
<MACRO>
<NAME>GST_RTP_H263_PAY_CLASS</NAME>
#define GST_RTP_H263_PAY_CLASS(klass) \
 (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_RTP_H263_PAY,GstRtpH263PayClass))
</MACRO>
<MACRO>
<NAME>GST_IS_RTP_H263_PAY</NAME>
#define GST_IS_RTP_H263_PAY(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_RTP_H263_PAY))
</MACRO>
<MACRO>
<NAME>GST_IS_RTP_H263_PAY_CLASS</NAME>
#define GST_IS_RTP_H263_PAY_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_RTP_H263_PAY))
</MACRO>
<MACRO>
<NAME>N_BLOCKS</NAME>
#define N_BLOCKS 6
</MACRO>
<MACRO>
<NAME>DEFAULT_MODE_A</NAME>
#define DEFAULT_MODE_A FALSE
</MACRO>
<MACRO>
<NAME>MTU_SECURITY_OFFSET</NAME>
#define MTU_SECURITY_OFFSET 50
</MACRO>
<ENUM>
<NAME>GstRtpH263PayHeaderMode</NAME>
    typedef enum _GstRtpH263PayHeaderMode
{
  GST_RTP_H263_PAYLOAD_HEADER_MODE_A = 4,
  GST_RTP_H263_PAYLOAD_HEADER_MODE_B = 8,
  GST_RTP_H263_PAYLOAD_HEADER_MODE_C = 12
} GstRtpH263PayHeaderMode;
</ENUM>
<STRUCT>
<NAME>GstRtpH263Pay</NAME>
struct _GstRtpH263Pay
{
  GstRTPBasePayload payload;

  GstBuffer *current_buffer;
  GstMapInfo map;

  GstClockTime first_ts;
  gboolean prop_payload_mode;
  guint8 *data;
  guint available_data;

};
</STRUCT>
<STRUCT>
<NAME>GstRtpH263PayContext</NAME>
struct _GstRtpH263PayContext
{
  GstRtpH263PayPic *piclayer;

  guint mtu;
  guint window;
  guint8 *win_end;
  guint8 cpm;

  guint no_gobs;
  GstRtpH263PayGob **gobs;

};
</STRUCT>
<STRUCT>
<NAME>GstRtpH263PayClass</NAME>
struct _GstRtpH263PayClass
{
  GstRTPBasePayloadClass parent_class;
};
</STRUCT>
<STRUCT>
<NAME>GstRtpH263PayPic</NAME>
struct _GstRtpH263PayPic
{
#if G_BYTE_ORDER == G_LITTLE_ENDIAN
  unsigned int psc1:16;

  unsigned int tr1:2;
  unsigned int psc2:6;

  unsigned int ptype_263:1;
  unsigned int ptype_start:1;
  unsigned int tr2:6;

  unsigned int ptype_umvmode:1;
  unsigned int ptype_pictype:1;
  unsigned int ptype_srcformat:3;
  unsigned int ptype_freeze:1;
  unsigned int ptype_camera:1;
  unsigned int ptype_split:1;

  unsigned int pquant:5;
  unsigned int ptype_pbmode:1;
  unsigned int ptype_apmode:1;
  unsigned int ptype_sacmode:1;

#elif G_BYTE_ORDER == G_BIG_ENDIAN
  unsigned int psc1:16;

  unsigned int psc2:6;
  unsigned int tr1:2;

  unsigned int tr2:6;
  unsigned int ptype_start:2;

  unsigned int ptype_split:1;
  unsigned int ptype_camera:1;
  unsigned int ptype_freeze:1;
  unsigned int ptype_srcformat:3;
  unsigned int ptype_pictype:1;
  unsigned int ptype_umvmode:1;

  unsigned int ptype_sacmode:1;
  unsigned int ptype_apmode:1;
  unsigned int ptype_pbmode:1;
  unsigned int pquant:5;

#else
#error "G_BYTE_ORDER should be big or little endian."
#endif
};
</STRUCT>
<STRUCT>
<NAME>GstRtpH263PayBoundry</NAME>
struct _GstRtpH263PayBoundry
{

  guint8 *start;
  guint8 *end;
  guint8 sbit;
  guint8 ebit;

};
</STRUCT>
<STRUCT>
<NAME>GstRtpH263PayMB</NAME>
struct _GstRtpH263PayMB
{
  guint8 *start;
  guint8 *end;
  guint8 sbit;
  guint8 ebit;
  guint length;

  guint8 mb_type;
  guint quant;

  guint mba;
  guint8 mvd[10];
};
</STRUCT>
<STRUCT>
<NAME>GstRtpH263PayGob</NAME>
struct _GstRtpH263PayGob
{
  guint8 *start;
  guint8 *end;
  guint length;
  guint8 sbit;
  guint8 ebit;

  guint gobn;
  guint quant;

  GstRtpH263PayMB **macroblocks;
  guint nmacroblocs;
};
</STRUCT>
<STRUCT>
<NAME>GstRtpH263PayPackage</NAME>
struct _GstRtpH263PayPackage
{
  guint8 *payload_start;
  guint8 *payload_end;
  guint payload_len;
  guint8 sbit;
  guint8 ebit;
  GstBuffer *outbuf;
  gboolean marker;

  GstRtpH263PayHeaderMode mode;

  /*
   *  mode B,C data
   */

  guint16 mba;
  guint nmvd;
  guint8 mvd[10];
  guint gobn;
  guint quant;
};
</STRUCT>
<MACRO>
<NAME>GST_H263_PICTURELAYER_PLSRC</NAME>
#define GST_H263_PICTURELAYER_PLSRC(buf) (((GstRtpH263PayPic *)(buf))->ptype_srcformat)
</MACRO>
<MACRO>
<NAME>GST_H263_PICTURELAYER_PLTYPE</NAME>
#define GST_H263_PICTURELAYER_PLTYPE(buf) (((GstRtpH263PayPic *)(buf))->ptype_pictype)
</MACRO>
<MACRO>
<NAME>GST_H263_PICTURELAYER_PLUMV</NAME>
#define GST_H263_PICTURELAYER_PLUMV(buf) (((GstRtpH263PayPic *)(buf))->ptype_umvmode)
</MACRO>
<MACRO>
<NAME>GST_H263_PICTURELAYER_PLSAC</NAME>
#define GST_H263_PICTURELAYER_PLSAC(buf) (((GstRtpH263PayPic *)(buf))->ptype_sacmode)
</MACRO>
<MACRO>
<NAME>GST_H263_PICTURELAYER_PLAP</NAME>
#define GST_H263_PICTURELAYER_PLAP(buf) (((GstRtpH263PayPic *)(buf))->ptype_apmode)
</MACRO>
<MACRO>
<NAME>GST_RTP_H263_PAY_END</NAME>
#define GST_RTP_H263_PAY_END(start, len) (((guint8 *)start) + ((guint)len))
</MACRO>
<MACRO>
<NAME>GST_RTP_H263_PAY_GOBN</NAME>
#define GST_RTP_H263_PAY_GOBN(gob) (((((guint8 *) gob)[2] >> 2) & 0x1f)
</MACRO>
<FUNCTION>
<NAME>gst_rtp_h263_pay_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_rtp_h263_pay_plugin_init</NAME>
<RETURNS>gboolean  </RETURNS>
GstPlugin * plugin
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_RTP_AMR_DEPAY</NAME>
#define GST_TYPE_RTP_AMR_DEPAY \
  (gst_rtp_amr_depay_get_type())
</MACRO>
<MACRO>
<NAME>GST_RTP_AMR_DEPAY</NAME>
#define GST_RTP_AMR_DEPAY(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_RTP_AMR_DEPAY,GstRtpAMRDepay))
</MACRO>
<MACRO>
<NAME>GST_RTP_AMR_DEPAY_CLASS</NAME>
#define GST_RTP_AMR_DEPAY_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_RTP_AMR_DEPAY,GstRtpAMRDepayClass))
</MACRO>
<MACRO>
<NAME>GST_IS_RTP_AMR_DEPAY</NAME>
#define GST_IS_RTP_AMR_DEPAY(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_RTP_AMR_DEPAY))
</MACRO>
<MACRO>
<NAME>GST_IS_RTP_AMR_DEPAY_CLASS</NAME>
#define GST_IS_RTP_AMR_DEPAY_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_RTP_AMR_DEPAY))
</MACRO>
<ENUM>
<NAME>GstRtpAMRDepayMode</NAME>
typedef enum {
  GST_RTP_AMR_DP_MODE_INVALID = 0,
  GST_RTP_AMR_DP_MODE_NB      = 1,
  GST_RTP_AMR_DP_MODE_WB      = 2
} GstRtpAMRDepayMode;
</ENUM>
<STRUCT>
<NAME>GstRtpAMRDepay</NAME>
struct _GstRtpAMRDepay
{
  GstRTPBaseDepayload depayload;

  GstRtpAMRDepayMode mode;

  gboolean octet_align;
  guint8   mode_set;
  gint     mode_change_period;
  gboolean mode_change_neighbor;
  gint     maxptime;
  gboolean crc;
  gboolean robust_sorting;
  gboolean interleaving;
  gint     ptime;
  gint     channels;
};
</STRUCT>
<STRUCT>
<NAME>GstRtpAMRDepayClass</NAME>
struct _GstRtpAMRDepayClass
{
  GstRTPBaseDepayloadClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_rtp_amr_depay_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_rtp_amr_depay_plugin_init</NAME>
<RETURNS>gboolean  </RETURNS>
GstPlugin * plugin
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_RTP_L24_PAY</NAME>
#define GST_TYPE_RTP_L24_PAY \
  (gst_rtp_L24_pay_get_type())
</MACRO>
<MACRO>
<NAME>GST_RTP_L24_PAY</NAME>
#define GST_RTP_L24_PAY(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_RTP_L24_PAY,GstRtpL24Pay))
</MACRO>
<MACRO>
<NAME>GST_RTP_L24_PAY_CLASS</NAME>
#define GST_RTP_L24_PAY_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_RTP_L24_PAY,GstRtpL24PayClass))
</MACRO>
<MACRO>
<NAME>GST_IS_RTP_L24_PAY</NAME>
#define GST_IS_RTP_L24_PAY(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_RTP_L24_PAY))
</MACRO>
<MACRO>
<NAME>GST_IS_RTP_L24_PAY_CLASS</NAME>
#define GST_IS_RTP_L24_PAY_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_RTP_L24_PAY))
</MACRO>
<STRUCT>
<NAME>GstRtpL24Pay</NAME>
struct _GstRtpL24Pay
{
  GstRTPBaseAudioPayload payload;

  GstAudioInfo info;
  const GstRTPChannelOrder *order;
};
</STRUCT>
<STRUCT>
<NAME>GstRtpL24PayClass</NAME>
struct _GstRtpL24PayClass
{
  GstRTPBaseAudioPayloadClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_rtp_L24_pay_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_rtp_L24_pay_plugin_init</NAME>
<RETURNS>gboolean  </RETURNS>
GstPlugin * plugin
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_RTP_MP4G_DEPAY</NAME>
#define GST_TYPE_RTP_MP4G_DEPAY \
  (gst_rtp_mp4g_depay_get_type())
</MACRO>
<MACRO>
<NAME>GST_RTP_MP4G_DEPAY</NAME>
#define GST_RTP_MP4G_DEPAY(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_RTP_MP4G_DEPAY,GstRtpMP4GDepay))
</MACRO>
<MACRO>
<NAME>GST_RTP_MP4G_DEPAY_CLASS</NAME>
#define GST_RTP_MP4G_DEPAY_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_RTP_MP4G_DEPAY,GstRtpMP4GDepayClass))
</MACRO>
<MACRO>
<NAME>GST_IS_RTP_MP4G_DEPAY</NAME>
#define GST_IS_RTP_MP4G_DEPAY(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_RTP_MP4G_DEPAY))
</MACRO>
<MACRO>
<NAME>GST_IS_RTP_MP4G_DEPAY_CLASS</NAME>
#define GST_IS_RTP_MP4G_DEPAY_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_RTP_MP4G_DEPAY))
</MACRO>
<STRUCT>
<NAME>GstRtpMP4GDepay</NAME>
struct _GstRtpMP4GDepay
{
  GstRTPBaseDepayload depayload;

  gint profile_level_id;
  gint streamtype;

  gint constantSize;
  gint constantDuration;
  gint maxDisplacement;

  gint sizelength;
  gint indexlength;
  gint indexdeltalength;
  gint ctsdeltalength;
  gint dtsdeltalength;
  gint randomaccessindication;
  gint streamstateindication;
  gint auxiliarydatasizelength;

  guint max_AU_index;
  guint prev_AU_index;
  guint last_AU_index;
  guint next_AU_index;
  guint32 prev_rtptime;
  guint prev_AU_num;

  GQueue *packets;
  
  GstAdapter *adapter;
};
</STRUCT>
<STRUCT>
<NAME>GstRtpMP4GDepayClass</NAME>
struct _GstRtpMP4GDepayClass
{
  GstRTPBaseDepayloadClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_rtp_mp4g_depay_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_rtp_mp4g_depay_plugin_init</NAME>
<RETURNS>gboolean  </RETURNS>
GstPlugin * plugin
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_RTP_VRAW_PAY</NAME>
#define GST_TYPE_RTP_VRAW_PAY \
  (gst_rtp_vraw_pay_get_type())
</MACRO>
<MACRO>
<NAME>GST_RTP_VRAW_PAY</NAME>
#define GST_RTP_VRAW_PAY(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_RTP_VRAW_PAY,GstRtpVRawPay))
</MACRO>
<MACRO>
<NAME>GST_RTP_VRAW_PAY_CLASS</NAME>
#define GST_RTP_VRAW_PAY_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_RTP_VRAW_PAY,GstRtpVRawPayClass))
</MACRO>
<MACRO>
<NAME>GST_IS_RTP_VRAW_PAY</NAME>
#define GST_IS_RTP_VRAW_PAY(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_RTP_VRAW_PAY))
</MACRO>
<MACRO>
<NAME>GST_IS_RTP_VRAW_PAY_CLASS</NAME>
#define GST_IS_RTP_VRAW_PAY_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_RTP_VRAW_PAY))
</MACRO>
<STRUCT>
<NAME>GstRtpVRawPay</NAME>
struct _GstRtpVRawPay
{
  GstRTPBasePayload payload;

  GstVideoInfo vinfo;

  gint pgroup;
  gint xinc, yinc;

  /* properties */
  guint chunks_per_frame;
};
</STRUCT>
<STRUCT>
<NAME>GstRtpVRawPayClass</NAME>
struct _GstRtpVRawPayClass
{
  GstRTPBasePayloadClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_rtp_vraw_pay_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_rtp_vraw_pay_plugin_init</NAME>
<RETURNS>gboolean  </RETURNS>
GstPlugin * plugin
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_RTP_G726_DEPAY</NAME>
#define GST_TYPE_RTP_G726_DEPAY \
  (gst_rtp_g726_depay_get_type())
</MACRO>
<MACRO>
<NAME>GST_RTP_G726_DEPAY</NAME>
#define GST_RTP_G726_DEPAY(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_RTP_G726_DEPAY,GstRtpG726Depay))
</MACRO>
<MACRO>
<NAME>GST_RTP_G726_DEPAY_CLASS</NAME>
#define GST_RTP_G726_DEPAY_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_RTP_G726_DEPAY,GstRtpG726DepayClass))
</MACRO>
<MACRO>
<NAME>GST_IS_RTP_G726_DEPAY</NAME>
#define GST_IS_RTP_G726_DEPAY(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_RTP_G726_DEPAY))
</MACRO>
<MACRO>
<NAME>GST_IS_RTP_G726_DEPAY_CLASS</NAME>
#define GST_IS_RTP_G726_DEPAY_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_RTP_G726_DEPAY))
</MACRO>
<STRUCT>
<NAME>GstRtpG726Depay</NAME>
struct _GstRtpG726Depay
{
  GstRTPBaseDepayload depayload;

  gboolean aal2;
  gboolean force_aal2;
  gint bitrate;
  guint block_align;
};
</STRUCT>
<STRUCT>
<NAME>GstRtpG726DepayClass</NAME>
struct _GstRtpG726DepayClass
{
  GstRTPBaseDepayloadClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_rtp_g726_depay_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_rtp_g726_depay_plugin_init</NAME>
<RETURNS>gboolean  </RETURNS>
GstPlugin * plugin
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_RTP_KLV_PAY</NAME>
#define GST_TYPE_RTP_KLV_PAY \
  (gst_rtp_klv_pay_get_type())
</MACRO>
<MACRO>
<NAME>GST_RTP_KLV_PAY</NAME>
#define GST_RTP_KLV_PAY(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_RTP_KLV_PAY,GstRtpKlvPay))
</MACRO>
<MACRO>
<NAME>GST_RTP_KLV_PAY_CLASS</NAME>
#define GST_RTP_KLV_PAY_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_RTP_KLV_PAY,GstRtpKlvPayClass))
</MACRO>
<MACRO>
<NAME>GST_IS_RTP_KLV_PAY</NAME>
#define GST_IS_RTP_KLV_PAY(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_RTP_KLV_PAY))
</MACRO>
<MACRO>
<NAME>GST_IS_RTP_KLV_PAY_CLASS</NAME>
#define GST_IS_RTP_KLV_PAY_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_RTP_KLV_PAY))
</MACRO>
<STRUCT>
<NAME>GstRtpKlvPay</NAME>
struct _GstRtpKlvPay
{
  GstRTPBasePayload rtpbasepayload;
};
</STRUCT>
<STRUCT>
<NAME>GstRtpKlvPayClass</NAME>
struct _GstRtpKlvPayClass
{
  GstRTPBasePayloadClass rtpbasepayload_class;
};
</STRUCT>
<MACRO>
<NAME>GST_TYPE_RTP_MP4V_PAY</NAME>
#define GST_TYPE_RTP_MP4V_PAY \
  (gst_rtp_mp4v_pay_get_type())
</MACRO>
<MACRO>
<NAME>GST_RTP_MP4V_PAY</NAME>
#define GST_RTP_MP4V_PAY(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_RTP_MP4V_PAY,GstRtpMP4VPay))
</MACRO>
<MACRO>
<NAME>GST_RTP_MP4V_PAY_CLASS</NAME>
#define GST_RTP_MP4V_PAY_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_RTP_MP4V_PAY,GstRtpMP4VPayClass))
</MACRO>
<MACRO>
<NAME>GST_IS_RTP_MP4V_PAY</NAME>
#define GST_IS_RTP_MP4V_PAY(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_RTP_MP4V_PAY))
</MACRO>
<MACRO>
<NAME>GST_IS_RTP_MP4V_PAY_CLASS</NAME>
#define GST_IS_RTP_MP4V_PAY_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_RTP_MP4V_PAY))
</MACRO>
<STRUCT>
<NAME>GstRtpMP4VPay</NAME>
struct _GstRtpMP4VPay
{
  GstRTPBasePayload    payload;

  GstAdapter   *adapter;
  GstClockTime  first_timestamp;
  GstClockTime  duration;

  gint          rate;
  gint          profile;
  GstBuffer    *config;
  gboolean      send_config;
  gboolean      need_config;

  /* naming might be confusing with send_config; but naming matches h264
   * payloader */
  guint         config_interval;
  GstClockTime  last_config;
};
</STRUCT>
<STRUCT>
<NAME>GstRtpMP4VPayClass</NAME>
struct _GstRtpMP4VPayClass
{
  GstRTPBasePayloadClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_rtp_mp4v_pay_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_rtp_mp4v_pay_plugin_init</NAME>
<RETURNS>gboolean  </RETURNS>
GstPlugin * plugin
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_RTP_SBC_PAY</NAME>
#define GST_TYPE_RTP_SBC_PAY \
	(gst_rtp_sbc_pay_get_type())
</MACRO>
<MACRO>
<NAME>GST_RTP_SBC_PAY</NAME>
#define GST_RTP_SBC_PAY(obj) \
	(G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_RTP_SBC_PAY,\
		GstRtpSBCPay))
</MACRO>
<MACRO>
<NAME>GST_RTP_SBC_PAY_CLASS</NAME>
#define GST_RTP_SBC_PAY_CLASS(klass) \
	(G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_RTP_SBC_PAY,\
		GstRtpSBCPayClass))
</MACRO>
<MACRO>
<NAME>GST_IS_RTP_SBC_PAY</NAME>
#define GST_IS_RTP_SBC_PAY(obj) \
	(G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_RTP_SBC_PAY))
</MACRO>
<MACRO>
<NAME>GST_IS_RTP_SBC_PAY_CLASS</NAME>
#define GST_IS_RTP_SBC_PAY_CLASS(obj) \
	(G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_RTP_SBC_PAY))
</MACRO>
<STRUCT>
<NAME>GstRtpSBCPay</NAME>
struct _GstRtpSBCPay {
	GstRTPBasePayload base;

	GstAdapter *adapter;
	GstClockTime last_timestamp;

	guint frame_length;
        GstClockTime frame_duration;

	guint min_frames;
};
</STRUCT>
<STRUCT>
<NAME>GstRtpSBCPayClass</NAME>
struct _GstRtpSBCPayClass {
	GstRTPBasePayloadClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_rtp_sbc_pay_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_rtp_sbc_pay_plugin_init</NAME>
<RETURNS>gboolean  </RETURNS>
GstPlugin * plugin
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_RTP_STREAM_DEPAY</NAME>
#define GST_TYPE_RTP_STREAM_DEPAY \
  (gst_rtp_stream_depay_get_type())
</MACRO>
<MACRO>
<NAME>GST_RTP_STREAM_DEPAY</NAME>
#define GST_RTP_STREAM_DEPAY(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_RTP_STREAM_DEPAY,GstRtpStreamDepay))
</MACRO>
<MACRO>
<NAME>GST_RTP_STREAM_DEPAY_CLASS</NAME>
#define GST_RTP_STREAM_DEPAY_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_RTP_STREAM_DEPAY,GstRtpStreamDepayClass))
</MACRO>
<MACRO>
<NAME>GST_IS_RTP_STREAM_DEPAY</NAME>
#define GST_IS_RTP_STREAM_DEPAY(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_RTP_STREAM_DEPAY))
</MACRO>
<MACRO>
<NAME>GST_IS_RTP_STREAM_DEPAY_CLASS</NAME>
#define GST_IS_RTP_STREAM_DEPAY_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_RTP_STREAM_DEPAY))
</MACRO>
<STRUCT>
<NAME>GstRtpStreamDepay</NAME>
struct _GstRtpStreamDepay
{
  GstBaseParse parent;
};
</STRUCT>
<STRUCT>
<NAME>GstRtpStreamDepayClass</NAME>
struct _GstRtpStreamDepayClass
{
  GstBaseParseClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_rtp_stream_depay_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_rtp_stream_depay_plugin_init</NAME>
<RETURNS>gboolean  </RETURNS>
GstPlugin * plugin
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_RTP_CELT_DEPAY</NAME>
#define GST_TYPE_RTP_CELT_DEPAY \
  (gst_rtp_celt_depay_get_type())
</MACRO>
<MACRO>
<NAME>GST_RTP_CELT_DEPAY</NAME>
#define GST_RTP_CELT_DEPAY(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_RTP_CELT_DEPAY,GstRtpCELTDepay))
</MACRO>
<MACRO>
<NAME>GST_RTP_CELT_DEPAY_CLASS</NAME>
#define GST_RTP_CELT_DEPAY_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_RTP_CELT_DEPAY,GstRtpCELTDepayClass))
</MACRO>
<MACRO>
<NAME>GST_IS_RTP_CELT_DEPAY</NAME>
#define GST_IS_RTP_CELT_DEPAY(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_RTP_CELT_DEPAY))
</MACRO>
<MACRO>
<NAME>GST_IS_RTP_CELT_DEPAY_CLASS</NAME>
#define GST_IS_RTP_CELT_DEPAY_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_RTP_CELT_DEPAY))
</MACRO>
<STRUCT>
<NAME>GstRtpCELTDepay</NAME>
struct _GstRtpCELTDepay
{
  GstRTPBaseDepayload depayload;
  gint frame_size;
};
</STRUCT>
<STRUCT>
<NAME>GstRtpCELTDepayClass</NAME>
struct _GstRtpCELTDepayClass
{
  GstRTPBaseDepayloadClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_rtp_celt_depay_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_rtp_celt_depay_plugin_init</NAME>
<RETURNS>gboolean  </RETURNS>
GstPlugin * plugin
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_RTP_MP1S_DEPAY</NAME>
#define GST_TYPE_RTP_MP1S_DEPAY \
  (gst_rtp_mp1s_depay_get_type())
</MACRO>
<MACRO>
<NAME>GST_RTP_MP1S_DEPAY</NAME>
#define GST_RTP_MP1S_DEPAY(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_RTP_MP1S_DEPAY,GstRtpMP1SDepay))
</MACRO>
<MACRO>
<NAME>GST_RTP_MP1S_DEPAY_CLASS</NAME>
#define GST_RTP_MP1S_DEPAY_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_RTP_MP1S_DEPAY,GstRtpMP1SDepayClass))
</MACRO>
<MACRO>
<NAME>GST_IS_RTP_MP1S_DEPAY</NAME>
#define GST_IS_RTP_MP1S_DEPAY(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_RTP_MP1S_DEPAY))
</MACRO>
<MACRO>
<NAME>GST_IS_RTP_MP1S_DEPAY_CLASS</NAME>
#define GST_IS_RTP_MP1S_DEPAY_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_RTP_MP1S_DEPAY))
</MACRO>
<STRUCT>
<NAME>GstRtpMP1SDepay</NAME>
struct _GstRtpMP1SDepay
{
  GstRTPBaseDepayload depayload;
};
</STRUCT>
<STRUCT>
<NAME>GstRtpMP1SDepayClass</NAME>
struct _GstRtpMP1SDepayClass
{
  GstRTPBaseDepayloadClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_rtp_mp1s_depay_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_rtp_mp1s_depay_plugin_init</NAME>
<RETURNS>gboolean  </RETURNS>
GstPlugin * plugin
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_RTP_MP4A_DEPAY</NAME>
#define GST_TYPE_RTP_MP4A_DEPAY \
  (gst_rtp_mp4a_depay_get_type())
</MACRO>
<MACRO>
<NAME>GST_RTP_MP4A_DEPAY</NAME>
#define GST_RTP_MP4A_DEPAY(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_RTP_MP4A_DEPAY,GstRtpMP4ADepay))
</MACRO>
<MACRO>
<NAME>GST_RTP_MP4A_DEPAY_CLASS</NAME>
#define GST_RTP_MP4A_DEPAY_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_RTP_MP4A_DEPAY,GstRtpMP4ADepayClass))
</MACRO>
<MACRO>
<NAME>GST_IS_RTP_MP4A_DEPAY</NAME>
#define GST_IS_RTP_MP4A_DEPAY(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_RTP_MP4A_DEPAY))
</MACRO>
<MACRO>
<NAME>GST_IS_RTP_MP4A_DEPAY_CLASS</NAME>
#define GST_IS_RTP_MP4A_DEPAY_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_RTP_MP4A_DEPAY))
</MACRO>
<STRUCT>
<NAME>GstRtpMP4ADepay</NAME>
struct _GstRtpMP4ADepay
{
  GstRTPBaseDepayload depayload;
  GstAdapter *adapter;
  guint8 numSubFrames;
  guint frame_len;

  gboolean framed;
};
</STRUCT>
<STRUCT>
<NAME>GstRtpMP4ADepayClass</NAME>
struct _GstRtpMP4ADepayClass
{
  GstRTPBaseDepayloadClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_rtp_mp4a_depay_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_rtp_mp4a_depay_plugin_init</NAME>
<RETURNS>gboolean  </RETURNS>
GstPlugin * plugin
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_RTP_GST_DEPAY</NAME>
#define GST_TYPE_RTP_GST_DEPAY \
  (gst_rtp_gst_depay_get_type())
</MACRO>
<MACRO>
<NAME>GST_RTP_GST_DEPAY</NAME>
#define GST_RTP_GST_DEPAY(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_RTP_GST_DEPAY,GstRtpGSTDepay))
</MACRO>
<MACRO>
<NAME>GST_RTP_GST_DEPAY_CLASS</NAME>
#define GST_RTP_GST_DEPAY_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_RTP_GST_DEPAY,GstRtpGSTDepayClass))
</MACRO>
<MACRO>
<NAME>GST_IS_RTP_GST_DEPAY</NAME>
#define GST_IS_RTP_GST_DEPAY(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_RTP_GST_DEPAY))
</MACRO>
<MACRO>
<NAME>GST_IS_RTP_GST_DEPAY_CLASS</NAME>
#define GST_IS_RTP_GST_DEPAY_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_RTP_GST_DEPAY))
</MACRO>
<STRUCT>
<NAME>GstRtpGSTDepay</NAME>
struct _GstRtpGSTDepay
{
  GstRTPBaseDepayload depayload;

  GstAdapter *adapter;
  guint current_CV;
  GstCaps *CV_cache[8];

  GstTagList *tags;
  gchar *stream_id;
};
</STRUCT>
<STRUCT>
<NAME>GstRtpGSTDepayClass</NAME>
struct _GstRtpGSTDepayClass
{
  GstRTPBaseDepayloadClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_rtp_gst_depay_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_rtp_gst_depay_plugin_init</NAME>
<RETURNS>gboolean  </RETURNS>
GstPlugin * plugin
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_RTP_G722_DEPAY</NAME>
#define GST_TYPE_RTP_G722_DEPAY \
  (gst_rtp_g722_depay_get_type())
</MACRO>
<MACRO>
<NAME>GST_RTP_G722_DEPAY</NAME>
#define GST_RTP_G722_DEPAY(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_RTP_G722_DEPAY,GstRtpG722Depay))
</MACRO>
<MACRO>
<NAME>GST_RTP_G722_DEPAY_CLASS</NAME>
#define GST_RTP_G722_DEPAY_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_RTP_G722_DEPAY,GstRtpG722DepayClass))
</MACRO>
<MACRO>
<NAME>GST_IS_RTP_G722_DEPAY</NAME>
#define GST_IS_RTP_G722_DEPAY(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_RTP_G722_DEPAY))
</MACRO>
<MACRO>
<NAME>GST_IS_RTP_G722_DEPAY_CLASS</NAME>
#define GST_IS_RTP_G722_DEPAY_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_RTP_G722_DEPAY))
</MACRO>
<STRUCT>
<NAME>GstRtpG722Depay</NAME>
struct _GstRtpG722Depay
{
  GstRTPBaseDepayload depayload;

  guint rate;
  guint channels;
};
</STRUCT>
<STRUCT>
<NAME>GstRtpG722DepayClass</NAME>
struct _GstRtpG722DepayClass
{
  GstRTPBaseDepayloadClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_rtp_g722_depay_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_rtp_g722_depay_plugin_init</NAME>
<RETURNS>gboolean  </RETURNS>
GstPlugin * plugin
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_RTP_SBC_DEPAY</NAME>
#define GST_TYPE_RTP_SBC_DEPAY \
	(gst_rtp_sbc_depay_get_type())
</MACRO>
<MACRO>
<NAME>GST_RTP_SBC_DEPAY</NAME>
#define GST_RTP_SBC_DEPAY(obj) \
	(G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_RTP_SBC_DEPAY,\
		GstRtpSbcDepay))
</MACRO>
<MACRO>
<NAME>GST_RTP_SBC_DEPAY_CLASS</NAME>
#define GST_RTP_SBC_DEPAY_CLASS(klass) \
	(G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_RTP_SBC_DEPAY,\
		GstRtpSbcDepayClass))
</MACRO>
<MACRO>
<NAME>GST_IS_RTP_SBC_DEPAY</NAME>
#define GST_IS_RTP_SBC_DEPAY(obj) \
	(G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_RTP_SBC_DEPAY))
</MACRO>
<MACRO>
<NAME>GST_IS_RTP_SBC_DEPAY_CLASS</NAME>
#define GST_IS_RTP_SBC_DEPAY_CLASS(obj) \
	(G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_RTP_SBC_DEPAY))
</MACRO>
<STRUCT>
<NAME>GstRtpSbcDepay</NAME>
struct _GstRtpSbcDepay
{
  GstRTPBaseDepayload base;

  int rate;
  GstAdapter *adapter;
};
</STRUCT>
<STRUCT>
<NAME>GstRtpSbcDepayClass</NAME>
struct _GstRtpSbcDepayClass
{
  GstRTPBaseDepayloadClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_rtp_sbc_depay_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_rtp_sbc_depay_plugin_init</NAME>
<RETURNS>gboolean  </RETURNS>
GstPlugin * plugin
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_RTP_H263_DEPAY</NAME>
#define GST_TYPE_RTP_H263_DEPAY \
  (gst_rtp_h263_depay_get_type())
</MACRO>
<MACRO>
<NAME>GST_RTP_H263_DEPAY</NAME>
#define GST_RTP_H263_DEPAY(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_RTP_H263_DEPAY,GstRtpH263Depay))
</MACRO>
<MACRO>
<NAME>GST_RTP_H263_DEPAY_CLASS</NAME>
#define GST_RTP_H263_DEPAY_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_RTP_H263_DEPAY,GstRtpH263DepayClass))
</MACRO>
<MACRO>
<NAME>GST_IS_RTP_H263_DEPAY</NAME>
#define GST_IS_RTP_H263_DEPAY(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_RTP_H263_DEPAY))
</MACRO>
<MACRO>
<NAME>GST_IS_RTP_H263_DEPAY_CLASS</NAME>
#define GST_IS_RTP_H263_DEPAY_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_RTP_H263_DEPAY))
</MACRO>
<STRUCT>
<NAME>GstRtpH263Depay</NAME>
struct _GstRtpH263Depay
{
  GstRTPBaseDepayload depayload;

  guint8 offset;	/* offset to apply to next payload */
  guint8 leftover;	/* leftover from previous payload (if offset != 0) */
  gboolean psc_I;       /* Picture-Coding-Type == I from Picture Start Code packet */
  GstAdapter *adapter;
  gboolean start;
};
</STRUCT>
<STRUCT>
<NAME>GstRtpH263DepayClass</NAME>
struct _GstRtpH263DepayClass
{
  GstRTPBaseDepayloadClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_rtp_h263_depay_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_rtp_h263_depay_plugin_init</NAME>
<RETURNS>gboolean  </RETURNS>
GstPlugin * plugin
</FUNCTION>
<ENUM>
<NAME>GstH265NalUnitType</NAME>
typedef enum
{
  GST_H265_NAL_SLICE_TRAIL_N    = 0,
  GST_H265_NAL_SLICE_TRAIL_R    = 1,
  GST_H265_NAL_SLICE_TSA_N      = 2,
  GST_H265_NAL_SLICE_TSA_R      = 3,
  GST_H265_NAL_SLICE_STSA_N     = 4,
  GST_H265_NAL_SLICE_STSA_R     = 5,
  GST_H265_NAL_SLICE_RADL_N     = 6,
  GST_H265_NAL_SLICE_RADL_R     = 7,
  GST_H265_NAL_SLICE_RASL_N     = 8,
  GST_H265_NAL_SLICE_RASL_R     = 9,
  GST_H265_NAL_SLICE_BLA_W_LP   = 16,
  GST_H265_NAL_SLICE_BLA_W_RADL = 17,
  GST_H265_NAL_SLICE_BLA_N_LP   = 18,
  GST_H265_NAL_SLICE_IDR_W_RADL = 19,
  GST_H265_NAL_SLICE_IDR_N_LP   = 20,
  GST_H265_NAL_SLICE_CRA_NUT    = 21,
  GST_H265_NAL_VPS              = 32,
  GST_H265_NAL_SPS              = 33,
  GST_H265_NAL_PPS              = 34,
  GST_H265_NAL_AUD              = 35,
  GST_H265_NAL_EOS              = 36,
  GST_H265_NAL_EOB              = 37,
  GST_H265_NAL_FD               = 38,
  GST_H265_NAL_PREFIX_SEI       = 39,
  GST_H265_NAL_SUFFIX_SEI       = 40
} GstH265NalUnitType;
</ENUM>
<MACRO>
<NAME>RESERVED_NON_IRAP_SUBLAYER_NAL_TYPE_MIN</NAME>
#define RESERVED_NON_IRAP_SUBLAYER_NAL_TYPE_MIN 10
</MACRO>
<MACRO>
<NAME>RESERVED_NON_IRAP_SUBLAYER_NAL_TYPE_MAX</NAME>
#define RESERVED_NON_IRAP_SUBLAYER_NAL_TYPE_MAX 15
</MACRO>
<MACRO>
<NAME>RESERVED_IRAP_NAL_TYPE_MIN</NAME>
#define RESERVED_IRAP_NAL_TYPE_MIN 22
</MACRO>
<MACRO>
<NAME>RESERVED_IRAP_NAL_TYPE_MAX</NAME>
#define RESERVED_IRAP_NAL_TYPE_MAX 23
</MACRO>
<MACRO>
<NAME>RESERVED_NON_IRAP_NAL_TYPE_MIN</NAME>
#define RESERVED_NON_IRAP_NAL_TYPE_MIN 24
</MACRO>
<MACRO>
<NAME>RESERVED_NON_IRAP_NAL_TYPE_MAX</NAME>
#define RESERVED_NON_IRAP_NAL_TYPE_MAX 31
</MACRO>
<MACRO>
<NAME>RESERVED_NON_VCL_NAL_TYPE_MIN</NAME>
#define RESERVED_NON_VCL_NAL_TYPE_MIN 41
</MACRO>
<MACRO>
<NAME>RESERVED_NON_VCL_NAL_TYPE_MAX</NAME>
#define RESERVED_NON_VCL_NAL_TYPE_MAX 47
</MACRO>
<MACRO>
<NAME>UNSPECIFIED_NON_VCL_NAL_TYPE_MIN</NAME>
#define UNSPECIFIED_NON_VCL_NAL_TYPE_MIN 48
</MACRO>
<MACRO>
<NAME>UNSPECIFIED_NON_VCL_NAL_TYPE_MAX</NAME>
#define UNSPECIFIED_NON_VCL_NAL_TYPE_MAX 63
</MACRO>
<TYPEDEF>
<NAME>orc_int8</NAME>
typedef int8_t orc_int8;
</TYPEDEF>
<TYPEDEF>
<NAME>orc_int16</NAME>
typedef int16_t orc_int16;
</TYPEDEF>
<TYPEDEF>
<NAME>orc_int32</NAME>
typedef int32_t orc_int32;
</TYPEDEF>
<TYPEDEF>
<NAME>orc_int64</NAME>
typedef int64_t orc_int64;
</TYPEDEF>
<TYPEDEF>
<NAME>orc_uint8</NAME>
typedef uint8_t orc_uint8;
</TYPEDEF>
<TYPEDEF>
<NAME>orc_uint16</NAME>
typedef uint16_t orc_uint16;
</TYPEDEF>
<TYPEDEF>
<NAME>orc_uint32</NAME>
typedef uint32_t orc_uint32;
</TYPEDEF>
<TYPEDEF>
<NAME>orc_uint64</NAME>
typedef uint64_t orc_uint64;
</TYPEDEF>
<MACRO>
<NAME>ORC_UINT64_C</NAME>
#define ORC_UINT64_C(x) UINT64_C(x)
</MACRO>
<MACRO>
<NAME>inline</NAME>
#define inline __inline
</MACRO>
<MACRO>
<NAME>BUILD_X86_ASM</NAME>
#define BUILD_X86_ASM
</MACRO>
<MACRO>
<NAME>GST_TYPE_DEINTERLACE_METHOD</NAME>
#define GST_TYPE_DEINTERLACE_METHOD		(gst_deinterlace_method_get_type ())
</MACRO>
<MACRO>
<NAME>GST_IS_DEINTERLACE_METHOD</NAME>
#define GST_IS_DEINTERLACE_METHOD(obj)		(G_TYPE_CHECK_INSTANCE_TYPE ((obj), GST_TYPE_DEINTERLACE_METHOD))
</MACRO>
<MACRO>
<NAME>GST_IS_DEINTERLACE_METHOD_CLASS</NAME>
#define GST_IS_DEINTERLACE_METHOD_CLASS(klass)	(G_TYPE_CHECK_CLASS_TYPE ((klass), GST_TYPE_DEINTERLACE_METHOD))
</MACRO>
<MACRO>
<NAME>GST_DEINTERLACE_METHOD_GET_CLASS</NAME>
#define GST_DEINTERLACE_METHOD_GET_CLASS(obj)	(G_TYPE_INSTANCE_GET_CLASS ((obj), GST_TYPE_DEINTERLACE_METHOD, GstDeinterlaceMethodClass))
</MACRO>
<MACRO>
<NAME>GST_DEINTERLACE_METHOD</NAME>
#define GST_DEINTERLACE_METHOD(obj)		(G_TYPE_CHECK_INSTANCE_CAST ((obj), GST_TYPE_DEINTERLACE_METHOD, GstDeinterlaceMethod))
</MACRO>
<MACRO>
<NAME>GST_DEINTERLACE_METHOD_CLASS</NAME>
#define GST_DEINTERLACE_METHOD_CLASS(klass)	(G_TYPE_CHECK_CLASS_CAST ((klass), GST_TYPE_DEINTERLACE_METHOD, GstDeinterlaceMethodClass))
</MACRO>
<MACRO>
<NAME>GST_DEINTERLACE_METHOD_CAST</NAME>
#define GST_DEINTERLACE_METHOD_CAST(obj)	((GstDeinterlaceMethod*)(obj))
</MACRO>
<MACRO>
<NAME>PICTURE_PROGRESSIVE</NAME>
#define PICTURE_PROGRESSIVE 0
</MACRO>
<MACRO>
<NAME>PICTURE_INTERLACED_BOTTOM</NAME>
#define PICTURE_INTERLACED_BOTTOM 1
</MACRO>
<MACRO>
<NAME>PICTURE_INTERLACED_TOP</NAME>
#define PICTURE_INTERLACED_TOP 2
</MACRO>
<MACRO>
<NAME>PICTURE_INTERLACED_MASK</NAME>
#define PICTURE_INTERLACED_MASK (PICTURE_INTERLACED_BOTTOM | PICTURE_INTERLACED_TOP)
</MACRO>
<USER_FUNCTION>
<NAME>GstDeinterlaceMethodDeinterlaceFunction</NAME>
<RETURNS>void </RETURNS>

    GstDeinterlaceMethod *self, const GstDeinterlaceField *history,
    guint history_count, GstVideoFrame *outframe, int cur_field_idx
</USER_FUNCTION>
<STRUCT>
<NAME>GstDeinterlaceMethod</NAME>
struct _GstDeinterlaceMethod {
  GstObject parent;

  GstVideoInfo *vinfo;

  GstDeinterlaceMethodDeinterlaceFunction deinterlace_frame;
};
</STRUCT>
<STRUCT>
<NAME>GstDeinterlaceMethodClass</NAME>
struct _GstDeinterlaceMethodClass {
  GstObjectClass parent_class;
  guint fields_required;
  guint latency;

  gboolean (*supported) (GstDeinterlaceMethodClass *klass, GstVideoFormat format, gint width, gint height);

  void (*setup) (GstDeinterlaceMethod *self, GstVideoInfo * vinfo);

  GstDeinterlaceMethodDeinterlaceFunction deinterlace_frame_yuy2;
  GstDeinterlaceMethodDeinterlaceFunction deinterlace_frame_yvyu;
  GstDeinterlaceMethodDeinterlaceFunction deinterlace_frame_uyvy;
  GstDeinterlaceMethodDeinterlaceFunction deinterlace_frame_i420;
  GstDeinterlaceMethodDeinterlaceFunction deinterlace_frame_yv12;
  GstDeinterlaceMethodDeinterlaceFunction deinterlace_frame_y444;
  GstDeinterlaceMethodDeinterlaceFunction deinterlace_frame_y42b;
  GstDeinterlaceMethodDeinterlaceFunction deinterlace_frame_y41b;
  GstDeinterlaceMethodDeinterlaceFunction deinterlace_frame_ayuv;
  GstDeinterlaceMethodDeinterlaceFunction deinterlace_frame_nv12;
  GstDeinterlaceMethodDeinterlaceFunction deinterlace_frame_nv21;
  GstDeinterlaceMethodDeinterlaceFunction deinterlace_frame_argb;
  GstDeinterlaceMethodDeinterlaceFunction deinterlace_frame_abgr;
  GstDeinterlaceMethodDeinterlaceFunction deinterlace_frame_rgba;
  GstDeinterlaceMethodDeinterlaceFunction deinterlace_frame_bgra;
  GstDeinterlaceMethodDeinterlaceFunction deinterlace_frame_rgb;
  GstDeinterlaceMethodDeinterlaceFunction deinterlace_frame_bgr;

  const gchar *name;
  const gchar *nick;
};
</STRUCT>
<FUNCTION>
<NAME>gst_deinterlace_method_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_deinterlace_method_supported</NAME>
<RETURNS>gboolean  </RETURNS>
GType type, GstVideoFormat format, gint width, gint height
</FUNCTION>
<FUNCTION>
<NAME>gst_deinterlace_method_setup</NAME>
<RETURNS>void  </RETURNS>
GstDeinterlaceMethod * self, GstVideoInfo * vinfo
</FUNCTION>
<FUNCTION>
<NAME>gst_deinterlace_method_deinterlace_frame</NAME>
<RETURNS>void  </RETURNS>
GstDeinterlaceMethod * self, const GstDeinterlaceField * history, guint history_count, GstVideoFrame * outframe, int cur_field_idx
</FUNCTION>
<FUNCTION>
<NAME>gst_deinterlace_method_get_fields_required</NAME>
<RETURNS>gint  </RETURNS>
GstDeinterlaceMethod * self
</FUNCTION>
<FUNCTION>
<NAME>gst_deinterlace_method_get_latency</NAME>
<RETURNS>gint  </RETURNS>
GstDeinterlaceMethod * self
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_DEINTERLACE_SIMPLE_METHOD</NAME>
#define GST_TYPE_DEINTERLACE_SIMPLE_METHOD		(gst_deinterlace_simple_method_get_type ())
</MACRO>
<MACRO>
<NAME>GST_IS_DEINTERLACE_SIMPLE_METHOD</NAME>
#define GST_IS_DEINTERLACE_SIMPLE_METHOD(obj)		(G_TYPE_CHECK_INSTANCE_TYPE ((obj), GST_TYPE_DEINTERLACE_SIMPLE_METHOD))
</MACRO>
<MACRO>
<NAME>GST_IS_DEINTERLACE_SIMPLE_METHOD_CLASS</NAME>
#define GST_IS_DEINTERLACE_SIMPLE_METHOD_CLASS(klass)	(G_TYPE_CHECK_CLASS_TYPE ((klass), GST_TYPE_DEINTERLACE_SIMPLE_METHOD))
</MACRO>
<MACRO>
<NAME>GST_DEINTERLACE_SIMPLE_METHOD_GET_CLASS</NAME>
#define GST_DEINTERLACE_SIMPLE_METHOD_GET_CLASS(obj)	(G_TYPE_INSTANCE_GET_CLASS ((obj), GST_TYPE_DEINTERLACE_SIMPLE_METHOD, GstDeinterlaceSimpleMethodClass))
</MACRO>
<MACRO>
<NAME>GST_DEINTERLACE_SIMPLE_METHOD</NAME>
#define GST_DEINTERLACE_SIMPLE_METHOD(obj)		(G_TYPE_CHECK_INSTANCE_CAST ((obj), GST_TYPE_DEINTERLACE_SIMPLE_METHOD, GstDeinterlaceSimpleMethod))
</MACRO>
<MACRO>
<NAME>GST_DEINTERLACE_SIMPLE_METHOD_CLASS</NAME>
#define GST_DEINTERLACE_SIMPLE_METHOD_CLASS(klass)	(G_TYPE_CHECK_CLASS_CAST ((klass), GST_TYPE_DEINTERLACE_SIMPLE_METHOD, GstDeinterlaceSimpleMethodClass))
</MACRO>
<MACRO>
<NAME>GST_DEINTERLACE_SIMPLE_METHOD_CAST</NAME>
#define GST_DEINTERLACE_SIMPLE_METHOD_CAST(obj)	((GstDeinterlaceSimpleMethod*)(obj))
</MACRO>
<STRUCT>
<NAME>GstDeinterlaceScanlineData</NAME>
struct _GstDeinterlaceScanlineData {
 const guint8 *ttp, *tp, *mp, *bp, *bbp;
 const guint8 *tt0, *t0, *m0, *b0, *bb0;
 const guint8 *tt1, *t1, *m1, *b1, *bb1;
 const guint8 *tt2, *t2, *m2, *b2, *bb2;
 gboolean bottom_field;
};
</STRUCT>
<USER_FUNCTION>
<NAME>GstDeinterlaceSimpleMethodFunction</NAME>
<RETURNS>void </RETURNS>
GstDeinterlaceSimpleMethod *self, guint8 *out, const GstDeinterlaceScanlineData *scanlines, guint size
</USER_FUNCTION>
<STRUCT>
<NAME>GstDeinterlaceSimpleMethod</NAME>
struct _GstDeinterlaceSimpleMethod {
  GstDeinterlaceMethod parent;

  GstDeinterlaceSimpleMethodFunction interpolate_scanline_packed;
  GstDeinterlaceSimpleMethodFunction copy_scanline_packed;

  GstDeinterlaceSimpleMethodFunction interpolate_scanline_planar[3];
  GstDeinterlaceSimpleMethodFunction copy_scanline_planar[3];
};
</STRUCT>
<STRUCT>
<NAME>GstDeinterlaceSimpleMethodClass</NAME>
struct _GstDeinterlaceSimpleMethodClass {
  GstDeinterlaceMethodClass parent_class;

  /* Packed formats */
  GstDeinterlaceSimpleMethodFunction interpolate_scanline_yuy2;
  GstDeinterlaceSimpleMethodFunction copy_scanline_yuy2;
  GstDeinterlaceSimpleMethodFunction interpolate_scanline_yvyu;
  GstDeinterlaceSimpleMethodFunction copy_scanline_yvyu;
  GstDeinterlaceSimpleMethodFunction interpolate_scanline_uyvy;
  GstDeinterlaceSimpleMethodFunction copy_scanline_uyvy;
  GstDeinterlaceSimpleMethodFunction interpolate_scanline_ayuv;
  GstDeinterlaceSimpleMethodFunction copy_scanline_ayuv;
  GstDeinterlaceSimpleMethodFunction interpolate_scanline_argb;
  GstDeinterlaceSimpleMethodFunction copy_scanline_argb;
  GstDeinterlaceSimpleMethodFunction interpolate_scanline_abgr;
  GstDeinterlaceSimpleMethodFunction copy_scanline_abgr;
  GstDeinterlaceSimpleMethodFunction interpolate_scanline_rgba;
  GstDeinterlaceSimpleMethodFunction copy_scanline_rgba;
  GstDeinterlaceSimpleMethodFunction interpolate_scanline_bgra;
  GstDeinterlaceSimpleMethodFunction copy_scanline_bgra;
  GstDeinterlaceSimpleMethodFunction interpolate_scanline_rgb;
  GstDeinterlaceSimpleMethodFunction copy_scanline_rgb;
  GstDeinterlaceSimpleMethodFunction interpolate_scanline_bgr;
  GstDeinterlaceSimpleMethodFunction copy_scanline_bgr;

  /* Semi-planar formats */
  GstDeinterlaceSimpleMethodFunction interpolate_scanline_nv12;
  GstDeinterlaceSimpleMethodFunction copy_scanline_nv12;
  GstDeinterlaceSimpleMethodFunction interpolate_scanline_nv21;
  GstDeinterlaceSimpleMethodFunction copy_scanline_nv21;

  /* Planar formats */
  GstDeinterlaceSimpleMethodFunction copy_scanline_planar_y;
  GstDeinterlaceSimpleMethodFunction interpolate_scanline_planar_y;
  GstDeinterlaceSimpleMethodFunction copy_scanline_planar_u;
  GstDeinterlaceSimpleMethodFunction interpolate_scanline_planar_u;
  GstDeinterlaceSimpleMethodFunction copy_scanline_planar_v;
  GstDeinterlaceSimpleMethodFunction interpolate_scanline_planar_v;
};
</STRUCT>
<FUNCTION>
<NAME>gst_deinterlace_simple_method_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<TYPEDEF>
<NAME>orc_int8</NAME>
typedef int8_t orc_int8;
</TYPEDEF>
<TYPEDEF>
<NAME>orc_int16</NAME>
typedef int16_t orc_int16;
</TYPEDEF>
<TYPEDEF>
<NAME>orc_int32</NAME>
typedef int32_t orc_int32;
</TYPEDEF>
<TYPEDEF>
<NAME>orc_int64</NAME>
typedef int64_t orc_int64;
</TYPEDEF>
<TYPEDEF>
<NAME>orc_uint8</NAME>
typedef uint8_t orc_uint8;
</TYPEDEF>
<TYPEDEF>
<NAME>orc_uint16</NAME>
typedef uint16_t orc_uint16;
</TYPEDEF>
<TYPEDEF>
<NAME>orc_uint32</NAME>
typedef uint32_t orc_uint32;
</TYPEDEF>
<TYPEDEF>
<NAME>orc_uint64</NAME>
typedef uint64_t orc_uint64;
</TYPEDEF>
<MACRO>
<NAME>ORC_UINT64_C</NAME>
#define ORC_UINT64_C(x) UINT64_C(x)
</MACRO>
<MACRO>
<NAME>inline</NAME>
#define inline __inline
</MACRO>
<MACRO>
<NAME>GST_TYPE_DEINTERLACE_TOMSMOCOMP</NAME>
#define GST_TYPE_DEINTERLACE_TOMSMOCOMP (gst_deinterlace_method_tomsmocomp_get_type ())
</MACRO>
<MACRO>
<NAME>GST_TYPE_DEINTERLACE_GREEDY_H</NAME>
#define GST_TYPE_DEINTERLACE_GREEDY_H (gst_deinterlace_method_greedy_h_get_type ())
</MACRO>
<MACRO>
<NAME>GST_TYPE_DEINTERLACE_GREEDY_L</NAME>
#define GST_TYPE_DEINTERLACE_GREEDY_L (gst_deinterlace_method_greedy_l_get_type ())
</MACRO>
<MACRO>
<NAME>GST_TYPE_DEINTERLACE_VFIR</NAME>
#define GST_TYPE_DEINTERLACE_VFIR (gst_deinterlace_method_vfir_get_type ())
</MACRO>
<MACRO>
<NAME>GST_TYPE_DEINTERLACE_LINEAR</NAME>
#define GST_TYPE_DEINTERLACE_LINEAR (gst_deinterlace_method_linear_get_type ())
</MACRO>
<MACRO>
<NAME>GST_TYPE_DEINTERLACE_LINEAR_BLEND</NAME>
#define GST_TYPE_DEINTERLACE_LINEAR_BLEND (gst_deinterlace_method_linear_blend_get_type ())
</MACRO>
<MACRO>
<NAME>GST_TYPE_DEINTERLACE_SCALER_BOB</NAME>
#define GST_TYPE_DEINTERLACE_SCALER_BOB (gst_deinterlace_method_scaler_bob_get_type ())
</MACRO>
<MACRO>
<NAME>GST_TYPE_DEINTERLACE_WEAVE</NAME>
#define GST_TYPE_DEINTERLACE_WEAVE (gst_deinterlace_method_weave_get_type ())
</MACRO>
<MACRO>
<NAME>GST_TYPE_DEINTERLACE_WEAVE_TFF</NAME>
#define GST_TYPE_DEINTERLACE_WEAVE_TFF (gst_deinterlace_method_weave_tff_get_type ())
</MACRO>
<MACRO>
<NAME>GST_TYPE_DEINTERLACE_WEAVE_BFF</NAME>
#define GST_TYPE_DEINTERLACE_WEAVE_BFF (gst_deinterlace_method_weave_bff_get_type ())
</MACRO>
<FUNCTION>
<NAME>gst_deinterlace_method_tomsmocomp_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_deinterlace_method_greedy_h_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_deinterlace_method_greedy_l_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_deinterlace_method_vfir_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_deinterlace_method_linear_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_deinterlace_method_linear_blend_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_deinterlace_method_scaler_bob_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_deinterlace_method_weave_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_deinterlace_method_weave_tff_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_deinterlace_method_weave_bff_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<UNION>
<NAME>mmx_t</NAME>
typedef	union {
	long long		q;	/* Quadword (64-bit) value */
	unsigned long long	uq;	/* Unsigned Quadword */
	int			d[2];	/* 2 Doubleword (32-bit) values */
	unsigned int		ud[2];	/* 2 Unsigned Doubleword */
	short			w[4];	/* 4 Word (16-bit) values */
	unsigned short		uw[4];	/* 4 Unsigned Word */
	char			b[8];	/* 8 Byte (8-bit) values */
	unsigned char		ub[8];	/* 8 Unsigned Byte */
	float			s[2];	/* Single-precision (32-bit) value */
} mmx_t;
</UNION>
<FUNCTION>
<NAME>mm_support</NAME>
<RETURNS>int </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>mmx_ok</NAME>
<RETURNS>int </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>mmx_i2r</NAME>
#define	mmx_i2r(op, imm, reg) \
	{ \
		mmx_t mmx_trace; \
		mmx_trace = (imm); \
		fprintf(stderr, #op "_i2r(" #imm "=0x%016llx, ", mmx_trace.q); \
		__asm__ __volatile__ ("movq %%" #reg ", %0" \
				      : "=X" (mmx_trace) \
				      : /* nothing */ ); \
		fprintf(stderr, #reg "=0x%016llx) => ", mmx_trace.q); \
		__asm__ __volatile__ (#op " %0, %%" #reg \
				      : /* nothing */ \
				      : "X" (imm)); \
		__asm__ __volatile__ ("movq %%" #reg ", %0" \
				      : "=X" (mmx_trace) \
				      : /* nothing */ ); \
		fprintf(stderr, #reg "=0x%016llx\n", mmx_trace.q); \
	}
</MACRO>
<MACRO>
<NAME>mmx_m2r</NAME>
#define	mmx_m2r(op, mem, reg) \
	{ \
		mmx_t mmx_trace; \
		mmx_trace = (mem); \
		fprintf(stderr, #op "_m2r(" #mem "=0x%016llx, ", mmx_trace.q); \
		__asm__ __volatile__ ("movq %%" #reg ", %0" \
				      : "=X" (mmx_trace) \
				      : /* nothing */ ); \
		fprintf(stderr, #reg "=0x%016llx) => ", mmx_trace.q); \
		__asm__ __volatile__ (#op " %0, %%" #reg \
				      : /* nothing */ \
				      : "X" (mem)); \
		__asm__ __volatile__ ("movq %%" #reg ", %0" \
				      : "=X" (mmx_trace) \
				      : /* nothing */ ); \
		fprintf(stderr, #reg "=0x%016llx\n", mmx_trace.q); \
	}
</MACRO>
<MACRO>
<NAME>mmx_r2m</NAME>
#define	mmx_r2m(op, reg, mem) \
	{ \
		mmx_t mmx_trace; \
		__asm__ __volatile__ ("movq %%" #reg ", %0" \
				      : "=X" (mmx_trace) \
				      : /* nothing */ ); \
		fprintf(stderr, #op "_r2m(" #reg "=0x%016llx, ", mmx_trace.q); \
		mmx_trace = (mem); \
		fprintf(stderr, #mem "=0x%016llx) => ", mmx_trace.q); \
		__asm__ __volatile__ (#op " %%" #reg ", %0" \
				      : "=X" (mem) \
				      : /* nothing */ ); \
		mmx_trace = (mem); \
		fprintf(stderr, #mem "=0x%016llx\n", mmx_trace.q); \
	}
</MACRO>
<MACRO>
<NAME>mmx_r2r</NAME>
#define	mmx_r2r(op, regs, regd) \
	{ \
		mmx_t mmx_trace; \
		__asm__ __volatile__ ("movq %%" #regs ", %0" \
				      : "=X" (mmx_trace) \
				      : /* nothing */ ); \
		fprintf(stderr, #op "_r2r(" #regs "=0x%016llx, ", mmx_trace.q); \
		__asm__ __volatile__ ("movq %%" #regd ", %0" \
				      : "=X" (mmx_trace) \
				      : /* nothing */ ); \
		fprintf(stderr, #regd "=0x%016llx) => ", mmx_trace.q); \
		__asm__ __volatile__ (#op " %" #regs ", %" #regd); \
		__asm__ __volatile__ ("movq %%" #regd ", %0" \
				      : "=X" (mmx_trace) \
				      : /* nothing */ ); \
		fprintf(stderr, #regd "=0x%016llx\n", mmx_trace.q); \
	}
</MACRO>
<MACRO>
<NAME>mmx_m2m</NAME>
#define	mmx_m2m(op, mems, memd) \
	{ \
		mmx_t mmx_trace; \
		mmx_trace = (mems); \
		fprintf(stderr, #op "_m2m(" #mems "=0x%016llx, ", mmx_trace.q); \
		mmx_trace = (memd); \
		fprintf(stderr, #memd "=0x%016llx) => ", mmx_trace.q); \
		__asm__ __volatile__ ("movq %0, %%mm0\n\t" \
				      #op " %1, %%mm0\n\t" \
				      "movq %%mm0, %0" \
				      : "=X" (memd) \
				      : "X" (mems)); \
		mmx_trace = (memd); \
		fprintf(stderr, #memd "=0x%016llx\n", mmx_trace.q); \
	}
</MACRO>
<MACRO>
<NAME>movq_m2r</NAME>
#define	movq_m2r(var, reg)	mmx_m2r(movq, var, reg)
</MACRO>
<MACRO>
<NAME>movq_r2m</NAME>
#define	movq_r2m(reg, var)	mmx_r2m(movq, reg, var)
</MACRO>
<MACRO>
<NAME>movq_r2r</NAME>
#define	movq_r2r(regs, regd)	mmx_r2r(movq, regs, regd)
</MACRO>
<MACRO>
<NAME>movq</NAME>
#define	movq(vars, vard) \
	__asm__ __volatile__ ("movq %1, %%mm0\n\t" \
			      "movq %%mm0, %0" \
			      : "=X" (vard) \
			      : "X" (vars))
</MACRO>
<MACRO>
<NAME>movd_m2r</NAME>
#define	movd_m2r(var, reg)	mmx_m2r(movd, var, reg)
</MACRO>
<MACRO>
<NAME>movd_r2m</NAME>
#define	movd_r2m(reg, var)	mmx_r2m(movd, reg, var)
</MACRO>
<MACRO>
<NAME>movd_r2r</NAME>
#define	movd_r2r(regs, regd)	mmx_r2r(movd, regs, regd)
</MACRO>
<MACRO>
<NAME>movd</NAME>
#define	movd(vars, vard) \
	__asm__ __volatile__ ("movd %1, %%mm0\n\t" \
			      "movd %%mm0, %0" \
			      : "=X" (vard) \
			      : "X" (vars))
</MACRO>
<MACRO>
<NAME>paddd_m2r</NAME>
#define	paddd_m2r(var, reg)	mmx_m2r(paddd, var, reg)
</MACRO>
<MACRO>
<NAME>paddd_r2r</NAME>
#define	paddd_r2r(regs, regd)	mmx_r2r(paddd, regs, regd)
</MACRO>
<MACRO>
<NAME>paddd</NAME>
#define	paddd(vars, vard)	mmx_m2m(paddd, vars, vard)
</MACRO>
<MACRO>
<NAME>paddw_m2r</NAME>
#define	paddw_m2r(var, reg)	mmx_m2r(paddw, var, reg)
</MACRO>
<MACRO>
<NAME>paddw_r2r</NAME>
#define	paddw_r2r(regs, regd)	mmx_r2r(paddw, regs, regd)
</MACRO>
<MACRO>
<NAME>paddw</NAME>
#define	paddw(vars, vard)	mmx_m2m(paddw, vars, vard)
</MACRO>
<MACRO>
<NAME>paddb_m2r</NAME>
#define	paddb_m2r(var, reg)	mmx_m2r(paddb, var, reg)
</MACRO>
<MACRO>
<NAME>paddb_r2r</NAME>
#define	paddb_r2r(regs, regd)	mmx_r2r(paddb, regs, regd)
</MACRO>
<MACRO>
<NAME>paddb</NAME>
#define	paddb(vars, vard)	mmx_m2m(paddb, vars, vard)
</MACRO>
<MACRO>
<NAME>paddsw_m2r</NAME>
#define	paddsw_m2r(var, reg)	mmx_m2r(paddsw, var, reg)
</MACRO>
<MACRO>
<NAME>paddsw_r2r</NAME>
#define	paddsw_r2r(regs, regd)	mmx_r2r(paddsw, regs, regd)
</MACRO>
<MACRO>
<NAME>paddsw</NAME>
#define	paddsw(vars, vard)	mmx_m2m(paddsw, vars, vard)
</MACRO>
<MACRO>
<NAME>paddsb_m2r</NAME>
#define	paddsb_m2r(var, reg)	mmx_m2r(paddsb, var, reg)
</MACRO>
<MACRO>
<NAME>paddsb_r2r</NAME>
#define	paddsb_r2r(regs, regd)	mmx_r2r(paddsb, regs, regd)
</MACRO>
<MACRO>
<NAME>paddsb</NAME>
#define	paddsb(vars, vard)	mmx_m2m(paddsb, vars, vard)
</MACRO>
<MACRO>
<NAME>paddusw_m2r</NAME>
#define	paddusw_m2r(var, reg)	mmx_m2r(paddusw, var, reg)
</MACRO>
<MACRO>
<NAME>paddusw_r2r</NAME>
#define	paddusw_r2r(regs, regd)	mmx_r2r(paddusw, regs, regd)
</MACRO>
<MACRO>
<NAME>paddusw</NAME>
#define	paddusw(vars, vard)	mmx_m2m(paddusw, vars, vard)
</MACRO>
<MACRO>
<NAME>paddusb_m2r</NAME>
#define	paddusb_m2r(var, reg)	mmx_m2r(paddusb, var, reg)
</MACRO>
<MACRO>
<NAME>paddusb_r2r</NAME>
#define	paddusb_r2r(regs, regd)	mmx_r2r(paddusb, regs, regd)
</MACRO>
<MACRO>
<NAME>paddusb</NAME>
#define	paddusb(vars, vard)	mmx_m2m(paddusb, vars, vard)
</MACRO>
<MACRO>
<NAME>psubd_m2r</NAME>
#define	psubd_m2r(var, reg)	mmx_m2r(psubd, var, reg)
</MACRO>
<MACRO>
<NAME>psubd_r2r</NAME>
#define	psubd_r2r(regs, regd)	mmx_r2r(psubd, regs, regd)
</MACRO>
<MACRO>
<NAME>psubd</NAME>
#define	psubd(vars, vard)	mmx_m2m(psubd, vars, vard)
</MACRO>
<MACRO>
<NAME>psubw_m2r</NAME>
#define	psubw_m2r(var, reg)	mmx_m2r(psubw, var, reg)
</MACRO>
<MACRO>
<NAME>psubw_r2r</NAME>
#define	psubw_r2r(regs, regd)	mmx_r2r(psubw, regs, regd)
</MACRO>
<MACRO>
<NAME>psubw</NAME>
#define	psubw(vars, vard)	mmx_m2m(psubw, vars, vard)
</MACRO>
<MACRO>
<NAME>psubb_m2r</NAME>
#define	psubb_m2r(var, reg)	mmx_m2r(psubb, var, reg)
</MACRO>
<MACRO>
<NAME>psubb_r2r</NAME>
#define	psubb_r2r(regs, regd)	mmx_r2r(psubb, regs, regd)
</MACRO>
<MACRO>
<NAME>psubb</NAME>
#define	psubb(vars, vard)	mmx_m2m(psubb, vars, vard)
</MACRO>
<MACRO>
<NAME>psubsw_m2r</NAME>
#define	psubsw_m2r(var, reg)	mmx_m2r(psubsw, var, reg)
</MACRO>
<MACRO>
<NAME>psubsw_r2r</NAME>
#define	psubsw_r2r(regs, regd)	mmx_r2r(psubsw, regs, regd)
</MACRO>
<MACRO>
<NAME>psubsw</NAME>
#define	psubsw(vars, vard)	mmx_m2m(psubsw, vars, vard)
</MACRO>
<MACRO>
<NAME>psubsb_m2r</NAME>
#define	psubsb_m2r(var, reg)	mmx_m2r(psubsb, var, reg)
</MACRO>
<MACRO>
<NAME>psubsb_r2r</NAME>
#define	psubsb_r2r(regs, regd)	mmx_r2r(psubsb, regs, regd)
</MACRO>
<MACRO>
<NAME>psubsb</NAME>
#define	psubsb(vars, vard)	mmx_m2m(psubsb, vars, vard)
</MACRO>
<MACRO>
<NAME>psubusw_m2r</NAME>
#define	psubusw_m2r(var, reg)	mmx_m2r(psubusw, var, reg)
</MACRO>
<MACRO>
<NAME>psubusw_r2r</NAME>
#define	psubusw_r2r(regs, regd)	mmx_r2r(psubusw, regs, regd)
</MACRO>
<MACRO>
<NAME>psubusw</NAME>
#define	psubusw(vars, vard)	mmx_m2m(psubusw, vars, vard)
</MACRO>
<MACRO>
<NAME>psubusb_m2r</NAME>
#define	psubusb_m2r(var, reg)	mmx_m2r(psubusb, var, reg)
</MACRO>
<MACRO>
<NAME>psubusb_r2r</NAME>
#define	psubusb_r2r(regs, regd)	mmx_r2r(psubusb, regs, regd)
</MACRO>
<MACRO>
<NAME>psubusb</NAME>
#define	psubusb(vars, vard)	mmx_m2m(psubusb, vars, vard)
</MACRO>
<MACRO>
<NAME>pmullw_m2r</NAME>
#define	pmullw_m2r(var, reg)	mmx_m2r(pmullw, var, reg)
</MACRO>
<MACRO>
<NAME>pmullw_r2r</NAME>
#define	pmullw_r2r(regs, regd)	mmx_r2r(pmullw, regs, regd)
</MACRO>
<MACRO>
<NAME>pmullw</NAME>
#define	pmullw(vars, vard)	mmx_m2m(pmullw, vars, vard)
</MACRO>
<MACRO>
<NAME>pmulhw_m2r</NAME>
#define	pmulhw_m2r(var, reg)	mmx_m2r(pmulhw, var, reg)
</MACRO>
<MACRO>
<NAME>pmulhw_r2r</NAME>
#define	pmulhw_r2r(regs, regd)	mmx_r2r(pmulhw, regs, regd)
</MACRO>
<MACRO>
<NAME>pmulhw</NAME>
#define	pmulhw(vars, vard)	mmx_m2m(pmulhw, vars, vard)
</MACRO>
<MACRO>
<NAME>pmaddwd_m2r</NAME>
#define	pmaddwd_m2r(var, reg)	mmx_m2r(pmaddwd, var, reg)
</MACRO>
<MACRO>
<NAME>pmaddwd_r2r</NAME>
#define	pmaddwd_r2r(regs, regd)	mmx_r2r(pmaddwd, regs, regd)
</MACRO>
<MACRO>
<NAME>pmaddwd</NAME>
#define	pmaddwd(vars, vard)	mmx_m2m(pmaddwd, vars, vard)
</MACRO>
<MACRO>
<NAME>pand_m2r</NAME>
#define	pand_m2r(var, reg) \
	{ \
		mmx_m2r(pandn, (mmx_t) -1LL, reg); \
		mmx_m2r(pandn, var, reg); \
	}
</MACRO>
<MACRO>
<NAME>pand_r2r</NAME>
#define	pand_r2r(regs, regd) \
	{ \
		mmx_m2r(pandn, (mmx_t) -1LL, regd); \
		mmx_r2r(pandn, regs, regd); \
	}
</MACRO>
<MACRO>
<NAME>pand</NAME>
#define	pand(vars, vard) \
	{ \
		movq_m2r(vard, mm0); \
		mmx_m2r(pandn, (mmx_t) -1LL, mm0); \
		mmx_m2r(pandn, vars, mm0); \
		movq_r2m(mm0, vard); \
	}
</MACRO>
<MACRO>
<NAME>pandn_m2r</NAME>
#define	pandn_m2r(var, reg)	mmx_m2r(pandn, var, reg)
</MACRO>
<MACRO>
<NAME>pandn_r2r</NAME>
#define	pandn_r2r(regs, regd)	mmx_r2r(pandn, regs, regd)
</MACRO>
<MACRO>
<NAME>pandn</NAME>
#define	pandn(vars, vard)	mmx_m2m(pandn, vars, vard)
</MACRO>
<MACRO>
<NAME>por_m2r</NAME>
#define	por_m2r(var, reg)	mmx_m2r(por, var, reg)
</MACRO>
<MACRO>
<NAME>por_r2r</NAME>
#define	por_r2r(regs, regd)	mmx_r2r(por, regs, regd)
</MACRO>
<MACRO>
<NAME>por</NAME>
#define	por(vars, vard)	mmx_m2m(por, vars, vard)
</MACRO>
<MACRO>
<NAME>pxor_m2r</NAME>
#define	pxor_m2r(var, reg)	mmx_m2r(pxor, var, reg)
</MACRO>
<MACRO>
<NAME>pxor_r2r</NAME>
#define	pxor_r2r(regs, regd)	mmx_r2r(pxor, regs, regd)
</MACRO>
<MACRO>
<NAME>pxor</NAME>
#define	pxor(vars, vard)	mmx_m2m(pxor, vars, vard)
</MACRO>
<MACRO>
<NAME>pcmpeqd_m2r</NAME>
#define	pcmpeqd_m2r(var, reg)	mmx_m2r(pcmpeqd, var, reg)
</MACRO>
<MACRO>
<NAME>pcmpeqd_r2r</NAME>
#define	pcmpeqd_r2r(regs, regd)	mmx_r2r(pcmpeqd, regs, regd)
</MACRO>
<MACRO>
<NAME>pcmpeqd</NAME>
#define	pcmpeqd(vars, vard)	mmx_m2m(pcmpeqd, vars, vard)
</MACRO>
<MACRO>
<NAME>pcmpeqw_m2r</NAME>
#define	pcmpeqw_m2r(var, reg)	mmx_m2r(pcmpeqw, var, reg)
</MACRO>
<MACRO>
<NAME>pcmpeqw_r2r</NAME>
#define	pcmpeqw_r2r(regs, regd)	mmx_r2r(pcmpeqw, regs, regd)
</MACRO>
<MACRO>
<NAME>pcmpeqw</NAME>
#define	pcmpeqw(vars, vard)	mmx_m2m(pcmpeqw, vars, vard)
</MACRO>
<MACRO>
<NAME>pcmpeqb_m2r</NAME>
#define	pcmpeqb_m2r(var, reg)	mmx_m2r(pcmpeqb, var, reg)
</MACRO>
<MACRO>
<NAME>pcmpeqb_r2r</NAME>
#define	pcmpeqb_r2r(regs, regd)	mmx_r2r(pcmpeqb, regs, regd)
</MACRO>
<MACRO>
<NAME>pcmpeqb</NAME>
#define	pcmpeqb(vars, vard)	mmx_m2m(pcmpeqb, vars, vard)
</MACRO>
<MACRO>
<NAME>pcmpgtd_m2r</NAME>
#define	pcmpgtd_m2r(var, reg)	mmx_m2r(pcmpgtd, var, reg)
</MACRO>
<MACRO>
<NAME>pcmpgtd_r2r</NAME>
#define	pcmpgtd_r2r(regs, regd)	mmx_r2r(pcmpgtd, regs, regd)
</MACRO>
<MACRO>
<NAME>pcmpgtd</NAME>
#define	pcmpgtd(vars, vard)	mmx_m2m(pcmpgtd, vars, vard)
</MACRO>
<MACRO>
<NAME>pcmpgtw_m2r</NAME>
#define	pcmpgtw_m2r(var, reg)	mmx_m2r(pcmpgtw, var, reg)
</MACRO>
<MACRO>
<NAME>pcmpgtw_r2r</NAME>
#define	pcmpgtw_r2r(regs, regd)	mmx_r2r(pcmpgtw, regs, regd)
</MACRO>
<MACRO>
<NAME>pcmpgtw</NAME>
#define	pcmpgtw(vars, vard)	mmx_m2m(pcmpgtw, vars, vard)
</MACRO>
<MACRO>
<NAME>pcmpgtb_m2r</NAME>
#define	pcmpgtb_m2r(var, reg)	mmx_m2r(pcmpgtb, var, reg)
</MACRO>
<MACRO>
<NAME>pcmpgtb_r2r</NAME>
#define	pcmpgtb_r2r(regs, regd)	mmx_r2r(pcmpgtb, regs, regd)
</MACRO>
<MACRO>
<NAME>pcmpgtb</NAME>
#define	pcmpgtb(vars, vard)	mmx_m2m(pcmpgtb, vars, vard)
</MACRO>
<MACRO>
<NAME>psllq_i2r</NAME>
#define	psllq_i2r(imm, reg)	mmx_i2r(psllq, imm, reg)
</MACRO>
<MACRO>
<NAME>psllq_m2r</NAME>
#define	psllq_m2r(var, reg)	mmx_m2r(psllq, var, reg)
</MACRO>
<MACRO>
<NAME>psllq_r2r</NAME>
#define	psllq_r2r(regs, regd)	mmx_r2r(psllq, regs, regd)
</MACRO>
<MACRO>
<NAME>psllq</NAME>
#define	psllq(vars, vard)	mmx_m2m(psllq, vars, vard)
</MACRO>
<MACRO>
<NAME>pslld_i2r</NAME>
#define	pslld_i2r(imm, reg)	mmx_i2r(pslld, imm, reg)
</MACRO>
<MACRO>
<NAME>pslld_m2r</NAME>
#define	pslld_m2r(var, reg)	mmx_m2r(pslld, var, reg)
</MACRO>
<MACRO>
<NAME>pslld_r2r</NAME>
#define	pslld_r2r(regs, regd)	mmx_r2r(pslld, regs, regd)
</MACRO>
<MACRO>
<NAME>pslld</NAME>
#define	pslld(vars, vard)	mmx_m2m(pslld, vars, vard)
</MACRO>
<MACRO>
<NAME>psllw_i2r</NAME>
#define	psllw_i2r(imm, reg)	mmx_i2r(psllw, imm, reg)
</MACRO>
<MACRO>
<NAME>psllw_m2r</NAME>
#define	psllw_m2r(var, reg)	mmx_m2r(psllw, var, reg)
</MACRO>
<MACRO>
<NAME>psllw_r2r</NAME>
#define	psllw_r2r(regs, regd)	mmx_r2r(psllw, regs, regd)
</MACRO>
<MACRO>
<NAME>psllw</NAME>
#define	psllw(vars, vard)	mmx_m2m(psllw, vars, vard)
</MACRO>
<MACRO>
<NAME>psrlq_i2r</NAME>
#define	psrlq_i2r(imm, reg)	mmx_i2r(psrlq, imm, reg)
</MACRO>
<MACRO>
<NAME>psrlq_m2r</NAME>
#define	psrlq_m2r(var, reg)	mmx_m2r(psrlq, var, reg)
</MACRO>
<MACRO>
<NAME>psrlq_r2r</NAME>
#define	psrlq_r2r(regs, regd)	mmx_r2r(psrlq, regs, regd)
</MACRO>
<MACRO>
<NAME>psrlq</NAME>
#define	psrlq(vars, vard)	mmx_m2m(psrlq, vars, vard)
</MACRO>
<MACRO>
<NAME>psrld_i2r</NAME>
#define	psrld_i2r(imm, reg)	mmx_i2r(psrld, imm, reg)
</MACRO>
<MACRO>
<NAME>psrld_m2r</NAME>
#define	psrld_m2r(var, reg)	mmx_m2r(psrld, var, reg)
</MACRO>
<MACRO>
<NAME>psrld_r2r</NAME>
#define	psrld_r2r(regs, regd)	mmx_r2r(psrld, regs, regd)
</MACRO>
<MACRO>
<NAME>psrld</NAME>
#define	psrld(vars, vard)	mmx_m2m(psrld, vars, vard)
</MACRO>
<MACRO>
<NAME>psrlw_i2r</NAME>
#define	psrlw_i2r(imm, reg)	mmx_i2r(psrlw, imm, reg)
</MACRO>
<MACRO>
<NAME>psrlw_m2r</NAME>
#define	psrlw_m2r(var, reg)	mmx_m2r(psrlw, var, reg)
</MACRO>
<MACRO>
<NAME>psrlw_r2r</NAME>
#define	psrlw_r2r(regs, regd)	mmx_r2r(psrlw, regs, regd)
</MACRO>
<MACRO>
<NAME>psrlw</NAME>
#define	psrlw(vars, vard)	mmx_m2m(psrlw, vars, vard)
</MACRO>
<MACRO>
<NAME>psrad_i2r</NAME>
#define	psrad_i2r(imm, reg)	mmx_i2r(psrad, imm, reg)
</MACRO>
<MACRO>
<NAME>psrad_m2r</NAME>
#define	psrad_m2r(var, reg)	mmx_m2r(psrad, var, reg)
</MACRO>
<MACRO>
<NAME>psrad_r2r</NAME>
#define	psrad_r2r(regs, regd)	mmx_r2r(psrad, regs, regd)
</MACRO>
<MACRO>
<NAME>psrad</NAME>
#define	psrad(vars, vard)	mmx_m2m(psrad, vars, vard)
</MACRO>
<MACRO>
<NAME>psraw_i2r</NAME>
#define	psraw_i2r(imm, reg)	mmx_i2r(psraw, imm, reg)
</MACRO>
<MACRO>
<NAME>psraw_m2r</NAME>
#define	psraw_m2r(var, reg)	mmx_m2r(psraw, var, reg)
</MACRO>
<MACRO>
<NAME>psraw_r2r</NAME>
#define	psraw_r2r(regs, regd)	mmx_r2r(psraw, regs, regd)
</MACRO>
<MACRO>
<NAME>psraw</NAME>
#define	psraw(vars, vard)	mmx_m2m(psraw, vars, vard)
</MACRO>
<MACRO>
<NAME>packssdw_m2r</NAME>
#define	packssdw_m2r(var, reg)	mmx_m2r(packssdw, var, reg)
</MACRO>
<MACRO>
<NAME>packssdw_r2r</NAME>
#define	packssdw_r2r(regs, regd) mmx_r2r(packssdw, regs, regd)
</MACRO>
<MACRO>
<NAME>packssdw</NAME>
#define	packssdw(vars, vard)	mmx_m2m(packssdw, vars, vard)
</MACRO>
<MACRO>
<NAME>packsswb_m2r</NAME>
#define	packsswb_m2r(var, reg)	mmx_m2r(packsswb, var, reg)
</MACRO>
<MACRO>
<NAME>packsswb_r2r</NAME>
#define	packsswb_r2r(regs, regd) mmx_r2r(packsswb, regs, regd)
</MACRO>
<MACRO>
<NAME>packsswb</NAME>
#define	packsswb(vars, vard)	mmx_m2m(packsswb, vars, vard)
</MACRO>
<MACRO>
<NAME>packuswb_m2r</NAME>
#define	packuswb_m2r(var, reg)	mmx_m2r(packuswb, var, reg)
</MACRO>
<MACRO>
<NAME>packuswb_r2r</NAME>
#define	packuswb_r2r(regs, regd) mmx_r2r(packuswb, regs, regd)
</MACRO>
<MACRO>
<NAME>packuswb</NAME>
#define	packuswb(vars, vard)	mmx_m2m(packuswb, vars, vard)
</MACRO>
<MACRO>
<NAME>punpckldq_m2r</NAME>
#define	punpckldq_m2r(var, reg)	mmx_m2r(punpckldq, var, reg)
</MACRO>
<MACRO>
<NAME>punpckldq_r2r</NAME>
#define	punpckldq_r2r(regs, regd) mmx_r2r(punpckldq, regs, regd)
</MACRO>
<MACRO>
<NAME>punpckldq</NAME>
#define	punpckldq(vars, vard)	mmx_m2m(punpckldq, vars, vard)
</MACRO>
<MACRO>
<NAME>punpcklwd_m2r</NAME>
#define	punpcklwd_m2r(var, reg)	mmx_m2r(punpcklwd, var, reg)
</MACRO>
<MACRO>
<NAME>punpcklwd_r2r</NAME>
#define	punpcklwd_r2r(regs, regd) mmx_r2r(punpcklwd, regs, regd)
</MACRO>
<MACRO>
<NAME>punpcklwd</NAME>
#define	punpcklwd(vars, vard)	mmx_m2m(punpcklwd, vars, vard)
</MACRO>
<MACRO>
<NAME>punpcklbw_m2r</NAME>
#define	punpcklbw_m2r(var, reg)	mmx_m2r(punpcklbw, var, reg)
</MACRO>
<MACRO>
<NAME>punpcklbw_r2r</NAME>
#define	punpcklbw_r2r(regs, regd) mmx_r2r(punpcklbw, regs, regd)
</MACRO>
<MACRO>
<NAME>punpcklbw</NAME>
#define	punpcklbw(vars, vard)	mmx_m2m(punpcklbw, vars, vard)
</MACRO>
<MACRO>
<NAME>punpckhdq_m2r</NAME>
#define	punpckhdq_m2r(var, reg)	mmx_m2r(punpckhdq, var, reg)
</MACRO>
<MACRO>
<NAME>punpckhdq_r2r</NAME>
#define	punpckhdq_r2r(regs, regd) mmx_r2r(punpckhdq, regs, regd)
</MACRO>
<MACRO>
<NAME>punpckhdq</NAME>
#define	punpckhdq(vars, vard)	mmx_m2m(punpckhdq, vars, vard)
</MACRO>
<MACRO>
<NAME>punpckhwd_m2r</NAME>
#define	punpckhwd_m2r(var, reg)	mmx_m2r(punpckhwd, var, reg)
</MACRO>
<MACRO>
<NAME>punpckhwd_r2r</NAME>
#define	punpckhwd_r2r(regs, regd) mmx_r2r(punpckhwd, regs, regd)
</MACRO>
<MACRO>
<NAME>punpckhwd</NAME>
#define	punpckhwd(vars, vard)	mmx_m2m(punpckhwd, vars, vard)
</MACRO>
<MACRO>
<NAME>punpckhbw_m2r</NAME>
#define	punpckhbw_m2r(var, reg)	mmx_m2r(punpckhbw, var, reg)
</MACRO>
<MACRO>
<NAME>punpckhbw_r2r</NAME>
#define	punpckhbw_r2r(regs, regd) mmx_r2r(punpckhbw, regs, regd)
</MACRO>
<MACRO>
<NAME>punpckhbw</NAME>
#define	punpckhbw(vars, vard)	mmx_m2m(punpckhbw, vars, vard)
</MACRO>
<MACRO>
<NAME>emms</NAME>
#define	emms() \
	{ \
		fprintf(stderr, "emms()\n"); \
		__asm__ __volatile__ ("emms"); \
	}
</MACRO>
<MACRO>
<NAME>V_PAVGB_MMX</NAME>
#define V_PAVGB_MMX(mmr1, mmr2, mmrw, smask) \
	"movq    "mmr2",  "mmrw"\n\t"            \
	"pand    "smask", "mmrw"\n\t"            \
	"psrlw   $1,      "mmrw"\n\t"            \
	"pand    "smask", "mmr1"\n\t"            \
	"psrlw   $1,      "mmr1"\n\t"            \
	"paddusb "mmrw",  "mmr1"\n\t"
</MACRO>
<MACRO>
<NAME>V_PAVGB_MMXEXT</NAME>
#define V_PAVGB_MMXEXT(mmr1, mmr2, mmrw, smask)      "pavgb   "mmr2", "mmr1"\n\t"
</MACRO>
<MACRO>
<NAME>V_PAVGB_3DNOW</NAME>
#define V_PAVGB_3DNOW(mmr1, mmr2, mmrw, smask)    "pavgusb "mmr2", "mmr1"\n\t"
</MACRO>
<MACRO>
<NAME>V_PAVGB</NAME>
#define V_PAVGB(mmr1, mmr2, mmrw, smask)          V_PAVGB2(mmr1, mmr2, mmrw, smask, SIMD_TYPE) 
</MACRO>
<MACRO>
<NAME>V_PAVGB2</NAME>
#define V_PAVGB2(mmr1, mmr2, mmrw, smask, simd_type) V_PAVGB3(mmr1, mmr2, mmrw, smask, simd_type) 
</MACRO>
<MACRO>
<NAME>V_PAVGB3</NAME>
#define V_PAVGB3(mmr1, mmr2, mmrw, smask, simd_type) V_PAVGB_##simd_type(mmr1, mmr2, mmrw, smask) 
</MACRO>
<MACRO>
<NAME>V_PMAXUB_MMX</NAME>
#define V_PMAXUB_MMX(mmr1, mmr2) \
    "psubusb "mmr2", "mmr1"\n\t" \
    "paddusb "mmr2", "mmr1"\n\t"
</MACRO>
<MACRO>
<NAME>V_PMAXUB_MMXEXT</NAME>
#define V_PMAXUB_MMXEXT(mmr1, mmr2)      "pmaxub "mmr2", "mmr1"\n\t"
</MACRO>
<MACRO>
<NAME>V_PMAXUB_3DNOW</NAME>
#define V_PMAXUB_3DNOW(mmr1, mmr2)    V_PMAXUB_MMX(mmr1, mmr2)  // use MMX version
</MACRO>
<MACRO>
<NAME>V_PMAXUB</NAME>
#define V_PMAXUB(mmr1, mmr2)          V_PMAXUB2(mmr1, mmr2, SIMD_TYPE) 
</MACRO>
<MACRO>
<NAME>V_PMAXUB2</NAME>
#define V_PMAXUB2(mmr1, mmr2, simd_type) V_PMAXUB3(mmr1, mmr2, simd_type) 
</MACRO>
<MACRO>
<NAME>V_PMAXUB3</NAME>
#define V_PMAXUB3(mmr1, mmr2, simd_type) V_PMAXUB_##simd_type(mmr1, mmr2) 
</MACRO>
<MACRO>
<NAME>V_PMINUB_MMX</NAME>
#define V_PMINUB_MMX(mmr1, mmr2, mmrw) \
    "pcmpeqb "mmrw", "mmrw"\n\t"       \
    "psubusb "mmr2", "mmrw"\n\t"       \
    "paddusb "mmrw", "mmr1"\n\t"       \
    "psubusb "mmrw", "mmr1"\n\t"
</MACRO>
<MACRO>
<NAME>V_PMINUB_MMXEXT</NAME>
#define V_PMINUB_MMXEXT(mmr1, mmr2, mmrw)      "pminub "mmr2", "mmr1"\n\t"
</MACRO>
<MACRO>
<NAME>V_PMINUB_3DNOW</NAME>
#define V_PMINUB_3DNOW(mmr1, mmr2, mmrw)    V_PMINUB_MMX(mmr1, mmr2, mmrw)  // use MMX version
</MACRO>
<MACRO>
<NAME>V_PMINUB</NAME>
#define V_PMINUB(mmr1, mmr2, mmrw)          V_PMINUB2(mmr1, mmr2, mmrw, SIMD_TYPE) 
</MACRO>
<MACRO>
<NAME>V_PMINUB2</NAME>
#define V_PMINUB2(mmr1, mmr2, mmrw, simd_type) V_PMINUB3(mmr1, mmr2, mmrw, simd_type) 
</MACRO>
<MACRO>
<NAME>V_PMINUB3</NAME>
#define V_PMINUB3(mmr1, mmr2, mmrw, simd_type) V_PMINUB_##simd_type(mmr1, mmr2, mmrw) 
</MACRO>
<MACRO>
<NAME>V_MOVNTQ_MMX</NAME>
#define V_MOVNTQ_MMX(mmr1, mmr2)      "movq   "mmr2", "mmr1"\n\t"
</MACRO>
<MACRO>
<NAME>V_MOVNTQ_3DNOW</NAME>
#define V_MOVNTQ_3DNOW(mmr1, mmr2)    "movq   "mmr2", "mmr1"\n\t"
</MACRO>
<MACRO>
<NAME>V_MOVNTQ_MMXEXT</NAME>
#define V_MOVNTQ_MMXEXT(mmr1, mmr2)      "movntq "mmr2", "mmr1"\n\t"
</MACRO>
<MACRO>
<NAME>V_MOVNTQ</NAME>
#define V_MOVNTQ(mmr1, mmr2)          V_MOVNTQ2(mmr1, mmr2, SIMD_TYPE) 
</MACRO>
<MACRO>
<NAME>V_MOVNTQ2</NAME>
#define V_MOVNTQ2(mmr1, mmr2, simd_type) V_MOVNTQ3(mmr1, mmr2, simd_type) 
</MACRO>
<MACRO>
<NAME>V_MOVNTQ3</NAME>
#define V_MOVNTQ3(mmr1, mmr2, simd_type) V_MOVNTQ_##simd_type(mmr1, mmr2)
</MACRO>
<MACRO>
<NAME>V_PAVGB_MMX</NAME>
#define V_PAVGB_MMX(mmr1, mmr2, mmrw, smask) \
	"movq    "mmr2",  "mmrw"\n\t"            \
	"pand    "smask", "mmrw"\n\t"            \
	"psrlw   $1,      "mmrw"\n\t"            \
	"pand    "smask", "mmr1"\n\t"            \
	"psrlw   $1,      "mmr1"\n\t"            \
	"paddusb "mmrw",  "mmr1"\n\t"
</MACRO>
<MACRO>
<NAME>V_PAVGB_MMXEXT</NAME>
#define V_PAVGB_MMXEXT(mmr1, mmr2, mmrw, smask)      "pavgb   "mmr2", "mmr1"\n\t"
</MACRO>
<MACRO>
<NAME>V_PAVGB_3DNOW</NAME>
#define V_PAVGB_3DNOW(mmr1, mmr2, mmrw, smask)    "pavgusb "mmr2", "mmr1"\n\t"
</MACRO>
<MACRO>
<NAME>V_PAVGB</NAME>
#define V_PAVGB(mmr1, mmr2, mmrw, smask)          V_PAVGB2(mmr1, mmr2, mmrw, smask, SIMD_TYPE) 
</MACRO>
<MACRO>
<NAME>V_PAVGB2</NAME>
#define V_PAVGB2(mmr1, mmr2, mmrw, smask, simd_type) V_PAVGB3(mmr1, mmr2, mmrw, smask, simd_type) 
</MACRO>
<MACRO>
<NAME>V_PAVGB3</NAME>
#define V_PAVGB3(mmr1, mmr2, mmrw, smask, simd_type) V_PAVGB_##simd_type(mmr1, mmr2, mmrw, smask) 
</MACRO>
<MACRO>
<NAME>V_PMAXUB_MMX</NAME>
#define V_PMAXUB_MMX(mmr1, mmr2) \
    "psubusb "mmr2", "mmr1"\n\t" \
    "paddusb "mmr2", "mmr1"\n\t"
</MACRO>
<MACRO>
<NAME>V_PMAXUB_MMXEXT</NAME>
#define V_PMAXUB_MMXEXT(mmr1, mmr2)      "pmaxub "mmr2", "mmr1"\n\t"
</MACRO>
<MACRO>
<NAME>V_PMAXUB_3DNOW</NAME>
#define V_PMAXUB_3DNOW(mmr1, mmr2)    V_PMAXUB_MMX(mmr1, mmr2)  // use MMX version
</MACRO>
<MACRO>
<NAME>V_PMAXUB</NAME>
#define V_PMAXUB(mmr1, mmr2)          V_PMAXUB2(mmr1, mmr2, SIMD_TYPE) 
</MACRO>
<MACRO>
<NAME>V_PMAXUB2</NAME>
#define V_PMAXUB2(mmr1, mmr2, simd_type) V_PMAXUB3(mmr1, mmr2, simd_type) 
</MACRO>
<MACRO>
<NAME>V_PMAXUB3</NAME>
#define V_PMAXUB3(mmr1, mmr2, simd_type) V_PMAXUB_##simd_type(mmr1, mmr2) 
</MACRO>
<MACRO>
<NAME>V_PMINUB_MMX</NAME>
#define V_PMINUB_MMX(mmr1, mmr2, mmrw) \
    "pcmpeqb "mmrw", "mmrw"\n\t"       \
    "psubusb "mmr2", "mmrw"\n\t"       \
    "paddusb "mmrw", "mmr1"\n\t"       \
    "psubusb "mmrw", "mmr1"\n\t"
</MACRO>
<MACRO>
<NAME>V_PMINUB_MMXEXT</NAME>
#define V_PMINUB_MMXEXT(mmr1, mmr2, mmrw)      "pminub "mmr2", "mmr1"\n\t"
</MACRO>
<MACRO>
<NAME>V_PMINUB_3DNOW</NAME>
#define V_PMINUB_3DNOW(mmr1, mmr2, mmrw)    V_PMINUB_MMX(mmr1, mmr2, mmrw)  // use MMX version
</MACRO>
<MACRO>
<NAME>V_PMINUB</NAME>
#define V_PMINUB(mmr1, mmr2, mmrw)          V_PMINUB2(mmr1, mmr2, mmrw, SIMD_TYPE) 
</MACRO>
<MACRO>
<NAME>V_PMINUB2</NAME>
#define V_PMINUB2(mmr1, mmr2, mmrw, simd_type) V_PMINUB3(mmr1, mmr2, mmrw, simd_type) 
</MACRO>
<MACRO>
<NAME>V_PMINUB3</NAME>
#define V_PMINUB3(mmr1, mmr2, mmrw, simd_type) V_PMINUB_##simd_type(mmr1, mmr2, mmrw) 
</MACRO>
<MACRO>
<NAME>V_MOVNTQ_MMX</NAME>
#define V_MOVNTQ_MMX(mmr1, mmr2)      "movq   "mmr2", "mmr1"\n\t"
</MACRO>
<MACRO>
<NAME>V_MOVNTQ_3DNOW</NAME>
#define V_MOVNTQ_3DNOW(mmr1, mmr2)    "movq   "mmr2", "mmr1"\n\t"
</MACRO>
<MACRO>
<NAME>V_MOVNTQ_MMXEXT</NAME>
#define V_MOVNTQ_MMXEXT(mmr1, mmr2)      "movntq "mmr2", "mmr1"\n\t"
</MACRO>
<MACRO>
<NAME>V_MOVNTQ</NAME>
#define V_MOVNTQ(mmr1, mmr2)          V_MOVNTQ2(mmr1, mmr2, SIMD_TYPE) 
</MACRO>
<MACRO>
<NAME>V_MOVNTQ2</NAME>
#define V_MOVNTQ2(mmr1, mmr2, simd_type) V_MOVNTQ3(mmr1, mmr2, simd_type) 
</MACRO>
<MACRO>
<NAME>V_MOVNTQ3</NAME>
#define V_MOVNTQ3(mmr1, mmr2, simd_type) V_MOVNTQ_##simd_type(mmr1, mmr2)
</MACRO>
<MACRO>
<NAME>MERGE4PIXavg</NAME>
#define MERGE4PIXavg(PADDR1, PADDR2)                                                     \
    "movdqu  "PADDR1",   %%xmm0\n\t"       /* our 4 pixels */                            \
    "movdqu  "PADDR2",   %%xmm1\n\t"       /* our pixel2 value */                        \
    "movdqa  %%xmm0,     %%xmm2\n\t"       /* another copy of our pixel1 value */        \
    "movdqa  %%xmm1,     %%xmm3\n\t"       /* another copy of our pixel1 value */        \
    "psubusb %%xmm1,     %%xmm2\n\t"                                                     \
    "psubusb %%xmm0,     %%xmm3\n\t"                                                     \
    "por     %%xmm3,     %%xmm2\n\t"                                                     \
    "pavgb   %%xmm1,     %%xmm0\n\t"       /* avg of 2 pixels */                         \
    "movdqa  %%xmm2,     %%xmm3\n\t"       /* another copy of our our weights */         \
    "pxor    %%xmm1,     %%xmm1\n\t"                                                     \
    "psubusb %%xmm7,     %%xmm3\n\t"       /* nonzero where old weights lower, else 0 */ \
    "pcmpeqb %%xmm1,     %%xmm3\n\t"       /* now ff where new better, else 00 */        \
    "pcmpeqb %%xmm3,     %%xmm1\n\t"       /* here ff where old better, else 00 */       \
    "pand    %%xmm3,     %%xmm0\n\t"       /* keep only better new pixels */             \
    "pand    %%xmm3,     %%xmm2\n\t"       /* and weights */                             \
    "pand    %%xmm1,     %%xmm5\n\t"       /* keep only better old pixels */             \
    "pand    %%xmm1,     %%xmm7\n\t"                                                     \
    "por     %%xmm0,     %%xmm5\n\t"       /* and merge new & old vals */                \
    "por     %%xmm2,     %%xmm7\n\t"
</MACRO>
<MACRO>
<NAME>MERGE4PIXavgH</NAME>
#define MERGE4PIXavgH(PADDR1A, PADDR1B, PADDR2A, PADDR2B)                                \
    "movdqu  "PADDR1A",   %%xmm0\n\t"      /* our 4 pixels */                            \
    "movdqu  "PADDR2A",   %%xmm1\n\t"      /* our pixel2 value */                        \
    "movdqu  "PADDR1B",   %%xmm2\n\t"      /* our 4 pixels */                            \
    "movdqu  "PADDR2B",   %%xmm3\n\t"      /* our pixel2 value */                        \
    "pavgb   %%xmm2,      %%xmm0\n\t"                                                    \
    "pavgb   %%xmm3,      %%xmm1\n\t"                                                    \
    "movdqa  %%xmm0,      %%xmm2\n\t"      /* another copy of our pixel1 value */        \
    "movdqa  %%xmm1,      %%xmm3\n\t"      /* another copy of our pixel1 value */        \
    "psubusb %%xmm1,      %%xmm2\n\t"                                                    \
    "psubusb %%xmm0,      %%xmm3\n\t"                                                    \
    "por     %%xmm3,      %%xmm2\n\t"                                                    \
    "pavgb   %%xmm1,      %%xmm0\n\t"      /* avg of 2 pixels */                         \
    "movdqa  %%xmm2,      %%xmm3\n\t"      /* another copy of our our weights */         \
    "pxor    %%xmm1,      %%xmm1\n\t"                                                    \
    "psubusb %%xmm7,      %%xmm3\n\t"      /* nonzero where old weights lower, else 0 */ \
    "pcmpeqb %%xmm1,      %%xmm3\n\t"      /* now ff where new better, else 00 */        \
    "pcmpeqb %%xmm3,      %%xmm1\n\t"      /* here ff where old better, else 00 */       \
    "pand    %%xmm3,      %%xmm0\n\t"      /* keep only better new pixels */             \
    "pand    %%xmm3,      %%xmm2\n\t"      /* and weights */                             \
    "pand    %%xmm1,      %%xmm5\n\t"      /* keep only better old pixels */             \
    "pand    %%xmm1,      %%xmm7\n\t"                                                    \
    "por     %%xmm0,      %%xmm5\n\t"      /* and merge new & old vals */                \
    "por     %%xmm2,      %%xmm7\n\t"
</MACRO>
<MACRO>
<NAME>RESET_CHROMA</NAME>
#define RESET_CHROMA "por "_UVMask", %%xmm7\n\t"
</MACRO>
<MACRO>
<NAME>GST_TYPE_PULSE_DEVICE_PROVIDER</NAME>
#define GST_TYPE_PULSE_DEVICE_PROVIDER                 (gst_pulse_device_provider_get_type())
</MACRO>
<MACRO>
<NAME>GST_IS_PULSE_DEVICE_PROVIDER</NAME>
#define GST_IS_PULSE_DEVICE_PROVIDER(obj)              (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GST_TYPE_PULSE_DEVICE_PROVIDER))
</MACRO>
<MACRO>
<NAME>GST_IS_PULSE_DEVICE_PROVIDER_CLASS</NAME>
#define GST_IS_PULSE_DEVICE_PROVIDER_CLASS(klass)      (G_TYPE_CHECK_CLASS_TYPE ((klass), GST_TYPE_PULSE_DEVICE_PROVIDER))
</MACRO>
<MACRO>
<NAME>GST_PULSE_DEVICE_PROVIDER_GET_CLASS</NAME>
#define GST_PULSE_DEVICE_PROVIDER_GET_CLASS(obj)       (G_TYPE_INSTANCE_GET_CLASS ((obj), GST_TYPE_PULSE_DEVICE_PROVIDER, GstPulseDeviceProviderClass))
</MACRO>
<MACRO>
<NAME>GST_PULSE_DEVICE_PROVIDER</NAME>
#define GST_PULSE_DEVICE_PROVIDER(obj)                 (G_TYPE_CHECK_INSTANCE_CAST ((obj), GST_TYPE_PULSE_DEVICE_PROVIDER, GstPulseDeviceProvider))
</MACRO>
<MACRO>
<NAME>GST_PULSE_DEVICE_PROVIDER_CLASS</NAME>
#define GST_PULSE_DEVICE_PROVIDER_CLASS(klass)         (G_TYPE_CHECK_CLASS_CAST ((klass), GST_TYPE_DEVICE_PROVIDER, GstPulseDeviceProviderClass))
</MACRO>
<MACRO>
<NAME>GST_PULSE_DEVICE_PROVIDER_CAST</NAME>
#define GST_PULSE_DEVICE_PROVIDER_CAST(obj)            ((GstPulseDeviceProvider *)(obj))
</MACRO>
<STRUCT>
<NAME>GstPulseDeviceProvider</NAME>
struct _GstPulseDeviceProvider {
  GstDeviceProvider         parent;

  gchar *server;
  gchar *client_name;

  pa_threaded_mainloop *mainloop;
  pa_context *context;
};
</STRUCT>
<ENUM>
<NAME>GstPulseDeviceType</NAME>
typedef enum {
  GST_PULSE_DEVICE_TYPE_SOURCE,
  GST_PULSE_DEVICE_TYPE_SINK
} GstPulseDeviceType;
</ENUM>
<STRUCT>
<NAME>GstPulseDeviceProviderClass</NAME>
struct _GstPulseDeviceProviderClass {
  GstDeviceProviderClass    parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_pulse_device_provider_get_type</NAME>
<RETURNS>GType         </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_PULSE_DEVICE</NAME>
#define GST_TYPE_PULSE_DEVICE                 (gst_pulse_device_get_type())
</MACRO>
<MACRO>
<NAME>GST_IS_PULSE_DEVICE</NAME>
#define GST_IS_PULSE_DEVICE(obj)              (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GST_TYPE_PULSE_DEVICE))
</MACRO>
<MACRO>
<NAME>GST_IS_PULSE_DEVICE_CLASS</NAME>
#define GST_IS_PULSE_DEVICE_CLASS(klass)      (G_TYPE_CHECK_CLASS_TYPE ((klass), GST_TYPE_PULSE_DEVICE))
</MACRO>
<MACRO>
<NAME>GST_PULSE_DEVICE_GET_CLASS</NAME>
#define GST_PULSE_DEVICE_GET_CLASS(obj)       (G_TYPE_INSTANCE_GET_CLASS ((obj), GST_TYPE_PULSE_DEVICE, GstPulseDeviceClass))
</MACRO>
<MACRO>
<NAME>GST_PULSE_DEVICE</NAME>
#define GST_PULSE_DEVICE(obj)                 (G_TYPE_CHECK_INSTANCE_CAST ((obj), GST_TYPE_PULSE_DEVICE, GstPulseDevice))
</MACRO>
<MACRO>
<NAME>GST_PULSE_DEVICE_CLASS</NAME>
#define GST_PULSE_DEVICE_CLASS(klass)         (G_TYPE_CHECK_CLASS_CAST ((klass), GST_TYPE_DEVICE, GstPulseDeviceClass))
</MACRO>
<MACRO>
<NAME>GST_PULSE_DEVICE_CAST</NAME>
#define GST_PULSE_DEVICE_CAST(obj)            ((GstPulseDevice *)(obj))
</MACRO>
<STRUCT>
<NAME>GstPulseDevice</NAME>
struct _GstPulseDevice {
  GstDevice         parent;

  GstPulseDeviceType type;
  guint             device_index;
  gchar            *internal_name;
  const gchar      *element;
};
</STRUCT>
<STRUCT>
<NAME>GstPulseDeviceClass</NAME>
struct _GstPulseDeviceClass {
  GstDeviceClass    parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_pulse_device_get_type</NAME>
<RETURNS>GType         </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_pulse_fill_sample_spec</NAME>
<RETURNS>gboolean  </RETURNS>
GstAudioRingBufferSpec * spec, pa_sample_spec * ss
</FUNCTION>
<FUNCTION>
<NAME>gst_pulse_fill_format_info</NAME>
<RETURNS>gboolean  </RETURNS>
GstAudioRingBufferSpec * spec, pa_format_info ** f, guint * channels
</FUNCTION>
<FUNCTION>
<NAME>gst_pulse_sample_format_to_caps_format</NAME>
<RETURNS>const char  * </RETURNS>
pa_sample_format_t sf
</FUNCTION>
<FUNCTION>
<NAME>gst_pulse_client_name</NAME>
<RETURNS>gchar  *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_pulse_gst_to_channel_map</NAME>
<RETURNS>pa_channel_map  *</RETURNS>
pa_channel_map * map, const GstAudioRingBufferSpec * spec
</FUNCTION>
<FUNCTION>
<NAME>gst_pulse_channel_map_to_gst</NAME>
<RETURNS>GstAudioRingBufferSpec  *</RETURNS>
const pa_channel_map * map, GstAudioRingBufferSpec * spec
</FUNCTION>
<FUNCTION>
<NAME>gst_pulse_cvolume_from_linear</NAME>
<RETURNS>void  </RETURNS>
pa_cvolume *v, unsigned channels, gdouble volume
</FUNCTION>
<FUNCTION>
<NAME>gst_pulse_make_proplist</NAME>
<RETURNS>pa_proplist  *</RETURNS>
const GstStructure *properties
</FUNCTION>
<FUNCTION>
<NAME>gst_pulse_make_structure</NAME>
<RETURNS>GstStructure  *</RETURNS>
pa_proplist *properties
</FUNCTION>
<FUNCTION>
<NAME>gst_pulse_format_info_to_caps</NAME>
<RETURNS>GstCaps  * </RETURNS>
pa_format_info * format
</FUNCTION>
<FUNCTION>
<NAME>gst_1394_type_add_property_probe_interface</NAME>
<RETURNS>void  </RETURNS>
GType type
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_1394_CLOCK</NAME>
#define GST_TYPE_1394_CLOCK \
  (gst_1394_clock_get_type())
</MACRO>
<MACRO>
<NAME>GST_1394_CLOCK</NAME>
#define GST_1394_CLOCK(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_1394_CLOCK,Gst1394Clock))
</MACRO>
<MACRO>
<NAME>GST_1394_CLOCK_CLASS</NAME>
#define GST_1394_CLOCK_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_1394_CLOCK,Gst1394ClockClass))
</MACRO>
<MACRO>
<NAME>GST_IS_1394_CLOCK</NAME>
#define GST_IS_1394_CLOCK(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_1394_CLOCK))
</MACRO>
<MACRO>
<NAME>GST_IS_1394_CLOCK_CLASS</NAME>
#define GST_IS_1394_CLOCK_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_1394_CLOCK))
</MACRO>
<MACRO>
<NAME>GST_1394_CLOCK_CAST</NAME>
#define GST_1394_CLOCK_CAST(obj) \
  ((Gst1394Clock*)(obj))
</MACRO>
<STRUCT>
<NAME>Gst1394Clock</NAME>
struct _Gst1394Clock {
  GstSystemClock clock;

  raw1394handle_t handle;

  guint32 cycle_timer_lo;
  guint32 cycle_timer_hi;
};
</STRUCT>
<STRUCT>
<NAME>Gst1394ClockClass</NAME>
struct _Gst1394ClockClass {
  GstSystemClockClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_1394_clock_get_type</NAME>
<RETURNS>GType            </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_1394_clock_new</NAME>
<RETURNS>Gst1394Clock *   </RETURNS>
const gchar *name
</FUNCTION>
<FUNCTION>
<NAME>gst_1394_clock_set_handle</NAME>
<RETURNS>void             </RETURNS>
Gst1394Clock *clock, raw1394handle_t handle
</FUNCTION>
<FUNCTION>
<NAME>gst_1394_clock_unset_handle</NAME>
<RETURNS>void             </RETURNS>
Gst1394Clock *clock
</FUNCTION>
<FUNCTION>
<NAME>gst_soup_util_log_setup</NAME>
<RETURNS>void  </RETURNS>
SoupSession * session, SoupLoggerLogLevel level, GstElement * element
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_SOUP_HTTP_CLIENT_SINK</NAME>
#define GST_TYPE_SOUP_HTTP_CLIENT_SINK           (gst_soup_http_client_sink_get_type())
</MACRO>
<MACRO>
<NAME>GST_SOUP_HTTP_CLIENT_SINK</NAME>
#define GST_SOUP_HTTP_CLIENT_SINK(obj)           (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_SOUP_HTTP_CLIENT_SINK,GstSoupHttpClientSink))
</MACRO>
<MACRO>
<NAME>GST_SOUP_HTTP_CLIENT_SINK_CLASS</NAME>
#define GST_SOUP_HTTP_CLIENT_SINK_CLASS(klass)   (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_SOUP_HTTP_CLIENT_SINK,GstSoupHttpClientSinkClass))
</MACRO>
<MACRO>
<NAME>GST_IS_SOUP_HTTP_CLIENT_SINK</NAME>
#define GST_IS_SOUP_HTTP_CLIENT_SINK(obj)        (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_SOUP_HTTP_CLIENT_SINK))
</MACRO>
<MACRO>
<NAME>GST_IS_SOUP_HTTP_CLIENT_SINK_CLASS</NAME>
#define GST_IS_SOUP_HTTP_CLIENT_SINK_CLASS(obj)  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_SOUP_HTTP_CLIENT_SINK))
</MACRO>
<STRUCT>
<NAME>GstSoupHttpClientSink</NAME>
struct _GstSoupHttpClientSink
{
  GstBaseSink base_souphttpsink;

  GMutex mutex;
  GCond cond;
  GMainContext *context;
  GMainLoop *loop;
  GThread *thread;
  GSource *timer;
  SoupMessage *message;
  SoupSession *session;
  GList *queued_buffers;
  GList *sent_buffers;
  GList *streamheader_buffers;

  int status_code;
  char *reason_phrase;

  guint64 offset;
  int timeout;
  gint failures;

  /* properties */
  SoupSession *prop_session;
  char *location;
  char *user_id;
  char *user_pw;
  SoupURI *proxy;
  char *proxy_id;
  char *proxy_pw;
  char *user_agent;
  gboolean automatic_redirect;
  gchar **cookies;
  SoupLoggerLogLevel log_level;
  gint retry_delay;
  gint retries;
};
</STRUCT>
<STRUCT>
<NAME>GstSoupHttpClientSinkClass</NAME>
struct _GstSoupHttpClientSinkClass
{
  GstBaseSinkClass base_souphttpsink_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_soup_http_client_sink_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_IDCT_METHOD</NAME>
#define GST_TYPE_IDCT_METHOD (gst_idct_method_get_type())
</MACRO>
<FUNCTION>
<NAME>gst_idct_method_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>ID_UNIQUE</NAME>
#define ID_UNIQUE               0x3f
</MACRO>
<MACRO>
<NAME>ID_OPTIONAL_DATA</NAME>
#define ID_OPTIONAL_DATA        0x20
</MACRO>
<MACRO>
<NAME>ID_ODD_SIZE</NAME>
#define ID_ODD_SIZE             0x40
</MACRO>
<MACRO>
<NAME>ID_LARGE</NAME>
#define ID_LARGE                0x80
</MACRO>
<MACRO>
<NAME>ID_DUMMY</NAME>
#define ID_DUMMY                0x0
</MACRO>
<MACRO>
<NAME>ID_ENCODER_INFO</NAME>
#define ID_ENCODER_INFO         0x1
</MACRO>
<MACRO>
<NAME>ID_DECORR_TERMS</NAME>
#define ID_DECORR_TERMS         0x2
</MACRO>
<MACRO>
<NAME>ID_DECORR_WEIGHTS</NAME>
#define ID_DECORR_WEIGHTS       0x3
</MACRO>
<MACRO>
<NAME>ID_DECORR_SAMPLES</NAME>
#define ID_DECORR_SAMPLES       0x4
</MACRO>
<MACRO>
<NAME>ID_ENTROPY_VARS</NAME>
#define ID_ENTROPY_VARS         0x5
</MACRO>
<MACRO>
<NAME>ID_HYBRID_PROFILE</NAME>
#define ID_HYBRID_PROFILE       0x6
</MACRO>
<MACRO>
<NAME>ID_SHAPING_WEIGHTS</NAME>
#define ID_SHAPING_WEIGHTS      0x7
</MACRO>
<MACRO>
<NAME>ID_FLOAT_INFO</NAME>
#define ID_FLOAT_INFO           0x8
</MACRO>
<MACRO>
<NAME>ID_INT32_INFO</NAME>
#define ID_INT32_INFO           0x9
</MACRO>
<MACRO>
<NAME>ID_WV_BITSTREAM</NAME>
#define ID_WV_BITSTREAM         0xa
</MACRO>
<MACRO>
<NAME>ID_WVC_BITSTREAM</NAME>
#define ID_WVC_BITSTREAM        0xb
</MACRO>
<MACRO>
<NAME>ID_WVX_BITSTREAM</NAME>
#define ID_WVX_BITSTREAM        0xc
</MACRO>
<MACRO>
<NAME>ID_CHANNEL_INFO</NAME>
#define ID_CHANNEL_INFO         0xd
</MACRO>
<MACRO>
<NAME>ID_RIFF_HEADER</NAME>
#define ID_RIFF_HEADER          (ID_OPTIONAL_DATA | 0x1)
</MACRO>
<MACRO>
<NAME>ID_RIFF_TRAILER</NAME>
#define ID_RIFF_TRAILER         (ID_OPTIONAL_DATA | 0x2)
</MACRO>
<MACRO>
<NAME>ID_REPLAY_GAIN</NAME>
#define ID_REPLAY_GAIN          (ID_OPTIONAL_DATA | 0x3)
</MACRO>
<MACRO>
<NAME>ID_CUESHEET</NAME>
#define ID_CUESHEET             (ID_OPTIONAL_DATA | 0x4)
</MACRO>
<MACRO>
<NAME>ID_CONFIG_BLOCK</NAME>
#define ID_CONFIG_BLOCK         (ID_OPTIONAL_DATA | 0x5)
</MACRO>
<MACRO>
<NAME>ID_MD5_CHECKSUM</NAME>
#define ID_MD5_CHECKSUM         (ID_OPTIONAL_DATA | 0x6)
</MACRO>
<MACRO>
<NAME>ID_SAMPLE_RATE</NAME>
#define ID_SAMPLE_RATE          (ID_OPTIONAL_DATA | 0x7)
</MACRO>
<FUNCTION>
<NAME>gst_wavpack_read_header</NAME>
<RETURNS>gboolean  </RETURNS>
WavpackHeader * header, guint8 * buf
</FUNCTION>
<FUNCTION>
<NAME>gst_wavpack_read_metadata</NAME>
<RETURNS>gboolean  </RETURNS>
GstWavpackMetadata * meta, guint8 * header_data, guint8 ** p_data
</FUNCTION>
<FUNCTION>
<NAME>gst_wavpack_get_default_channel_mask</NAME>
<RETURNS>gint  </RETURNS>
gint nchannels
</FUNCTION>
<FUNCTION>
<NAME>gst_wavpack_get_channel_positions</NAME>
<RETURNS>gboolean  </RETURNS>
gint nchannels, gint layout, GstAudioChannelPosition *pos
</FUNCTION>
<FUNCTION>
<NAME>gst_wavpack_get_default_channel_positions</NAME>
<RETURNS>GstAudioChannelPosition  *</RETURNS>
gint nchannels
</FUNCTION>
<FUNCTION>
<NAME>gst_wavpack_get_channel_mask_from_positions</NAME>
<RETURNS>gint  </RETURNS>
GstAudioChannelPosition *pos, gint nchannels
</FUNCTION>
<FUNCTION>
<NAME>gst_wavpack_set_channel_mapping</NAME>
<RETURNS>gboolean  </RETURNS>
GstAudioChannelPosition *pos, gint nchannels, gint8 *channel_mapping
</FUNCTION>
<FUNCTION>
<NAME>gst_wavpack_stream_reader_new</NAME>
<RETURNS>WavpackStreamReader  *</RETURNS>
void
</FUNCTION>
<ENUM>
<NAME>GstJackClientType</NAME>
typedef enum 
{
  GST_JACK_CLIENT_SOURCE,
  GST_JACK_CLIENT_SINK
} GstJackClientType;
</ENUM>
<FUNCTION>
<NAME>gst_jack_audio_client_init</NAME>
<RETURNS>void                   </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_jack_audio_client_new</NAME>
<RETURNS>GstJackAudioClient  *  </RETURNS>
const gchar *id, const gchar *server, jack_client_t *jclient, GstJackClientType type, void (*shutdown) (void *arg), JackProcessCallback    process, JackBufferSizeCallback buffer_size, JackSampleRateCallback sample_rate, gpointer user_data, jack_status_t *status
</FUNCTION>
<FUNCTION>
<NAME>gst_jack_audio_client_free</NAME>
<RETURNS>void                   </RETURNS>
GstJackAudioClient *client
</FUNCTION>
<FUNCTION>
<NAME>gst_jack_audio_client_get_client</NAME>
<RETURNS>jack_client_t  *       </RETURNS>
GstJackAudioClient *client
</FUNCTION>
<FUNCTION>
<NAME>gst_jack_audio_client_set_active</NAME>
<RETURNS>gboolean               </RETURNS>
GstJackAudioClient *client, gboolean active
</FUNCTION>
<FUNCTION>
<NAME>gst_jack_audio_client_get_transport_state</NAME>
<RETURNS>GstState               </RETURNS>
GstJackAudioClient *client
</FUNCTION>
<STRUCT>
<NAME>GstJackAudioClient</NAME>
</STRUCT>
<ENUM>
<NAME>GstJackConnect</NAME>
typedef enum {
  GST_JACK_CONNECT_NONE,
  GST_JACK_CONNECT_AUTO,
  GST_JACK_CONNECT_AUTO_FORCED
} GstJackConnect;
</ENUM>
<ENUM>
<NAME>GstJackTransport</NAME>
typedef enum {
  GST_JACK_TRANSPORT_AUTONOMOUS = 0,
  GST_JACK_TRANSPORT_MASTER = (1 << 0),
  GST_JACK_TRANSPORT_SLAVE = (1 << 1),
} GstJackTransport;
</ENUM>
<TYPEDEF>
<NAME>sample_t</NAME>
typedef jack_default_audio_sample_t sample_t;
</TYPEDEF>
<MACRO>
<NAME>GST_TYPE_JACK_CONNECT</NAME>
#define GST_TYPE_JACK_CONNECT   (gst_jack_connect_get_type ())
</MACRO>
<MACRO>
<NAME>GST_TYPE_JACK_TRANSPORT</NAME>
#define GST_TYPE_JACK_TRANSPORT (gst_jack_transport_get_type ())
</MACRO>
<MACRO>
<NAME>GST_TYPE_JACK_CLIENT</NAME>
#define GST_TYPE_JACK_CLIENT    (gst_jack_client_get_type ())
</MACRO>
<MACRO>
<NAME>GST_JACK_FORMAT_STR</NAME>
#define GST_JACK_FORMAT_STR "F32LE"
</MACRO>
<FUNCTION>
<NAME>gst_jack_client_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_jack_connect_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_jack_transport_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_jack_set_layout</NAME>
<RETURNS>void </RETURNS>
GstAudioRingBuffer * buffer, GstAudioRingBufferSpec *spec
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_JACK_RING_BUFFER</NAME>
#define GST_TYPE_JACK_RING_BUFFER               (gst_jack_ring_buffer_get_type())
</MACRO>
<MACRO>
<NAME>GST_JACK_RING_BUFFER</NAME>
#define GST_JACK_RING_BUFFER(obj)               (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_JACK_RING_BUFFER,GstJackRingBuffer))
</MACRO>
<MACRO>
<NAME>GST_JACK_RING_BUFFER_CLASS</NAME>
#define GST_JACK_RING_BUFFER_CLASS(klass)       (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_JACK_RING_BUFFER,GstJackRingBufferClass))
</MACRO>
<MACRO>
<NAME>GST_JACK_RING_BUFFER_GET_CLASS</NAME>
#define GST_JACK_RING_BUFFER_GET_CLASS(obj)     (G_TYPE_INSTANCE_GET_CLASS ((obj), GST_TYPE_JACK_RING_BUFFER,GstJackRingBufferClass))
</MACRO>
<MACRO>
<NAME>GST_JACK_RING_BUFFER_CAST</NAME>
#define GST_JACK_RING_BUFFER_CAST(obj)          ((GstJackRingBuffer *)obj)
</MACRO>
<MACRO>
<NAME>GST_IS_JACK_RING_BUFFER</NAME>
#define GST_IS_JACK_RING_BUFFER(obj)            (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_JACK_RING_BUFFER))
</MACRO>
<MACRO>
<NAME>GST_IS_JACK_RING_BUFFER_CLASS</NAME>
#define GST_IS_JACK_RING_BUFFER_CLASS(klass)    (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_JACK_RING_BUFFER))
</MACRO>
<STRUCT>
<NAME>GstJackRingBuffer</NAME>
struct _GstJackRingBuffer
{
  GstAudioRingBuffer object;

  gint sample_rate;
  gint buffer_size;
  gint channels;
};
</STRUCT>
<STRUCT>
<NAME>GstJackRingBufferClass</NAME>
struct _GstJackRingBufferClass
{
  GstAudioRingBufferClass parent_class;
};
</STRUCT>
<MACRO>
<NAME>GST_TYPE_GDK_PIXBUF_DEC</NAME>
#define GST_TYPE_GDK_PIXBUF_DEC			\
  (gst_gdk_pixbuf_dec_get_type())
</MACRO>
<MACRO>
<NAME>GST_GDK_PIXBUF_DEC</NAME>
#define GST_GDK_PIXBUF_DEC(obj)						\
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_GDK_PIXBUF_DEC,GstGdkPixbufDec))
</MACRO>
<MACRO>
<NAME>GST_GDK_PIXBUF_DEC_CLASS</NAME>
#define GST_GDK_PIXBUF_DEC_CLASS(klass)					\
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_GDK_PIXBUF_DEC,GstGdkPixbufDecClass))
</MACRO>
<MACRO>
<NAME>GST_IS_GDK_PIXBUF_DEC</NAME>
#define GST_IS_GDK_PIXBUF_DEC(obj)					\
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_GDK_PIXBUF_DEC))
</MACRO>
<MACRO>
<NAME>GST_IS_GDK_PIXBUF_DEC_CLASS</NAME>
#define GST_IS_GDK_PIXBUF_DEC_CLASS(klass)				\
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_GDK_PIXBUF_DEC))
</MACRO>
<STRUCT>
<NAME>GstGdkPixbufDec</NAME>
struct _GstGdkPixbufDec
{
  GstElement element;

  GstPad *sinkpad, *srcpad;

  GstClockTime      last_timestamp;
  GdkPixbufLoader  *pixbuf_loader;

  gint in_fps_n, in_fps_d;

  GstVideoInfo   info;
  GstBufferPool *pool;
  GList         *pending_events;
  gboolean       packetized;
};
</STRUCT>
<STRUCT>
<NAME>GstGdkPixbufDecClass</NAME>
struct _GstGdkPixbufDecClass
{
  GstElementClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_gdk_pixbuf_dec_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_GDK_PIXBUF_OVERLAY</NAME>
#define GST_TYPE_GDK_PIXBUF_OVERLAY   (gst_gdk_pixbuf_overlay_get_type())
</MACRO>
<MACRO>
<NAME>GST_GDK_PIXBUF_OVERLAY</NAME>
#define GST_GDK_PIXBUF_OVERLAY(obj)   (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_GDK_PIXBUF_OVERLAY,GstGdkPixbufOverlay))
</MACRO>
<MACRO>
<NAME>GST_GDK_PIXBUF_OVERLAY_CLASS</NAME>
#define GST_GDK_PIXBUF_OVERLAY_CLASS(klass)   (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_GDK_PIXBUF_OVERLAY,GstGdkPixbufOverlayClass))
</MACRO>
<MACRO>
<NAME>GST_IS_GDK_PIXBUF_OVERLAY</NAME>
#define GST_IS_GDK_PIXBUF_OVERLAY(obj)   (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_GDK_PIXBUF_OVERLAY))
</MACRO>
<MACRO>
<NAME>GST_IS_GDK_PIXBUF_OVERLAY_CLASS</NAME>
#define GST_IS_GDK_PIXBUF_OVERLAY_CLASS(obj)   (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_GDK_PIXBUF_OVERLAY))
</MACRO>
<ENUM>
<NAME>GstGdkPixbufPositioningMode</NAME>
typedef enum {
  GST_GDK_PIXBUF_POSITIONING_PIXELS_RELATIVE_TO_EDGES,
  GST_GDK_PIXBUF_POSITIONING_PIXELS_ABSOLUTE
} GstGdkPixbufPositioningMode;
</ENUM>
<STRUCT>
<NAME>GstGdkPixbufOverlay</NAME>
struct _GstGdkPixbufOverlay
{
  GstVideoFilter               videofilter;

  /* properties */
  gchar                      * location;

  /* pixbuf set via pixbuf property */
  GdkPixbuf                  * pixbuf;

  gint                         offset_x;
  gint                         offset_y;

  gdouble                      relative_x;
  gdouble                      relative_y;

  gdouble                      coef_x;
  gdouble                      coef_y;

  GstGdkPixbufPositioningMode  positioning_mode;

  gint                         overlay_width;
  gint                         overlay_height;

  gdouble                      alpha;

  /* the loaded image, as BGRA/ARGB pixels, with GstVideoMeta */
  GstBuffer                  * pixels;               /* OBJECT_LOCK */

  GstVideoOverlayComposition * comp;

  /* render position or dimension has changed */
  gboolean                     update_composition;
};
</STRUCT>
<STRUCT>
<NAME>GstGdkPixbufOverlayClass</NAME>
struct _GstGdkPixbufOverlayClass
{
  GstVideoFilterClass  videofilter_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_gdk_pixbuf_overlay_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<ENUM>
<NAME>GstSMPTETimeCodeSystem</NAME>
typedef enum {
  GST_SMPTE_TIME_CODE_SYSTEM_30 = 0,
  GST_SMPTE_TIME_CODE_SYSTEM_25,
  GST_SMPTE_TIME_CODE_SYSTEM_24
} GstSMPTETimeCodeSystem;
</ENUM>
<STRUCT>
<NAME>GstSMPTETimeCode</NAME>
struct _GstSMPTETimeCode {
  int hours;
  int minutes;
  int seconds;
  int frames;
};
</STRUCT>
<MACRO>
<NAME>GST_SMPTE_TIME_CODE_SYSTEM_IS_VALID</NAME>
#define GST_SMPTE_TIME_CODE_SYSTEM_IS_VALID(x) \
  ((x) >= GST_SMPTE_TIME_CODE_SYSTEM_30 && (x) <= GST_SMPTE_TIME_CODE_SYSTEM_24)
</MACRO>
<MACRO>
<NAME>GST_SMPTE_TIME_CODE_FORMAT</NAME>
#define GST_SMPTE_TIME_CODE_FORMAT "02d:%02d:%02d:%02d"
</MACRO>
<MACRO>
<NAME>GST_SMPTE_TIME_CODE_ARGS</NAME>
#define GST_SMPTE_TIME_CODE_ARGS(timecode) \
  (timecode)->hours, (timecode)->minutes, \
  (timecode)->seconds, (timecode)->frames
</MACRO>
<FUNCTION>
<NAME>gst_smpte_time_code_is_valid</NAME>
<RETURNS>gboolean  </RETURNS>
GstSMPTETimeCodeSystem system, GstSMPTETimeCode *time_code
</FUNCTION>
<FUNCTION>
<NAME>gst_smpte_time_code_from_frame_number</NAME>
<RETURNS>gboolean  </RETURNS>
GstSMPTETimeCodeSystem system, GstSMPTETimeCode *time_code, int frame_number
</FUNCTION>
<FUNCTION>
<NAME>gst_smpte_time_code_get_frame_number</NAME>
<RETURNS>gboolean  </RETURNS>
GstSMPTETimeCodeSystem system, int *frame_number, GstSMPTETimeCode *time_code
</FUNCTION>
<FUNCTION>
<NAME>gst_smpte_time_code_get_timestamp</NAME>
<RETURNS>GstClockTime  </RETURNS>
GstSMPTETimeCodeSystem system, GstSMPTETimeCode *time_code
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_VPX_DEC</NAME>
#define GST_TYPE_VPX_DEC \
  (gst_vpx_dec_get_type())
</MACRO>
<MACRO>
<NAME>GST_VPX_DEC</NAME>
#define GST_VPX_DEC(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_VPX_DEC,GstVPXDec))
</MACRO>
<MACRO>
<NAME>GST_VPX_DEC_CLASS</NAME>
#define GST_VPX_DEC_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_VPX_DEC,GstVPXDecClass))
</MACRO>
<MACRO>
<NAME>GST_IS_VPX_DEC</NAME>
#define GST_IS_VPX_DEC(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_VPX_DEC))
</MACRO>
<MACRO>
<NAME>GST_IS_VPX_DEC_CLASS</NAME>
#define GST_IS_VPX_DEC_CLASS(obj) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_VPX_DEC))
</MACRO>
<MACRO>
<NAME>GST_VPX_DEC_GET_CLASS</NAME>
#define GST_VPX_DEC_GET_CLASS(obj)     (G_TYPE_INSTANCE_GET_CLASS ((obj), GST_TYPE_VPX_DEC, GstVPXDecClass))
</MACRO>
<STRUCT>
<NAME>GstVPXDec</NAME>
struct _GstVPXDec
{
  GstVideoDecoder base_video_decoder;

  /* < private > */
  vpx_codec_ctx_t decoder;

  /* state */
  gboolean decoder_inited;

  /* properties */
  gboolean post_processing;
  enum vp8_postproc_level post_processing_flags;
  gint deblocking_level;
  gint noise_level;
  gint threads;

  GstVideoCodecState *input_state;
  GstVideoCodecState *output_state;

  /* allocation */
  gboolean have_video_meta;
  GstBufferPool *pool;
  gsize buf_size;
};
</STRUCT>
<STRUCT>
<NAME>GstVPXDecClass</NAME>
struct _GstVPXDecClass
{
  GstVideoDecoderClass base_video_decoder_class;
  const char* video_codec_tag;
  /*supported vpx algo*/
  vpx_codec_iface_t* codec_algo;
  /*virtual function to open_codec*/
  GstFlowReturn (*open_codec) (GstVPXDec * dec, GstVideoCodecFrame * frame);
  /*virtual function to send tags*/
  void (*send_tags) (GstVPXDec* dec);
  /*virtual function to set/correct the stream info*/
  void (*set_stream_info) (GstVPXDec *dec, vpx_codec_stream_info_t *stream_info);
  /*virtual function to set default format while opening codec*/
  void (*set_default_format) (GstVPXDec *dec, GstVideoFormat fmt, int width, int height);
  /*virtual function to negotiate format while handling frame*/
  void (*handle_resolution_change) (GstVPXDec *dec, vpx_image_t *img, GstVideoFormat fmt);
  /*virtual function to check valid format*/
  gboolean (*get_frame_format)(GstVPXDec *dec, vpx_image_t *img, GstVideoFormat* fmt);
};
</STRUCT>
<FUNCTION>
<NAME>gst_vpx_dec_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_vpx_error_name</NAME>
<RETURNS>const char  * </RETURNS>
vpx_codec_err_t status
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_VP9_DEC</NAME>
#define GST_TYPE_VP9_DEC \
  (gst_vp9_dec_get_type())
</MACRO>
<MACRO>
<NAME>GST_VP9_DEC</NAME>
#define GST_VP9_DEC(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_VP9_DEC,GstVP9Dec))
</MACRO>
<MACRO>
<NAME>GST_VP9_DEC_CLASS</NAME>
#define GST_VP9_DEC_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_VP9_DEC,GstVP9DecClass))
</MACRO>
<MACRO>
<NAME>GST_IS_VP9_DEC</NAME>
#define GST_IS_VP9_DEC(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_VP9_DEC))
</MACRO>
<MACRO>
<NAME>GST_IS_VP9_DEC_CLASS</NAME>
#define GST_IS_VP9_DEC_CLASS(obj) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_VP9_DEC))
</MACRO>
<STRUCT>
<NAME>GstVP9Dec</NAME>
struct _GstVP9Dec
{
  GstVPXDec base_vpx_decoder;
};
</STRUCT>
<STRUCT>
<NAME>GstVP9DecClass</NAME>
struct _GstVP9DecClass
{
  GstVPXDecClass base_vpx_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_vp9_dec_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_VPX_ENC</NAME>
#define GST_TYPE_VPX_ENC \
  (gst_vpx_enc_get_type())
</MACRO>
<MACRO>
<NAME>GST_VPX_ENC</NAME>
#define GST_VPX_ENC(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_VPX_ENC,GstVPXEnc))
</MACRO>
<MACRO>
<NAME>GST_VPX_ENC_CLASS</NAME>
#define GST_VPX_ENC_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_VPX_ENC,GstVPXEncClass))
</MACRO>
<MACRO>
<NAME>GST_IS_VPX_ENC</NAME>
#define GST_IS_VPX_ENC(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_VPX_ENC))
</MACRO>
<MACRO>
<NAME>GST_IS_VPX_ENC_CLASS</NAME>
#define GST_IS_VPX_ENC_CLASS(obj) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_VPX_ENC))
</MACRO>
<MACRO>
<NAME>GST_VPX_ENC_GET_CLASS</NAME>
#define GST_VPX_ENC_GET_CLASS(obj)     (G_TYPE_INSTANCE_GET_CLASS ((obj), GST_TYPE_VPX_ENC, GstVPXEncClass))
</MACRO>
<STRUCT>
<NAME>GstVPXEnc</NAME>
struct _GstVPXEnc
{
  GstVideoEncoder base_video_encoder;

  /* < private > */
  vpx_codec_ctx_t encoder;
  GMutex encoder_lock;

  /* properties */
  vpx_codec_enc_cfg_t cfg;
  gboolean have_default_config;
  gboolean rc_target_bitrate_set;
  gint n_ts_target_bitrate;
  gint n_ts_rate_decimator;
  gint n_ts_layer_id;
  /* Global two-pass options */
  gchar *multipass_cache_file;
  gchar *multipass_cache_prefix;
  guint multipass_cache_idx;
  GByteArray *first_pass_cache_content;

  /* Encode parameter */
  gint64 deadline;

  /* Controls */
  VPX_SCALING_MODE h_scaling_mode;
  VPX_SCALING_MODE v_scaling_mode;
  int cpu_used;
  gboolean enable_auto_alt_ref;
  unsigned int noise_sensitivity;
  unsigned int sharpness;
  unsigned int static_threshold;
  vp8e_token_partitions token_partitions;
  unsigned int arnr_maxframes;
  unsigned int arnr_strength;
  unsigned int arnr_type;
  vp8e_tuning tuning;
  unsigned int cq_level;
  unsigned int max_intra_bitrate_pct;
  /* Timebase - a value of 0 will use the framerate */
  unsigned int timebase_n;
  unsigned int timebase_d;

  /* state */
  gboolean inited;

  vpx_image_t image;

  GstClockTime last_pts;

  GstVideoCodecState *input_state;
};
</STRUCT>
<STRUCT>
<NAME>GstVPXEncClass</NAME>
struct _GstVPXEncClass
{
  GstVideoEncoderClass base_video_encoder_class;
  /*virtual function to get supported algo*/
  vpx_codec_iface_t* (*get_algo) (GstVPXEnc *enc);
  /*enabled scaling*/
  gboolean (*enable_scaling) (GstVPXEnc *enc);
  /*set image format info*/
  void (*set_image_format) (GstVPXEnc *enc, vpx_image_t *image);
  /*get new simple caps*/
  GstCaps* (*get_new_vpx_caps) (GstVPXEnc *enc);
  /*set stream info*/
  void (*set_stream_info) (GstVPXEnc *enc, GstCaps *caps, GstVideoInfo *info);
  /*process user data*/
  void* (*process_frame_user_data) (GstVPXEnc *enc, GstVideoCodecFrame* frame);
  /*set frame user data*/
  void (*set_frame_user_data) (GstVPXEnc *enc, GstVideoCodecFrame* frame, vpx_image_t *image);
  /*Handle invisible frame*/
  GstFlowReturn (*handle_invisible_frame_buffer) (GstVPXEnc *enc, void* user_data, GstBuffer* buffer);
};
</STRUCT>
<FUNCTION>
<NAME>gst_vpx_enc_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_VP9_ENC</NAME>
#define GST_TYPE_VP9_ENC \
  (gst_vp9_enc_get_type())
</MACRO>
<MACRO>
<NAME>GST_VP9_ENC</NAME>
#define GST_VP9_ENC(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_VP9_ENC,GstVP9Enc))
</MACRO>
<MACRO>
<NAME>GST_VP9_ENC_CLASS</NAME>
#define GST_VP9_ENC_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_VP9_ENC,GstVP9EncClass))
</MACRO>
<MACRO>
<NAME>GST_IS_VP9_ENC</NAME>
#define GST_IS_VP9_ENC(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_VP9_ENC))
</MACRO>
<MACRO>
<NAME>GST_IS_VP9_ENC_CLASS</NAME>
#define GST_IS_VP9_ENC_CLASS(obj) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_VP9_ENC))
</MACRO>
<STRUCT>
<NAME>GstVP9Enc</NAME>
struct _GstVP9Enc
{
	GstVPXEnc base_vpx_encoder;
};
</STRUCT>
<STRUCT>
<NAME>GstVP9EncClass</NAME>
struct _GstVP9EncClass
{
  GstVPXEncClass  base_vpxenc_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_vp9_enc_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_core_audio_bind_device</NAME>
<RETURNS>gboolean  </RETURNS>
GstCoreAudio *core_audio
</FUNCTION>
<FUNCTION>
<NAME>gst_core_audio_dump_channel_layout</NAME>
<RETURNS>void  </RETURNS>
AudioChannelLayout * channel_layout
</FUNCTION>
<FUNCTION>
<NAME>gst_core_audio_remove_render_callback</NAME>
<RETURNS>void  </RETURNS>
GstCoreAudio * core_audio
</FUNCTION>
<FUNCTION>
<NAME>gst_core_audio_io_proc_start</NAME>
<RETURNS>gboolean  </RETURNS>
GstCoreAudio * core_audio
</FUNCTION>
<FUNCTION>
<NAME>gst_core_audio_io_proc_stop</NAME>
<RETURNS>gboolean  </RETURNS>
GstCoreAudio * core_audio
</FUNCTION>
<FUNCTION>
<NAME>buffer_list_alloc</NAME>
<RETURNS>AudioBufferList  * </RETURNS>
UInt32 channels, UInt32 size, gboolean interleaved
</FUNCTION>
<FUNCTION>
<NAME>buffer_list_free</NAME>
<RETURNS>void  </RETURNS>
AudioBufferList * list
</FUNCTION>
<FUNCTION>
<NAME>gst_core_audio_set_format</NAME>
<RETURNS>gboolean  </RETURNS>
GstCoreAudio * core_audio, AudioStreamBasicDescription format
</FUNCTION>
<FUNCTION>
<NAME>gst_core_audio_set_channel_layout</NAME>
<RETURNS>gboolean  </RETURNS>
GstCoreAudio * core_audio, gint channels, GstCaps * caps
</FUNCTION>
<FUNCTION>
<NAME>gst_core_audio_open_device</NAME>
<RETURNS>gboolean  </RETURNS>
GstCoreAudio *core_audio, OSType sub_type, const gchar *adesc
</FUNCTION>
<FUNCTION>
<NAME>gst_core_audio_render_notify</NAME>
<RETURNS>OSStatus  </RETURNS>
GstCoreAudio * core_audio, AudioUnitRenderActionFlags * ioActionFlags, const AudioTimeStamp * inTimeStamp, unsigned int inBusNumber, unsigned int inNumberFrames, AudioBufferList * ioData
</FUNCTION>
<FUNCTION>
<NAME>gst_audio_channel_position_to_core_audio</NAME>
<RETURNS>AudioChannelLabel  </RETURNS>
GstAudioChannelPosition position, int channel
</FUNCTION>
<FUNCTION>
<NAME>gst_core_audio_channel_label_to_gst</NAME>
<RETURNS>GstAudioChannelPosition  </RETURNS>
AudioChannelLabel label, int channel, gboolean warn
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_OSX_AUDIO_DEVICE_PROVIDER</NAME>
#define GST_TYPE_OSX_AUDIO_DEVICE_PROVIDER                 (gst_osx_audio_device_provider_get_type())
</MACRO>
<MACRO>
<NAME>GST_IS_OSX_AUDIO_DEVICE_PROVIDER</NAME>
#define GST_IS_OSX_AUDIO_DEVICE_PROVIDER(obj)              (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GST_TYPE_OSX_AUDIO_DEVICE_PROVIDER))
</MACRO>
<MACRO>
<NAME>GST_IS_OSX_AUDIO_DEVICE_PROVIDER_CLASS</NAME>
#define GST_IS_OSX_AUDIO_DEVICE_PROVIDER_CLASS(klass)      (G_TYPE_CHECK_CLASS_TYPE ((klass), GST_TYPE_OSX_AUDIO_DEVICE_PROVIDER))
</MACRO>
<MACRO>
<NAME>GST_OSX_AUDIO_DEVICE_PROVIDER_GET_CLASS</NAME>
#define GST_OSX_AUDIO_DEVICE_PROVIDER_GET_CLASS(obj)       (G_TYPE_INSTANCE_GET_CLASS ((obj), GST_TYPE_OSX_AUDIO_DEVICE_PROVIDER, GstOsxAudioDeviceProviderClass))
</MACRO>
<MACRO>
<NAME>GST_OSX_AUDIO_DEVICE_PROVIDER</NAME>
#define GST_OSX_AUDIO_DEVICE_PROVIDER(obj)                 (G_TYPE_CHECK_INSTANCE_CAST ((obj), GST_TYPE_OSX_AUDIO_DEVICE_PROVIDER, GstOsxAudioDeviceProvider))
</MACRO>
<MACRO>
<NAME>GST_OSX_AUDIO_DEVICE_PROVIDER_CLASS</NAME>
#define GST_OSX_AUDIO_DEVICE_PROVIDER_CLASS(klass)         (G_TYPE_CHECK_CLASS_CAST ((klass), GST_TYPE_DEVICE_PROVIDER, GstOsxAudioDeviceProviderClass))
</MACRO>
<MACRO>
<NAME>GST_OSX_AUDIO_DEVICE_PROVIDER_CAST</NAME>
#define GST_OSX_AUDIO_DEVICE_PROVIDER_CAST(obj)            ((GstOsxAudioDeviceProvider *)(obj))
</MACRO>
<STRUCT>
<NAME>GstOsxAudioDeviceProvider</NAME>
struct _GstOsxAudioDeviceProvider
{
  GstDeviceProvider parent;
};
</STRUCT>
<STRUCT>
<NAME>GstOsxAudioDeviceProviderClass</NAME>
struct _GstOsxAudioDeviceProviderClass
{
  GstDeviceProviderClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_osx_audio_device_provider_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_OSX_AUDIO_DEVICE</NAME>
#define GST_TYPE_OSX_AUDIO_DEVICE                 (gst_osx_audio_device_get_type())
</MACRO>
<MACRO>
<NAME>GST_IS_OSX_AUDIO_DEVICE</NAME>
#define GST_IS_OSX_AUDIO_DEVICE(obj)              (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GST_TYPE_OSX_AUDIO_DEVICE))
</MACRO>
<MACRO>
<NAME>GST_IS_OSX_AUDIO_DEVICE_CLASS</NAME>
#define GST_IS_OSX_AUDIO_DEVICE_CLASS(klass)      (G_TYPE_CHECK_CLASS_TYPE ((klass), GST_TYPE_OSX_AUDIO_DEVICE))
</MACRO>
<MACRO>
<NAME>GST_OSX_AUDIO_DEVICE_GET_CLASS</NAME>
#define GST_OSX_AUDIO_DEVICE_GET_CLASS(obj)       (G_TYPE_INSTANCE_GET_CLASS ((obj), GST_TYPE_OSX_AUDIO_DEVICE, GstOsxAudioClass))
</MACRO>
<MACRO>
<NAME>GST_OSX_AUDIO_DEVICE</NAME>
#define GST_OSX_AUDIO_DEVICE(obj)                 (G_TYPE_CHECK_INSTANCE_CAST ((obj), GST_TYPE_OSX_AUDIO_DEVICE, GstOsxAudioDevice))
</MACRO>
<MACRO>
<NAME>GST_OSX_AUDIO_DEVICE_CLASS</NAME>
#define GST_OSX_AUDIO_DEVICE_CLASS(klass)         (G_TYPE_CHECK_CLASS_CAST ((klass), GST_TYPE_DEVICE, GstOsxAudioDeviceClass))
</MACRO>
<MACRO>
<NAME>GST_OSX_AUDIO_DEVICE_CAST</NAME>
#define GST_OSX_AUDIO_DEVICE_CAST(obj)            ((GstOsxAudioDevice *)(obj))
</MACRO>
<ENUM>
<NAME>GstOsxAudioDeviceType</NAME>
typedef enum
{
  GST_OSX_AUDIO_DEVICE_TYPE_INVALID = 0,
  GST_OSX_AUDIO_DEVICE_TYPE_SOURCE,
  GST_OSX_AUDIO_DEVICE_TYPE_SINK
} GstOsxAudioDeviceType;
</ENUM>
<STRUCT>
<NAME>GstOsxAudioDevice</NAME>
struct _GstOsxAudioDevice
{
  GstDevice parent;

  const gchar *element;
  AudioDeviceID device_id;
};
</STRUCT>
<STRUCT>
<NAME>GstOsxAudioDeviceClass</NAME>
struct _GstOsxAudioDeviceClass
{
  GstDeviceClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_osx_audio_device_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>AudioDeviceID</NAME>
  #define AudioDeviceID gint
</MACRO>
<MACRO>
<NAME>kAudioDeviceUnknown</NAME>
  #define kAudioDeviceUnknown 0
</MACRO>
<MACRO>
<NAME>AudioComponentFindNext</NAME>
    #define AudioComponentFindNext FindNextComponent
</MACRO>
<MACRO>
<NAME>AudioComponentInstanceNew</NAME>
    #define AudioComponentInstanceNew OpenAComponent
</MACRO>
<MACRO>
<NAME>AudioComponentInstanceDispose</NAME>
    #define AudioComponentInstanceDispose CloseComponent
</MACRO>
<MACRO>
<NAME>AudioComponent</NAME>
    #define AudioComponent Component
</MACRO>
<MACRO>
<NAME>AudioComponentDescription</NAME>
    #define AudioComponentDescription ComponentDescription
</MACRO>
<MACRO>
<NAME>GST_TYPE_CORE_AUDIO</NAME>
#define GST_TYPE_CORE_AUDIO \
  (gst_core_audio_get_type())
</MACRO>
<MACRO>
<NAME>GST_CORE_AUDIO</NAME>
#define GST_CORE_AUDIO(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_CORE_AUDIO,GstCoreAudio))
</MACRO>
<MACRO>
<NAME>GST_CORE_AUDIO_CLASS</NAME>
#define GST_CORE_AUDIO_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_CORE_AUDIO,GstCoreAudioClass))
</MACRO>
<MACRO>
<NAME>GST_CORE_AUDIO_GET_CLASS</NAME>
#define GST_CORE_AUDIO_GET_CLASS(obj) \
  (G_TYPE_INSTANCE_GET_CLASS((obj),GST_TYPE_CORE_AUDIO,GstCoreAudioClass))
</MACRO>
<MACRO>
<NAME>GST_IS_CORE_AUDIO</NAME>
#define GST_IS_CORE_AUDIO(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_CORE_AUDIO))
</MACRO>
<MACRO>
<NAME>GST_IS_CORE_AUDIO_CLASS</NAME>
#define GST_IS_CORE_AUDIO_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_CORE_AUDIO))
</MACRO>
<MACRO>
<NAME>GST_OSX_AUDIO_MAX_CHANNEL</NAME>
#define GST_OSX_AUDIO_MAX_CHANNEL (9)
</MACRO>
<MACRO>
<NAME>CORE_AUDIO_FORMAT_IS_SPDIF</NAME>
#define CORE_AUDIO_FORMAT_IS_SPDIF(f) ((f).mFormat.mFormatID == 'IAC3' || (f).mFormat.mFormatID == 'iac3' || (f).mFormat.mFormatID == kAudioFormat60958AC3 || (f).mFormat.mFormatID == kAudioFormatAC3)
</MACRO>
<MACRO>
<NAME>CORE_AUDIO_FORMAT</NAME>
#define CORE_AUDIO_FORMAT "FormatID: %" GST_FOURCC_FORMAT " rate: %f flags: 0x%x BytesPerPacket: %u FramesPerPacket: %u BytesPerFrame: %u ChannelsPerFrame: %u BitsPerChannel: %u"
</MACRO>
<MACRO>
<NAME>CORE_AUDIO_FORMAT_ARGS</NAME>
#define CORE_AUDIO_FORMAT_ARGS(f) GST_FOURCC_ARGS((unsigned int)(f).mFormatID),(f).mSampleRate,(unsigned int)(f).mFormatFlags,(unsigned int)(f).mBytesPerPacket,(unsigned int)(f).mFramesPerPacket,(unsigned int)(f).mBytesPerFrame,(unsigned int)(f).mChannelsPerFrame,(unsigned int)(f).mBitsPerChannel
</MACRO>
<MACRO>
<NAME>CORE_AUDIO_INNER_SCOPE</NAME>
#define CORE_AUDIO_INNER_SCOPE(core_audio) ((core_audio)->is_src ? kAudioUnitScope_Output : kAudioUnitScope_Input)
</MACRO>
<MACRO>
<NAME>CORE_AUDIO_OUTER_SCOPE</NAME>
#define CORE_AUDIO_OUTER_SCOPE(core_audio) ((core_audio)->is_src ? kAudioUnitScope_Input : kAudioUnitScope_Output)
</MACRO>
<MACRO>
<NAME>CORE_AUDIO_ELEMENT</NAME>
#define CORE_AUDIO_ELEMENT(core_audio) ((core_audio)->is_src ? 1 : 0)
</MACRO>
<STRUCT>
<NAME>GstCoreAudio</NAME>
struct _GstCoreAudio
{
  GObject object;

  GstObject *osxbuf;
  GstOsxAudioElementInterface *element;

  gboolean is_src;
  gboolean is_passthrough;
  AudioDeviceID device_id;
  gboolean cached_caps_valid; /* thread-safe flag */
  GstCaps *cached_caps;
  gint stream_idx;
  gboolean io_proc_active;
  gboolean io_proc_needs_deactivation;

  /* For LPCM in/out */
  AudioUnit audiounit;
  UInt32 recBufferSize; /* AudioUnitRender clobbers mDataByteSize */
  AudioBufferList *recBufferList;

#ifndef HAVE_IOS
  /* For SPDIF out */
  pid_t hog_pid;
  gboolean disabled_mixing;
  AudioStreamID stream_id;
  gboolean revert_format;
  AudioStreamBasicDescription original_format, stream_format;
  AudioDeviceIOProcID procID;
#endif
};
</STRUCT>
<STRUCT>
<NAME>GstCoreAudioClass</NAME>
struct _GstCoreAudioClass
{
  GObjectClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_core_audio_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_core_audio_init_debug</NAME>
<RETURNS>void  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_core_audio_new</NAME>
<RETURNS>GstCoreAudio  * </RETURNS>
GstObject *osxbuf
</FUNCTION>
<FUNCTION>
<NAME>gst_core_audio_open</NAME>
<RETURNS>gboolean  </RETURNS>
GstCoreAudio *core_audio
</FUNCTION>
<FUNCTION>
<NAME>gst_core_audio_close</NAME>
<RETURNS>gboolean  </RETURNS>
GstCoreAudio *core_audio
</FUNCTION>
<FUNCTION>
<NAME>gst_core_audio_initialize</NAME>
<RETURNS>gboolean  </RETURNS>
GstCoreAudio *core_audio, AudioStreamBasicDescription format, GstCaps *caps, gboolean is_passthrough
</FUNCTION>
<FUNCTION>
<NAME>gst_core_audio_uninitialize</NAME>
<RETURNS>void  </RETURNS>
GstCoreAudio *core_audio
</FUNCTION>
<FUNCTION>
<NAME>gst_core_audio_start_processing</NAME>
<RETURNS>gboolean  </RETURNS>
GstCoreAudio *core_audio
</FUNCTION>
<FUNCTION>
<NAME>gst_core_audio_pause_processing</NAME>
<RETURNS>gboolean  </RETURNS>
GstCoreAudio *core_audio
</FUNCTION>
<FUNCTION>
<NAME>gst_core_audio_stop_processing</NAME>
<RETURNS>gboolean  </RETURNS>
GstCoreAudio *core_audio
</FUNCTION>
<FUNCTION>
<NAME>gst_core_audio_get_samples_and_latency</NAME>
<RETURNS>gboolean  </RETURNS>
GstCoreAudio * core_audio, gdouble rate, guint *samples, gdouble *latency
</FUNCTION>
<FUNCTION>
<NAME>gst_core_audio_set_volume</NAME>
<RETURNS>void   </RETURNS>
GstCoreAudio *core_audio, gfloat volume
</FUNCTION>
<FUNCTION>
<NAME>gst_core_audio_audio_device_is_spdif_avail</NAME>
<RETURNS>gboolean  </RETURNS>
AudioDeviceID device_id
</FUNCTION>
<FUNCTION>
<NAME>gst_core_audio_select_device</NAME>
<RETURNS>gboolean  </RETURNS>
GstCoreAudio * core_audio
</FUNCTION>
<FUNCTION>
<NAME>gst_core_audio_probe_caps</NAME>
<RETURNS>GstCaps  *</RETURNS>
GstCoreAudio * core_audio, GstCaps * in_caps
</FUNCTION>
<FUNCTION>
<NAME>gst_core_audio_get_channel_layout</NAME>
<RETURNS>AudioChannelLayout  *</RETURNS>
GstCoreAudio * core_audio, gboolean outer
</FUNCTION>
<FUNCTION>
<NAME>gst_core_audio_parse_channel_layout</NAME>
<RETURNS>gboolean  </RETURNS>
AudioChannelLayout * layout, guint * channels, guint64 * channel_mask, GstAudioChannelPosition * pos
</FUNCTION>
<FUNCTION>
<NAME>gst_core_audio_asbd_to_caps</NAME>
<RETURNS>GstCaps  * </RETURNS>
AudioStreamBasicDescription * asbd, AudioChannelLayout * layout
</FUNCTION>
<MACRO>
<NAME>GST_OSX_AUDIO_ELEMENT_TYPE</NAME>
#define GST_OSX_AUDIO_ELEMENT_TYPE \
  (gst_osx_audio_element_get_type())
</MACRO>
<MACRO>
<NAME>GST_OSX_AUDIO_ELEMENT</NAME>
#define GST_OSX_AUDIO_ELEMENT(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_OSX_AUDIO_ELEMENT_TYPE,GstOsxAudioElementInterface))
</MACRO>
<MACRO>
<NAME>GST_IS_OSX_AUDIO_ELEMENT</NAME>
#define GST_IS_OSX_AUDIO_ELEMENT(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_OSX_AUDIO_ELEMENT_TYPE))
</MACRO>
<MACRO>
<NAME>GST_OSX_AUDIO_ELEMENT_GET_INTERFACE</NAME>
#define GST_OSX_AUDIO_ELEMENT_GET_INTERFACE(inst) \
  (G_TYPE_INSTANCE_GET_INTERFACE((inst),GST_OSX_AUDIO_ELEMENT_TYPE,GstOsxAudioElementInterface))
</MACRO>
<STRUCT>
<NAME>GstOsxAudioElementInterface</NAME>
struct _GstOsxAudioElementInterface
{
  GTypeInterface parent;

  OSStatus (*io_proc) (void * userdata,
      AudioUnitRenderActionFlags * ioActionFlags,
      const AudioTimeStamp * inTimeStamp,
      UInt32 inBusNumber, UInt32 inNumberFrames,
      AudioBufferList * bufferList);
};
</STRUCT>
<FUNCTION>
<NAME>gst_osx_audio_element_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_OSX_AUDIO_RING_BUFFER</NAME>
#define GST_TYPE_OSX_AUDIO_RING_BUFFER \
  (gst_osx_audio_ring_buffer_get_type())
</MACRO>
<MACRO>
<NAME>GST_OSX_AUDIO_RING_BUFFER</NAME>
#define GST_OSX_AUDIO_RING_BUFFER(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_OSX_AUDIO_RING_BUFFER,GstOsxAudioRingBuffer))
</MACRO>
<MACRO>
<NAME>GST_OSX_AUDIO_RING_BUFFER_CLASS</NAME>
#define GST_OSX_AUDIO_RING_BUFFER_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_OSX_AUDIO_RING_BUFFER,GstOsxAudioRingBufferClass))
</MACRO>
<MACRO>
<NAME>GST_OSX_AUDIO_RING_BUFFER_GET_CLASS</NAME>
#define GST_OSX_AUDIO_RING_BUFFER_GET_CLASS(obj) \
  (G_TYPE_INSTANCE_GET_CLASS((obj),GST_TYPE_OSX_AUDIO_RING_BUFFER,GstOsxAudioRingBufferClass))
</MACRO>
<MACRO>
<NAME>GST_IS_OSX_AUDIO_RING_BUFFER</NAME>
#define GST_IS_OSX_AUDIO_RING_BUFFER(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_OSX_AUDIO_RING_BUFFER))
</MACRO>
<MACRO>
<NAME>GST_IS_OSX_AUDIO_RING_BUFFER_CLASS</NAME>
#define GST_IS_OSX_AUDIO_RING_BUFFER_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_OSX_AUDIO_RING_BUFFER))
</MACRO>
<MACRO>
<NAME>RINGBUFFER_IS_SPDIF</NAME>
#define RINGBUFFER_IS_SPDIF(t) ((t) == GST_AUDIO_RING_BUFFER_FORMAT_TYPE_AC3 || (t) == GST_AUDIO_RING_BUFFER_FORMAT_TYPE_DTS)
</MACRO>
<STRUCT>
<NAME>GstOsxAudioRingBuffer</NAME>
struct _GstOsxAudioRingBuffer
{
  GstAudioRingBuffer object;

  GstCoreAudio *core_audio;

  guint buffer_len;
  guint segoffset;
};
</STRUCT>
<STRUCT>
<NAME>GstOsxAudioRingBufferClass</NAME>
struct _GstOsxAudioRingBufferClass
{
  GstAudioRingBufferClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_osx_audio_ring_buffer_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<STRUCT>
<NAME>GstXContext</NAME>
struct _GstXContext {
  Display *disp;

  Screen *screen;

  Visual *visual;

  Window root;

  gulong white, black;

  gint depth;
  gint bpp;
  gint endianness;

  gint width, height;
  gint widthmm, heightmm;

  /* these are the output masks
   * for buffers from ximagesrc
   * and are in big endian */
  guint32 r_mask_output, g_mask_output, b_mask_output;

  guint par_n;                  /* calculated pixel aspect ratio numerator */
  guint par_d;                  /* calculated pixel aspect ratio denumerator */

  gboolean use_xshm;

  GstCaps *caps;
};
</STRUCT>
<STRUCT>
<NAME>GstXWindow</NAME>
struct _GstXWindow {
  Window win;
  gint width, height;
  gboolean internal;
  GC gc;
};
</STRUCT>
<FUNCTION>
<NAME>ximageutil_check_xshm_calls</NAME>
<RETURNS>gboolean  </RETURNS>
GstXContext * xcontext
</FUNCTION>
<FUNCTION>
<NAME>ximageutil_xcontext_get</NAME>
<RETURNS>GstXContext  *</RETURNS>
GstElement *parent, const gchar *display_name
</FUNCTION>
<FUNCTION>
<NAME>ximageutil_xcontext_clear</NAME>
<RETURNS>void  </RETURNS>
GstXContext *xcontext
</FUNCTION>
<FUNCTION>
<NAME>ximageutil_calculate_pixel_aspect_ratio</NAME>
<RETURNS>void  </RETURNS>
GstXContext * xcontext
</FUNCTION>
<USER_FUNCTION>
<NAME>BufferReturnFunc</NAME>
<RETURNS>gboolean </RETURNS>
GstElement *parent, GstBuffer *buf
</USER_FUNCTION>
<STRUCT>
<NAME>GstMetaXImage</NAME>
struct _GstMetaXImage {
  GstMeta meta;

  /* Reference to the ximagesrc we belong to */
  GstElement *parent;

  XImage *ximage;

#ifdef HAVE_XSHM
  XShmSegmentInfo SHMInfo;
#endif /* HAVE_XSHM */

  gint width, height;
  size_t size;

  BufferReturnFunc return_func;
};
</STRUCT>
<FUNCTION>
<NAME>gst_meta_ximage_api_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_meta_ximage_get_info</NAME>
<RETURNS>const GstMetaInfo  * </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_META_XIMAGE_GET</NAME>
#define GST_META_XIMAGE_GET(buf) ((GstMetaXImage *)gst_buffer_get_meta(buf,gst_meta_ximage_api_get_type()))
</MACRO>
<MACRO>
<NAME>GST_META_XIMAGE_ADD</NAME>
#define GST_META_XIMAGE_ADD(buf) ((GstMetaXImage *)gst_buffer_add_meta(buf,gst_meta_ximage_get_info(),NULL))
</MACRO>
<FUNCTION>
<NAME>gst_ximageutil_ximage_new</NAME>
<RETURNS>GstBuffer  *</RETURNS>
GstXContext *xcontext, GstElement *parent, int width, int height, BufferReturnFunc return_func
</FUNCTION>
<FUNCTION>
<NAME>gst_ximageutil_ximage_destroy</NAME>
<RETURNS>void  </RETURNS>
GstXContext *xcontext, GstBuffer * ximage
</FUNCTION>
<FUNCTION>
<NAME>gst_ximage_buffer_free</NAME>
<RETURNS>void  </RETURNS>
GstBuffer *ximage
</FUNCTION>
<STRUCT>
<NAME>GstXImage</NAME>
</STRUCT>
<ENUM>
<NAME>GstSunAudioTrackType</NAME>
typedef enum
{
   GST_SUNAUDIO_TRACK_OUTPUT   = 0,
   GST_SUNAUDIO_TRACK_RECORD,
   GST_SUNAUDIO_TRACK_MONITOR,
   GST_SUNAUDIO_TRACK_SPEAKER,
   GST_SUNAUDIO_TRACK_HP,
   GST_SUNAUDIO_TRACK_LINEOUT,
   GST_SUNAUDIO_TRACK_SPDIFOUT,
   GST_SUNAUDIO_TRACK_AUX1OUT,
   GST_SUNAUDIO_TRACK_AUX2OUT,
   GST_SUNAUDIO_TRACK_RECSRC
} GstSunAudioTrackType;
</ENUM>
<MACRO>
<NAME>GST_TYPE_SUNAUDIO_MIXER_TRACK</NAME>
#define GST_TYPE_SUNAUDIO_MIXER_TRACK \
  (gst_sunaudiomixer_track_get_type ())
</MACRO>
<MACRO>
<NAME>GST_SUNAUDIO_MIXER_TRACK</NAME>
#define GST_SUNAUDIO_MIXER_TRACK(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST ((obj), GST_TYPE_SUNAUDIO_MIXER_TRACK, \
			       GstSunAudioMixerTrack))
</MACRO>
<MACRO>
<NAME>GST_SUNAUDIO_MIXER_TRACK_CLASS</NAME>
#define GST_SUNAUDIO_MIXER_TRACK_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST ((klass), GST_TYPE_SUNAUDIO_MIXER_TRACK, \
			    GstSunAudioMixerTrackClass))
</MACRO>
<MACRO>
<NAME>GST_IS_SUNAUDIO_MIXER_TRACK</NAME>
#define GST_IS_SUNAUDIO_MIXER_TRACK(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GST_TYPE_SUNAUDIO_MIXER_TRACK))
</MACRO>
<MACRO>
<NAME>GST_IS_SUNAUDIO_MIXER_TRACK_CLASS</NAME>
#define GST_IS_SUNAUDIO_MIXER_TRACK_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE ((klass), GST_TYPE_SUNAUDIO_MIXER_TRACK))
</MACRO>
<STRUCT>
<NAME>GstSunAudioMixerTrack</NAME>
typedef struct _GstSunAudioMixerTrack {
  GstMixerTrack parent;

  gint                  gain;
  gint                  balance;
  GstSunAudioTrackType track_num;
} GstSunAudioMixerTrack;
</STRUCT>
<STRUCT>
<NAME>GstSunAudioMixerTrackClass</NAME>
typedef struct _GstSunAudioMixerTrackClass {
  GstMixerTrackClass parent;
} GstSunAudioMixerTrackClass;
</STRUCT>
<FUNCTION>
<NAME>gst_sunaudiomixer_track_get_type</NAME>
<RETURNS>GType 		</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_sunaudiomixer_track_new</NAME>
<RETURNS>GstMixerTrack *	</RETURNS>
GstSunAudioTrackType track_num
</FUNCTION>
<MACRO>
<NAME>GST_SUNAUDIO_MIXER</NAME>
#define GST_SUNAUDIO_MIXER(obj)		   (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_SUNAUDIO_MIXER,GstSunAudioMixer))
</MACRO>
<MACRO>
<NAME>GST_SUNAUDIO_MIXER_CLASS</NAME>
#define GST_SUNAUDIO_MIXER_CLASS(klass)	   (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_SUNAUDIO_MIXER,GstSunAudioMixerClass))
</MACRO>
<MACRO>
<NAME>GST_IS_SUNAUDIO_MIXER</NAME>
#define GST_IS_SUNAUDIO_MIXER(obj)	   (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_SUNAUDIO_MIXER))
</MACRO>
<MACRO>
<NAME>GST_IS_SUNAUDIO_MIXER_CLASS</NAME>
#define GST_IS_SUNAUDIO_MIXER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_SUNAUDIO_MIXER))
</MACRO>
<MACRO>
<NAME>GST_TYPE_SUNAUDIO_MIXER</NAME>
#define GST_TYPE_SUNAUDIO_MIXER		   (gst_sunaudiomixer_get_type())
</MACRO>
<STRUCT>
<NAME>GstSunAudioMixer</NAME>
struct _GstSunAudioMixer {
  GstElement		parent;

  GstSunAudioMixerCtrl	*mixer;
};
</STRUCT>
<STRUCT>
<NAME>GstSunAudioMixerClass</NAME>
struct _GstSunAudioMixerClass {
  GstElementClass	parent;
};
</STRUCT>
<FUNCTION>
<NAME>gst_sunaudiomixer_get_type</NAME>
<RETURNS>GType 		</RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_SUNAUDIO_MIXER_OPTIONS</NAME>
#define GST_SUNAUDIO_MIXER_OPTIONS(obj)         (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_SUNAUDIO_MIXER_OPTIONS, GstSunAudioMixerOptions))
</MACRO>
<MACRO>
<NAME>GST_SUNAUDIO_MIXER_OPTIONS_CLASS</NAME>
#define GST_SUNAUDIO_MIXER_OPTIONS_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_SUNAUDIO_MIXER_OPTIONS, GstSunAudioMixerOptionsClass))
</MACRO>
<MACRO>
<NAME>GST_IS_SUNAUDIO_MIXER_OPTIONS</NAME>
#define GST_IS_SUNAUDIO_MIXER_OPTIONS(obj)          (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_SUNAUDIO_MIXER_OPTIONS))
</MACRO>
<MACRO>
<NAME>GST_IS_SUNAUDIO_MIXER_OPTIONS_CLASS</NAME>
#define GST_IS_SUNAUDIO_MIXER_OPTIONS_CLASS(klass)  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_SUNAUDIO_MIXER_OPTIONS))
</MACRO>
<MACRO>
<NAME>GST_TYPE_SUNAUDIO_MIXER_OPTIONS</NAME>
#define GST_TYPE_SUNAUDIO_MIXER_OPTIONS             (gst_sunaudiomixer_options_get_type())
</MACRO>
<STRUCT>
<NAME>GstSunAudioMixerOptions</NAME>
struct _GstSunAudioMixerOptions {
  GstMixerOptions        parent;
  gint                  track_num;
  GQuark		names[8];	/* only 8 possible */
  gint			avail;		/* mask of avail */
};
</STRUCT>
<STRUCT>
<NAME>GstSunAudioMixerOptionsClass</NAME>
struct _GstSunAudioMixerOptionsClass {
  GstMixerOptionsClass parent;
};
</STRUCT>
<FUNCTION>
<NAME>gst_sunaudiomixer_options_get_type</NAME>
<RETURNS>GType            </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_sunaudiomixer_options_new</NAME>
<RETURNS>GstMixerOptions  *</RETURNS>
GstSunAudioMixerCtrl *mixer, gint track_num
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_SUNAUDIO_SINK</NAME>
#define GST_TYPE_SUNAUDIO_SINK            (gst_sunaudiosink_get_type())
</MACRO>
<MACRO>
<NAME>GST_SUNAUDIO_SINK</NAME>
#define GST_SUNAUDIO_SINK(obj)            (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_SUNAUDIO_SINK,GstSunAudioSink))
</MACRO>
<MACRO>
<NAME>GST_SUNAUDIO_SINK_CLASS</NAME>
#define GST_SUNAUDIO_SINK_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_SUNAUDIO_SINK,GstSunAudioSinkClass))
</MACRO>
<MACRO>
<NAME>GST_IS_SUNAUDIO_SINK</NAME>
#define GST_IS_SUNAUDIO_SINK(obj)         (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_SUNAUDIO_SINK))
</MACRO>
<MACRO>
<NAME>GST_IS_SUNAUDIO_SINK_CLASS</NAME>
#define GST_IS_SUNAUDIO_SINK_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_SUNAUDIO_SINK))
</MACRO>
<STRUCT>
<NAME>GstSunAudioSink</NAME>
struct _GstSunAudioSink {
  GstAudioSink    sink;

  gchar *device;
  gint   fd;

  audio_device_t dev;
  audio_info_t info;

  /* Number of segments the ringbuffer is configured for */
  guint segtotal;
  guint segtotal_samples;

  /* Number of segments written to the device */
  gint segs_written;
  /* Number of samples written to the device */
  gint samples_written;
  guint bytes_per_sample;

  /* mutex and gcond used to control the write method */
  GMutex *write_mutex;
  GCond *sleep_cond;
  gboolean flushing;
};
</STRUCT>
<STRUCT>
<NAME>GstSunAudioSinkClass</NAME>
struct _GstSunAudioSinkClass {
  GstAudioSinkClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_sunaudiosink_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_SUNAUDIO_MIXER_CTRL</NAME>
#define GST_SUNAUDIO_MIXER_CTRL(obj)              ((GstSunAudioMixerCtrl*)(obj))
</MACRO>
<STRUCT>
<NAME>GstSunAudioMixerCtrl</NAME>
struct _GstSunAudioMixerCtrl {
  GList *               tracklist;      /* list of available tracks */

  gint                  fd;
  gint                  mixer_fd;

  gchar *               device;
};
</STRUCT>
<FUNCTION>
<NAME>gst_sunaudiomixer_ctrl_new</NAME>
<RETURNS>GstSunAudioMixerCtrl * </RETURNS>
const gchar *device
</FUNCTION>
<FUNCTION>
<NAME>gst_sunaudiomixer_ctrl_free</NAME>
<RETURNS>void                   </RETURNS>
GstSunAudioMixerCtrl *mixer
</FUNCTION>
<FUNCTION>
<NAME>gst_sunaudiomixer_ctrl_list_tracks</NAME>
<RETURNS>const GList *          </RETURNS>
GstSunAudioMixerCtrl * mixer
</FUNCTION>
<FUNCTION>
<NAME>gst_sunaudiomixer_ctrl_set_volume</NAME>
<RETURNS>void                   </RETURNS>
GstSunAudioMixerCtrl * mixer, GstMixerTrack * track, gint * volumes
</FUNCTION>
<FUNCTION>
<NAME>gst_sunaudiomixer_ctrl_get_volume</NAME>
<RETURNS>void                   </RETURNS>
GstSunAudioMixerCtrl * mixer, GstMixerTrack * track, gint * volumes
</FUNCTION>
<FUNCTION>
<NAME>gst_sunaudiomixer_ctrl_set_record</NAME>
<RETURNS>void                   </RETURNS>
GstSunAudioMixerCtrl * mixer, GstMixerTrack * track, gboolean record
</FUNCTION>
<FUNCTION>
<NAME>gst_sunaudiomixer_ctrl_set_mute</NAME>
<RETURNS>void                   </RETURNS>
GstSunAudioMixerCtrl * mixer, GstMixerTrack * track, gboolean mute
</FUNCTION>
<FUNCTION>
<NAME>gst_sunaudiomixer_ctrl_set_option</NAME>
<RETURNS>void                   </RETURNS>
GstSunAudioMixerCtrl * mixer, GstMixerOptions * options, gchar * value
</FUNCTION>
<FUNCTION>
<NAME>gst_sunaudiomixer_ctrl_get_option</NAME>
<RETURNS>const gchar  *         </RETURNS>
GstSunAudioMixerCtrl * mixer, GstMixerOptions * options
</FUNCTION>
<FUNCTION>
<NAME>gst_sunaudiomixer_ctrl_get_mixer_flags</NAME>
<RETURNS>GstMixerFlags 	      </RETURNS>
GstSunAudioMixerCtrl *mixer
</FUNCTION>
<MACRO>
<NAME>GST_IMPLEMENT_SUNAUDIO_MIXER_CTRL_METHODS</NAME>
#define GST_IMPLEMENT_SUNAUDIO_MIXER_CTRL_METHODS(Type, interface_as_function)  \
static gboolean                                                                 \
interface_as_function ## _supported (Type *this, GType iface_type)              \
{                                                                               \
  g_assert (iface_type == GST_TYPE_MIXER);                                      \
                                                                                \
  return (this->mixer != NULL);                                                 \
}                                                                               \
                                                                                \
static const GList*                                                             \
interface_as_function ## _list_tracks (GstMixer * mixer)                        \
{                                                                               \
  Type *this = (Type*) mixer;                                                   \
                                                                                \
  g_return_val_if_fail (this != NULL, NULL);                                    \
  g_return_val_if_fail (this->mixer != NULL, NULL);                             \
                                                                                \
  return gst_sunaudiomixer_ctrl_list_tracks (this->mixer);                      \
}                                                                               \
                                                                                \
static void                                                                     \
interface_as_function ## _set_volume (GstMixer * mixer, GstMixerTrack * track,  \
    gint * volumes)                                                             \
{                                                                               \
  Type *this = (Type*) mixer;                                                   \
                                                                                \
  g_return_if_fail (this != NULL);                                              \
  g_return_if_fail (this->mixer != NULL);                                       \
                                                                                \
  gst_sunaudiomixer_ctrl_set_volume (this->mixer, track, volumes);              \
}                                                                               \
                                                                                \
static void                                                                     \
interface_as_function ## _get_volume (GstMixer * mixer, GstMixerTrack * track,  \
    gint * volumes)                                                             \
{                                                                               \
  Type *this = (Type*) mixer;                                                   \
                                                                                \
  g_return_if_fail (this != NULL);                                              \
  g_return_if_fail (this->mixer != NULL);                                       \
                                                                                \
  gst_sunaudiomixer_ctrl_get_volume (this->mixer, track, volumes);              \
}                                                                               \
                                                                                \
static void                                                                     \
interface_as_function ## _set_record (GstMixer * mixer, GstMixerTrack * track,  \
    gboolean record)                                                            \
{                                                                               \
  Type *this = (Type*) mixer;                                                   \
                                                                                \
  g_return_if_fail (this != NULL);                                              \
  g_return_if_fail (this->mixer != NULL);                                       \
                                                                                \
  gst_sunaudiomixer_ctrl_set_record (this->mixer, track, record);               \
}                                                                               \
                                                                                \
static void                                                                     \
interface_as_function ## _set_mute (GstMixer * mixer, GstMixerTrack * track,    \
    gboolean mute)                                                              \
{                                                                               \
  Type *this = (Type*) mixer;                                                   \
                                                                                \
  g_return_if_fail (this != NULL);                                              \
  g_return_if_fail (this->mixer != NULL);                                       \
                                                                                \
  gst_sunaudiomixer_ctrl_set_mute (this->mixer, track, mute);                   \
}                                                                               \
										\
static const gchar *								\
interface_as_function ## _get_option (GstMixer * mixer, GstMixerOptions * opts)	\
{                                                                               \
  Type *this = (Type*) mixer;                                                   \
                                                                                \
  g_return_val_if_fail (this != NULL, NULL);					\
  g_return_val_if_fail (this->mixer != NULL, NULL);				\
                                                                                \
  return gst_sunaudiomixer_ctrl_get_option (this->mixer, opts);			\
}                                                                               \
\
static void									\
interface_as_function ## _set_option (GstMixer * mixer, GstMixerOptions * opts,	\
    gchar * value)								\
{                                                                               \
  Type *this = (Type*) mixer;                                                   \
                                                                                \
  g_return_if_fail (this != NULL);                                              \
  g_return_if_fail (this->mixer != NULL);                                       \
                                                                                \
  gst_sunaudiomixer_ctrl_set_option (this->mixer, opts, value);			\
}                                                                               \
\
static GstMixerFlags                                                            \
interface_as_function ## _get_mixer_flags (GstMixer * mixer)                    \
{                                                                               \
  Type *this = (Type*) mixer;                                                   \
                                                                                \
  g_return_val_if_fail (this != NULL, GST_MIXER_FLAG_NONE);                     \
  g_return_val_if_fail (this->mixer != NULL, GST_MIXER_FLAG_NONE);              \
                                                                                \
  return gst_sunaudiomixer_ctrl_get_mixer_flags (this->mixer);			\
}                                                                               \
										\
static void                                                                     \
interface_as_function ## _interface_init (GstMixerInterface * iface)                \
{                                                                               \
  GST_MIXER_TYPE (iface) = GST_MIXER_HARDWARE;                                  \
                                                                                \
  /* set up the interface hooks */                                              \
  iface->list_tracks = interface_as_function ## _list_tracks;                   \
  iface->set_volume  = interface_as_function ## _set_volume;                    \
  iface->get_volume  = interface_as_function ## _get_volume;                    \
  iface->set_mute    = interface_as_function ## _set_mute;                      \
  iface->set_record  = interface_as_function ## _set_record;                    \
  iface->get_option  = interface_as_function ## _get_option;			\
  iface->set_option  = interface_as_function ## _set_option;			\
  iface->get_mixer_flags   = interface_as_function ## _get_mixer_flags;		\
}
</MACRO>
<MACRO>
<NAME>GST_TYPE_SUNAUDIO_SRC</NAME>
#define GST_TYPE_SUNAUDIO_SRC     (gst_sunaudiosrc_get_type())
</MACRO>
<MACRO>
<NAME>GST_SUNAUDIO_SRC</NAME>
#define GST_SUNAUDIO_SRC(obj)     (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_SUNAUDIO_SRC,GstSunAudioSrc))
</MACRO>
<MACRO>
<NAME>GST_SUNAUDIO_SRC_CLASS</NAME>
#define GST_SUNAUDIO_SRC_CLASS(klass)  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_SUNAUDIO_SRC,GstSunAudioSrcClass))
</MACRO>
<MACRO>
<NAME>GST_IS_SUNAUDIO_SRC</NAME>
#define GST_IS_SUNAUDIO_SRC(obj)       (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_SUNAUDIO_SRC))
</MACRO>
<MACRO>
<NAME>GST_IS_SUNAUDIO_SRC_CLASS</NAME>
#define GST_IS_SUNAUDIO_SRC_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_SUNAUDIO_SRC))
</MACRO>
<STRUCT>
<NAME>GstSunAudioSrc</NAME>
struct _GstSunAudioSrc {
  GstAudioSrc    src;

  gchar *device;
  gint   fd;
  gint   control_fd;

  audio_device_t dev;
  audio_info_t info;

  gint   bytes_per_sample;

  GstSunAudioMixerCtrl *mixer;
};
</STRUCT>
<STRUCT>
<NAME>GstSunAudioSrcClass</NAME>
struct _GstSunAudioSrcClass {
  GstAudioSrcClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_sunaudiosrc_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_V4L2_TUNER_CHANNEL</NAME>
#define GST_TYPE_V4L2_TUNER_CHANNEL \
  (gst_v4l2_tuner_channel_get_type ())
</MACRO>
<MACRO>
<NAME>GST_V4L2_TUNER_CHANNEL</NAME>
#define GST_V4L2_TUNER_CHANNEL(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST ((obj), GST_TYPE_V4L2_TUNER_CHANNEL, \
          GstV4l2TunerChannel))
</MACRO>
<MACRO>
<NAME>GST_V4L2_TUNER_CHANNEL_CLASS</NAME>
#define GST_V4L2_TUNER_CHANNEL_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST ((klass), GST_TYPE_V4L2_TUNER_CHANNEL, \
       GstV4l2TunerChannelClass))
</MACRO>
<MACRO>
<NAME>GST_IS_V4L2_TUNER_CHANNEL</NAME>
#define GST_IS_V4L2_TUNER_CHANNEL(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GST_TYPE_V4L2_TUNER_CHANNEL))
</MACRO>
<MACRO>
<NAME>GST_IS_V4L2_TUNER_CHANNEL_CLASS</NAME>
#define GST_IS_V4L2_TUNER_CHANNEL_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE ((klass), GST_TYPE_V4L2_TUNER_CHANNEL))
</MACRO>
<STRUCT>
<NAME>GstV4l2TunerChannel</NAME>
typedef struct _GstV4l2TunerChannel {
  GstTunerChannel parent;

  guint32         index;
  guint32         tuner;
  guint32         audio;
} GstV4l2TunerChannel;
</STRUCT>
<STRUCT>
<NAME>GstV4l2TunerChannelClass</NAME>
typedef struct _GstV4l2TunerChannelClass {
  GstTunerChannelClass parent;
} GstV4l2TunerChannelClass;
</STRUCT>
<MACRO>
<NAME>GST_TYPE_V4L2_TUNER_NORM</NAME>
#define GST_TYPE_V4L2_TUNER_NORM \
  (gst_v4l2_tuner_norm_get_type ())
</MACRO>
<MACRO>
<NAME>GST_V4L2_TUNER_NORM</NAME>
#define GST_V4L2_TUNER_NORM(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST ((obj), GST_TYPE_V4L2_TUNER_NORM, \
          GstV4l2TunerNorm))
</MACRO>
<MACRO>
<NAME>GST_V4L2_TUNER_NORM_CLASS</NAME>
#define GST_V4L2_TUNER_NORM_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST ((klass), GST_TYPE_V4L2_TUNER_NORM, \
       GstV4l2TunerNormClass))
</MACRO>
<MACRO>
<NAME>GST_IS_V4L2_TUNER_NORM</NAME>
#define GST_IS_V4L2_TUNER_NORM(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GST_TYPE_V4L2_TUNER_NORM))
</MACRO>
<MACRO>
<NAME>GST_IS_V4L2_TUNER_NORM_CLASS</NAME>
#define GST_IS_V4L2_TUNER_NORM_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE ((klass), GST_TYPE_V4L2_TUNER_NORM))
</MACRO>
<STRUCT>
<NAME>GstV4l2TunerNorm</NAME>
typedef struct _GstV4l2TunerNorm {
  GstTunerNorm parent;

  v4l2_std_id  index;
} GstV4l2TunerNorm;
</STRUCT>
<STRUCT>
<NAME>GstV4l2TunerNormClass</NAME>
typedef struct _GstV4l2TunerNormClass {
  GstTunerNormClass parent;
} GstV4l2TunerNormClass;
</STRUCT>
<FUNCTION>
<NAME>gst_v4l2_tuner_channel_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_v4l2_tuner_norm_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_v4l2_tuner_list_channels</NAME>
<RETURNS>const GList *      </RETURNS>
GstV4l2Object * v4l2object
</FUNCTION>
<FUNCTION>
<NAME>gst_v4l2_tuner_get_channel</NAME>
<RETURNS>GstTunerChannel *  </RETURNS>
GstV4l2Object * v4l2object
</FUNCTION>
<FUNCTION>
<NAME>gst_v4l2_tuner_set_channel</NAME>
<RETURNS>gboolean           </RETURNS>
GstV4l2Object * v4l2object, GstTunerChannel * channel
</FUNCTION>
<FUNCTION>
<NAME>gst_v4l2_tuner_list_norms</NAME>
<RETURNS>const GList *      </RETURNS>
GstV4l2Object * v4l2object
</FUNCTION>
<FUNCTION>
<NAME>gst_v4l2_tuner_set_norm_and_notify</NAME>
<RETURNS>void               </RETURNS>
GstV4l2Object * v4l2object, GstTunerNorm * norm
</FUNCTION>
<FUNCTION>
<NAME>gst_v4l2_tuner_get_norm</NAME>
<RETURNS>GstTunerNorm *     </RETURNS>
GstV4l2Object * v4l2object
</FUNCTION>
<FUNCTION>
<NAME>gst_v4l2_tuner_set_norm</NAME>
<RETURNS>gboolean           </RETURNS>
GstV4l2Object * v4l2object, GstTunerNorm * norm
</FUNCTION>
<FUNCTION>
<NAME>gst_v4l2_tuner_get_norm_by_std_id</NAME>
<RETURNS>GstTunerNorm *     </RETURNS>
GstV4l2Object * v4l2object, v4l2_std_id norm
</FUNCTION>
<FUNCTION>
<NAME>gst_v4l2_tuner_get_std_id_by_norm</NAME>
<RETURNS>v4l2_std_id        </RETURNS>
GstV4l2Object * v4l2object, GstTunerNorm * norm
</FUNCTION>
<FUNCTION>
<NAME>gst_v4l2_tuner_set_frequency_and_notify</NAME>
<RETURNS>void               </RETURNS>
GstV4l2Object * v4l2object, GstTunerChannel * channel, gulong frequency
</FUNCTION>
<FUNCTION>
<NAME>gst_v4l2_tuner_signal_strength</NAME>
<RETURNS>gint               </RETURNS>
GstV4l2Object * v4l2object, GstTunerChannel * channel
</FUNCTION>
<FUNCTION>
<NAME>gst_v4l2_tuner_get_frequency</NAME>
<RETURNS>gulong             </RETURNS>
GstV4l2Object * v4l2object, GstTunerChannel * channel
</FUNCTION>
<FUNCTION>
<NAME>gst_v4l2_tuner_set_frequency</NAME>
<RETURNS>gboolean           </RETURNS>
GstV4l2Object * v4l2object, GstTunerChannel * channel, gulong frequency
</FUNCTION>
<MACRO>
<NAME>GST_IMPLEMENT_V4L2_TUNER_METHODS</NAME>
#define GST_IMPLEMENT_V4L2_TUNER_METHODS(Type, interface_as_function)                 \
                                                                                      \
static const GList *                                                                  \
interface_as_function ## _tuner_list_channels (GstTuner * mixer)                      \
{                                                                                     \
  Type *this = (Type*) mixer;                                                         \
  return gst_v4l2_tuner_list_channels (this->v4l2object);                             \
}                                                                                     \
                                                                                      \
static void                                                                           \
interface_as_function ## _tuner_set_channel (GstTuner * mixer,                        \
                                             GstTunerChannel * channel)               \
{                                                                                     \
  Type *this = (Type*) mixer;                                                         \
  gst_v4l2_tuner_set_channel (this->v4l2object, channel);                             \
}                                                                                     \
static GstTunerChannel *                                                              \
interface_as_function ## _tuner_get_channel (GstTuner * mixer)                        \
{                                                                                     \
  Type *this = (Type*) mixer;                                                         \
  return gst_v4l2_tuner_get_channel (this->v4l2object);                               \
}                                                                                     \
static const GList *                                                                  \
interface_as_function ## _tuner_list_norms (GstTuner * mixer)                         \
{                                                                                     \
  Type *this = (Type*) mixer;                                                         \
  return gst_v4l2_tuner_list_norms (this->v4l2object);                                \
}                                                                                     \
static void                                                                           \
interface_as_function ## _tuner_set_norm_and_notify (GstTuner * mixer,                \
                                                     GstTunerNorm * norm)             \
{                                                                                     \
  Type *this = (Type*) mixer;                                                         \
  gst_v4l2_tuner_set_norm_and_notify (this->v4l2object, norm);                        \
}                                                                                     \
static GstTunerNorm *                                                                 \
interface_as_function ## _tuner_get_norm (GstTuner * mixer)                           \
{                                                                                     \
  Type *this = (Type*) mixer;                                                         \
  return gst_v4l2_tuner_get_norm (this->v4l2object);                                  \
}                                                                                     \
                                                                                      \
static void                                                                           \
interface_as_function ## _tuner_set_frequency_and_notify (GstTuner * mixer,           \
                                                          GstTunerChannel * channel,  \
                                                          gulong frequency)           \
{                                                                                     \
  Type *this = (Type*) mixer;                                                         \
  gst_v4l2_tuner_set_frequency_and_notify (this->v4l2object, channel, frequency);     \
}                                                                                     \
                                                                                      \
static gulong                                                                         \
interface_as_function ## _tuner_get_frequency (GstTuner * mixer,                      \
                                               GstTunerChannel * channel)             \
{                                                                                     \
  Type *this = (Type*) mixer;                                                         \
  return gst_v4l2_tuner_get_frequency (this->v4l2object, channel);                    \
}                                                                                     \
                                                                                      \
static gint                                                                           \
interface_as_function ## _tuner_signal_strength (GstTuner * mixer,                    \
                                                 GstTunerChannel * channel)           \
{                                                                                     \
  Type *this = (Type*) mixer;                                                         \
  return gst_v4l2_tuner_signal_strength (this->v4l2object, channel);                  \
}                                                                                     \
                                                                                      \
static void                                                                           \
interface_as_function ## _tuner_interface_init (GstTunerInterface * iface)                \
{                                                                                     \
  /* default virtual functions */                                                     \
  iface->list_channels = interface_as_function ## _tuner_list_channels;               \
  iface->set_channel = interface_as_function ## _tuner_set_channel;                   \
  iface->get_channel = interface_as_function ## _tuner_get_channel;                   \
                                                                                      \
  iface->list_norms = interface_as_function ## _tuner_list_norms;                     \
  iface->set_norm = interface_as_function ## _tuner_set_norm_and_notify;              \
  iface->get_norm = interface_as_function ## _tuner_get_norm;                         \
                                                                                      \
  iface->set_frequency = interface_as_function ## _tuner_set_frequency_and_notify;    \
  iface->get_frequency = interface_as_function ## _tuner_get_frequency;               \
  iface->signal_strength = interface_as_function ## _tuner_signal_strength;           \
}                                                                                     \

G_END_DECLS
</MACRO>
<MACRO>
<NAME>GST_TYPE_V4L2_BUFFER_POOL</NAME>
#define GST_TYPE_V4L2_BUFFER_POOL      (gst_v4l2_buffer_pool_get_type())
</MACRO>
<MACRO>
<NAME>GST_IS_V4L2_BUFFER_POOL</NAME>
#define GST_IS_V4L2_BUFFER_POOL(obj)   (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GST_TYPE_V4L2_BUFFER_POOL))
</MACRO>
<MACRO>
<NAME>GST_V4L2_BUFFER_POOL</NAME>
#define GST_V4L2_BUFFER_POOL(obj)      (G_TYPE_CHECK_INSTANCE_CAST ((obj), GST_TYPE_V4L2_BUFFER_POOL, GstV4l2BufferPool))
</MACRO>
<MACRO>
<NAME>GST_V4L2_BUFFER_POOL_CAST</NAME>
#define GST_V4L2_BUFFER_POOL_CAST(obj) ((GstV4l2BufferPool*)(obj))
</MACRO>
<MACRO>
<NAME>GST_V4L2_FLOW_LAST_BUFFER</NAME>
#define GST_V4L2_FLOW_LAST_BUFFER GST_FLOW_CUSTOM_SUCCESS
</MACRO>
<MACRO>
<NAME>GST_V4L2_FLOW_CORRUPTED_BUFFER</NAME>
#define GST_V4L2_FLOW_CORRUPTED_BUFFER GST_FLOW_CUSTOM_SUCCESS_1
</MACRO>
<STRUCT>
<NAME>GstV4l2BufferPool</NAME>
struct _GstV4l2BufferPool
{
  GstBufferPool parent;

  GstV4l2Object *obj;        /* the v4l2 object */
  gint video_fd;             /* a dup(2) of the v4l2object's video_fd */
  GstPoll *poll;             /* a poll for video_fd */
  GstPollFD pollfd;
  gboolean can_poll_device;

  gboolean empty;
  GCond empty_cond;

  GstV4l2Allocator *vallocator;
  GstAllocator *allocator;
  GstAllocationParams params;
  GstBufferPool *other_pool;
  guint size;
  GstVideoInfo caps_info;   /* Default video information */

  gboolean add_videometa;    /* set if video meta should be added */
  gboolean enable_copy_threshold; /* If copy_threshold should be set */

  guint min_latency;         /* number of buffers we will hold */
  guint max_latency;         /* number of buffers we can hold */
  guint num_queued;          /* number of buffers queued in the driver */
  guint copy_threshold;      /* when our pool runs lower, start handing out copies */

  gboolean streaming;
  gboolean flushing;

  GstBuffer *buffers[VIDEO_MAX_FRAME];

  /* signal handlers */
  gulong group_released_handler;

  /* Control to warn only once on buggy feild driver bug */
  gboolean has_warned_on_buggy_field;
};
</STRUCT>
<STRUCT>
<NAME>GstV4l2BufferPoolClass</NAME>
struct _GstV4l2BufferPoolClass
{
  GstBufferPoolClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_v4l2_buffer_pool_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_v4l2_buffer_pool_new</NAME>
<RETURNS>GstBufferPool  *     </RETURNS>
GstV4l2Object *obj, GstCaps *caps
</FUNCTION>
<FUNCTION>
<NAME>gst_v4l2_buffer_pool_process</NAME>
<RETURNS>GstFlowReturn        </RETURNS>
GstV4l2BufferPool * bpool, GstBuffer ** buf
</FUNCTION>
<FUNCTION>
<NAME>gst_v4l2_buffer_pool_set_other_pool</NAME>
<RETURNS>void                 </RETURNS>
GstV4l2BufferPool * pool, GstBufferPool * other_pool
</FUNCTION>
<FUNCTION>
<NAME>gst_v4l2_buffer_pool_copy_at_threshold</NAME>
<RETURNS>void                 </RETURNS>
GstV4l2BufferPool * pool, gboolean copy
</FUNCTION>
<STRUCT>
<NAME>GstV4l2Meta</NAME>
</STRUCT>
<MACRO>
<NAME>v4l2_fd_open</NAME>
#  define v4l2_fd_open(fd, flags) (fd)
</MACRO>
<MACRO>
<NAME>v4l2_close</NAME>
#  define v4l2_close    close
</MACRO>
<MACRO>
<NAME>v4l2_dup</NAME>
#  define v4l2_dup      dup
</MACRO>
<MACRO>
<NAME>v4l2_ioctl</NAME>
#  define v4l2_ioctl    ioctl
</MACRO>
<MACRO>
<NAME>v4l2_read</NAME>
#  define v4l2_read     read
</MACRO>
<MACRO>
<NAME>v4l2_mmap</NAME>
#  define v4l2_mmap     mmap
</MACRO>
<MACRO>
<NAME>v4l2_munmap</NAME>
#  define v4l2_munmap   munmap
</MACRO>
<MACRO>
<NAME>GST_V4L2_IS_OVERLAY</NAME>
#define GST_V4L2_IS_OVERLAY(v4l2object) \
  (v4l2object->vcap.capabilities & V4L2_CAP_VIDEO_OVERLAY)
</MACRO>
<MACRO>
<NAME>GST_V4L2_CHECK_OPEN</NAME>
#define GST_V4L2_CHECK_OPEN(v4l2object)				\
  if (!GST_V4L2_IS_OPEN(v4l2object))				\
  {								\
    GST_ELEMENT_ERROR (v4l2object->element, RESOURCE, SETTINGS,	\
      (_("Device is not open.")), (NULL));                      \
    return FALSE;						\
  }
</MACRO>
<MACRO>
<NAME>GST_V4L2_CHECK_NOT_OPEN</NAME>
#define GST_V4L2_CHECK_NOT_OPEN(v4l2object)			\
  if (GST_V4L2_IS_OPEN(v4l2object))				\
  {								\
    GST_ELEMENT_ERROR (v4l2object->element, RESOURCE, SETTINGS,	\
      (_("Device is open.")), (NULL));                          \
    return FALSE;						\
  }
</MACRO>
<MACRO>
<NAME>GST_V4L2_CHECK_OVERLAY</NAME>
#define GST_V4L2_CHECK_OVERLAY(v4l2object)			\
  if (!GST_V4L2_IS_OVERLAY(v4l2object))				\
  {								\
    GST_ELEMENT_ERROR (v4l2object->element, RESOURCE, SETTINGS, \
      (NULL), ("Device cannot handle overlay"));                \
    return FALSE;						\
  }
</MACRO>
<MACRO>
<NAME>GST_V4L2_CHECK_ACTIVE</NAME>
#define GST_V4L2_CHECK_ACTIVE(v4l2object)			\
  if (!GST_V4L2_IS_ACTIVE(v4l2object))				\
  {								\
    GST_ELEMENT_ERROR (v4l2object->element, RESOURCE, SETTINGS, \
      (NULL), ("Device is not in streaming mode"));             \
    return FALSE;						\
  }
</MACRO>
<MACRO>
<NAME>GST_V4L2_CHECK_NOT_ACTIVE</NAME>
#define GST_V4L2_CHECK_NOT_ACTIVE(v4l2object)			\
  if (GST_V4L2_IS_ACTIVE(v4l2object))				\
  {								\
    GST_ELEMENT_ERROR (v4l2object->element, RESOURCE, SETTINGS, \
      (NULL), ("Device is in streaming mode"));                 \
    return FALSE;						\
  }
</MACRO>
<FUNCTION>
<NAME>gst_v4l2_open</NAME>
<RETURNS>gboolean 	</RETURNS>
GstV4l2Object *v4l2object
</FUNCTION>
<FUNCTION>
<NAME>gst_v4l2_dup</NAME>
<RETURNS>gboolean 	</RETURNS>
GstV4l2Object *v4l2object, GstV4l2Object *other
</FUNCTION>
<FUNCTION>
<NAME>gst_v4l2_close</NAME>
<RETURNS>gboolean 	</RETURNS>
GstV4l2Object *v4l2object
</FUNCTION>
<FUNCTION>
<NAME>gst_v4l2_get_norm</NAME>
<RETURNS>gboolean 	</RETURNS>
GstV4l2Object *v4l2object, v4l2_std_id    *norm
</FUNCTION>
<FUNCTION>
<NAME>gst_v4l2_set_norm</NAME>
<RETURNS>gboolean 	</RETURNS>
GstV4l2Object *v4l2object, v4l2_std_id     norm
</FUNCTION>
<FUNCTION>
<NAME>gst_v4l2_get_input</NAME>
<RETURNS>gboolean         </RETURNS>
GstV4l2Object * v4l2object, gint * input
</FUNCTION>
<FUNCTION>
<NAME>gst_v4l2_set_input</NAME>
<RETURNS>gboolean         </RETURNS>
GstV4l2Object * v4l2object, gint input
</FUNCTION>
<FUNCTION>
<NAME>gst_v4l2_get_output</NAME>
<RETURNS>gboolean 	</RETURNS>
GstV4l2Object *v4l2object, gint           *output
</FUNCTION>
<FUNCTION>
<NAME>gst_v4l2_set_output</NAME>
<RETURNS>gboolean 	</RETURNS>
GstV4l2Object *v4l2object, gint            output
</FUNCTION>
<FUNCTION>
<NAME>gst_v4l2_get_frequency</NAME>
<RETURNS>gboolean 	</RETURNS>
GstV4l2Object *v4l2object, gint            tunernum, gulong         *frequency
</FUNCTION>
<FUNCTION>
<NAME>gst_v4l2_set_frequency</NAME>
<RETURNS>gboolean 	</RETURNS>
GstV4l2Object *v4l2object, gint            tunernum, gulong          frequency
</FUNCTION>
<FUNCTION>
<NAME>gst_v4l2_signal_strength</NAME>
<RETURNS>gboolean 	</RETURNS>
GstV4l2Object *v4l2object, gint            tunernum, gulong         *signal
</FUNCTION>
<FUNCTION>
<NAME>gst_v4l2_get_attribute</NAME>
<RETURNS>gboolean 	</RETURNS>
GstV4l2Object *v4l2object, int             attribute, int            *value
</FUNCTION>
<FUNCTION>
<NAME>gst_v4l2_set_attribute</NAME>
<RETURNS>gboolean 	</RETURNS>
GstV4l2Object *v4l2object, int             attribute, const int       value
</FUNCTION>
<FUNCTION>
<NAME>gst_v4l2_set_controls</NAME>
<RETURNS>gboolean 	</RETURNS>
GstV4l2Object * v4l2object, GstStructure * controls
</FUNCTION>
<FUNCTION>
<NAME>gst_v4l2_get_capabilities</NAME>
<RETURNS>gboolean         </RETURNS>
GstV4l2Object * v4l2object
</FUNCTION>
<MACRO>
<NAME>GST_V4L2_MIN_BUFFERS</NAME>
#define GST_V4L2_MIN_BUFFERS 2
</MACRO>
<MACRO>
<NAME>GST_V4L2_MAX_SIZE</NAME>
#define GST_V4L2_MAX_SIZE (1<<15) /* 2^15 == 32768 */
</MACRO>
<MACRO>
<NAME>GST_TYPE_V4L2_IO_MODE</NAME>
#define GST_TYPE_V4L2_IO_MODE (gst_v4l2_io_mode_get_type ())
</MACRO>
<FUNCTION>
<NAME>gst_v4l2_io_mode_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_V4L2_OBJECT</NAME>
#define GST_V4L2_OBJECT(obj) (GstV4l2Object *)(obj)
</MACRO>
<ENUM>
<NAME>GstV4l2IOMode</NAME>
typedef enum {
  GST_V4L2_IO_AUTO          = 0,
  GST_V4L2_IO_RW            = 1,
  GST_V4L2_IO_MMAP          = 2,
  GST_V4L2_IO_USERPTR       = 3,
  GST_V4L2_IO_DMABUF        = 4,
  GST_V4L2_IO_DMABUF_IMPORT = 5
} GstV4l2IOMode;
</ENUM>
<USER_FUNCTION>
<NAME>GstV4l2GetInOutFunction</NAME>
<RETURNS>gboolean </RETURNS>
GstV4l2Object * v4l2object, gint * input
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GstV4l2SetInOutFunction</NAME>
<RETURNS>gboolean </RETURNS>
GstV4l2Object * v4l2object, gint input
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GstV4l2UpdateFpsFunction</NAME>
<RETURNS>gboolean </RETURNS>
GstV4l2Object * v4l2object
</USER_FUNCTION>
<MACRO>
<NAME>GST_V4L2_WIDTH</NAME>
#define GST_V4L2_WIDTH(o)        (GST_VIDEO_INFO_WIDTH (&(o)->info))
</MACRO>
<MACRO>
<NAME>GST_V4L2_HEIGHT</NAME>
#define GST_V4L2_HEIGHT(o)       (GST_VIDEO_INFO_HEIGHT (&(o)->info))
</MACRO>
<MACRO>
<NAME>GST_V4L2_PIXELFORMAT</NAME>
#define GST_V4L2_PIXELFORMAT(o)  ((o)->fmtdesc->pixelformat)
</MACRO>
<MACRO>
<NAME>GST_V4L2_FPS_N</NAME>
#define GST_V4L2_FPS_N(o)        (GST_VIDEO_INFO_FPS_N (&(o)->info))
</MACRO>
<MACRO>
<NAME>GST_V4L2_FPS_D</NAME>
#define GST_V4L2_FPS_D(o)        (GST_VIDEO_INFO_FPS_D (&(o)->info))
</MACRO>
<MACRO>
<NAME>GST_V4L2_IS_OPEN</NAME>
#define GST_V4L2_IS_OPEN(o)      ((o)->video_fd > 0)
</MACRO>
<MACRO>
<NAME>GST_V4L2_IS_ACTIVE</NAME>
#define GST_V4L2_IS_ACTIVE(o)    ((o)->active)
</MACRO>
<MACRO>
<NAME>GST_V4L2_SET_ACTIVE</NAME>
#define GST_V4L2_SET_ACTIVE(o)   ((o)->active = TRUE)
</MACRO>
<MACRO>
<NAME>GST_V4L2_SET_INACTIVE</NAME>
#define GST_V4L2_SET_INACTIVE(o) ((o)->active = FALSE)
</MACRO>
<STRUCT>
<NAME>GstV4l2Object</NAME>
struct _GstV4l2Object {
  GstElement * element;

  enum v4l2_buf_type type;   /* V4L2_BUF_TYPE_VIDEO_CAPTURE, V4L2_BUF_TYPE_VIDEO_OUTPUT */

  /* the video device */
  char *videodev;

  /* the video-device's file descriptor */
  gint video_fd;
  GstV4l2IOMode mode;

  gboolean active;
  gboolean streaming;

  /* the current format */
  struct v4l2_fmtdesc *fmtdesc;
  struct v4l2_format format;
  GstVideoInfo info;
  GstVideoAlignment align;

  /* Features */
  gboolean need_video_meta;
  gboolean has_alpha_component;

  /* only used if the device supports MPLANE
   * nb planes is meaning of v4l2 planes
   * the gstreamer equivalent is gst_buffer_n_memory
   */
  gint n_v4l2_planes;

  /* We cache the frame duration if known */
  GstClockTime duration;

  /* if the MPLANE device support both contiguous and non contiguous
   * it allows to select which one we want. But we prefered_non_contiguous
   * non contiguous mode.
   */
  gboolean prefered_non_contiguous;

  /* This will be set if supported in decide_allocation. It can be used to
   * calculate the minimum latency. */
  guint32 min_buffers;

  /* This will be set if supported in propose allocation. */
  guint32 min_buffers_for_output;

  /* wanted mode */
  GstV4l2IOMode req_mode;

  /* optional pool */
  GstBufferPool *pool;

  /* the video device's capabilities */
  struct v4l2_capability vcap;
  /* opened device specific capabilities */
  guint32 device_caps;

  /* the video device's window properties */
  struct v4l2_window vwin;

  /* some more info about the current input's capabilities */
  struct v4l2_input vinput;

  /* lists... */
  GSList *formats;              /* list of available capture formats */
  GstCaps *probed_caps;

  GList *colors;
  GList *norms;
  GList *channels;
  GData *controls;

  /* properties */
  v4l2_std_id tv_norm;
  gchar *channel;
  gulong frequency;
  GstStructure *extra_controls;
  gboolean keep_aspect;
  GValue *par;

  /* X-overlay */
  GstV4l2Xv *xv;
  gulong xwindow_id;

  /* funcs */
  GstV4l2GetInOutFunction  get_in_out_func;
  GstV4l2SetInOutFunction  set_in_out_func;
  GstV4l2UpdateFpsFunction update_fps_func;

  /* Quirks */
  /* Skips interlacing probes */
  gboolean never_interlaced;
  /* Allow to skip reading initial format through G_FMT. Some devices
   * just fails if you don't call S_FMT first. (ex: M2M decoders) */
  gboolean no_initial_format;
};
</STRUCT>
<STRUCT>
<NAME>GstV4l2ObjectClassHelper</NAME>
struct _GstV4l2ObjectClassHelper {
  /* probed devices */
  GList *devices;
};
</STRUCT>
<FUNCTION>
<NAME>gst_v4l2_object_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>V4L2_STD_OBJECT_PROPS</NAME>
#define V4L2_STD_OBJECT_PROPS \
    PROP_DEVICE,              \
    PROP_DEVICE_NAME,         \
    PROP_DEVICE_FD,           \
    PROP_FLAGS,               \
    PROP_BRIGHTNESS,          \
    PROP_CONTRAST,            \
    PROP_SATURATION,          \
    PROP_HUE,                 \
    PROP_TV_NORM,             \
    PROP_IO_MODE,             \
    PROP_OUTPUT_IO_MODE,      \
    PROP_CAPTURE_IO_MODE,     \
    PROP_EXTRA_CONTROLS,      \
    PROP_PIXEL_ASPECT_RATIO,  \
    PROP_FORCE_ASPECT_RATIO
</MACRO>
<FUNCTION>
<NAME>gst_v4l2_object_new</NAME>
<RETURNS>GstV4l2Object *  </RETURNS>
GstElement * element, enum v4l2_buf_type  type, const char * default_device, GstV4l2GetInOutFunction get_in_out_func, GstV4l2SetInOutFunction set_in_out_func, GstV4l2UpdateFpsFunction update_fps_func
</FUNCTION>
<FUNCTION>
<NAME>gst_v4l2_object_destroy</NAME>
<RETURNS>void             </RETURNS>
GstV4l2Object * v4l2object
</FUNCTION>
<FUNCTION>
<NAME>gst_v4l2_object_install_properties_helper</NAME>
<RETURNS>void          </RETURNS>
GObjectClass * gobject_class, const char * default_device
</FUNCTION>
<FUNCTION>
<NAME>gst_v4l2_object_install_m2m_properties_helper</NAME>
<RETURNS>void          </RETURNS>
GObjectClass * gobject_class
</FUNCTION>
<FUNCTION>
<NAME>gst_v4l2_object_set_property_helper</NAME>
<RETURNS>gboolean      </RETURNS>
GstV4l2Object * v4l2object, guint prop_id, const GValue * value, GParamSpec * pspec
</FUNCTION>
<FUNCTION>
<NAME>gst_v4l2_object_get_property_helper</NAME>
<RETURNS>gboolean      </RETURNS>
GstV4l2Object *v4l2object, guint prop_id, GValue * value, GParamSpec * pspec
</FUNCTION>
<FUNCTION>
<NAME>gst_v4l2_object_open</NAME>
<RETURNS>gboolean      </RETURNS>
GstV4l2Object *v4l2object
</FUNCTION>
<FUNCTION>
<NAME>gst_v4l2_object_open_shared</NAME>
<RETURNS>gboolean      </RETURNS>
GstV4l2Object *v4l2object, GstV4l2Object *other
</FUNCTION>
<FUNCTION>
<NAME>gst_v4l2_object_close</NAME>
<RETURNS>gboolean      </RETURNS>
GstV4l2Object *v4l2object
</FUNCTION>
<FUNCTION>
<NAME>gst_v4l2_object_get_all_caps</NAME>
<RETURNS>GstCaps *      </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_v4l2_object_get_raw_caps</NAME>
<RETURNS>GstCaps *      </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_v4l2_object_get_codec_caps</NAME>
<RETURNS>GstCaps *      </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_v4l2_object_extrapolate_stride</NAME>
<RETURNS>gint           </RETURNS>
const GstVideoFormatInfo * finfo, gint plane, gint stride
</FUNCTION>
<FUNCTION>
<NAME>gst_v4l2_object_set_format</NAME>
<RETURNS>gboolean       </RETURNS>
GstV4l2Object * v4l2object, GstCaps * caps, GstV4l2Error *error
</FUNCTION>
<FUNCTION>
<NAME>gst_v4l2_object_try_format</NAME>
<RETURNS>gboolean       </RETURNS>
GstV4l2Object * v4l2object, GstCaps * caps, GstV4l2Error *error
</FUNCTION>
<FUNCTION>
<NAME>gst_v4l2_object_caps_equal</NAME>
<RETURNS>gboolean       </RETURNS>
GstV4l2Object * v4l2object, GstCaps * caps
</FUNCTION>
<FUNCTION>
<NAME>gst_v4l2_object_unlock</NAME>
<RETURNS>gboolean       </RETURNS>
GstV4l2Object * v4l2object
</FUNCTION>
<FUNCTION>
<NAME>gst_v4l2_object_unlock_stop</NAME>
<RETURNS>gboolean       </RETURNS>
GstV4l2Object * v4l2object
</FUNCTION>
<FUNCTION>
<NAME>gst_v4l2_object_stop</NAME>
<RETURNS>gboolean       </RETURNS>
GstV4l2Object * v4l2object
</FUNCTION>
<FUNCTION>
<NAME>gst_v4l2_object_probe_caps</NAME>
<RETURNS>GstCaps  *     </RETURNS>
GstV4l2Object * v4l2object, GstCaps * filter
</FUNCTION>
<FUNCTION>
<NAME>gst_v4l2_object_get_caps</NAME>
<RETURNS>GstCaps  *     </RETURNS>
GstV4l2Object * v4l2object, GstCaps * filter
</FUNCTION>
<FUNCTION>
<NAME>gst_v4l2_object_acquire_format</NAME>
<RETURNS>gboolean       </RETURNS>
GstV4l2Object * v4l2object, GstVideoInfo * info
</FUNCTION>
<FUNCTION>
<NAME>gst_v4l2_object_set_crop</NAME>
<RETURNS>gboolean       </RETURNS>
GstV4l2Object * obj
</FUNCTION>
<FUNCTION>
<NAME>gst_v4l2_object_decide_allocation</NAME>
<RETURNS>gboolean       </RETURNS>
GstV4l2Object * v4l2object, GstQuery * query
</FUNCTION>
<FUNCTION>
<NAME>gst_v4l2_object_propose_allocation</NAME>
<RETURNS>gboolean       </RETURNS>
GstV4l2Object * obj, GstQuery * query
</FUNCTION>
<FUNCTION>
<NAME>gst_v4l2_object_v4l2fourcc_to_structure</NAME>
<RETURNS>GstStructure  * </RETURNS>
guint32 fourcc
</FUNCTION>
<STRUCT>
<NAME>GstV4l2Xv</NAME>
</STRUCT>
<MACRO>
<NAME>GST_TYPE_V4L2_ALLOCATOR</NAME>
#define GST_TYPE_V4L2_ALLOCATOR                 (gst_v4l2_allocator_get_type())
</MACRO>
<MACRO>
<NAME>GST_IS_V4L2_ALLOCATOR</NAME>
#define GST_IS_V4L2_ALLOCATOR(obj)              (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GST_TYPE_V4L2_ALLOCATOR))
</MACRO>
<MACRO>
<NAME>GST_IS_V4L2_ALLOCATOR_CLASS</NAME>
#define GST_IS_V4L2_ALLOCATOR_CLASS(klass)      (G_TYPE_CHECK_CLASS_TYPE ((klass), GST_TYPE_V4L2_ALLOCATOR))
</MACRO>
<MACRO>
<NAME>GST_V4L2_ALLOCATOR_GET_CLASS</NAME>
#define GST_V4L2_ALLOCATOR_GET_CLASS(obj)       (G_TYPE_INSTANCE_GET_CLASS ((obj), GST_TYPE_V4L2_ALLOCATOR, GstV4l2AllocatorClass))
</MACRO>
<MACRO>
<NAME>GST_V4L2_ALLOCATOR</NAME>
#define GST_V4L2_ALLOCATOR(obj)                 (G_TYPE_CHECK_INSTANCE_CAST ((obj), GST_TYPE_V4L2_ALLOCATOR, GstV4l2Allocator))
</MACRO>
<MACRO>
<NAME>GST_V4L2_ALLOCATOR_CLASS</NAME>
#define GST_V4L2_ALLOCATOR_CLASS(klass)         (G_TYPE_CHECK_CLASS_CAST ((klass), GST_TYPE_V4L2_ALLOCATOR, GstV4l2AllocatorClass))
</MACRO>
<MACRO>
<NAME>GST_V4L2_ALLOCATOR_CAST</NAME>
#define GST_V4L2_ALLOCATOR_CAST(obj)            ((GstV4l2Allocator *)(obj))
</MACRO>
<MACRO>
<NAME>GST_V4L2_ALLOCATOR_CAN_REQUEST</NAME>
#define GST_V4L2_ALLOCATOR_CAN_REQUEST(obj,type) \
        (GST_OBJECT_FLAG_IS_SET (obj, GST_V4L2_ALLOCATOR_FLAG_ ## type ## _REQBUFS))
</MACRO>
<MACRO>
<NAME>GST_V4L2_ALLOCATOR_CAN_ALLOCATE</NAME>
#define GST_V4L2_ALLOCATOR_CAN_ALLOCATE(obj,type) \
        (GST_OBJECT_FLAG_IS_SET (obj, GST_V4L2_ALLOCATOR_FLAG_ ## type ## _CREATE_BUFS))
</MACRO>
<MACRO>
<NAME>GST_V4L2_MEMORY_QUARK</NAME>
#define GST_V4L2_MEMORY_QUARK gst_v4l2_memory_quark ()
</MACRO>
<STRUCT>
<NAME>GstV4l2Memory</NAME>
struct _GstV4l2Memory
{
  GstMemory mem;
  gint plane;
  GstV4l2MemoryGroup *group;
  gpointer data;
  gint dmafd;
};
</STRUCT>
<STRUCT>
<NAME>GstV4l2MemoryGroup</NAME>
struct _GstV4l2MemoryGroup
{
  gint n_mem;
  GstMemory * mem[VIDEO_MAX_PLANES];
  gint mems_allocated;
  struct v4l2_buffer buffer;
  struct v4l2_plane planes[VIDEO_MAX_PLANES];
};
</STRUCT>
<STRUCT>
<NAME>GstV4l2Allocator</NAME>
struct _GstV4l2Allocator
{
  GstAllocator parent;
  gint video_fd;
  guint32 count;
  guint32 type;
  guint32 memory;
  struct v4l2_format format;
  gboolean can_allocate;
  gboolean active;

  GstV4l2MemoryGroup * groups[VIDEO_MAX_FRAME];
  GstAtomicQueue *free_queue;
  GstAtomicQueue *pending_queue;

};
</STRUCT>
<STRUCT>
<NAME>GstV4l2AllocatorClass</NAME>
struct _GstV4l2AllocatorClass {
  GstAllocatorClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_v4l2_allocator_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_is_v4l2_memory</NAME>
<RETURNS>gboolean              </RETURNS>
GstMemory * mem
</FUNCTION>
<FUNCTION>
<NAME>gst_v4l2_memory_quark</NAME>
<RETURNS>GQuark                </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_v4l2_allocator_is_active</NAME>
<RETURNS>gboolean              </RETURNS>
GstV4l2Allocator * allocator
</FUNCTION>
<FUNCTION>
<NAME>gst_v4l2_allocator_get_size</NAME>
<RETURNS>guint                 </RETURNS>
GstV4l2Allocator * allocator
</FUNCTION>
<FUNCTION>
<NAME>gst_v4l2_allocator_new</NAME>
<RETURNS>GstV4l2Allocator *    </RETURNS>
GstObject *parent, gint video_fd, struct v4l2_format * format
</FUNCTION>
<FUNCTION>
<NAME>gst_v4l2_allocator_start</NAME>
<RETURNS>guint                 </RETURNS>
GstV4l2Allocator * allocator, guint32 count, guint32 memory
</FUNCTION>
<FUNCTION>
<NAME>gst_v4l2_allocator_stop</NAME>
<RETURNS>GstV4l2Return         </RETURNS>
GstV4l2Allocator * allocator
</FUNCTION>
<FUNCTION>
<NAME>gst_v4l2_allocator_alloc_mmap</NAME>
<RETURNS>GstV4l2MemoryGroup *  </RETURNS>
GstV4l2Allocator * allocator
</FUNCTION>
<FUNCTION>
<NAME>gst_v4l2_allocator_alloc_dmabuf</NAME>
<RETURNS>GstV4l2MemoryGroup *  </RETURNS>
GstV4l2Allocator * allocator, GstAllocator * dmabuf_allocator
</FUNCTION>
<FUNCTION>
<NAME>gst_v4l2_allocator_alloc_dmabufin</NAME>
<RETURNS>GstV4l2MemoryGroup  * </RETURNS>
GstV4l2Allocator * allocator
</FUNCTION>
<FUNCTION>
<NAME>gst_v4l2_allocator_alloc_userptr</NAME>
<RETURNS>GstV4l2MemoryGroup  * </RETURNS>
GstV4l2Allocator * allocator
</FUNCTION>
<FUNCTION>
<NAME>gst_v4l2_allocator_import_dmabuf</NAME>
<RETURNS>gboolean              </RETURNS>
GstV4l2Allocator * allocator, GstV4l2MemoryGroup *group, gint n_mem, GstMemory ** dma_mem
</FUNCTION>
<FUNCTION>
<NAME>gst_v4l2_allocator_import_userptr</NAME>
<RETURNS>gboolean              </RETURNS>
GstV4l2Allocator * allocator, GstV4l2MemoryGroup *group, gsize img_size, int n_planes, gpointer * data, gsize * size
</FUNCTION>
<FUNCTION>
<NAME>gst_v4l2_allocator_flush</NAME>
<RETURNS>void                  </RETURNS>
GstV4l2Allocator * allocator
</FUNCTION>
<FUNCTION>
<NAME>gst_v4l2_allocator_qbuf</NAME>
<RETURNS>gboolean              </RETURNS>
GstV4l2Allocator * allocator, GstV4l2MemoryGroup * group
</FUNCTION>
<FUNCTION>
<NAME>gst_v4l2_allocator_dqbuf</NAME>
<RETURNS>GstFlowReturn         </RETURNS>
GstV4l2Allocator * allocator, GstV4l2MemoryGroup ** group
</FUNCTION>
<FUNCTION>
<NAME>gst_v4l2_allocator_reset_group</NAME>
<RETURNS>void                  </RETURNS>
GstV4l2Allocator * allocator, GstV4l2MemoryGroup * group
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_V4L2_COLOR_BALANCE_CHANNEL</NAME>
#define GST_TYPE_V4L2_COLOR_BALANCE_CHANNEL \
  (gst_v4l2_color_balance_channel_get_type ())
</MACRO>
<MACRO>
<NAME>GST_V4L2_COLOR_BALANCE_CHANNEL</NAME>
#define GST_V4L2_COLOR_BALANCE_CHANNEL(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST ((obj), GST_TYPE_V4L2_COLOR_BALANCE_CHANNEL, \
                               GstV4l2ColorBalanceChannel))
</MACRO>
<MACRO>
<NAME>GST_V4L2_COLOR_BALANCE_CHANNEL_CLASS</NAME>
#define GST_V4L2_COLOR_BALANCE_CHANNEL_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST ((klass), GST_TYPE_V4L2_COLOR_BALANCE_CHANNEL, \
                            GstV4l2ColorBalanceChannelClass))
</MACRO>
<MACRO>
<NAME>GST_IS_V4L2_COLOR_BALANCE_CHANNEL</NAME>
#define GST_IS_V4L2_COLOR_BALANCE_CHANNEL(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GST_TYPE_V4L2_COLOR_BALANCE_CHANNEL))
</MACRO>
<MACRO>
<NAME>GST_IS_V4L2_COLOR_BALANCE_CHANNEL_CLASS</NAME>
#define GST_IS_V4L2_COLOR_BALANCE_CHANNEL_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE ((klass), GST_TYPE_V4L2_COLOR_BALANCE_CHANNEL))
</MACRO>
<STRUCT>
<NAME>GstV4l2ColorBalanceChannel</NAME>
typedef struct _GstV4l2ColorBalanceChannel {
  GstColorBalanceChannel parent;

  guint32 id;
} GstV4l2ColorBalanceChannel;
</STRUCT>
<STRUCT>
<NAME>GstV4l2ColorBalanceChannelClass</NAME>
typedef struct _GstV4l2ColorBalanceChannelClass {
  GstColorBalanceChannelClass parent;
} GstV4l2ColorBalanceChannelClass;
</STRUCT>
<FUNCTION>
<NAME>gst_v4l2_color_balance_channel_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_v4l2_color_balance_list_channels</NAME>
<RETURNS>const GList  *   </RETURNS>
GstV4l2Object * v4l2object
</FUNCTION>
<FUNCTION>
<NAME>gst_v4l2_color_balance_set_value</NAME>
<RETURNS>void             </RETURNS>
GstV4l2Object * v4l2object, GstColorBalanceChannel * channel, gint value
</FUNCTION>
<FUNCTION>
<NAME>gst_v4l2_color_balance_get_value</NAME>
<RETURNS>gint             </RETURNS>
GstV4l2Object * v4l2object, GstColorBalanceChannel * channel
</FUNCTION>
<MACRO>
<NAME>GST_IMPLEMENT_V4L2_COLOR_BALANCE_METHODS</NAME>
#define GST_IMPLEMENT_V4L2_COLOR_BALANCE_METHODS(Type, interface_as_function)         \
                                                                                      \
static const GList *                                                                  \
interface_as_function ## _color_balance_list_channels (GstColorBalance * balance)     \
{                                                                                     \
  Type *this = (Type*) balance;                                                       \
  return gst_v4l2_color_balance_list_channels(this->v4l2object);                      \
}                                                                                     \
                                                                                      \
static void                                                                           \
interface_as_function ## _color_balance_set_value (GstColorBalance * balance,         \
                                                   GstColorBalanceChannel * channel,  \
                                                   gint value)                        \
{                                                                                     \
  Type *this = (Type*) balance;                                                       \
  gst_v4l2_color_balance_set_value(this->v4l2object, channel, value);          \
}                                                                                     \
                                                                                      \
static gint                                                                           \
interface_as_function ## _color_balance_get_value (GstColorBalance * balance,         \
                                                   GstColorBalanceChannel * channel)  \
{                                                                                     \
  Type *this = (Type*) balance;                                                       \
  return gst_v4l2_color_balance_get_value(this->v4l2object, channel);                 \
}                                                                                     \
                                                                                      \
static GstColorBalanceType                                                            \
interface_as_function ## _color_balance_get_balance_type (GstColorBalance * balance)  \
{                                                                                     \
  return GST_COLOR_BALANCE_HARDWARE;                                                  \
}                                                                                     \
                                                                                      \
static void                                                                           \
interface_as_function ## _color_balance_interface_init (GstColorBalanceInterface * iface) \
{                                                                                     \
  /* default virtual functions */                                                     \
  iface->list_channels = interface_as_function ## _color_balance_list_channels;       \
  iface->set_value = interface_as_function ## _color_balance_set_value;               \
  iface->get_value = interface_as_function ## _color_balance_get_value;               \
  iface->get_balance_type = interface_as_function ## _color_balance_get_balance_type; \
}                                                                                     \

G_END_DECLS
</MACRO>
<MACRO>
<NAME>GST_TYPE_TUNER_CHANNEL</NAME>
#define GST_TYPE_TUNER_CHANNEL \
  (gst_tuner_channel_get_type ())
</MACRO>
<MACRO>
<NAME>GST_TUNER_CHANNEL</NAME>
#define GST_TUNER_CHANNEL(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST ((obj), GST_TYPE_TUNER_CHANNEL, \
                               GstTunerChannel))
</MACRO>
<MACRO>
<NAME>GST_TUNER_CHANNEL_CLASS</NAME>
#define GST_TUNER_CHANNEL_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST ((klass), GST_TYPE_TUNER_CHANNEL, \
                            GstTunerChannelClass))
</MACRO>
<MACRO>
<NAME>GST_IS_TUNER_CHANNEL</NAME>
#define GST_IS_TUNER_CHANNEL(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GST_TYPE_TUNER_CHANNEL))
</MACRO>
<MACRO>
<NAME>GST_IS_TUNER_CHANNEL_CLASS</NAME>
#define GST_IS_TUNER_CHANNEL_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE ((klass), GST_TYPE_TUNER_CHANNEL))
</MACRO>
<ENUM>
<NAME>GstTunerChannelFlags</NAME>
typedef enum {
  GST_TUNER_CHANNEL_INPUT     = (1<<0),
  GST_TUNER_CHANNEL_OUTPUT    = (1<<1),
  GST_TUNER_CHANNEL_FREQUENCY = (1<<2),
  GST_TUNER_CHANNEL_AUDIO     = (1<<3)
} GstTunerChannelFlags;
</ENUM>
<MACRO>
<NAME>GST_TUNER_CHANNEL_HAS_FLAG</NAME>
#define GST_TUNER_CHANNEL_HAS_FLAG(channel, flag) \
  ((channel)->flags & flag)
</MACRO>
<STRUCT>
<NAME>GstTunerChannel</NAME>
struct _GstTunerChannel {
  GObject              parent;

  /*< public >*/
  gchar               *label;
  GstTunerChannelFlags flags;
  gfloat               freq_multiplicator;
  gulong               min_frequency;
  gulong               max_frequency;
  gint                 min_signal;
  gint                 max_signal;

  /*< private >*/
  gpointer _gst_reserved[GST_PADDING];
};
</STRUCT>
<STRUCT>
<NAME>GstTunerChannelClass</NAME>
struct _GstTunerChannelClass {
  GObjectClass parent;

  /*< private >*/
  /* signals */
  void (*frequency_changed) (GstTunerChannel *channel,
                             gulong           frequency);
  void (*signal_changed)    (GstTunerChannel *channel,
                             gint             signal);

  gpointer _gst_reserved[GST_PADDING];
};
</STRUCT>
<FUNCTION>
<NAME>gst_tuner_channel_get_type</NAME>
<RETURNS>GType            </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_v4l2_video_orientation_interface_init</NAME>
<RETURNS>void      </RETURNS>
GstVideoOrientationInterface * iface
</FUNCTION>
<FUNCTION>
<NAME>gst_v4l2_video_orientation_get_hflip</NAME>
<RETURNS>gboolean  </RETURNS>
GstV4l2Object *v4l2object, gboolean *flip
</FUNCTION>
<FUNCTION>
<NAME>gst_v4l2_video_orientation_get_vflip</NAME>
<RETURNS>gboolean  </RETURNS>
GstV4l2Object *v4l2object, gboolean *flip
</FUNCTION>
<FUNCTION>
<NAME>gst_v4l2_video_orientation_get_hcenter</NAME>
<RETURNS>gboolean  </RETURNS>
GstV4l2Object *v4l2object, gint *center
</FUNCTION>
<FUNCTION>
<NAME>gst_v4l2_video_orientation_get_vcenter</NAME>
<RETURNS>gboolean  </RETURNS>
GstV4l2Object *v4l2object, gint *center
</FUNCTION>
<FUNCTION>
<NAME>gst_v4l2_video_orientation_set_hflip</NAME>
<RETURNS>gboolean  </RETURNS>
GstV4l2Object *v4l2object, gboolean flip
</FUNCTION>
<FUNCTION>
<NAME>gst_v4l2_video_orientation_set_vflip</NAME>
<RETURNS>gboolean  </RETURNS>
GstV4l2Object *v4l2object, gboolean flip
</FUNCTION>
<FUNCTION>
<NAME>gst_v4l2_video_orientation_set_hcenter</NAME>
<RETURNS>gboolean  </RETURNS>
GstV4l2Object *v4l2object, gint center
</FUNCTION>
<FUNCTION>
<NAME>gst_v4l2_video_orientation_set_vcenter</NAME>
<RETURNS>gboolean  </RETURNS>
GstV4l2Object *v4l2object, gint center
</FUNCTION>
<MACRO>
<NAME>GST_IMPLEMENT_V4L2_VIDORIENT_METHODS</NAME>
#define GST_IMPLEMENT_V4L2_VIDORIENT_METHODS(Type, interface_as_function)                         \
                                                                                                  \
  static gboolean                                                                                 \
  interface_as_function ## _video_orientation_get_hflip (GstVideoOrientation *vo, gboolean *flip)       \
  {                                                                                               \
    Type *this = (Type*) vo;                                                                      \
    return gst_v4l2_video_orientation_get_hflip (this->v4l2object, flip);		          \
  }                                                                                               \
                                                                                                  \
  static gboolean                                                                                 \
  interface_as_function ## _video_orientation_get_vflip (GstVideoOrientation *vo, gboolean *flip)       \
  {                                                                                               \
    Type *this = (Type*) vo;                                                                      \
    return gst_v4l2_video_orientation_get_vflip (this->v4l2object, flip);		          \
  }                                                                                               \
                                                                                                  \
  static gboolean                                                                                 \
  interface_as_function ## _video_orientation_get_hcenter (GstVideoOrientation *vo, gint *center)       \
  {                                                                                               \
    Type *this = (Type*) vo;                                                                      \
    return gst_v4l2_video_orientation_get_hcenter (this->v4l2object, center);		          \
  }                                                                                               \
                                                                                                  \
  static gboolean                                                                                 \
  interface_as_function ## _video_orientation_get_vcenter (GstVideoOrientation *vo, gint *center)       \
  {                                                                                               \
    Type *this = (Type*) vo;                                                                      \
    return gst_v4l2_video_orientation_get_vcenter (this->v4l2object, center);		          \
  }                                                                                               \
                                                                                                  \
  static gboolean                                                                                 \
  interface_as_function ## _video_orientation_set_hflip (GstVideoOrientation *vo, gboolean flip)        \
  {                                                                                               \
    Type *this = (Type*) vo;                                                                      \
    return gst_v4l2_video_orientation_set_hflip (this->v4l2object, flip);		          \
  }                                                                                               \
                                                                                                  \
  static gboolean                                                                                 \
  interface_as_function ## _video_orientation_set_vflip (GstVideoOrientation *vo, gboolean flip)        \
  {                                                                                               \
    Type *this = (Type*) vo;                                                                      \
    return gst_v4l2_video_orientation_set_vflip (this->v4l2object, flip);		          \
  }                                                                                               \
                                                                                                  \
  static gboolean                                                                                 \
  interface_as_function ## _video_orientation_set_hcenter (GstVideoOrientation *vo, gint center)        \
  {                                                                                               \
    Type *this = (Type*) vo;                                                                      \
    return gst_v4l2_video_orientation_set_hcenter (this->v4l2object, center);		          \
  }                                                                                               \
                                                                                                  \
  static gboolean                                                                                 \
  interface_as_function ## _video_orientation_set_vcenter (GstVideoOrientation *vo, gint center)        \
  {                                                                                               \
    Type *this = (Type*) vo;                                                                      \
    return gst_v4l2_video_orientation_set_vcenter (this->v4l2object, center);		          \
  }                                                                                               \
                                                                                                  \
  static void                                                                                     \
  interface_as_function ## _video_orientation_interface_init (GstVideoOrientationInterface * iface)          \
  {                                                                                               \
    /* default virtual functions */                                                               \
    iface->get_hflip   = interface_as_function ## _video_orientation_get_hflip;                   \
    iface->get_vflip   = interface_as_function ## _video_orientation_get_vflip;                   \
    iface->get_hcenter = interface_as_function ## _video_orientation_get_hcenter;                 \
    iface->get_vcenter = interface_as_function ## _video_orientation_get_vcenter;                 \
    iface->set_hflip   = interface_as_function ## _video_orientation_set_hflip;                   \
    iface->set_vflip   = interface_as_function ## _video_orientation_set_vflip;                   \
    iface->set_hcenter = interface_as_function ## _video_orientation_set_hcenter;                 \
    iface->set_vcenter = interface_as_function ## _video_orientation_set_vcenter;                 \
  }
</MACRO>
<MACRO>
<NAME>GST_TYPE_TUNER_NORM</NAME>
#define GST_TYPE_TUNER_NORM \
  (gst_tuner_norm_get_type ())
</MACRO>
<MACRO>
<NAME>GST_TUNER_NORM</NAME>
#define GST_TUNER_NORM(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST ((obj), GST_TYPE_TUNER_NORM, GstTunerNorm))
</MACRO>
<MACRO>
<NAME>GST_TUNER_NORM_CLASS</NAME>
#define GST_TUNER_NORM_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST ((klass), GST_TYPE_TUNER_NORM, GstTunerNormClass))
</MACRO>
<MACRO>
<NAME>GST_IS_TUNER_NORM</NAME>
#define GST_IS_TUNER_NORM(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GST_TYPE_TUNER_NORM))
</MACRO>
<MACRO>
<NAME>GST_IS_TUNER_NORM_CLASS</NAME>
#define GST_IS_TUNER_NORM_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE ((klass), GST_TYPE_TUNER_NORM))
</MACRO>
<STRUCT>
<NAME>GstTunerNorm</NAME>
struct _GstTunerNorm {
  GObject parent;

  /*< public >*/
  gchar  *label;
  GValue  framerate;

  /*< private >*/
  gpointer _gst_reserved[GST_PADDING];
};
</STRUCT>
<STRUCT>
<NAME>GstTunerNormClass</NAME>
struct _GstTunerNormClass {
  GObjectClass parent;

  gpointer _gst_reserved[GST_PADDING];
};
</STRUCT>
<FUNCTION>
<NAME>gst_tuner_norm_get_type</NAME>
<RETURNS>GType            </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_V4L2_DEVICE_PROVIDER</NAME>
#define GST_TYPE_V4L2_DEVICE_PROVIDER                 (gst_v4l2_device_provider_get_type())
</MACRO>
<MACRO>
<NAME>GST_IS_V4L2_DEVICE_PROVIDER</NAME>
#define GST_IS_V4L2_DEVICE_PROVIDER(obj)              (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GST_TYPE_V4L2_DEVICE_PROVIDER))
</MACRO>
<MACRO>
<NAME>GST_IS_V4L2_DEVICE_PROVIDER_CLASS</NAME>
#define GST_IS_V4L2_DEVICE_PROVIDER_CLASS(klass)      (G_TYPE_CHECK_CLASS_TYPE ((klass), GST_TYPE_V4L2_DEVICE_PROVIDER))
</MACRO>
<MACRO>
<NAME>GST_V4L2_DEVICE_PROVIDER_GET_CLASS</NAME>
#define GST_V4L2_DEVICE_PROVIDER_GET_CLASS(obj)       (G_TYPE_INSTANCE_GET_CLASS ((obj), GST_TYPE_V4L2_DEVICE_PROVIDER, GstV4l2DeviceProviderClass))
</MACRO>
<MACRO>
<NAME>GST_V4L2_DEVICE_PROVIDER</NAME>
#define GST_V4L2_DEVICE_PROVIDER(obj)                 (G_TYPE_CHECK_INSTANCE_CAST ((obj), GST_TYPE_V4L2_DEVICE_PROVIDER, GstV4l2DeviceProvider))
</MACRO>
<MACRO>
<NAME>GST_V4L2_DEVICE_PROVIDER_CLASS</NAME>
#define GST_V4L2_DEVICE_PROVIDER_CLASS(klass)         (G_TYPE_CHECK_CLASS_CAST ((klass), GST_TYPE_DEVICE_PROVIDER, GstV4l2DeviceProviderClass))
</MACRO>
<MACRO>
<NAME>GST_V4L2_DEVICE_PROVIDER_CAST</NAME>
#define GST_V4L2_DEVICE_PROVIDER_CAST(obj)            ((GstV4l2DeviceProvider *)(obj))
</MACRO>
<STRUCT>
<NAME>GstV4l2DeviceProvider</NAME>
struct _GstV4l2DeviceProvider {
  GstDeviceProvider         parent;

#ifdef HAVE_GUDEV
  GMainContext *context;
  GMainLoop *loop;
  GThread *thread;
  gboolean started;
  GCond started_cond;
#endif
};
</STRUCT>
<ENUM>
<NAME>GstV4l2DeviceType</NAME>
typedef enum {
  GST_V4L2_DEVICE_TYPE_INVALID = 0,
  GST_V4L2_DEVICE_TYPE_SOURCE,
  GST_V4L2_DEVICE_TYPE_SINK
} GstV4l2DeviceType;
</ENUM>
<STRUCT>
<NAME>GstV4l2DeviceProviderClass</NAME>
struct _GstV4l2DeviceProviderClass {
  GstDeviceProviderClass    parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_v4l2_device_provider_get_type</NAME>
<RETURNS>GType         </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_V4L2_DEVICE</NAME>
#define GST_TYPE_V4L2_DEVICE                 (gst_v4l2_device_get_type())
</MACRO>
<MACRO>
<NAME>GST_IS_V4L2_DEVICE</NAME>
#define GST_IS_V4L2_DEVICE(obj)              (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GST_TYPE_V4L2_DEVICE))
</MACRO>
<MACRO>
<NAME>GST_IS_V4L2_DEVICE_CLASS</NAME>
#define GST_IS_V4L2_DEVICE_CLASS(klass)      (G_TYPE_CHECK_CLASS_TYPE ((klass), GST_TYPE_V4L2_DEVICE))
</MACRO>
<MACRO>
<NAME>GST_V4L2_DEVICE_GET_CLASS</NAME>
#define GST_V4L2_DEVICE_GET_CLASS(obj)       (G_TYPE_INSTANCE_GET_CLASS ((obj), GST_TYPE_V4L2_DEVICE, GstV4l2DeviceClass))
</MACRO>
<MACRO>
<NAME>GST_V4L2_DEVICE</NAME>
#define GST_V4L2_DEVICE(obj)                 (G_TYPE_CHECK_INSTANCE_CAST ((obj), GST_TYPE_V4L2_DEVICE, GstV4l2Device))
</MACRO>
<MACRO>
<NAME>GST_V4L2_DEVICE_CLASS</NAME>
#define GST_V4L2_DEVICE_CLASS(klass)         (G_TYPE_CHECK_CLASS_CAST ((klass), GST_TYPE_DEVICE, GstV4l2DeviceClass))
</MACRO>
<MACRO>
<NAME>GST_V4L2_DEVICE_CAST</NAME>
#define GST_V4L2_DEVICE_CAST(obj)            ((GstV4l2Device *)(obj))
</MACRO>
<STRUCT>
<NAME>GstV4l2Device</NAME>
struct _GstV4l2Device {
  GstDevice         parent;

  gchar            *device_path;
  gchar            *syspath;
  const gchar      *element;
};
</STRUCT>
<STRUCT>
<NAME>GstV4l2DeviceClass</NAME>
struct _GstV4l2DeviceClass {
  GstDeviceClass    parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_v4l2_device_get_type</NAME>
<RETURNS>GType         </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_TUNER</NAME>
#define GST_TYPE_TUNER \
  (gst_tuner_get_type ())
</MACRO>
<MACRO>
<NAME>GST_TUNER</NAME>
#define GST_TUNER(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST ((obj), GST_TYPE_TUNER, GstTuner))
</MACRO>
<MACRO>
<NAME>GST_IS_TUNER</NAME>
#define GST_IS_TUNER(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GST_TYPE_TUNER))
</MACRO>
<MACRO>
<NAME>GST_TUNER_GET_INTERFACE</NAME>
#define GST_TUNER_GET_INTERFACE(inst) \
  (G_TYPE_INSTANCE_GET_INTERFACE ((inst), GST_TYPE_TUNER, GstTunerInterface))
</MACRO>
<STRUCT>
<NAME>GstTunerInterface</NAME>
struct _GstTunerInterface {
  GTypeInterface iface;

  /* virtual functions */
  const GList * (* list_channels)   (GstTuner        *tuner);
  void          (* set_channel)     (GstTuner        *tuner,
                                     GstTunerChannel *channel);
  GstTunerChannel *
                (* get_channel)     (GstTuner        *tuner);

  const GList * (* list_norms)      (GstTuner        *tuner);
  void          (* set_norm)        (GstTuner        *tuner,
                                     GstTunerNorm    *norm);
  GstTunerNorm *(* get_norm)        (GstTuner        *tuner);

  void          (* set_frequency)   (GstTuner        *tuner,
                                     GstTunerChannel *channel,
                                     gulong           frequency);
  gulong        (* get_frequency)   (GstTuner        *tuner,
                                     GstTunerChannel *channel);
  gint          (* signal_strength) (GstTuner        *tuner,
                                     GstTunerChannel *channel);

  /* signals */
  void (*channel_changed)   (GstTuner        *tuner,
                             GstTunerChannel *channel);
  void (*norm_changed)      (GstTuner        *tuner,
                             GstTunerNorm    *norm);
  void (*frequency_changed) (GstTuner        *tuner,
                             GstTunerChannel *channel,
                             gulong           frequency);
  void (*signal_changed)    (GstTuner        *tuner,
                             GstTunerChannel *channel,
                             gint             signal);
};
</STRUCT>
<FUNCTION>
<NAME>gst_tuner_get_type</NAME>
<RETURNS>GType            </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_tuner_list_channels</NAME>
<RETURNS>const GList  *   </RETURNS>
GstTuner        *tuner
</FUNCTION>
<FUNCTION>
<NAME>gst_tuner_set_channel</NAME>
<RETURNS>void             </RETURNS>
GstTuner        *tuner, GstTunerChannel *channel
</FUNCTION>
<FUNCTION>
<NAME>gst_tuner_get_channel</NAME>
<RETURNS>GstTunerChannel  *</RETURNS>
GstTuner        *tuner
</FUNCTION>
<FUNCTION>
<NAME>gst_tuner_list_norms</NAME>
<RETURNS>const GList  *   </RETURNS>
GstTuner        *tuner
</FUNCTION>
<FUNCTION>
<NAME>gst_tuner_set_norm</NAME>
<RETURNS>void             </RETURNS>
GstTuner        *tuner, GstTunerNorm    *norm
</FUNCTION>
<FUNCTION>
<NAME>gst_tuner_get_norm</NAME>
<RETURNS>GstTunerNorm  *  </RETURNS>
GstTuner        *tuner
</FUNCTION>
<FUNCTION>
<NAME>gst_tuner_set_frequency</NAME>
<RETURNS>void             </RETURNS>
GstTuner        *tuner, GstTunerChannel *channel, gulong           frequency
</FUNCTION>
<FUNCTION>
<NAME>gst_tuner_get_frequency</NAME>
<RETURNS>gulong           </RETURNS>
GstTuner        *tuner, GstTunerChannel *channel
</FUNCTION>
<FUNCTION>
<NAME>gst_tuner_signal_strength</NAME>
<RETURNS>gint             </RETURNS>
GstTuner        *tuner, GstTunerChannel *channel
</FUNCTION>
<FUNCTION>
<NAME>gst_tuner_find_norm_by_name</NAME>
<RETURNS>GstTunerNorm  *  </RETURNS>
GstTuner        *tuner, gchar           *norm
</FUNCTION>
<FUNCTION>
<NAME>gst_tuner_find_channel_by_name</NAME>
<RETURNS>GstTunerChannel  *</RETURNS>
GstTuner        *tuner, gchar           *channel
</FUNCTION>
<FUNCTION>
<NAME>gst_tuner_channel_changed</NAME>
<RETURNS>void             </RETURNS>
GstTuner        *tuner, GstTunerChannel *channel
</FUNCTION>
<FUNCTION>
<NAME>gst_tuner_norm_changed</NAME>
<RETURNS>void             </RETURNS>
GstTuner        *tuner, GstTunerNorm    *norm
</FUNCTION>
<FUNCTION>
<NAME>gst_tuner_frequency_changed</NAME>
<RETURNS>void             </RETURNS>
GstTuner        *tuner, GstTunerChannel *channel, gulong           frequency
</FUNCTION>
<FUNCTION>
<NAME>gst_tuner_signal_changed</NAME>
<RETURNS>void             </RETURNS>
GstTuner        *tuner, GstTunerChannel *channel, gint             signal
</FUNCTION>
<STRUCT>
<NAME>GstTuner</NAME>
</STRUCT>
<MACRO>
<NAME>GST_V4L2_ERROR_INIT</NAME>
#define GST_V4L2_ERROR_INIT { NULL, NULL }
</MACRO>
<MACRO>
<NAME>GST_V4L2_ERROR</NAME>
#define GST_V4L2_ERROR(v4l2err,domain,code,msg,dbg) \
{\
  if (v4l2err) { \
    gchar *_msg = _gst_element_error_printf msg; \
    v4l2err->error = g_error_new_literal (GST_##domain##_ERROR, \
        GST_##domain##_ERROR_##code, _msg); \
    g_free (_msg); \
    v4l2err->dbg_message = _gst_element_error_printf dbg; \
    v4l2err->file = __FILE__; \
    v4l2err->func = GST_FUNCTION; \
    v4l2err->line = __LINE__; \
  } \
}
</MACRO>
<STRUCT>
<NAME>GstV4l2Iterator</NAME>
struct _GstV4l2Iterator
{
    const gchar *device_path;
    const gchar *device_name;
    const gchar *sys_path;
};
</STRUCT>
<STRUCT>
<NAME>GstV4l2Error</NAME>
struct _GstV4l2Error
{
    GError *error;
    gchar *dbg_message;
    const gchar *file;
    const gchar *func;
    gint line;
};
</STRUCT>
<FUNCTION>
<NAME>gst_v4l2_iterator_new</NAME>
<RETURNS>GstV4l2Iterator  *  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_v4l2_iterator_next</NAME>
<RETURNS>gboolean            </RETURNS>
GstV4l2Iterator *it
</FUNCTION>
<FUNCTION>
<NAME>gst_v4l2_iterator_free</NAME>
<RETURNS>void                </RETURNS>
GstV4l2Iterator *it
</FUNCTION>
<FUNCTION>
<NAME>gst_v4l2_iterator_get_device_path</NAME>
<RETURNS>const gchar  *      </RETURNS>
GstV4l2Iterator *it
</FUNCTION>
<FUNCTION>
<NAME>gst_v4l2_iterator_get_device_name</NAME>
<RETURNS>const gchar  *      </RETURNS>
GstV4l2Iterator *it
</FUNCTION>
<FUNCTION>
<NAME>gst_v4l2_iterator_get_sys_path</NAME>
<RETURNS>const gchar  *      </RETURNS>
GstV4l2Iterator *it
</FUNCTION>
<FUNCTION>
<NAME>gst_v4l2_clear_error</NAME>
<RETURNS>void                </RETURNS>
GstV4l2Error *error
</FUNCTION>
<FUNCTION>
<NAME>gst_v4l2_error</NAME>
<RETURNS>void                </RETURNS>
gpointer element, GstV4l2Error *error
</FUNCTION>
<MACRO>
<NAME>VIDEO_MAX_FRAME</NAME>
#define VIDEO_MAX_FRAME               32
</MACRO>
<MACRO>
<NAME>VIDEO_MAX_PLANES</NAME>
#define VIDEO_MAX_PLANES               8
</MACRO>
<MACRO>
<NAME>v4l2_fourcc</NAME>
#define v4l2_fourcc(a, b, c, d)\
	((__u32)(a) | ((__u32)(b) << 8) | ((__u32)(c) << 16) | ((__u32)(d) << 24))
</MACRO>
<MACRO>
<NAME>v4l2_fourcc_be</NAME>
#define v4l2_fourcc_be(a, b, c, d)	(v4l2_fourcc(a, b, c, d) | (1 << 31))
</MACRO>
<ENUM>
<NAME>v4l2_field</NAME>
enum v4l2_field {
	V4L2_FIELD_ANY           = 0, /* driver can choose from none,
					 top, bottom, interlaced
					 depending on whatever it thinks
					 is approximate ... */
	V4L2_FIELD_NONE          = 1, /* this device has no fields ... */
	V4L2_FIELD_TOP           = 2, /* top field only */
	V4L2_FIELD_BOTTOM        = 3, /* bottom field only */
	V4L2_FIELD_INTERLACED    = 4, /* both fields interlaced */
	V4L2_FIELD_SEQ_TB        = 5, /* both fields sequential into one
					 buffer, top-bottom order */
	V4L2_FIELD_SEQ_BT        = 6, /* same as above + bottom-top order */
	V4L2_FIELD_ALTERNATE     = 7, /* both fields alternating into
					 separate buffers */
	V4L2_FIELD_INTERLACED_TB = 8, /* both fields interlaced, top field
					 first and the top field is
					 transmitted first */
	V4L2_FIELD_INTERLACED_BT = 9, /* both fields interlaced, top field
					 first and the bottom field is
					 transmitted first */
};
</ENUM>
<MACRO>
<NAME>V4L2_FIELD_HAS_TOP</NAME>
#define V4L2_FIELD_HAS_TOP(field)	\
	((field) == V4L2_FIELD_TOP 	||\
	 (field) == V4L2_FIELD_INTERLACED ||\
	 (field) == V4L2_FIELD_INTERLACED_TB ||\
	 (field) == V4L2_FIELD_INTERLACED_BT ||\
	 (field) == V4L2_FIELD_SEQ_TB	||\
	 (field) == V4L2_FIELD_SEQ_BT)
</MACRO>
<MACRO>
<NAME>V4L2_FIELD_HAS_BOTTOM</NAME>
#define V4L2_FIELD_HAS_BOTTOM(field)	\
	((field) == V4L2_FIELD_BOTTOM 	||\
	 (field) == V4L2_FIELD_INTERLACED ||\
	 (field) == V4L2_FIELD_INTERLACED_TB ||\
	 (field) == V4L2_FIELD_INTERLACED_BT ||\
	 (field) == V4L2_FIELD_SEQ_TB	||\
	 (field) == V4L2_FIELD_SEQ_BT)
</MACRO>
<MACRO>
<NAME>V4L2_FIELD_HAS_BOTH</NAME>
#define V4L2_FIELD_HAS_BOTH(field)	\
	((field) == V4L2_FIELD_INTERLACED ||\
	 (field) == V4L2_FIELD_INTERLACED_TB ||\
	 (field) == V4L2_FIELD_INTERLACED_BT ||\
	 (field) == V4L2_FIELD_SEQ_TB ||\
	 (field) == V4L2_FIELD_SEQ_BT)
</MACRO>
<MACRO>
<NAME>V4L2_FIELD_HAS_T_OR_B</NAME>
#define V4L2_FIELD_HAS_T_OR_B(field)	\
	((field) == V4L2_FIELD_BOTTOM ||\
	 (field) == V4L2_FIELD_TOP ||\
	 (field) == V4L2_FIELD_ALTERNATE)
</MACRO>
<ENUM>
<NAME>v4l2_buf_type</NAME>
enum v4l2_buf_type {
	V4L2_BUF_TYPE_VIDEO_CAPTURE        = 1,
	V4L2_BUF_TYPE_VIDEO_OUTPUT         = 2,
	V4L2_BUF_TYPE_VIDEO_OVERLAY        = 3,
	V4L2_BUF_TYPE_VBI_CAPTURE          = 4,
	V4L2_BUF_TYPE_VBI_OUTPUT           = 5,
	V4L2_BUF_TYPE_SLICED_VBI_CAPTURE   = 6,
	V4L2_BUF_TYPE_SLICED_VBI_OUTPUT    = 7,
#if 1
	/* Experimental */
	V4L2_BUF_TYPE_VIDEO_OUTPUT_OVERLAY = 8,
#endif
	V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE = 9,
	V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE  = 10,
	V4L2_BUF_TYPE_SDR_CAPTURE          = 11,
	/* Deprecated, do not use */
	V4L2_BUF_TYPE_PRIVATE              = 0x80,
};
</ENUM>
<MACRO>
<NAME>V4L2_TYPE_IS_MULTIPLANAR</NAME>
#define V4L2_TYPE_IS_MULTIPLANAR(type)			\
	((type) == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE	\
	 || (type) == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE)
</MACRO>
<MACRO>
<NAME>V4L2_TYPE_IS_OUTPUT</NAME>
#define V4L2_TYPE_IS_OUTPUT(type)				\
	((type) == V4L2_BUF_TYPE_VIDEO_OUTPUT			\
	 || (type) == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE		\
	 || (type) == V4L2_BUF_TYPE_VIDEO_OVERLAY		\
	 || (type) == V4L2_BUF_TYPE_VIDEO_OUTPUT_OVERLAY	\
	 || (type) == V4L2_BUF_TYPE_VBI_OUTPUT			\
	 || (type) == V4L2_BUF_TYPE_SLICED_VBI_OUTPUT)
</MACRO>
<ENUM>
<NAME>v4l2_tuner_type</NAME>
enum v4l2_tuner_type {
	V4L2_TUNER_RADIO	     = 1,
	V4L2_TUNER_ANALOG_TV	     = 2,
	V4L2_TUNER_DIGITAL_TV	     = 3,
	V4L2_TUNER_ADC               = 4,
	V4L2_TUNER_RF                = 5,
};
</ENUM>
<ENUM>
<NAME>v4l2_memory</NAME>
enum v4l2_memory {
	V4L2_MEMORY_MMAP             = 1,
	V4L2_MEMORY_USERPTR          = 2,
	V4L2_MEMORY_OVERLAY          = 3,
	V4L2_MEMORY_DMABUF           = 4,
};
</ENUM>
<ENUM>
<NAME>v4l2_colorspace</NAME>
enum v4l2_colorspace {
	/*
	 * Default colorspace, i.e. let the driver figure it out.
	 * Can only be used with video capture.
	 */
	V4L2_COLORSPACE_DEFAULT       = 0,

	/* SMPTE 170M: used for broadcast NTSC/PAL SDTV */
	V4L2_COLORSPACE_SMPTE170M     = 1,

	/* Obsolete pre-1998 SMPTE 240M HDTV standard, superseded by Rec 709 */
	V4L2_COLORSPACE_SMPTE240M     = 2,

	/* Rec.709: used for HDTV */
	V4L2_COLORSPACE_REC709        = 3,

	/*
	 * Deprecated, do not use. No driver will ever return this. This was
	 * based on a misunderstanding of the bt878 datasheet.
	 */
	V4L2_COLORSPACE_BT878         = 4,

	/*
	 * NTSC 1953 colorspace. This only makes sense when dealing with
	 * really, really old NTSC recordings. Superseded by SMPTE 170M.
	 */
	V4L2_COLORSPACE_470_SYSTEM_M  = 5,

	/*
	 * EBU Tech 3213 PAL/SECAM colorspace. This only makes sense when
	 * dealing with really old PAL/SECAM recordings. Superseded by
	 * SMPTE 170M.
	 */
	V4L2_COLORSPACE_470_SYSTEM_BG = 6,

	/*
	 * Effectively shorthand for V4L2_COLORSPACE_SRGB, V4L2_YCBCR_ENC_601
	 * and V4L2_QUANTIZATION_FULL_RANGE. To be used for (Motion-)JPEG.
	 */
	V4L2_COLORSPACE_JPEG          = 7,

	/* For RGB colorspaces such as produces by most webcams. */
	V4L2_COLORSPACE_SRGB          = 8,

	/* AdobeRGB colorspace */
	V4L2_COLORSPACE_ADOBERGB      = 9,

	/* BT.2020 colorspace, used for UHDTV. */
	V4L2_COLORSPACE_BT2020        = 10,

	/* Raw colorspace: for RAW unprocessed images */
	V4L2_COLORSPACE_RAW           = 11,
};
</ENUM>
<MACRO>
<NAME>V4L2_MAP_COLORSPACE_DEFAULT</NAME>
#define V4L2_MAP_COLORSPACE_DEFAULT(is_sdtv, is_hdtv) \
	((is_sdtv) ? V4L2_COLORSPACE_SMPTE170M : \
	 ((is_hdtv) ? V4L2_COLORSPACE_REC709 : V4L2_COLORSPACE_SRGB))
</MACRO>
<ENUM>
<NAME>v4l2_xfer_func</NAME>
enum v4l2_xfer_func {
	/*
	 * Mapping of V4L2_XFER_FUNC_DEFAULT to actual transfer functions
	 * for the various colorspaces:
	 *
	 * V4L2_COLORSPACE_SMPTE170M, V4L2_COLORSPACE_470_SYSTEM_M,
	 * V4L2_COLORSPACE_470_SYSTEM_BG, V4L2_COLORSPACE_REC709 and
	 * V4L2_COLORSPACE_BT2020: V4L2_XFER_FUNC_709
	 *
	 * V4L2_COLORSPACE_SRGB, V4L2_COLORSPACE_JPEG: V4L2_XFER_FUNC_SRGB
	 *
	 * V4L2_COLORSPACE_ADOBERGB: V4L2_XFER_FUNC_ADOBERGB
	 *
	 * V4L2_COLORSPACE_SMPTE240M: V4L2_XFER_FUNC_SMPTE240M
	 *
	 * V4L2_COLORSPACE_RAW: V4L2_XFER_FUNC_NONE
	 */
	V4L2_XFER_FUNC_DEFAULT     = 0,
	V4L2_XFER_FUNC_709         = 1,
	V4L2_XFER_FUNC_SRGB        = 2,
	V4L2_XFER_FUNC_ADOBERGB    = 3,
	V4L2_XFER_FUNC_SMPTE240M   = 4,
	V4L2_XFER_FUNC_NONE        = 5,
};
</ENUM>
<MACRO>
<NAME>V4L2_MAP_XFER_FUNC_DEFAULT</NAME>
#define V4L2_MAP_XFER_FUNC_DEFAULT(colsp) \
	((colsp) == V4L2_XFER_FUNC_ADOBERGB ? V4L2_XFER_FUNC_ADOBERGB : \
	 ((colsp) == V4L2_COLORSPACE_SMPTE240M ? V4L2_XFER_FUNC_SMPTE240M : \
	  ((colsp) == V4L2_COLORSPACE_RAW ? V4L2_XFER_FUNC_NONE : \
	   ((colsp) == V4L2_COLORSPACE_SRGB || (colsp) == V4L2_COLORSPACE_JPEG ? \
	    V4L2_XFER_FUNC_SRGB : V4L2_XFER_FUNC_709))))
</MACRO>
<ENUM>
<NAME>v4l2_ycbcr_encoding</NAME>
enum v4l2_ycbcr_encoding {
	/*
	 * Mapping of V4L2_YCBCR_ENC_DEFAULT to actual encodings for the
	 * various colorspaces:
	 *
	 * V4L2_COLORSPACE_SMPTE170M, V4L2_COLORSPACE_470_SYSTEM_M,
	 * V4L2_COLORSPACE_470_SYSTEM_BG, V4L2_COLORSPACE_ADOBERGB and
	 * V4L2_COLORSPACE_JPEG: V4L2_YCBCR_ENC_601
	 *
	 * V4L2_COLORSPACE_REC709: V4L2_YCBCR_ENC_709
	 *
	 * V4L2_COLORSPACE_SRGB: V4L2_YCBCR_ENC_SYCC
	 *
	 * V4L2_COLORSPACE_BT2020: V4L2_YCBCR_ENC_BT2020
	 *
	 * V4L2_COLORSPACE_SMPTE240M: V4L2_YCBCR_ENC_SMPTE240M
	 */
	V4L2_YCBCR_ENC_DEFAULT        = 0,

	/* ITU-R 601 -- SDTV */
	V4L2_YCBCR_ENC_601            = 1,

	/* Rec. 709 -- HDTV */
	V4L2_YCBCR_ENC_709            = 2,

	/* ITU-R 601/EN 61966-2-4 Extended Gamut -- SDTV */
	V4L2_YCBCR_ENC_XV601          = 3,

	/* Rec. 709/EN 61966-2-4 Extended Gamut -- HDTV */
	V4L2_YCBCR_ENC_XV709          = 4,

	/* sYCC (Y'CbCr encoding of sRGB) */
	V4L2_YCBCR_ENC_SYCC           = 5,

	/* BT.2020 Non-constant Luminance Y'CbCr */
	V4L2_YCBCR_ENC_BT2020         = 6,

	/* BT.2020 Constant Luminance Y'CbcCrc */
	V4L2_YCBCR_ENC_BT2020_CONST_LUM = 7,

	/* SMPTE 240M -- Obsolete HDTV */
	V4L2_YCBCR_ENC_SMPTE240M      = 8,
};
</ENUM>
<MACRO>
<NAME>V4L2_MAP_YCBCR_ENC_DEFAULT</NAME>
#define V4L2_MAP_YCBCR_ENC_DEFAULT(colsp) \
	((colsp) == V4L2_COLORSPACE_REC709 ? V4L2_YCBCR_ENC_709 : \
	 ((colsp) == V4L2_COLORSPACE_BT2020 ? V4L2_YCBCR_ENC_BT2020 : \
	  ((colsp) == V4L2_COLORSPACE_SMPTE240M ? V4L2_YCBCR_ENC_SMPTE240M : \
	   V4L2_YCBCR_ENC_601)))
</MACRO>
<ENUM>
<NAME>v4l2_quantization</NAME>
enum v4l2_quantization {
	/*
	 * The default for R'G'B' quantization is always full range, except
	 * for the BT2020 colorspace. For Y'CbCr the quantization is always
	 * limited range, except for COLORSPACE_JPEG, SYCC, XV601 or XV709:
	 * those are full range.
	 */
	V4L2_QUANTIZATION_DEFAULT     = 0,
	V4L2_QUANTIZATION_FULL_RANGE  = 1,
	V4L2_QUANTIZATION_LIM_RANGE   = 2,
};
</ENUM>
<MACRO>
<NAME>V4L2_MAP_QUANTIZATION_DEFAULT</NAME>
#define V4L2_MAP_QUANTIZATION_DEFAULT(is_rgb, colsp, ycbcr_enc) \
	(((is_rgb) && (colsp) == V4L2_COLORSPACE_BT2020) ? V4L2_QUANTIZATION_LIM_RANGE : \
	 (((is_rgb) || (ycbcr_enc) == V4L2_YCBCR_ENC_XV601 || \
	  (ycbcr_enc) == V4L2_YCBCR_ENC_XV709 || (colsp) == V4L2_COLORSPACE_JPEG) ? \
	 V4L2_QUANTIZATION_FULL_RANGE : V4L2_QUANTIZATION_LIM_RANGE))
</MACRO>
<ENUM>
<NAME>v4l2_priority</NAME>
enum v4l2_priority {
	V4L2_PRIORITY_UNSET       = 0,  /* not initialized */
	V4L2_PRIORITY_BACKGROUND  = 1,
	V4L2_PRIORITY_INTERACTIVE = 2,
	V4L2_PRIORITY_RECORD      = 3,
	V4L2_PRIORITY_DEFAULT     = V4L2_PRIORITY_INTERACTIVE,
};
</ENUM>
<STRUCT>
<NAME>v4l2_rect</NAME>
struct v4l2_rect {
	__s32   left;
	__s32   top;
	__u32   width;
	__u32   height;
};
</STRUCT>
<STRUCT>
<NAME>v4l2_fract</NAME>
struct v4l2_fract {
	__u32   numerator;
	__u32   denominator;
};
</STRUCT>
<STRUCT>
<NAME>v4l2_capability</NAME>
struct v4l2_capability {
	__u8	driver[16];
	__u8	card[32];
	__u8	bus_info[32];
	__u32   version;
	__u32	capabilities;
	__u32	device_caps;
	__u32	reserved[3];
};
</STRUCT>
<MACRO>
<NAME>V4L2_CAP_VIDEO_CAPTURE</NAME>
#define V4L2_CAP_VIDEO_CAPTURE		0x00000001  /* Is a video capture device */
</MACRO>
<MACRO>
<NAME>V4L2_CAP_VIDEO_OUTPUT</NAME>
#define V4L2_CAP_VIDEO_OUTPUT		0x00000002  /* Is a video output device */
</MACRO>
<MACRO>
<NAME>V4L2_CAP_VIDEO_OVERLAY</NAME>
#define V4L2_CAP_VIDEO_OVERLAY		0x00000004  /* Can do video overlay */
</MACRO>
<MACRO>
<NAME>V4L2_CAP_VBI_CAPTURE</NAME>
#define V4L2_CAP_VBI_CAPTURE		0x00000010  /* Is a raw VBI capture device */
</MACRO>
<MACRO>
<NAME>V4L2_CAP_VBI_OUTPUT</NAME>
#define V4L2_CAP_VBI_OUTPUT		0x00000020  /* Is a raw VBI output device */
</MACRO>
<MACRO>
<NAME>V4L2_CAP_SLICED_VBI_CAPTURE</NAME>
#define V4L2_CAP_SLICED_VBI_CAPTURE	0x00000040  /* Is a sliced VBI capture device */
</MACRO>
<MACRO>
<NAME>V4L2_CAP_SLICED_VBI_OUTPUT</NAME>
#define V4L2_CAP_SLICED_VBI_OUTPUT	0x00000080  /* Is a sliced VBI output device */
</MACRO>
<MACRO>
<NAME>V4L2_CAP_RDS_CAPTURE</NAME>
#define V4L2_CAP_RDS_CAPTURE		0x00000100  /* RDS data capture */
</MACRO>
<MACRO>
<NAME>V4L2_CAP_VIDEO_OUTPUT_OVERLAY</NAME>
#define V4L2_CAP_VIDEO_OUTPUT_OVERLAY	0x00000200  /* Can do video output overlay */
</MACRO>
<MACRO>
<NAME>V4L2_CAP_HW_FREQ_SEEK</NAME>
#define V4L2_CAP_HW_FREQ_SEEK		0x00000400  /* Can do hardware frequency seek  */
</MACRO>
<MACRO>
<NAME>V4L2_CAP_RDS_OUTPUT</NAME>
#define V4L2_CAP_RDS_OUTPUT		0x00000800  /* Is an RDS encoder */
</MACRO>
<MACRO>
<NAME>V4L2_CAP_VIDEO_CAPTURE_MPLANE</NAME>
#define V4L2_CAP_VIDEO_CAPTURE_MPLANE	0x00001000
</MACRO>
<MACRO>
<NAME>V4L2_CAP_VIDEO_OUTPUT_MPLANE</NAME>
#define V4L2_CAP_VIDEO_OUTPUT_MPLANE	0x00002000
</MACRO>
<MACRO>
<NAME>V4L2_CAP_VIDEO_M2M_MPLANE</NAME>
#define V4L2_CAP_VIDEO_M2M_MPLANE	0x00004000
</MACRO>
<MACRO>
<NAME>V4L2_CAP_VIDEO_M2M</NAME>
#define V4L2_CAP_VIDEO_M2M		0x00008000
</MACRO>
<MACRO>
<NAME>V4L2_CAP_TUNER</NAME>
#define V4L2_CAP_TUNER			0x00010000  /* has a tuner */
</MACRO>
<MACRO>
<NAME>V4L2_CAP_AUDIO</NAME>
#define V4L2_CAP_AUDIO			0x00020000  /* has audio support */
</MACRO>
<MACRO>
<NAME>V4L2_CAP_RADIO</NAME>
#define V4L2_CAP_RADIO			0x00040000  /* is a radio device */
</MACRO>
<MACRO>
<NAME>V4L2_CAP_MODULATOR</NAME>
#define V4L2_CAP_MODULATOR		0x00080000  /* has a modulator */
</MACRO>
<MACRO>
<NAME>V4L2_CAP_SDR_CAPTURE</NAME>
#define V4L2_CAP_SDR_CAPTURE		0x00100000  /* Is a SDR capture device */
</MACRO>
<MACRO>
<NAME>V4L2_CAP_EXT_PIX_FORMAT</NAME>
#define V4L2_CAP_EXT_PIX_FORMAT		0x00200000  /* Supports the extended pixel format */
</MACRO>
<MACRO>
<NAME>V4L2_CAP_READWRITE</NAME>
#define V4L2_CAP_READWRITE              0x01000000  /* read/write systemcalls */
</MACRO>
<MACRO>
<NAME>V4L2_CAP_ASYNCIO</NAME>
#define V4L2_CAP_ASYNCIO                0x02000000  /* async I/O */
</MACRO>
<MACRO>
<NAME>V4L2_CAP_STREAMING</NAME>
#define V4L2_CAP_STREAMING              0x04000000  /* streaming I/O ioctls */
</MACRO>
<MACRO>
<NAME>V4L2_CAP_DEVICE_CAPS</NAME>
#define V4L2_CAP_DEVICE_CAPS            0x80000000  /* sets device capabilities field */
</MACRO>
<STRUCT>
<NAME>v4l2_pix_format</NAME>
struct v4l2_pix_format {
	__u32         		width;
	__u32			height;
	__u32			pixelformat;
	__u32			field;		/* enum v4l2_field */
	__u32            	bytesperline;	/* for padding, zero if unused */
	__u32          		sizeimage;
	__u32			colorspace;	/* enum v4l2_colorspace */
	__u32			priv;		/* private data, depends on pixelformat */
	__u32			flags;		/* format flags (V4L2_PIX_FMT_FLAG_*) */
	__u32			ycbcr_enc;	/* enum v4l2_ycbcr_encoding */
	__u32			quantization;	/* enum v4l2_quantization */
	__u32			xfer_func;	/* enum v4l2_xfer_func */
};
</STRUCT>
<MACRO>
<NAME>V4L2_PIX_FMT_RGB332</NAME>
#define V4L2_PIX_FMT_RGB332  v4l2_fourcc('R', 'G', 'B', '1') /*  8  RGB-3-3-2     */
</MACRO>
<MACRO>
<NAME>V4L2_PIX_FMT_RGB444</NAME>
#define V4L2_PIX_FMT_RGB444  v4l2_fourcc('R', '4', '4', '4') /* 16  xxxxrrrr ggggbbbb */
</MACRO>
<MACRO>
<NAME>V4L2_PIX_FMT_ARGB444</NAME>
#define V4L2_PIX_FMT_ARGB444 v4l2_fourcc('A', 'R', '1', '2') /* 16  aaaarrrr ggggbbbb */
</MACRO>
<MACRO>
<NAME>V4L2_PIX_FMT_XRGB444</NAME>
#define V4L2_PIX_FMT_XRGB444 v4l2_fourcc('X', 'R', '1', '2') /* 16  xxxxrrrr ggggbbbb */
</MACRO>
<MACRO>
<NAME>V4L2_PIX_FMT_RGB555</NAME>
#define V4L2_PIX_FMT_RGB555  v4l2_fourcc('R', 'G', 'B', 'O') /* 16  RGB-5-5-5     */
</MACRO>
<MACRO>
<NAME>V4L2_PIX_FMT_ARGB555</NAME>
#define V4L2_PIX_FMT_ARGB555 v4l2_fourcc('A', 'R', '1', '5') /* 16  ARGB-1-5-5-5  */
</MACRO>
<MACRO>
<NAME>V4L2_PIX_FMT_XRGB555</NAME>
#define V4L2_PIX_FMT_XRGB555 v4l2_fourcc('X', 'R', '1', '5') /* 16  XRGB-1-5-5-5  */
</MACRO>
<MACRO>
<NAME>V4L2_PIX_FMT_RGB565</NAME>
#define V4L2_PIX_FMT_RGB565  v4l2_fourcc('R', 'G', 'B', 'P') /* 16  RGB-5-6-5     */
</MACRO>
<MACRO>
<NAME>V4L2_PIX_FMT_RGB555X</NAME>
#define V4L2_PIX_FMT_RGB555X v4l2_fourcc('R', 'G', 'B', 'Q') /* 16  RGB-5-5-5 BE  */
</MACRO>
<MACRO>
<NAME>V4L2_PIX_FMT_ARGB555X</NAME>
#define V4L2_PIX_FMT_ARGB555X v4l2_fourcc_be('A', 'R', '1', '5') /* 16  ARGB-5-5-5 BE */
</MACRO>
<MACRO>
<NAME>V4L2_PIX_FMT_XRGB555X</NAME>
#define V4L2_PIX_FMT_XRGB555X v4l2_fourcc_be('X', 'R', '1', '5') /* 16  XRGB-5-5-5 BE */
</MACRO>
<MACRO>
<NAME>V4L2_PIX_FMT_RGB565X</NAME>
#define V4L2_PIX_FMT_RGB565X v4l2_fourcc('R', 'G', 'B', 'R') /* 16  RGB-5-6-5 BE  */
</MACRO>
<MACRO>
<NAME>V4L2_PIX_FMT_BGR666</NAME>
#define V4L2_PIX_FMT_BGR666  v4l2_fourcc('B', 'G', 'R', 'H') /* 18  BGR-6-6-6	  */
</MACRO>
<MACRO>
<NAME>V4L2_PIX_FMT_BGR24</NAME>
#define V4L2_PIX_FMT_BGR24   v4l2_fourcc('B', 'G', 'R', '3') /* 24  BGR-8-8-8     */
</MACRO>
<MACRO>
<NAME>V4L2_PIX_FMT_RGB24</NAME>
#define V4L2_PIX_FMT_RGB24   v4l2_fourcc('R', 'G', 'B', '3') /* 24  RGB-8-8-8     */
</MACRO>
<MACRO>
<NAME>V4L2_PIX_FMT_BGR32</NAME>
#define V4L2_PIX_FMT_BGR32   v4l2_fourcc('B', 'G', 'R', '4') /* 32  BGR-8-8-8-8   */
</MACRO>
<MACRO>
<NAME>V4L2_PIX_FMT_ABGR32</NAME>
#define V4L2_PIX_FMT_ABGR32  v4l2_fourcc('A', 'R', '2', '4') /* 32  BGRA-8-8-8-8  */
</MACRO>
<MACRO>
<NAME>V4L2_PIX_FMT_XBGR32</NAME>
#define V4L2_PIX_FMT_XBGR32  v4l2_fourcc('X', 'R', '2', '4') /* 32  BGRX-8-8-8-8  */
</MACRO>
<MACRO>
<NAME>V4L2_PIX_FMT_RGB32</NAME>
#define V4L2_PIX_FMT_RGB32   v4l2_fourcc('R', 'G', 'B', '4') /* 32  RGB-8-8-8-8   */
</MACRO>
<MACRO>
<NAME>V4L2_PIX_FMT_ARGB32</NAME>
#define V4L2_PIX_FMT_ARGB32  v4l2_fourcc('B', 'A', '2', '4') /* 32  ARGB-8-8-8-8  */
</MACRO>
<MACRO>
<NAME>V4L2_PIX_FMT_XRGB32</NAME>
#define V4L2_PIX_FMT_XRGB32  v4l2_fourcc('B', 'X', '2', '4') /* 32  XRGB-8-8-8-8  */
</MACRO>
<MACRO>
<NAME>V4L2_PIX_FMT_GREY</NAME>
#define V4L2_PIX_FMT_GREY    v4l2_fourcc('G', 'R', 'E', 'Y') /*  8  Greyscale     */
</MACRO>
<MACRO>
<NAME>V4L2_PIX_FMT_Y4</NAME>
#define V4L2_PIX_FMT_Y4      v4l2_fourcc('Y', '0', '4', ' ') /*  4  Greyscale     */
</MACRO>
<MACRO>
<NAME>V4L2_PIX_FMT_Y6</NAME>
#define V4L2_PIX_FMT_Y6      v4l2_fourcc('Y', '0', '6', ' ') /*  6  Greyscale     */
</MACRO>
<MACRO>
<NAME>V4L2_PIX_FMT_Y10</NAME>
#define V4L2_PIX_FMT_Y10     v4l2_fourcc('Y', '1', '0', ' ') /* 10  Greyscale     */
</MACRO>
<MACRO>
<NAME>V4L2_PIX_FMT_Y12</NAME>
#define V4L2_PIX_FMT_Y12     v4l2_fourcc('Y', '1', '2', ' ') /* 12  Greyscale     */
</MACRO>
<MACRO>
<NAME>V4L2_PIX_FMT_Y16</NAME>
#define V4L2_PIX_FMT_Y16     v4l2_fourcc('Y', '1', '6', ' ') /* 16  Greyscale     */
</MACRO>
<MACRO>
<NAME>V4L2_PIX_FMT_Y16_BE</NAME>
#define V4L2_PIX_FMT_Y16_BE  v4l2_fourcc_be('Y', '1', '6', ' ') /* 16  Greyscale BE  */
</MACRO>
<MACRO>
<NAME>V4L2_PIX_FMT_Y10BPACK</NAME>
#define V4L2_PIX_FMT_Y10BPACK    v4l2_fourcc('Y', '1', '0', 'B') /* 10  Greyscale bit-packed */
</MACRO>
<MACRO>
<NAME>V4L2_PIX_FMT_PAL8</NAME>
#define V4L2_PIX_FMT_PAL8    v4l2_fourcc('P', 'A', 'L', '8') /*  8  8-bit palette */
</MACRO>
<MACRO>
<NAME>V4L2_PIX_FMT_UV8</NAME>
#define V4L2_PIX_FMT_UV8     v4l2_fourcc('U', 'V', '8', ' ') /*  8  UV 4:4 */
</MACRO>
<MACRO>
<NAME>V4L2_PIX_FMT_YVU410</NAME>
#define V4L2_PIX_FMT_YVU410  v4l2_fourcc('Y', 'V', 'U', '9') /*  9  YVU 4:1:0     */
</MACRO>
<MACRO>
<NAME>V4L2_PIX_FMT_YVU420</NAME>
#define V4L2_PIX_FMT_YVU420  v4l2_fourcc('Y', 'V', '1', '2') /* 12  YVU 4:2:0     */
</MACRO>
<MACRO>
<NAME>V4L2_PIX_FMT_YUYV</NAME>
#define V4L2_PIX_FMT_YUYV    v4l2_fourcc('Y', 'U', 'Y', 'V') /* 16  YUV 4:2:2     */
</MACRO>
<MACRO>
<NAME>V4L2_PIX_FMT_YYUV</NAME>
#define V4L2_PIX_FMT_YYUV    v4l2_fourcc('Y', 'Y', 'U', 'V') /* 16  YUV 4:2:2     */
</MACRO>
<MACRO>
<NAME>V4L2_PIX_FMT_YVYU</NAME>
#define V4L2_PIX_FMT_YVYU    v4l2_fourcc('Y', 'V', 'Y', 'U') /* 16 YVU 4:2:2 */
</MACRO>
<MACRO>
<NAME>V4L2_PIX_FMT_UYVY</NAME>
#define V4L2_PIX_FMT_UYVY    v4l2_fourcc('U', 'Y', 'V', 'Y') /* 16  YUV 4:2:2     */
</MACRO>
<MACRO>
<NAME>V4L2_PIX_FMT_VYUY</NAME>
#define V4L2_PIX_FMT_VYUY    v4l2_fourcc('V', 'Y', 'U', 'Y') /* 16  YUV 4:2:2     */
</MACRO>
<MACRO>
<NAME>V4L2_PIX_FMT_YUV422P</NAME>
#define V4L2_PIX_FMT_YUV422P v4l2_fourcc('4', '2', '2', 'P') /* 16  YVU422 planar */
</MACRO>
<MACRO>
<NAME>V4L2_PIX_FMT_YUV411P</NAME>
#define V4L2_PIX_FMT_YUV411P v4l2_fourcc('4', '1', '1', 'P') /* 16  YVU411 planar */
</MACRO>
<MACRO>
<NAME>V4L2_PIX_FMT_Y41P</NAME>
#define V4L2_PIX_FMT_Y41P    v4l2_fourcc('Y', '4', '1', 'P') /* 12  YUV 4:1:1     */
</MACRO>
<MACRO>
<NAME>V4L2_PIX_FMT_YUV444</NAME>
#define V4L2_PIX_FMT_YUV444  v4l2_fourcc('Y', '4', '4', '4') /* 16  xxxxyyyy uuuuvvvv */
</MACRO>
<MACRO>
<NAME>V4L2_PIX_FMT_YUV555</NAME>
#define V4L2_PIX_FMT_YUV555  v4l2_fourcc('Y', 'U', 'V', 'O') /* 16  YUV-5-5-5     */
</MACRO>
<MACRO>
<NAME>V4L2_PIX_FMT_YUV565</NAME>
#define V4L2_PIX_FMT_YUV565  v4l2_fourcc('Y', 'U', 'V', 'P') /* 16  YUV-5-6-5     */
</MACRO>
<MACRO>
<NAME>V4L2_PIX_FMT_YUV32</NAME>
#define V4L2_PIX_FMT_YUV32   v4l2_fourcc('Y', 'U', 'V', '4') /* 32  YUV-8-8-8-8   */
</MACRO>
<MACRO>
<NAME>V4L2_PIX_FMT_YUV410</NAME>
#define V4L2_PIX_FMT_YUV410  v4l2_fourcc('Y', 'U', 'V', '9') /*  9  YUV 4:1:0     */
</MACRO>
<MACRO>
<NAME>V4L2_PIX_FMT_YUV420</NAME>
#define V4L2_PIX_FMT_YUV420  v4l2_fourcc('Y', 'U', '1', '2') /* 12  YUV 4:2:0     */
</MACRO>
<MACRO>
<NAME>V4L2_PIX_FMT_HI240</NAME>
#define V4L2_PIX_FMT_HI240   v4l2_fourcc('H', 'I', '2', '4') /*  8  8-bit color   */
</MACRO>
<MACRO>
<NAME>V4L2_PIX_FMT_HM12</NAME>
#define V4L2_PIX_FMT_HM12    v4l2_fourcc('H', 'M', '1', '2') /*  8  YUV 4:2:0 16x16 macroblocks */
</MACRO>
<MACRO>
<NAME>V4L2_PIX_FMT_M420</NAME>
#define V4L2_PIX_FMT_M420    v4l2_fourcc('M', '4', '2', '0') /* 12  YUV 4:2:0 2 lines y, 1 line uv interleaved */
</MACRO>
<MACRO>
<NAME>V4L2_PIX_FMT_NV12</NAME>
#define V4L2_PIX_FMT_NV12    v4l2_fourcc('N', 'V', '1', '2') /* 12  Y/CbCr 4:2:0  */
</MACRO>
<MACRO>
<NAME>V4L2_PIX_FMT_NV21</NAME>
#define V4L2_PIX_FMT_NV21    v4l2_fourcc('N', 'V', '2', '1') /* 12  Y/CrCb 4:2:0  */
</MACRO>
<MACRO>
<NAME>V4L2_PIX_FMT_NV16</NAME>
#define V4L2_PIX_FMT_NV16    v4l2_fourcc('N', 'V', '1', '6') /* 16  Y/CbCr 4:2:2  */
</MACRO>
<MACRO>
<NAME>V4L2_PIX_FMT_NV61</NAME>
#define V4L2_PIX_FMT_NV61    v4l2_fourcc('N', 'V', '6', '1') /* 16  Y/CrCb 4:2:2  */
</MACRO>
<MACRO>
<NAME>V4L2_PIX_FMT_NV24</NAME>
#define V4L2_PIX_FMT_NV24    v4l2_fourcc('N', 'V', '2', '4') /* 24  Y/CbCr 4:4:4  */
</MACRO>
<MACRO>
<NAME>V4L2_PIX_FMT_NV42</NAME>
#define V4L2_PIX_FMT_NV42    v4l2_fourcc('N', 'V', '4', '2') /* 24  Y/CrCb 4:4:4  */
</MACRO>
<MACRO>
<NAME>V4L2_PIX_FMT_NV12M</NAME>
#define V4L2_PIX_FMT_NV12M   v4l2_fourcc('N', 'M', '1', '2') /* 12  Y/CbCr 4:2:0  */
</MACRO>
<MACRO>
<NAME>V4L2_PIX_FMT_NV21M</NAME>
#define V4L2_PIX_FMT_NV21M   v4l2_fourcc('N', 'M', '2', '1') /* 21  Y/CrCb 4:2:0  */
</MACRO>
<MACRO>
<NAME>V4L2_PIX_FMT_NV16M</NAME>
#define V4L2_PIX_FMT_NV16M   v4l2_fourcc('N', 'M', '1', '6') /* 16  Y/CbCr 4:2:2  */
</MACRO>
<MACRO>
<NAME>V4L2_PIX_FMT_NV61M</NAME>
#define V4L2_PIX_FMT_NV61M   v4l2_fourcc('N', 'M', '6', '1') /* 16  Y/CrCb 4:2:2  */
</MACRO>
<MACRO>
<NAME>V4L2_PIX_FMT_NV12MT</NAME>
#define V4L2_PIX_FMT_NV12MT  v4l2_fourcc('T', 'M', '1', '2') /* 12  Y/CbCr 4:2:0 64x32 macroblocks */
</MACRO>
<MACRO>
<NAME>V4L2_PIX_FMT_NV12MT_16X16</NAME>
#define V4L2_PIX_FMT_NV12MT_16X16 v4l2_fourcc('V', 'M', '1', '2') /* 12  Y/CbCr 4:2:0 16x16 macroblocks */
</MACRO>
<MACRO>
<NAME>V4L2_PIX_FMT_YUV420M</NAME>
#define V4L2_PIX_FMT_YUV420M v4l2_fourcc('Y', 'M', '1', '2') /* 12  YUV420 planar */
</MACRO>
<MACRO>
<NAME>V4L2_PIX_FMT_YVU420M</NAME>
#define V4L2_PIX_FMT_YVU420M v4l2_fourcc('Y', 'M', '2', '1') /* 12  YVU420 planar */
</MACRO>
<MACRO>
<NAME>V4L2_PIX_FMT_SBGGR8</NAME>
#define V4L2_PIX_FMT_SBGGR8  v4l2_fourcc('B', 'A', '8', '1') /*  8  BGBG.. GRGR.. */
</MACRO>
<MACRO>
<NAME>V4L2_PIX_FMT_SGBRG8</NAME>
#define V4L2_PIX_FMT_SGBRG8  v4l2_fourcc('G', 'B', 'R', 'G') /*  8  GBGB.. RGRG.. */
</MACRO>
<MACRO>
<NAME>V4L2_PIX_FMT_SGRBG8</NAME>
#define V4L2_PIX_FMT_SGRBG8  v4l2_fourcc('G', 'R', 'B', 'G') /*  8  GRGR.. BGBG.. */
</MACRO>
<MACRO>
<NAME>V4L2_PIX_FMT_SRGGB8</NAME>
#define V4L2_PIX_FMT_SRGGB8  v4l2_fourcc('R', 'G', 'G', 'B') /*  8  RGRG.. GBGB.. */
</MACRO>
<MACRO>
<NAME>V4L2_PIX_FMT_SBGGR10</NAME>
#define V4L2_PIX_FMT_SBGGR10 v4l2_fourcc('B', 'G', '1', '0') /* 10  BGBG.. GRGR.. */
</MACRO>
<MACRO>
<NAME>V4L2_PIX_FMT_SGBRG10</NAME>
#define V4L2_PIX_FMT_SGBRG10 v4l2_fourcc('G', 'B', '1', '0') /* 10  GBGB.. RGRG.. */
</MACRO>
<MACRO>
<NAME>V4L2_PIX_FMT_SGRBG10</NAME>
#define V4L2_PIX_FMT_SGRBG10 v4l2_fourcc('B', 'A', '1', '0') /* 10  GRGR.. BGBG.. */
</MACRO>
<MACRO>
<NAME>V4L2_PIX_FMT_SRGGB10</NAME>
#define V4L2_PIX_FMT_SRGGB10 v4l2_fourcc('R', 'G', '1', '0') /* 10  RGRG.. GBGB.. */
</MACRO>
<MACRO>
<NAME>V4L2_PIX_FMT_SBGGR10P</NAME>
#define V4L2_PIX_FMT_SBGGR10P v4l2_fourcc('p', 'B', 'A', 'A')
</MACRO>
<MACRO>
<NAME>V4L2_PIX_FMT_SGBRG10P</NAME>
#define V4L2_PIX_FMT_SGBRG10P v4l2_fourcc('p', 'G', 'A', 'A')
</MACRO>
<MACRO>
<NAME>V4L2_PIX_FMT_SGRBG10P</NAME>
#define V4L2_PIX_FMT_SGRBG10P v4l2_fourcc('p', 'g', 'A', 'A')
</MACRO>
<MACRO>
<NAME>V4L2_PIX_FMT_SRGGB10P</NAME>
#define V4L2_PIX_FMT_SRGGB10P v4l2_fourcc('p', 'R', 'A', 'A')
</MACRO>
<MACRO>
<NAME>V4L2_PIX_FMT_SBGGR10ALAW8</NAME>
#define V4L2_PIX_FMT_SBGGR10ALAW8 v4l2_fourcc('a', 'B', 'A', '8')
</MACRO>
<MACRO>
<NAME>V4L2_PIX_FMT_SGBRG10ALAW8</NAME>
#define V4L2_PIX_FMT_SGBRG10ALAW8 v4l2_fourcc('a', 'G', 'A', '8')
</MACRO>
<MACRO>
<NAME>V4L2_PIX_FMT_SGRBG10ALAW8</NAME>
#define V4L2_PIX_FMT_SGRBG10ALAW8 v4l2_fourcc('a', 'g', 'A', '8')
</MACRO>
<MACRO>
<NAME>V4L2_PIX_FMT_SRGGB10ALAW8</NAME>
#define V4L2_PIX_FMT_SRGGB10ALAW8 v4l2_fourcc('a', 'R', 'A', '8')
</MACRO>
<MACRO>
<NAME>V4L2_PIX_FMT_SBGGR10DPCM8</NAME>
#define V4L2_PIX_FMT_SBGGR10DPCM8 v4l2_fourcc('b', 'B', 'A', '8')
</MACRO>
<MACRO>
<NAME>V4L2_PIX_FMT_SGBRG10DPCM8</NAME>
#define V4L2_PIX_FMT_SGBRG10DPCM8 v4l2_fourcc('b', 'G', 'A', '8')
</MACRO>
<MACRO>
<NAME>V4L2_PIX_FMT_SGRBG10DPCM8</NAME>
#define V4L2_PIX_FMT_SGRBG10DPCM8 v4l2_fourcc('B', 'D', '1', '0')
</MACRO>
<MACRO>
<NAME>V4L2_PIX_FMT_SRGGB10DPCM8</NAME>
#define V4L2_PIX_FMT_SRGGB10DPCM8 v4l2_fourcc('b', 'R', 'A', '8')
</MACRO>
<MACRO>
<NAME>V4L2_PIX_FMT_SBGGR12</NAME>
#define V4L2_PIX_FMT_SBGGR12 v4l2_fourcc('B', 'G', '1', '2') /* 12  BGBG.. GRGR.. */
</MACRO>
<MACRO>
<NAME>V4L2_PIX_FMT_SGBRG12</NAME>
#define V4L2_PIX_FMT_SGBRG12 v4l2_fourcc('G', 'B', '1', '2') /* 12  GBGB.. RGRG.. */
</MACRO>
<MACRO>
<NAME>V4L2_PIX_FMT_SGRBG12</NAME>
#define V4L2_PIX_FMT_SGRBG12 v4l2_fourcc('B', 'A', '1', '2') /* 12  GRGR.. BGBG.. */
</MACRO>
<MACRO>
<NAME>V4L2_PIX_FMT_SRGGB12</NAME>
#define V4L2_PIX_FMT_SRGGB12 v4l2_fourcc('R', 'G', '1', '2') /* 12  RGRG.. GBGB.. */
</MACRO>
<MACRO>
<NAME>V4L2_PIX_FMT_SBGGR16</NAME>
#define V4L2_PIX_FMT_SBGGR16 v4l2_fourcc('B', 'Y', 'R', '2') /* 16  BGBG.. GRGR.. */
</MACRO>
<MACRO>
<NAME>V4L2_PIX_FMT_MJPEG</NAME>
#define V4L2_PIX_FMT_MJPEG    v4l2_fourcc('M', 'J', 'P', 'G') /* Motion-JPEG   */
</MACRO>
<MACRO>
<NAME>V4L2_PIX_FMT_JPEG</NAME>
#define V4L2_PIX_FMT_JPEG     v4l2_fourcc('J', 'P', 'E', 'G') /* JFIF JPEG     */
</MACRO>
<MACRO>
<NAME>V4L2_PIX_FMT_DV</NAME>
#define V4L2_PIX_FMT_DV       v4l2_fourcc('d', 'v', 's', 'd') /* 1394          */
</MACRO>
<MACRO>
<NAME>V4L2_PIX_FMT_MPEG</NAME>
#define V4L2_PIX_FMT_MPEG     v4l2_fourcc('M', 'P', 'E', 'G') /* MPEG-1/2/4 Multiplexed */
</MACRO>
<MACRO>
<NAME>V4L2_PIX_FMT_H264</NAME>
#define V4L2_PIX_FMT_H264     v4l2_fourcc('H', '2', '6', '4') /* H264 with start codes */
</MACRO>
<MACRO>
<NAME>V4L2_PIX_FMT_H264_NO_SC</NAME>
#define V4L2_PIX_FMT_H264_NO_SC v4l2_fourcc('A', 'V', 'C', '1') /* H264 without start codes */
</MACRO>
<MACRO>
<NAME>V4L2_PIX_FMT_H264_MVC</NAME>
#define V4L2_PIX_FMT_H264_MVC v4l2_fourcc('M', '2', '6', '4') /* H264 MVC */
</MACRO>
<MACRO>
<NAME>V4L2_PIX_FMT_H263</NAME>
#define V4L2_PIX_FMT_H263     v4l2_fourcc('H', '2', '6', '3') /* H263          */
</MACRO>
<MACRO>
<NAME>V4L2_PIX_FMT_MPEG1</NAME>
#define V4L2_PIX_FMT_MPEG1    v4l2_fourcc('M', 'P', 'G', '1') /* MPEG-1 ES     */
</MACRO>
<MACRO>
<NAME>V4L2_PIX_FMT_MPEG2</NAME>
#define V4L2_PIX_FMT_MPEG2    v4l2_fourcc('M', 'P', 'G', '2') /* MPEG-2 ES     */
</MACRO>
<MACRO>
<NAME>V4L2_PIX_FMT_MPEG4</NAME>
#define V4L2_PIX_FMT_MPEG4    v4l2_fourcc('M', 'P', 'G', '4') /* MPEG-4 part 2 ES */
</MACRO>
<MACRO>
<NAME>V4L2_PIX_FMT_XVID</NAME>
#define V4L2_PIX_FMT_XVID     v4l2_fourcc('X', 'V', 'I', 'D') /* Xvid           */
</MACRO>
<MACRO>
<NAME>V4L2_PIX_FMT_VC1_ANNEX_G</NAME>
#define V4L2_PIX_FMT_VC1_ANNEX_G v4l2_fourcc('V', 'C', '1', 'G') /* SMPTE 421M Annex G compliant stream */
</MACRO>
<MACRO>
<NAME>V4L2_PIX_FMT_VC1_ANNEX_L</NAME>
#define V4L2_PIX_FMT_VC1_ANNEX_L v4l2_fourcc('V', 'C', '1', 'L') /* SMPTE 421M Annex L compliant stream */
</MACRO>
<MACRO>
<NAME>V4L2_PIX_FMT_VP8</NAME>
#define V4L2_PIX_FMT_VP8      v4l2_fourcc('V', 'P', '8', '0') /* VP8 */
</MACRO>
<MACRO>
<NAME>V4L2_PIX_FMT_CPIA1</NAME>
#define V4L2_PIX_FMT_CPIA1    v4l2_fourcc('C', 'P', 'I', 'A') /* cpia1 YUV */
</MACRO>
<MACRO>
<NAME>V4L2_PIX_FMT_WNVA</NAME>
#define V4L2_PIX_FMT_WNVA     v4l2_fourcc('W', 'N', 'V', 'A') /* Winnov hw compress */
</MACRO>
<MACRO>
<NAME>V4L2_PIX_FMT_SN9C10X</NAME>
#define V4L2_PIX_FMT_SN9C10X  v4l2_fourcc('S', '9', '1', '0') /* SN9C10x compression */
</MACRO>
<MACRO>
<NAME>V4L2_PIX_FMT_SN9C20X_I420</NAME>
#define V4L2_PIX_FMT_SN9C20X_I420 v4l2_fourcc('S', '9', '2', '0') /* SN9C20x YUV 4:2:0 */
</MACRO>
<MACRO>
<NAME>V4L2_PIX_FMT_PWC1</NAME>
#define V4L2_PIX_FMT_PWC1     v4l2_fourcc('P', 'W', 'C', '1') /* pwc older webcam */
</MACRO>
<MACRO>
<NAME>V4L2_PIX_FMT_PWC2</NAME>
#define V4L2_PIX_FMT_PWC2     v4l2_fourcc('P', 'W', 'C', '2') /* pwc newer webcam */
</MACRO>
<MACRO>
<NAME>V4L2_PIX_FMT_ET61X251</NAME>
#define V4L2_PIX_FMT_ET61X251 v4l2_fourcc('E', '6', '2', '5') /* ET61X251 compression */
</MACRO>
<MACRO>
<NAME>V4L2_PIX_FMT_SPCA501</NAME>
#define V4L2_PIX_FMT_SPCA501  v4l2_fourcc('S', '5', '0', '1') /* YUYV per line */
</MACRO>
<MACRO>
<NAME>V4L2_PIX_FMT_SPCA505</NAME>
#define V4L2_PIX_FMT_SPCA505  v4l2_fourcc('S', '5', '0', '5') /* YYUV per line */
</MACRO>
<MACRO>
<NAME>V4L2_PIX_FMT_SPCA508</NAME>
#define V4L2_PIX_FMT_SPCA508  v4l2_fourcc('S', '5', '0', '8') /* YUVY per line */
</MACRO>
<MACRO>
<NAME>V4L2_PIX_FMT_SPCA561</NAME>
#define V4L2_PIX_FMT_SPCA561  v4l2_fourcc('S', '5', '6', '1') /* compressed GBRG bayer */
</MACRO>
<MACRO>
<NAME>V4L2_PIX_FMT_PAC207</NAME>
#define V4L2_PIX_FMT_PAC207   v4l2_fourcc('P', '2', '0', '7') /* compressed BGGR bayer */
</MACRO>
<MACRO>
<NAME>V4L2_PIX_FMT_MR97310A</NAME>
#define V4L2_PIX_FMT_MR97310A v4l2_fourcc('M', '3', '1', '0') /* compressed BGGR bayer */
</MACRO>
<MACRO>
<NAME>V4L2_PIX_FMT_JL2005BCD</NAME>
#define V4L2_PIX_FMT_JL2005BCD v4l2_fourcc('J', 'L', '2', '0') /* compressed RGGB bayer */
</MACRO>
<MACRO>
<NAME>V4L2_PIX_FMT_SN9C2028</NAME>
#define V4L2_PIX_FMT_SN9C2028 v4l2_fourcc('S', 'O', 'N', 'X') /* compressed GBRG bayer */
</MACRO>
<MACRO>
<NAME>V4L2_PIX_FMT_SQ905C</NAME>
#define V4L2_PIX_FMT_SQ905C   v4l2_fourcc('9', '0', '5', 'C') /* compressed RGGB bayer */
</MACRO>
<MACRO>
<NAME>V4L2_PIX_FMT_PJPG</NAME>
#define V4L2_PIX_FMT_PJPG     v4l2_fourcc('P', 'J', 'P', 'G') /* Pixart 73xx JPEG */
</MACRO>
<MACRO>
<NAME>V4L2_PIX_FMT_OV511</NAME>
#define V4L2_PIX_FMT_OV511    v4l2_fourcc('O', '5', '1', '1') /* ov511 JPEG */
</MACRO>
<MACRO>
<NAME>V4L2_PIX_FMT_OV518</NAME>
#define V4L2_PIX_FMT_OV518    v4l2_fourcc('O', '5', '1', '8') /* ov518 JPEG */
</MACRO>
<MACRO>
<NAME>V4L2_PIX_FMT_STV0680</NAME>
#define V4L2_PIX_FMT_STV0680  v4l2_fourcc('S', '6', '8', '0') /* stv0680 bayer */
</MACRO>
<MACRO>
<NAME>V4L2_PIX_FMT_TM6000</NAME>
#define V4L2_PIX_FMT_TM6000   v4l2_fourcc('T', 'M', '6', '0') /* tm5600/tm60x0 */
</MACRO>
<MACRO>
<NAME>V4L2_PIX_FMT_CIT_YYVYUY</NAME>
#define V4L2_PIX_FMT_CIT_YYVYUY v4l2_fourcc('C', 'I', 'T', 'V') /* one line of Y then 1 line of VYUY */
</MACRO>
<MACRO>
<NAME>V4L2_PIX_FMT_KONICA420</NAME>
#define V4L2_PIX_FMT_KONICA420  v4l2_fourcc('K', 'O', 'N', 'I') /* YUV420 planar in blocks of 256 pixels */
</MACRO>
<MACRO>
<NAME>V4L2_PIX_FMT_JPGL</NAME>
#define V4L2_PIX_FMT_JPGL	v4l2_fourcc('J', 'P', 'G', 'L') /* JPEG-Lite */
</MACRO>
<MACRO>
<NAME>V4L2_PIX_FMT_SE401</NAME>
#define V4L2_PIX_FMT_SE401      v4l2_fourcc('S', '4', '0', '1') /* se401 janggu compressed rgb */
</MACRO>
<MACRO>
<NAME>V4L2_PIX_FMT_S5C_UYVY_JPG</NAME>
#define V4L2_PIX_FMT_S5C_UYVY_JPG v4l2_fourcc('S', '5', 'C', 'I') /* S5C73M3 interleaved UYVY/JPEG */
</MACRO>
<MACRO>
<NAME>V4L2_SDR_FMT_CU8</NAME>
#define V4L2_SDR_FMT_CU8          v4l2_fourcc('C', 'U', '0', '8') /* IQ u8 */
</MACRO>
<MACRO>
<NAME>V4L2_SDR_FMT_CU16LE</NAME>
#define V4L2_SDR_FMT_CU16LE       v4l2_fourcc('C', 'U', '1', '6') /* IQ u16le */
</MACRO>
<MACRO>
<NAME>V4L2_SDR_FMT_CS8</NAME>
#define V4L2_SDR_FMT_CS8          v4l2_fourcc('C', 'S', '0', '8') /* complex s8 */
</MACRO>
<MACRO>
<NAME>V4L2_SDR_FMT_CS14LE</NAME>
#define V4L2_SDR_FMT_CS14LE       v4l2_fourcc('C', 'S', '1', '4') /* complex s14le */
</MACRO>
<MACRO>
<NAME>V4L2_SDR_FMT_RU12LE</NAME>
#define V4L2_SDR_FMT_RU12LE       v4l2_fourcc('R', 'U', '1', '2') /* real u12le */
</MACRO>
<MACRO>
<NAME>V4L2_PIX_FMT_PRIV_MAGIC</NAME>
#define V4L2_PIX_FMT_PRIV_MAGIC		0xfeedcafe
</MACRO>
<MACRO>
<NAME>V4L2_PIX_FMT_FLAG_PREMUL_ALPHA</NAME>
#define V4L2_PIX_FMT_FLAG_PREMUL_ALPHA	0x00000001
</MACRO>
<STRUCT>
<NAME>v4l2_fmtdesc</NAME>
struct v4l2_fmtdesc {
	__u32		    index;             /* Format number      */
	__u32		    type;              /* enum v4l2_buf_type */
	__u32               flags;
	__u8		    description[32];   /* Description string */
	__u32		    pixelformat;       /* Format fourcc      */
	__u32		    reserved[4];
};
</STRUCT>
<MACRO>
<NAME>V4L2_FMT_FLAG_COMPRESSED</NAME>
#define V4L2_FMT_FLAG_COMPRESSED 0x0001
</MACRO>
<MACRO>
<NAME>V4L2_FMT_FLAG_EMULATED</NAME>
#define V4L2_FMT_FLAG_EMULATED   0x0002
</MACRO>
<ENUM>
<NAME>v4l2_frmsizetypes</NAME>
enum v4l2_frmsizetypes {
	V4L2_FRMSIZE_TYPE_DISCRETE	= 1,
	V4L2_FRMSIZE_TYPE_CONTINUOUS	= 2,
	V4L2_FRMSIZE_TYPE_STEPWISE	= 3,
};
</ENUM>
<STRUCT>
<NAME>v4l2_frmsize_discrete</NAME>
struct v4l2_frmsize_discrete {
	__u32			width;		/* Frame width [pixel] */
	__u32			height;		/* Frame height [pixel] */
};
</STRUCT>
<STRUCT>
<NAME>v4l2_frmsize_stepwise</NAME>
struct v4l2_frmsize_stepwise {
	__u32			min_width;	/* Minimum frame width [pixel] */
	__u32			max_width;	/* Maximum frame width [pixel] */
	__u32			step_width;	/* Frame width step size [pixel] */
	__u32			min_height;	/* Minimum frame height [pixel] */
	__u32			max_height;	/* Maximum frame height [pixel] */
	__u32			step_height;	/* Frame height step size [pixel] */
};
</STRUCT>
<STRUCT>
<NAME>v4l2_frmsizeenum</NAME>
struct v4l2_frmsizeenum {
	__u32			index;		/* Frame size number */
	__u32			pixel_format;	/* Pixel format */
	__u32			type;		/* Frame size type the device supports. */

	union {					/* Frame size */
		struct v4l2_frmsize_discrete	discrete;
		struct v4l2_frmsize_stepwise	stepwise;
	};

	__u32   reserved[2];			/* Reserved space for future use */
};
</STRUCT>
<ENUM>
<NAME>v4l2_frmivaltypes</NAME>
enum v4l2_frmivaltypes {
	V4L2_FRMIVAL_TYPE_DISCRETE	= 1,
	V4L2_FRMIVAL_TYPE_CONTINUOUS	= 2,
	V4L2_FRMIVAL_TYPE_STEPWISE	= 3,
};
</ENUM>
<STRUCT>
<NAME>v4l2_frmival_stepwise</NAME>
struct v4l2_frmival_stepwise {
	struct v4l2_fract	min;		/* Minimum frame interval [s] */
	struct v4l2_fract	max;		/* Maximum frame interval [s] */
	struct v4l2_fract	step;		/* Frame interval step size [s] */
};
</STRUCT>
<STRUCT>
<NAME>v4l2_frmivalenum</NAME>
struct v4l2_frmivalenum {
	__u32			index;		/* Frame format index */
	__u32			pixel_format;	/* Pixel format */
	__u32			width;		/* Frame width */
	__u32			height;		/* Frame height */
	__u32			type;		/* Frame interval type the device supports. */

	union {					/* Frame interval */
		struct v4l2_fract		discrete;
		struct v4l2_frmival_stepwise	stepwise;
	};

	__u32	reserved[2];			/* Reserved space for future use */
};
</STRUCT>
<STRUCT>
<NAME>v4l2_timecode</NAME>
struct v4l2_timecode {
	__u32	type;
	__u32	flags;
	__u8	frames;
	__u8	seconds;
	__u8	minutes;
	__u8	hours;
	__u8	userbits[4];
};
</STRUCT>
<MACRO>
<NAME>V4L2_TC_TYPE_24FPS</NAME>
#define V4L2_TC_TYPE_24FPS		1
</MACRO>
<MACRO>
<NAME>V4L2_TC_TYPE_25FPS</NAME>
#define V4L2_TC_TYPE_25FPS		2
</MACRO>
<MACRO>
<NAME>V4L2_TC_TYPE_30FPS</NAME>
#define V4L2_TC_TYPE_30FPS		3
</MACRO>
<MACRO>
<NAME>V4L2_TC_TYPE_50FPS</NAME>
#define V4L2_TC_TYPE_50FPS		4
</MACRO>
<MACRO>
<NAME>V4L2_TC_TYPE_60FPS</NAME>
#define V4L2_TC_TYPE_60FPS		5
</MACRO>
<MACRO>
<NAME>V4L2_TC_FLAG_DROPFRAME</NAME>
#define V4L2_TC_FLAG_DROPFRAME		0x0001 /* "drop-frame" mode */
</MACRO>
<MACRO>
<NAME>V4L2_TC_FLAG_COLORFRAME</NAME>
#define V4L2_TC_FLAG_COLORFRAME		0x0002
</MACRO>
<MACRO>
<NAME>V4L2_TC_USERBITS_field</NAME>
#define V4L2_TC_USERBITS_field		0x000C
</MACRO>
<MACRO>
<NAME>V4L2_TC_USERBITS_USERDEFINED</NAME>
#define V4L2_TC_USERBITS_USERDEFINED	0x0000
</MACRO>
<MACRO>
<NAME>V4L2_TC_USERBITS_8BITCHARS</NAME>
#define V4L2_TC_USERBITS_8BITCHARS	0x0008
</MACRO>
<STRUCT>
<NAME>v4l2_jpegcompression</NAME>
struct v4l2_jpegcompression {
	int quality;

	int  APPn;              /* Number of APP segment to be written,
				 * must be 0..15 */
	int  APP_len;           /* Length of data in JPEG APPn segment */
	char APP_data[60];      /* Data in the JPEG APPn segment. */

	int  COM_len;           /* Length of data in JPEG COM segment */
	char COM_data[60];      /* Data in JPEG COM segment */

	__u32 jpeg_markers;     /* Which markers should go into the JPEG
				 * output. Unless you exactly know what
				 * you do, leave them untouched.
				 * Including less markers will make the
				 * resulting code smaller, but there will
				 * be fewer applications which can read it.
				 * The presence of the APP and COM marker
				 * is influenced by APP_len and COM_len
				 * ONLY, not by this property! */

#define V4L2_JPEG_MARKER_DHT (1<<3)    /* Define Huffman Tables */
#define V4L2_JPEG_MARKER_DQT (1<<4)    /* Define Quantization Tables */
#define V4L2_JPEG_MARKER_DRI (1<<5)    /* Define Restart Interval */
#define V4L2_JPEG_MARKER_COM (1<<6)    /* Comment segment */
#define V4L2_JPEG_MARKER_APP (1<<7)    /* App segment, driver will
					* always use APP0 */
};
</STRUCT>
<STRUCT>
<NAME>v4l2_requestbuffers</NAME>
struct v4l2_requestbuffers {
	__u32			count;
	__u32			type;		/* enum v4l2_buf_type */
	__u32			memory;		/* enum v4l2_memory */
	__u32			reserved[2];
};
</STRUCT>
<STRUCT>
<NAME>v4l2_plane</NAME>
struct v4l2_plane {
	__u32			bytesused;
	__u32			length;
	union {
		__u32		mem_offset;
		unsigned long	userptr;
		__s32		fd;
	} m;
	__u32			data_offset;
	__u32			reserved[11];
};
</STRUCT>
<STRUCT>
<NAME>v4l2_buffer</NAME>
struct v4l2_buffer {
	__u32			index;
	__u32			type;
	__u32			bytesused;
	__u32			flags;
	__u32			field;
	struct timeval		timestamp;
	struct v4l2_timecode	timecode;
	__u32			sequence;

	/* memory location */
	__u32			memory;
	union {
		__u32           offset;
		unsigned long   userptr;
		struct v4l2_plane *planes;
		__s32		fd;
	} m;
	__u32			length;
	__u32			reserved2;
	__u32			reserved;
};
</STRUCT>
<MACRO>
<NAME>V4L2_BUF_FLAG_MAPPED</NAME>
#define V4L2_BUF_FLAG_MAPPED			0x00000001
</MACRO>
<MACRO>
<NAME>V4L2_BUF_FLAG_QUEUED</NAME>
#define V4L2_BUF_FLAG_QUEUED			0x00000002
</MACRO>
<MACRO>
<NAME>V4L2_BUF_FLAG_DONE</NAME>
#define V4L2_BUF_FLAG_DONE			0x00000004
</MACRO>
<MACRO>
<NAME>V4L2_BUF_FLAG_KEYFRAME</NAME>
#define V4L2_BUF_FLAG_KEYFRAME			0x00000008
</MACRO>
<MACRO>
<NAME>V4L2_BUF_FLAG_PFRAME</NAME>
#define V4L2_BUF_FLAG_PFRAME			0x00000010
</MACRO>
<MACRO>
<NAME>V4L2_BUF_FLAG_BFRAME</NAME>
#define V4L2_BUF_FLAG_BFRAME			0x00000020
</MACRO>
<MACRO>
<NAME>V4L2_BUF_FLAG_ERROR</NAME>
#define V4L2_BUF_FLAG_ERROR			0x00000040
</MACRO>
<MACRO>
<NAME>V4L2_BUF_FLAG_TIMECODE</NAME>
#define V4L2_BUF_FLAG_TIMECODE			0x00000100
</MACRO>
<MACRO>
<NAME>V4L2_BUF_FLAG_PREPARED</NAME>
#define V4L2_BUF_FLAG_PREPARED			0x00000400
</MACRO>
<MACRO>
<NAME>V4L2_BUF_FLAG_NO_CACHE_INVALIDATE</NAME>
#define V4L2_BUF_FLAG_NO_CACHE_INVALIDATE	0x00000800
</MACRO>
<MACRO>
<NAME>V4L2_BUF_FLAG_NO_CACHE_CLEAN</NAME>
#define V4L2_BUF_FLAG_NO_CACHE_CLEAN		0x00001000
</MACRO>
<MACRO>
<NAME>V4L2_BUF_FLAG_TIMESTAMP_MASK</NAME>
#define V4L2_BUF_FLAG_TIMESTAMP_MASK		0x0000e000
</MACRO>
<MACRO>
<NAME>V4L2_BUF_FLAG_TIMESTAMP_UNKNOWN</NAME>
#define V4L2_BUF_FLAG_TIMESTAMP_UNKNOWN		0x00000000
</MACRO>
<MACRO>
<NAME>V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC</NAME>
#define V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC	0x00002000
</MACRO>
<MACRO>
<NAME>V4L2_BUF_FLAG_TIMESTAMP_COPY</NAME>
#define V4L2_BUF_FLAG_TIMESTAMP_COPY		0x00004000
</MACRO>
<MACRO>
<NAME>V4L2_BUF_FLAG_TSTAMP_SRC_MASK</NAME>
#define V4L2_BUF_FLAG_TSTAMP_SRC_MASK		0x00070000
</MACRO>
<MACRO>
<NAME>V4L2_BUF_FLAG_TSTAMP_SRC_EOF</NAME>
#define V4L2_BUF_FLAG_TSTAMP_SRC_EOF		0x00000000
</MACRO>
<MACRO>
<NAME>V4L2_BUF_FLAG_TSTAMP_SRC_SOE</NAME>
#define V4L2_BUF_FLAG_TSTAMP_SRC_SOE		0x00010000
</MACRO>
<MACRO>
<NAME>V4L2_BUF_FLAG_LAST</NAME>
#define V4L2_BUF_FLAG_LAST			0x00100000
</MACRO>
<STRUCT>
<NAME>v4l2_exportbuffer</NAME>
struct v4l2_exportbuffer {
	__u32		type; /* enum v4l2_buf_type */
	__u32		index;
	__u32		plane;
	__u32		flags;
	__s32		fd;
	__u32		reserved[11];
};
</STRUCT>
<STRUCT>
<NAME>v4l2_framebuffer</NAME>
struct v4l2_framebuffer {
	__u32			capability;
	__u32			flags;
/* FIXME: in theory we should pass something like PCI device + memory
 * region + offset instead of some physical address */
	void                    *base;
	struct {
		__u32		width;
		__u32		height;
		__u32		pixelformat;
		__u32		field;		/* enum v4l2_field */
		__u32		bytesperline;	/* for padding, zero if unused */
		__u32		sizeimage;
		__u32		colorspace;	/* enum v4l2_colorspace */
		__u32		priv;		/* reserved field, set to 0 */
	} fmt;
};
</STRUCT>
<MACRO>
<NAME>V4L2_FBUF_CAP_EXTERNOVERLAY</NAME>
#define V4L2_FBUF_CAP_EXTERNOVERLAY	0x0001
</MACRO>
<MACRO>
<NAME>V4L2_FBUF_CAP_CHROMAKEY</NAME>
#define V4L2_FBUF_CAP_CHROMAKEY		0x0002
</MACRO>
<MACRO>
<NAME>V4L2_FBUF_CAP_LIST_CLIPPING</NAME>
#define V4L2_FBUF_CAP_LIST_CLIPPING     0x0004
</MACRO>
<MACRO>
<NAME>V4L2_FBUF_CAP_BITMAP_CLIPPING</NAME>
#define V4L2_FBUF_CAP_BITMAP_CLIPPING	0x0008
</MACRO>
<MACRO>
<NAME>V4L2_FBUF_CAP_LOCAL_ALPHA</NAME>
#define V4L2_FBUF_CAP_LOCAL_ALPHA	0x0010
</MACRO>
<MACRO>
<NAME>V4L2_FBUF_CAP_GLOBAL_ALPHA</NAME>
#define V4L2_FBUF_CAP_GLOBAL_ALPHA	0x0020
</MACRO>
<MACRO>
<NAME>V4L2_FBUF_CAP_LOCAL_INV_ALPHA</NAME>
#define V4L2_FBUF_CAP_LOCAL_INV_ALPHA	0x0040
</MACRO>
<MACRO>
<NAME>V4L2_FBUF_CAP_SRC_CHROMAKEY</NAME>
#define V4L2_FBUF_CAP_SRC_CHROMAKEY	0x0080
</MACRO>
<MACRO>
<NAME>V4L2_FBUF_FLAG_PRIMARY</NAME>
#define V4L2_FBUF_FLAG_PRIMARY		0x0001
</MACRO>
<MACRO>
<NAME>V4L2_FBUF_FLAG_OVERLAY</NAME>
#define V4L2_FBUF_FLAG_OVERLAY		0x0002
</MACRO>
<MACRO>
<NAME>V4L2_FBUF_FLAG_CHROMAKEY</NAME>
#define V4L2_FBUF_FLAG_CHROMAKEY	0x0004
</MACRO>
<MACRO>
<NAME>V4L2_FBUF_FLAG_LOCAL_ALPHA</NAME>
#define V4L2_FBUF_FLAG_LOCAL_ALPHA	0x0008
</MACRO>
<MACRO>
<NAME>V4L2_FBUF_FLAG_GLOBAL_ALPHA</NAME>
#define V4L2_FBUF_FLAG_GLOBAL_ALPHA	0x0010
</MACRO>
<MACRO>
<NAME>V4L2_FBUF_FLAG_LOCAL_INV_ALPHA</NAME>
#define V4L2_FBUF_FLAG_LOCAL_INV_ALPHA	0x0020
</MACRO>
<MACRO>
<NAME>V4L2_FBUF_FLAG_SRC_CHROMAKEY</NAME>
#define V4L2_FBUF_FLAG_SRC_CHROMAKEY	0x0040
</MACRO>
<STRUCT>
<NAME>v4l2_clip</NAME>
struct v4l2_clip {
	struct v4l2_rect        c;
	struct v4l2_clip	__user *next;
};
</STRUCT>
<STRUCT>
<NAME>v4l2_window</NAME>
struct v4l2_window {
	struct v4l2_rect        w;
	__u32			field;	 /* enum v4l2_field */
	__u32			chromakey;
	struct v4l2_clip	__user *clips;
	__u32			clipcount;
	void			__user *bitmap;
	__u8                    global_alpha;
};
</STRUCT>
<STRUCT>
<NAME>v4l2_captureparm</NAME>
struct v4l2_captureparm {
	__u32		   capability;	  /*  Supported modes */
	__u32		   capturemode;	  /*  Current mode */
	struct v4l2_fract  timeperframe;  /*  Time per frame in seconds */
	__u32		   extendedmode;  /*  Driver-specific extensions */
	__u32              readbuffers;   /*  # of buffers for read */
	__u32		   reserved[4];
};
</STRUCT>
<MACRO>
<NAME>V4L2_MODE_HIGHQUALITY</NAME>
#define V4L2_MODE_HIGHQUALITY	0x0001	/*  High quality imaging mode */
</MACRO>
<MACRO>
<NAME>V4L2_CAP_TIMEPERFRAME</NAME>
#define V4L2_CAP_TIMEPERFRAME	0x1000	/*  timeperframe field is supported */
</MACRO>
<STRUCT>
<NAME>v4l2_outputparm</NAME>
struct v4l2_outputparm {
	__u32		   capability;	 /*  Supported modes */
	__u32		   outputmode;	 /*  Current mode */
	struct v4l2_fract  timeperframe; /*  Time per frame in seconds */
	__u32		   extendedmode; /*  Driver-specific extensions */
	__u32              writebuffers; /*  # of buffers for write */
	__u32		   reserved[4];
};
</STRUCT>
<STRUCT>
<NAME>v4l2_cropcap</NAME>
struct v4l2_cropcap {
	__u32			type;	/* enum v4l2_buf_type */
	struct v4l2_rect        bounds;
	struct v4l2_rect        defrect;
	struct v4l2_fract       pixelaspect;
};
</STRUCT>
<STRUCT>
<NAME>v4l2_crop</NAME>
struct v4l2_crop {
	__u32			type;	/* enum v4l2_buf_type */
	struct v4l2_rect        c;
};
</STRUCT>
<STRUCT>
<NAME>v4l2_selection</NAME>
struct v4l2_selection {
	__u32			type;
	__u32			target;
	__u32                   flags;
	struct v4l2_rect        r;
	__u32                   reserved[9];
};
</STRUCT>
<TYPEDEF>
<NAME>v4l2_std_id</NAME>
typedef __u64 v4l2_std_id;
</TYPEDEF>
<MACRO>
<NAME>V4L2_STD_PAL_B</NAME>
#define V4L2_STD_PAL_B          ((v4l2_std_id)0x00000001)
</MACRO>
<MACRO>
<NAME>V4L2_STD_PAL_B1</NAME>
#define V4L2_STD_PAL_B1         ((v4l2_std_id)0x00000002)
</MACRO>
<MACRO>
<NAME>V4L2_STD_PAL_G</NAME>
#define V4L2_STD_PAL_G          ((v4l2_std_id)0x00000004)
</MACRO>
<MACRO>
<NAME>V4L2_STD_PAL_H</NAME>
#define V4L2_STD_PAL_H          ((v4l2_std_id)0x00000008)
</MACRO>
<MACRO>
<NAME>V4L2_STD_PAL_I</NAME>
#define V4L2_STD_PAL_I          ((v4l2_std_id)0x00000010)
</MACRO>
<MACRO>
<NAME>V4L2_STD_PAL_D</NAME>
#define V4L2_STD_PAL_D          ((v4l2_std_id)0x00000020)
</MACRO>
<MACRO>
<NAME>V4L2_STD_PAL_D1</NAME>
#define V4L2_STD_PAL_D1         ((v4l2_std_id)0x00000040)
</MACRO>
<MACRO>
<NAME>V4L2_STD_PAL_K</NAME>
#define V4L2_STD_PAL_K          ((v4l2_std_id)0x00000080)
</MACRO>
<MACRO>
<NAME>V4L2_STD_PAL_M</NAME>
#define V4L2_STD_PAL_M          ((v4l2_std_id)0x00000100)
</MACRO>
<MACRO>
<NAME>V4L2_STD_PAL_N</NAME>
#define V4L2_STD_PAL_N          ((v4l2_std_id)0x00000200)
</MACRO>
<MACRO>
<NAME>V4L2_STD_PAL_Nc</NAME>
#define V4L2_STD_PAL_Nc         ((v4l2_std_id)0x00000400)
</MACRO>
<MACRO>
<NAME>V4L2_STD_PAL_60</NAME>
#define V4L2_STD_PAL_60         ((v4l2_std_id)0x00000800)
</MACRO>
<MACRO>
<NAME>V4L2_STD_NTSC_M</NAME>
#define V4L2_STD_NTSC_M         ((v4l2_std_id)0x00001000)	/* BTSC */
</MACRO>
<MACRO>
<NAME>V4L2_STD_NTSC_M_JP</NAME>
#define V4L2_STD_NTSC_M_JP      ((v4l2_std_id)0x00002000)	/* EIA-J */
</MACRO>
<MACRO>
<NAME>V4L2_STD_NTSC_443</NAME>
#define V4L2_STD_NTSC_443       ((v4l2_std_id)0x00004000)
</MACRO>
<MACRO>
<NAME>V4L2_STD_NTSC_M_KR</NAME>
#define V4L2_STD_NTSC_M_KR      ((v4l2_std_id)0x00008000)	/* FM A2 */
</MACRO>
<MACRO>
<NAME>V4L2_STD_SECAM_B</NAME>
#define V4L2_STD_SECAM_B        ((v4l2_std_id)0x00010000)
</MACRO>
<MACRO>
<NAME>V4L2_STD_SECAM_D</NAME>
#define V4L2_STD_SECAM_D        ((v4l2_std_id)0x00020000)
</MACRO>
<MACRO>
<NAME>V4L2_STD_SECAM_G</NAME>
#define V4L2_STD_SECAM_G        ((v4l2_std_id)0x00040000)
</MACRO>
<MACRO>
<NAME>V4L2_STD_SECAM_H</NAME>
#define V4L2_STD_SECAM_H        ((v4l2_std_id)0x00080000)
</MACRO>
<MACRO>
<NAME>V4L2_STD_SECAM_K</NAME>
#define V4L2_STD_SECAM_K        ((v4l2_std_id)0x00100000)
</MACRO>
<MACRO>
<NAME>V4L2_STD_SECAM_K1</NAME>
#define V4L2_STD_SECAM_K1       ((v4l2_std_id)0x00200000)
</MACRO>
<MACRO>
<NAME>V4L2_STD_SECAM_L</NAME>
#define V4L2_STD_SECAM_L        ((v4l2_std_id)0x00400000)
</MACRO>
<MACRO>
<NAME>V4L2_STD_SECAM_LC</NAME>
#define V4L2_STD_SECAM_LC       ((v4l2_std_id)0x00800000)
</MACRO>
<MACRO>
<NAME>V4L2_STD_ATSC_8_VSB</NAME>
#define V4L2_STD_ATSC_8_VSB     ((v4l2_std_id)0x01000000)
</MACRO>
<MACRO>
<NAME>V4L2_STD_ATSC_16_VSB</NAME>
#define V4L2_STD_ATSC_16_VSB    ((v4l2_std_id)0x02000000)
</MACRO>
<MACRO>
<NAME>V4L2_STD_NTSC</NAME>
#define V4L2_STD_NTSC           (V4L2_STD_NTSC_M	|\
				 V4L2_STD_NTSC_M_JP     |\
				 V4L2_STD_NTSC_M_KR)
</MACRO>
<MACRO>
<NAME>V4L2_STD_SECAM_DK</NAME>
#define V4L2_STD_SECAM_DK      	(V4L2_STD_SECAM_D	|\
				 V4L2_STD_SECAM_K	|\
				 V4L2_STD_SECAM_K1)
</MACRO>
<MACRO>
<NAME>V4L2_STD_SECAM</NAME>
#define V4L2_STD_SECAM		(V4L2_STD_SECAM_B	|\
				 V4L2_STD_SECAM_G	|\
				 V4L2_STD_SECAM_H	|\
				 V4L2_STD_SECAM_DK	|\
				 V4L2_STD_SECAM_L       |\
				 V4L2_STD_SECAM_LC)
</MACRO>
<MACRO>
<NAME>V4L2_STD_PAL_BG</NAME>
#define V4L2_STD_PAL_BG		(V4L2_STD_PAL_B		|\
				 V4L2_STD_PAL_B1	|\
				 V4L2_STD_PAL_G)
</MACRO>
<MACRO>
<NAME>V4L2_STD_PAL_DK</NAME>
#define V4L2_STD_PAL_DK		(V4L2_STD_PAL_D		|\
				 V4L2_STD_PAL_D1	|\
				 V4L2_STD_PAL_K)
</MACRO>
<MACRO>
<NAME>V4L2_STD_PAL</NAME>
#define V4L2_STD_PAL		(V4L2_STD_PAL_BG	|\
				 V4L2_STD_PAL_DK	|\
				 V4L2_STD_PAL_H		|\
				 V4L2_STD_PAL_I)
</MACRO>
<MACRO>
<NAME>V4L2_STD_B</NAME>
#define V4L2_STD_B		(V4L2_STD_PAL_B		|\
				 V4L2_STD_PAL_B1	|\
				 V4L2_STD_SECAM_B)
</MACRO>
<MACRO>
<NAME>V4L2_STD_G</NAME>
#define V4L2_STD_G		(V4L2_STD_PAL_G		|\
				 V4L2_STD_SECAM_G)
</MACRO>
<MACRO>
<NAME>V4L2_STD_H</NAME>
#define V4L2_STD_H		(V4L2_STD_PAL_H		|\
				 V4L2_STD_SECAM_H)
</MACRO>
<MACRO>
<NAME>V4L2_STD_L</NAME>
#define V4L2_STD_L		(V4L2_STD_SECAM_L	|\
				 V4L2_STD_SECAM_LC)
</MACRO>
<MACRO>
<NAME>V4L2_STD_GH</NAME>
#define V4L2_STD_GH		(V4L2_STD_G		|\
				 V4L2_STD_H)
</MACRO>
<MACRO>
<NAME>V4L2_STD_DK</NAME>
#define V4L2_STD_DK		(V4L2_STD_PAL_DK	|\
				 V4L2_STD_SECAM_DK)
</MACRO>
<MACRO>
<NAME>V4L2_STD_BG</NAME>
#define V4L2_STD_BG		(V4L2_STD_B		|\
				 V4L2_STD_G)
</MACRO>
<MACRO>
<NAME>V4L2_STD_MN</NAME>
#define V4L2_STD_MN		(V4L2_STD_PAL_M		|\
				 V4L2_STD_PAL_N		|\
				 V4L2_STD_PAL_Nc	|\
				 V4L2_STD_NTSC)
</MACRO>
<MACRO>
<NAME>V4L2_STD_MTS</NAME>
#define V4L2_STD_MTS		(V4L2_STD_NTSC_M	|\
				 V4L2_STD_PAL_M		|\
				 V4L2_STD_PAL_N		|\
				 V4L2_STD_PAL_Nc)
</MACRO>
<MACRO>
<NAME>V4L2_STD_525_60</NAME>
#define V4L2_STD_525_60		(V4L2_STD_PAL_M		|\
				 V4L2_STD_PAL_60	|\
				 V4L2_STD_NTSC		|\
				 V4L2_STD_NTSC_443)
</MACRO>
<MACRO>
<NAME>V4L2_STD_625_50</NAME>
#define V4L2_STD_625_50		(V4L2_STD_PAL		|\
				 V4L2_STD_PAL_N		|\
				 V4L2_STD_PAL_Nc	|\
				 V4L2_STD_SECAM)
</MACRO>
<MACRO>
<NAME>V4L2_STD_ATSC</NAME>
#define V4L2_STD_ATSC           (V4L2_STD_ATSC_8_VSB    |\
				 V4L2_STD_ATSC_16_VSB)
</MACRO>
<MACRO>
<NAME>V4L2_STD_UNKNOWN</NAME>
#define V4L2_STD_UNKNOWN        0
</MACRO>
<MACRO>
<NAME>V4L2_STD_ALL</NAME>
#define V4L2_STD_ALL            (V4L2_STD_525_60	|\
				 V4L2_STD_625_50)
</MACRO>
<STRUCT>
<NAME>v4l2_standard</NAME>
struct v4l2_standard {
	__u32		     index;
	v4l2_std_id          id;
	__u8		     name[24];
	struct v4l2_fract    frameperiod; /* Frames, not fields */
	__u32		     framelines;
	__u32		     reserved[4];
};
</STRUCT>
<STRUCT>
<NAME>v4l2_bt_timings</NAME>
struct v4l2_bt_timings {
	__u32	width;
	__u32	height;
	__u32	interlaced;
	__u32	polarities;
	__u64	pixelclock;
	__u32	hfrontporch;
	__u32	hsync;
	__u32	hbackporch;
	__u32	vfrontporch;
	__u32	vsync;
	__u32	vbackporch;
	__u32	il_vfrontporch;
	__u32	il_vsync;
	__u32	il_vbackporch;
	__u32	standards;
	__u32	flags;
	__u32	reserved[14];
} __attribute__ ((packed));

/* Interlaced or progressive format */
#define	V4L2_DV_PROGRESSIVE	0
#define	V4L2_DV_INTERLACED	1

/* Polarities. If bit is not set, it is assumed to be negative polarity */
#define V4L2_DV_VSYNC_POS_POL	0x00000001
#define V4L2_DV_HSYNC_POS_POL	0x00000002

/* Timings standards */
#define V4L2_DV_BT_STD_CEA861	(1 << 0)  /* CEA-861 Digital TV Profile */
#define V4L2_DV_BT_STD_DMT	(1 << 1)  /* VESA Discrete Monitor Timings */
#define V4L2_DV_BT_STD_CVT	(1 << 2)  /* VESA Coordinated Video Timings */
#define V4L2_DV_BT_STD_GTF	(1 << 3)  /* VESA Generalized Timings Formula */

/* Flags */

/* CVT/GTF specific: timing uses reduced blanking (CVT) or the 'Secondary
   GTF' curve (GTF). In both cases the horizontal and/or vertical blanking
   intervals are reduced, allowing a higher resolution over the same
   bandwidth. This is a read-only flag. */
#define V4L2_DV_FL_REDUCED_BLANKING		(1 << 0)
/* CEA-861 specific: set for CEA-861 formats with a framerate of a multiple
   of six. These formats can be optionally played at 1 / 1.001 speed.
   This is a read-only flag. */
#define V4L2_DV_FL_CAN_REDUCE_FPS		(1 << 1)
/* CEA-861 specific: only valid for video transmitters, the flag is cleared
   by receivers.
   If the framerate of the format is a multiple of six, then the pixelclock
   used to set up the transmitter is divided by 1.001 to make it compatible
   with 60 Hz based standards such as NTSC and PAL-M that use a framerate of
   29.97 Hz. Otherwise this flag is cleared. If the transmitter can't generate
   such frequencies, then the flag will also be cleared. */
#define V4L2_DV_FL_REDUCED_FPS			(1 << 2)
/* Specific to interlaced formats: if set, then field 1 is really one half-line
   longer and field 2 is really one half-line shorter, so each field has
   exactly the same number of half-lines. Whether half-lines can be detected
   or used depends on the hardware. */
#define V4L2_DV_FL_HALF_LINE			(1 << 3)
/* If set, then this is a Consumer Electronics (CE) video format. Such formats
 * differ from other formats (commonly called IT formats) in that if RGB
 * encoding is used then by default the RGB values use limited range (i.e.
 * use the range 16-235) as opposed to 0-255. All formats defined in CEA-861
 * except for the 640x480 format are CE formats. */
#define V4L2_DV_FL_IS_CE_VIDEO			(1 << 4)

/* A few useful defines to calculate the total blanking and frame sizes */
#define V4L2_DV_BT_BLANKING_WIDTH(bt) \
	((bt)->hfrontporch + (bt)->hsync + (bt)->hbackporch)
#define V4L2_DV_BT_FRAME_WIDTH(bt) \
	((bt)->width + V4L2_DV_BT_BLANKING_WIDTH(bt))
#define V4L2_DV_BT_BLANKING_HEIGHT(bt) \
	((bt)->vfrontporch + (bt)->vsync + (bt)->vbackporch + \
	 (bt)->il_vfrontporch + (bt)->il_vsync + (bt)->il_vbackporch)
#define V4L2_DV_BT_FRAME_HEIGHT(bt) \
	((bt)->height + V4L2_DV_BT_BLANKING_HEIGHT(bt))

/** struct v4l2_dv_timings - DV timings
 * @type:	the type of the timings
 * @bt:	BT656/1120 timings
 */
struct v4l2_dv_timings {
	__u32 type;
	union {
		struct v4l2_bt_timings	bt;
		__u32	reserved[32];
	};
} __attribute__ ((packed));

/* Values for the type field */
#define V4L2_DV_BT_656_1120	0	/* BT.656/1120 timing type */


/** struct v4l2_enum_dv_timings - DV timings enumeration
 * @index:	enumeration index
 * @pad:	the pad number for which to enumerate timings (used with
 *		v4l-subdev nodes only)
 * @reserved:	must be zeroed
 * @timings:	the timings for the given index
 */
struct v4l2_enum_dv_timings {
	__u32 index;
	__u32 pad;
	__u32 reserved[2];
	struct v4l2_dv_timings timings;
};
</STRUCT>
<STRUCT>
<NAME>v4l2_bt_timings_cap</NAME>
struct v4l2_bt_timings_cap {
	__u32	min_width;
	__u32	max_width;
	__u32	min_height;
	__u32	max_height;
	__u64	min_pixelclock;
	__u64	max_pixelclock;
	__u32	standards;
	__u32	capabilities;
	__u32	reserved[16];
} __attribute__ ((packed));

/* Supports interlaced formats */
#define V4L2_DV_BT_CAP_INTERLACED	(1 << 0)
/* Supports progressive formats */
#define V4L2_DV_BT_CAP_PROGRESSIVE	(1 << 1)
/* Supports CVT/GTF reduced blanking */
#define V4L2_DV_BT_CAP_REDUCED_BLANKING	(1 << 2)
/* Supports custom formats */
#define V4L2_DV_BT_CAP_CUSTOM		(1 << 3)

/** struct v4l2_dv_timings_cap - DV timings capabilities
 * @type:	the type of the timings (same as in struct v4l2_dv_timings)
 * @pad:	the pad number for which to query capabilities (used with
 *		v4l-subdev nodes only)
 * @bt:		the BT656/1120 timings capabilities
 */
struct v4l2_dv_timings_cap {
	__u32 type;
	__u32 pad;
	__u32 reserved[2];
	union {
		struct v4l2_bt_timings_cap bt;
		__u32 raw_data[32];
	};
};
</STRUCT>
<STRUCT>
<NAME>v4l2_input</NAME>
struct v4l2_input {
	__u32	     index;		/*  Which input */
	__u8	     name[32];		/*  Label */
	__u32	     type;		/*  Type of input */
	__u32	     audioset;		/*  Associated audios (bitfield) */
	__u32        tuner;             /*  enum v4l2_tuner_type */
	v4l2_std_id  std;
	__u32	     status;
	__u32	     capabilities;
	__u32	     reserved[3];
};
</STRUCT>
<MACRO>
<NAME>V4L2_INPUT_TYPE_TUNER</NAME>
#define V4L2_INPUT_TYPE_TUNER		1
</MACRO>
<MACRO>
<NAME>V4L2_INPUT_TYPE_CAMERA</NAME>
#define V4L2_INPUT_TYPE_CAMERA		2
</MACRO>
<MACRO>
<NAME>V4L2_IN_ST_NO_POWER</NAME>
#define V4L2_IN_ST_NO_POWER    0x00000001  /* Attached device is off */
</MACRO>
<MACRO>
<NAME>V4L2_IN_ST_NO_SIGNAL</NAME>
#define V4L2_IN_ST_NO_SIGNAL   0x00000002
</MACRO>
<MACRO>
<NAME>V4L2_IN_ST_NO_COLOR</NAME>
#define V4L2_IN_ST_NO_COLOR    0x00000004
</MACRO>
<MACRO>
<NAME>V4L2_IN_ST_HFLIP</NAME>
#define V4L2_IN_ST_HFLIP       0x00000010 /* Frames are flipped horizontally */
</MACRO>
<MACRO>
<NAME>V4L2_IN_ST_VFLIP</NAME>
#define V4L2_IN_ST_VFLIP       0x00000020 /* Frames are flipped vertically */
</MACRO>
<MACRO>
<NAME>V4L2_IN_ST_NO_H_LOCK</NAME>
#define V4L2_IN_ST_NO_H_LOCK   0x00000100  /* No horizontal sync lock */
</MACRO>
<MACRO>
<NAME>V4L2_IN_ST_COLOR_KILL</NAME>
#define V4L2_IN_ST_COLOR_KILL  0x00000200  /* Color killer is active */
</MACRO>
<MACRO>
<NAME>V4L2_IN_ST_NO_SYNC</NAME>
#define V4L2_IN_ST_NO_SYNC     0x00010000  /* No synchronization lock */
</MACRO>
<MACRO>
<NAME>V4L2_IN_ST_NO_EQU</NAME>
#define V4L2_IN_ST_NO_EQU      0x00020000  /* No equalizer lock */
</MACRO>
<MACRO>
<NAME>V4L2_IN_ST_NO_CARRIER</NAME>
#define V4L2_IN_ST_NO_CARRIER  0x00040000  /* Carrier recovery failed */
</MACRO>
<MACRO>
<NAME>V4L2_IN_ST_MACROVISION</NAME>
#define V4L2_IN_ST_MACROVISION 0x01000000  /* Macrovision detected */
</MACRO>
<MACRO>
<NAME>V4L2_IN_ST_NO_ACCESS</NAME>
#define V4L2_IN_ST_NO_ACCESS   0x02000000  /* Conditional access denied */
</MACRO>
<MACRO>
<NAME>V4L2_IN_ST_VTR</NAME>
#define V4L2_IN_ST_VTR         0x04000000  /* VTR time constant */
</MACRO>
<MACRO>
<NAME>V4L2_IN_CAP_DV_TIMINGS</NAME>
#define V4L2_IN_CAP_DV_TIMINGS		0x00000002 /* Supports S_DV_TIMINGS */
</MACRO>
<MACRO>
<NAME>V4L2_IN_CAP_CUSTOM_TIMINGS</NAME>
#define V4L2_IN_CAP_CUSTOM_TIMINGS	V4L2_IN_CAP_DV_TIMINGS /* For compatibility */
</MACRO>
<MACRO>
<NAME>V4L2_IN_CAP_STD</NAME>
#define V4L2_IN_CAP_STD			0x00000004 /* Supports S_STD */
</MACRO>
<MACRO>
<NAME>V4L2_IN_CAP_NATIVE_SIZE</NAME>
#define V4L2_IN_CAP_NATIVE_SIZE		0x00000008 /* Supports setting native size */
</MACRO>
<STRUCT>
<NAME>v4l2_output</NAME>
struct v4l2_output {
	__u32	     index;		/*  Which output */
	__u8	     name[32];		/*  Label */
	__u32	     type;		/*  Type of output */
	__u32	     audioset;		/*  Associated audios (bitfield) */
	__u32	     modulator;         /*  Associated modulator */
	v4l2_std_id  std;
	__u32	     capabilities;
	__u32	     reserved[3];
};
</STRUCT>
<MACRO>
<NAME>V4L2_OUTPUT_TYPE_MODULATOR</NAME>
#define V4L2_OUTPUT_TYPE_MODULATOR		1
</MACRO>
<MACRO>
<NAME>V4L2_OUTPUT_TYPE_ANALOG</NAME>
#define V4L2_OUTPUT_TYPE_ANALOG			2
</MACRO>
<MACRO>
<NAME>V4L2_OUTPUT_TYPE_ANALOGVGAOVERLAY</NAME>
#define V4L2_OUTPUT_TYPE_ANALOGVGAOVERLAY	3
</MACRO>
<MACRO>
<NAME>V4L2_OUT_CAP_DV_TIMINGS</NAME>
#define V4L2_OUT_CAP_DV_TIMINGS		0x00000002 /* Supports S_DV_TIMINGS */
</MACRO>
<MACRO>
<NAME>V4L2_OUT_CAP_CUSTOM_TIMINGS</NAME>
#define V4L2_OUT_CAP_CUSTOM_TIMINGS	V4L2_OUT_CAP_DV_TIMINGS /* For compatibility */
</MACRO>
<MACRO>
<NAME>V4L2_OUT_CAP_STD</NAME>
#define V4L2_OUT_CAP_STD		0x00000004 /* Supports S_STD */
</MACRO>
<MACRO>
<NAME>V4L2_OUT_CAP_NATIVE_SIZE</NAME>
#define V4L2_OUT_CAP_NATIVE_SIZE	0x00000008 /* Supports setting native size */
</MACRO>
<STRUCT>
<NAME>v4l2_control</NAME>
struct v4l2_control {
	__u32		     id;
	__s32		     value;
};
</STRUCT>
<STRUCT>
<NAME>v4l2_ext_control</NAME>
struct v4l2_ext_control {
	__u32 id;
	__u32 size;
	__u32 reserved2[1];
	union {
		__s32 value;
		__s64 value64;
		char __user *string;
		__u8 __user *p_u8;
		__u16 __user *p_u16;
		__u32 __user *p_u32;
		void __user *ptr;
	};
} __attribute__ ((packed));

struct v4l2_ext_controls {
	__u32 ctrl_class;
	__u32 count;
	__u32 error_idx;
	__u32 reserved[2];
	struct v4l2_ext_control *controls;
};
</STRUCT>
<MACRO>
<NAME>V4L2_CTRL_ID_MASK</NAME>
#define V4L2_CTRL_ID_MASK      	  (0x0fffffff)
</MACRO>
<MACRO>
<NAME>V4L2_CTRL_ID2CLASS</NAME>
#define V4L2_CTRL_ID2CLASS(id)    ((id) & 0x0fff0000UL)
</MACRO>
<MACRO>
<NAME>V4L2_CTRL_DRIVER_PRIV</NAME>
#define V4L2_CTRL_DRIVER_PRIV(id) (((id) & 0xffff) >= 0x1000)
</MACRO>
<MACRO>
<NAME>V4L2_CTRL_MAX_DIMS</NAME>
#define V4L2_CTRL_MAX_DIMS	  (4)
</MACRO>
<ENUM>
<NAME>v4l2_ctrl_type</NAME>
enum v4l2_ctrl_type {
	V4L2_CTRL_TYPE_INTEGER	     = 1,
	V4L2_CTRL_TYPE_BOOLEAN	     = 2,
	V4L2_CTRL_TYPE_MENU	     = 3,
	V4L2_CTRL_TYPE_BUTTON	     = 4,
	V4L2_CTRL_TYPE_INTEGER64     = 5,
	V4L2_CTRL_TYPE_CTRL_CLASS    = 6,
	V4L2_CTRL_TYPE_STRING        = 7,
	V4L2_CTRL_TYPE_BITMASK       = 8,
	V4L2_CTRL_TYPE_INTEGER_MENU  = 9,

	/* Compound types are >= 0x0100 */
	V4L2_CTRL_COMPOUND_TYPES     = 0x0100,
	V4L2_CTRL_TYPE_U8	     = 0x0100,
	V4L2_CTRL_TYPE_U16	     = 0x0101,
	V4L2_CTRL_TYPE_U32	     = 0x0102,
};
</ENUM>
<STRUCT>
<NAME>v4l2_queryctrl</NAME>
struct v4l2_queryctrl {
	__u32		     id;
	__u32		     type;	/* enum v4l2_ctrl_type */
	__u8		     name[32];	/* Whatever */
	__s32		     minimum;	/* Note signedness */
	__s32		     maximum;
	__s32		     step;
	__s32		     default_value;
	__u32                flags;
	__u32		     reserved[2];
};
</STRUCT>
<STRUCT>
<NAME>v4l2_query_ext_ctrl</NAME>
struct v4l2_query_ext_ctrl {
	__u32		     id;
	__u32		     type;
	char		     name[32];
	__s64		     minimum;
	__s64		     maximum;
	__u64		     step;
	__s64		     default_value;
	__u32                flags;
	__u32                elem_size;
	__u32                elems;
	__u32                nr_of_dims;
	__u32                dims[V4L2_CTRL_MAX_DIMS];
	__u32		     reserved[32];
};
</STRUCT>
<STRUCT>
<NAME>v4l2_querymenu</NAME>
struct v4l2_querymenu {
	__u32		id;
	__u32		index;
	union {
		__u8	name[32];	/* Whatever */
		__s64	value;
	};
	__u32		reserved;
} __attribute__ ((packed));

/*  Control flags  */
#define V4L2_CTRL_FLAG_DISABLED		0x0001
#define V4L2_CTRL_FLAG_GRABBED		0x0002
#define V4L2_CTRL_FLAG_READ_ONLY 	0x0004
#define V4L2_CTRL_FLAG_UPDATE 		0x0008
#define V4L2_CTRL_FLAG_INACTIVE 	0x0010
#define V4L2_CTRL_FLAG_SLIDER 		0x0020
#define V4L2_CTRL_FLAG_WRITE_ONLY 	0x0040
#define V4L2_CTRL_FLAG_VOLATILE		0x0080
#define V4L2_CTRL_FLAG_HAS_PAYLOAD	0x0100
#define V4L2_CTRL_FLAG_EXECUTE_ON_WRITE	0x0200

/*  Query flags, to be ORed with the control ID */
#define V4L2_CTRL_FLAG_NEXT_CTRL	0x80000000
#define V4L2_CTRL_FLAG_NEXT_COMPOUND	0x40000000

/*  User-class control IDs defined by V4L2 */
#define V4L2_CID_MAX_CTRLS		1024
/*  IDs reserved for driver specific controls */
#define V4L2_CID_PRIVATE_BASE		0x08000000


/*
 *	T U N I N G
 */
struct v4l2_tuner {
	__u32                   index;
	__u8			name[32];
	__u32			type;	/* enum v4l2_tuner_type */
	__u32			capability;
	__u32			rangelow;
	__u32			rangehigh;
	__u32			rxsubchans;
	__u32			audmode;
	__s32			signal;
	__s32			afc;
	__u32			reserved[4];
};
</STRUCT>
<STRUCT>
<NAME>v4l2_modulator</NAME>
struct v4l2_modulator {
	__u32			index;
	__u8			name[32];
	__u32			capability;
	__u32			rangelow;
	__u32			rangehigh;
	__u32			txsubchans;
	__u32			reserved[4];
};
</STRUCT>
<MACRO>
<NAME>V4L2_TUNER_CAP_LOW</NAME>
#define V4L2_TUNER_CAP_LOW		0x0001
</MACRO>
<MACRO>
<NAME>V4L2_TUNER_CAP_NORM</NAME>
#define V4L2_TUNER_CAP_NORM		0x0002
</MACRO>
<MACRO>
<NAME>V4L2_TUNER_CAP_HWSEEK_BOUNDED</NAME>
#define V4L2_TUNER_CAP_HWSEEK_BOUNDED	0x0004
</MACRO>
<MACRO>
<NAME>V4L2_TUNER_CAP_HWSEEK_WRAP</NAME>
#define V4L2_TUNER_CAP_HWSEEK_WRAP	0x0008
</MACRO>
<MACRO>
<NAME>V4L2_TUNER_CAP_STEREO</NAME>
#define V4L2_TUNER_CAP_STEREO		0x0010
</MACRO>
<MACRO>
<NAME>V4L2_TUNER_CAP_LANG2</NAME>
#define V4L2_TUNER_CAP_LANG2		0x0020
</MACRO>
<MACRO>
<NAME>V4L2_TUNER_CAP_SAP</NAME>
#define V4L2_TUNER_CAP_SAP		0x0020
</MACRO>
<MACRO>
<NAME>V4L2_TUNER_CAP_LANG1</NAME>
#define V4L2_TUNER_CAP_LANG1		0x0040
</MACRO>
<MACRO>
<NAME>V4L2_TUNER_CAP_RDS</NAME>
#define V4L2_TUNER_CAP_RDS		0x0080
</MACRO>
<MACRO>
<NAME>V4L2_TUNER_CAP_RDS_BLOCK_IO</NAME>
#define V4L2_TUNER_CAP_RDS_BLOCK_IO	0x0100
</MACRO>
<MACRO>
<NAME>V4L2_TUNER_CAP_RDS_CONTROLS</NAME>
#define V4L2_TUNER_CAP_RDS_CONTROLS	0x0200
</MACRO>
<MACRO>
<NAME>V4L2_TUNER_CAP_FREQ_BANDS</NAME>
#define V4L2_TUNER_CAP_FREQ_BANDS	0x0400
</MACRO>
<MACRO>
<NAME>V4L2_TUNER_CAP_HWSEEK_PROG_LIM</NAME>
#define V4L2_TUNER_CAP_HWSEEK_PROG_LIM	0x0800
</MACRO>
<MACRO>
<NAME>V4L2_TUNER_CAP_1HZ</NAME>
#define V4L2_TUNER_CAP_1HZ		0x1000
</MACRO>
<MACRO>
<NAME>V4L2_TUNER_SUB_MONO</NAME>
#define V4L2_TUNER_SUB_MONO		0x0001
</MACRO>
<MACRO>
<NAME>V4L2_TUNER_SUB_STEREO</NAME>
#define V4L2_TUNER_SUB_STEREO		0x0002
</MACRO>
<MACRO>
<NAME>V4L2_TUNER_SUB_LANG2</NAME>
#define V4L2_TUNER_SUB_LANG2		0x0004
</MACRO>
<MACRO>
<NAME>V4L2_TUNER_SUB_SAP</NAME>
#define V4L2_TUNER_SUB_SAP		0x0004
</MACRO>
<MACRO>
<NAME>V4L2_TUNER_SUB_LANG1</NAME>
#define V4L2_TUNER_SUB_LANG1		0x0008
</MACRO>
<MACRO>
<NAME>V4L2_TUNER_SUB_RDS</NAME>
#define V4L2_TUNER_SUB_RDS		0x0010
</MACRO>
<MACRO>
<NAME>V4L2_TUNER_MODE_MONO</NAME>
#define V4L2_TUNER_MODE_MONO		0x0000
</MACRO>
<MACRO>
<NAME>V4L2_TUNER_MODE_STEREO</NAME>
#define V4L2_TUNER_MODE_STEREO		0x0001
</MACRO>
<MACRO>
<NAME>V4L2_TUNER_MODE_LANG2</NAME>
#define V4L2_TUNER_MODE_LANG2		0x0002
</MACRO>
<MACRO>
<NAME>V4L2_TUNER_MODE_SAP</NAME>
#define V4L2_TUNER_MODE_SAP		0x0002
</MACRO>
<MACRO>
<NAME>V4L2_TUNER_MODE_LANG1</NAME>
#define V4L2_TUNER_MODE_LANG1		0x0003
</MACRO>
<MACRO>
<NAME>V4L2_TUNER_MODE_LANG1_LANG2</NAME>
#define V4L2_TUNER_MODE_LANG1_LANG2	0x0004
</MACRO>
<STRUCT>
<NAME>v4l2_frequency</NAME>
struct v4l2_frequency {
	__u32	tuner;
	__u32	type;	/* enum v4l2_tuner_type */
	__u32	frequency;
	__u32	reserved[8];
};
</STRUCT>
<MACRO>
<NAME>V4L2_BAND_MODULATION_VSB</NAME>
#define V4L2_BAND_MODULATION_VSB	(1 << 1)
</MACRO>
<MACRO>
<NAME>V4L2_BAND_MODULATION_FM</NAME>
#define V4L2_BAND_MODULATION_FM		(1 << 2)
</MACRO>
<MACRO>
<NAME>V4L2_BAND_MODULATION_AM</NAME>
#define V4L2_BAND_MODULATION_AM		(1 << 3)
</MACRO>
<STRUCT>
<NAME>v4l2_frequency_band</NAME>
struct v4l2_frequency_band {
	__u32	tuner;
	__u32	type;	/* enum v4l2_tuner_type */
	__u32	index;
	__u32	capability;
	__u32	rangelow;
	__u32	rangehigh;
	__u32	modulation;
	__u32	reserved[9];
};
</STRUCT>
<STRUCT>
<NAME>v4l2_hw_freq_seek</NAME>
struct v4l2_hw_freq_seek {
	__u32	tuner;
	__u32	type;	/* enum v4l2_tuner_type */
	__u32	seek_upward;
	__u32	wrap_around;
	__u32	spacing;
	__u32	rangelow;
	__u32	rangehigh;
	__u32	reserved[5];
};
</STRUCT>
<STRUCT>
<NAME>v4l2_rds_data</NAME>
struct v4l2_rds_data {
	__u8 	lsb;
	__u8 	msb;
	__u8 	block;
} __attribute__ ((packed));

#define V4L2_RDS_BLOCK_MSK 	 0x7
#define V4L2_RDS_BLOCK_A 	 0
#define V4L2_RDS_BLOCK_B 	 1
#define V4L2_RDS_BLOCK_C 	 2
#define V4L2_RDS_BLOCK_D 	 3
#define V4L2_RDS_BLOCK_C_ALT 	 4
#define V4L2_RDS_BLOCK_INVALID 	 7

#define V4L2_RDS_BLOCK_CORRECTED 0x40
#define V4L2_RDS_BLOCK_ERROR 	 0x80

/*
 *	A U D I O
 */
struct v4l2_audio {
	__u32	index;
	__u8	name[32];
	__u32	capability;
	__u32	mode;
	__u32	reserved[2];
};
</STRUCT>
<MACRO>
<NAME>V4L2_AUDCAP_STEREO</NAME>
#define V4L2_AUDCAP_STEREO		0x00001
</MACRO>
<MACRO>
<NAME>V4L2_AUDCAP_AVL</NAME>
#define V4L2_AUDCAP_AVL			0x00002
</MACRO>
<MACRO>
<NAME>V4L2_AUDMODE_AVL</NAME>
#define V4L2_AUDMODE_AVL		0x00001
</MACRO>
<STRUCT>
<NAME>v4l2_audioout</NAME>
struct v4l2_audioout {
	__u32	index;
	__u8	name[32];
	__u32	capability;
	__u32	mode;
	__u32	reserved[2];
};
</STRUCT>
<MACRO>
<NAME>V4L2_ENC_IDX_FRAME_I</NAME>
#define V4L2_ENC_IDX_FRAME_I    (0)
</MACRO>
<MACRO>
<NAME>V4L2_ENC_IDX_FRAME_P</NAME>
#define V4L2_ENC_IDX_FRAME_P    (1)
</MACRO>
<MACRO>
<NAME>V4L2_ENC_IDX_FRAME_B</NAME>
#define V4L2_ENC_IDX_FRAME_B    (2)
</MACRO>
<MACRO>
<NAME>V4L2_ENC_IDX_FRAME_MASK</NAME>
#define V4L2_ENC_IDX_FRAME_MASK (0xf)
</MACRO>
<STRUCT>
<NAME>v4l2_enc_idx_entry</NAME>
struct v4l2_enc_idx_entry {
	__u64 offset;
	__u64 pts;
	__u32 length;
	__u32 flags;
	__u32 reserved[2];
};
</STRUCT>
<MACRO>
<NAME>V4L2_ENC_IDX_ENTRIES</NAME>
#define V4L2_ENC_IDX_ENTRIES (64)
</MACRO>
<STRUCT>
<NAME>v4l2_enc_idx</NAME>
struct v4l2_enc_idx {
	__u32 entries;
	__u32 entries_cap;
	__u32 reserved[4];
	struct v4l2_enc_idx_entry entry[V4L2_ENC_IDX_ENTRIES];
};
</STRUCT>
<MACRO>
<NAME>V4L2_ENC_CMD_START</NAME>
#define V4L2_ENC_CMD_START      (0)
</MACRO>
<MACRO>
<NAME>V4L2_ENC_CMD_STOP</NAME>
#define V4L2_ENC_CMD_STOP       (1)
</MACRO>
<MACRO>
<NAME>V4L2_ENC_CMD_PAUSE</NAME>
#define V4L2_ENC_CMD_PAUSE      (2)
</MACRO>
<MACRO>
<NAME>V4L2_ENC_CMD_RESUME</NAME>
#define V4L2_ENC_CMD_RESUME     (3)
</MACRO>
<MACRO>
<NAME>V4L2_ENC_CMD_STOP_AT_GOP_END</NAME>
#define V4L2_ENC_CMD_STOP_AT_GOP_END    (1 << 0)
</MACRO>
<STRUCT>
<NAME>v4l2_encoder_cmd</NAME>
struct v4l2_encoder_cmd {
	__u32 cmd;
	__u32 flags;
	union {
		struct {
			__u32 data[8];
		} raw;
	};
};
</STRUCT>
<MACRO>
<NAME>V4L2_DEC_CMD_START</NAME>
#define V4L2_DEC_CMD_START       (0)
</MACRO>
<MACRO>
<NAME>V4L2_DEC_CMD_STOP</NAME>
#define V4L2_DEC_CMD_STOP        (1)
</MACRO>
<MACRO>
<NAME>V4L2_DEC_CMD_PAUSE</NAME>
#define V4L2_DEC_CMD_PAUSE       (2)
</MACRO>
<MACRO>
<NAME>V4L2_DEC_CMD_RESUME</NAME>
#define V4L2_DEC_CMD_RESUME      (3)
</MACRO>
<MACRO>
<NAME>V4L2_DEC_CMD_START_MUTE_AUDIO</NAME>
#define V4L2_DEC_CMD_START_MUTE_AUDIO	(1 << 0)
</MACRO>
<MACRO>
<NAME>V4L2_DEC_CMD_PAUSE_TO_BLACK</NAME>
#define V4L2_DEC_CMD_PAUSE_TO_BLACK	(1 << 0)
</MACRO>
<MACRO>
<NAME>V4L2_DEC_CMD_STOP_TO_BLACK</NAME>
#define V4L2_DEC_CMD_STOP_TO_BLACK	(1 << 0)
</MACRO>
<MACRO>
<NAME>V4L2_DEC_CMD_STOP_IMMEDIATELY</NAME>
#define V4L2_DEC_CMD_STOP_IMMEDIATELY	(1 << 1)
</MACRO>
<MACRO>
<NAME>V4L2_DEC_START_FMT_NONE</NAME>
#define V4L2_DEC_START_FMT_NONE		(0)
</MACRO>
<MACRO>
<NAME>V4L2_DEC_START_FMT_GOP</NAME>
#define V4L2_DEC_START_FMT_GOP		(1)
</MACRO>
<STRUCT>
<NAME>v4l2_decoder_cmd</NAME>
struct v4l2_decoder_cmd {
	__u32 cmd;
	__u32 flags;
	union {
		struct {
			__u64 pts;
		} stop;

		struct {
			/* 0 or 1000 specifies normal speed,
			   1 specifies forward single stepping,
			   -1 specifies backward single stepping,
			   >1: playback at speed/1000 of the normal speed,
			   <-1: reverse playback at (-speed/1000) of the normal speed. */
			__s32 speed;
			__u32 format;
		} start;

		struct {
			__u32 data[16];
		} raw;
	};
};
</STRUCT>
<STRUCT>
<NAME>v4l2_vbi_format</NAME>
struct v4l2_vbi_format {
	__u32	sampling_rate;		/* in 1 Hz */
	__u32	offset;
	__u32	samples_per_line;
	__u32	sample_format;		/* V4L2_PIX_FMT_* */
	__s32	start[2];
	__u32	count[2];
	__u32	flags;			/* V4L2_VBI_* */
	__u32	reserved[2];		/* must be zero */
};
</STRUCT>
<MACRO>
<NAME>V4L2_VBI_UNSYNC</NAME>
#define V4L2_VBI_UNSYNC		(1 << 0)
</MACRO>
<MACRO>
<NAME>V4L2_VBI_INTERLACED</NAME>
#define V4L2_VBI_INTERLACED	(1 << 1)
</MACRO>
<MACRO>
<NAME>V4L2_VBI_ITU_525_F1_START</NAME>
#define V4L2_VBI_ITU_525_F1_START (1)
</MACRO>
<MACRO>
<NAME>V4L2_VBI_ITU_525_F2_START</NAME>
#define V4L2_VBI_ITU_525_F2_START (264)
</MACRO>
<MACRO>
<NAME>V4L2_VBI_ITU_625_F1_START</NAME>
#define V4L2_VBI_ITU_625_F1_START (1)
</MACRO>
<MACRO>
<NAME>V4L2_VBI_ITU_625_F2_START</NAME>
#define V4L2_VBI_ITU_625_F2_START (314)
</MACRO>
<STRUCT>
<NAME>v4l2_sliced_vbi_format</NAME>
struct v4l2_sliced_vbi_format {
	__u16   service_set;
	/* service_lines[0][...] specifies lines 0-23 (1-23 used) of the first field
	   service_lines[1][...] specifies lines 0-23 (1-23 used) of the second field
				 (equals frame lines 313-336 for 625 line video
				  standards, 263-286 for 525 line standards) */
	__u16   service_lines[2][24];
	__u32   io_size;
	__u32   reserved[2];            /* must be zero */
};
</STRUCT>
<MACRO>
<NAME>V4L2_SLICED_TELETEXT_B</NAME>
#define V4L2_SLICED_TELETEXT_B          (0x0001)
</MACRO>
<MACRO>
<NAME>V4L2_SLICED_VPS</NAME>
#define V4L2_SLICED_VPS                 (0x0400)
</MACRO>
<MACRO>
<NAME>V4L2_SLICED_CAPTION_525</NAME>
#define V4L2_SLICED_CAPTION_525         (0x1000)
</MACRO>
<MACRO>
<NAME>V4L2_SLICED_WSS_625</NAME>
#define V4L2_SLICED_WSS_625             (0x4000)
</MACRO>
<MACRO>
<NAME>V4L2_SLICED_VBI_525</NAME>
#define V4L2_SLICED_VBI_525             (V4L2_SLICED_CAPTION_525)
</MACRO>
<MACRO>
<NAME>V4L2_SLICED_VBI_625</NAME>
#define V4L2_SLICED_VBI_625             (V4L2_SLICED_TELETEXT_B | V4L2_SLICED_VPS | V4L2_SLICED_WSS_625)
</MACRO>
<STRUCT>
<NAME>v4l2_sliced_vbi_cap</NAME>
struct v4l2_sliced_vbi_cap {
	__u16   service_set;
	/* service_lines[0][...] specifies lines 0-23 (1-23 used) of the first field
	   service_lines[1][...] specifies lines 0-23 (1-23 used) of the second field
				 (equals frame lines 313-336 for 625 line video
				  standards, 263-286 for 525 line standards) */
	__u16   service_lines[2][24];
	__u32	type;		/* enum v4l2_buf_type */
	__u32   reserved[3];    /* must be 0 */
};
</STRUCT>
<STRUCT>
<NAME>v4l2_sliced_vbi_data</NAME>
struct v4l2_sliced_vbi_data {
	__u32   id;
	__u32   field;          /* 0: first field, 1: second field */
	__u32   line;           /* 1-23 */
	__u32   reserved;       /* must be 0 */
	__u8    data[48];
};
</STRUCT>
<MACRO>
<NAME>V4L2_MPEG_VBI_IVTV_TELETEXT_B</NAME>
#define V4L2_MPEG_VBI_IVTV_TELETEXT_B     (1)
</MACRO>
<MACRO>
<NAME>V4L2_MPEG_VBI_IVTV_CAPTION_525</NAME>
#define V4L2_MPEG_VBI_IVTV_CAPTION_525    (4)
</MACRO>
<MACRO>
<NAME>V4L2_MPEG_VBI_IVTV_WSS_625</NAME>
#define V4L2_MPEG_VBI_IVTV_WSS_625        (5)
</MACRO>
<MACRO>
<NAME>V4L2_MPEG_VBI_IVTV_VPS</NAME>
#define V4L2_MPEG_VBI_IVTV_VPS            (7)
</MACRO>
<STRUCT>
<NAME>v4l2_mpeg_vbi_itv0_line</NAME>
struct v4l2_mpeg_vbi_itv0_line {
	__u8 id;	/* One of V4L2_MPEG_VBI_IVTV_* above */
	__u8 data[42];	/* Sliced VBI data for the line */
} __attribute__ ((packed));

struct v4l2_mpeg_vbi_itv0 {
	__le32 linemask[2]; /* Bitmasks of VBI service lines present */
	struct v4l2_mpeg_vbi_itv0_line line[35];
} __attribute__ ((packed));

struct v4l2_mpeg_vbi_ITV0 {
	struct v4l2_mpeg_vbi_itv0_line line[36];
} __attribute__ ((packed));

#define V4L2_MPEG_VBI_IVTV_MAGIC0	"itv0"
#define V4L2_MPEG_VBI_IVTV_MAGIC1	"ITV0"

struct v4l2_mpeg_vbi_fmt_ivtv {
	__u8 magic[4];
	union {
		struct v4l2_mpeg_vbi_itv0 itv0;
		struct v4l2_mpeg_vbi_ITV0 ITV0;
	};
} __attribute__ ((packed));

/*
 *	A G G R E G A T E   S T R U C T U R E S
 */

/**
 * struct v4l2_plane_pix_format - additional, per-plane format definition
 * @sizeimage:		maximum size in bytes required for data, for which
 *			this plane will be used
 * @bytesperline:	distance in bytes between the leftmost pixels in two
 *			adjacent lines
 */
struct v4l2_plane_pix_format {
	__u32		sizeimage;
	__u32		bytesperline;
	__u16		reserved[6];
} __attribute__ ((packed));

/**
 * struct v4l2_pix_format_mplane - multiplanar format definition
 * @width:		image width in pixels
 * @height:		image height in pixels
 * @pixelformat:	little endian four character code (fourcc)
 * @field:		enum v4l2_field; field order (for interlaced video)
 * @colorspace:		enum v4l2_colorspace; supplemental to pixelformat
 * @plane_fmt:		per-plane information
 * @num_planes:		number of planes for this format
 * @flags:		format flags (V4L2_PIX_FMT_FLAG_*)
 * @ycbcr_enc:		enum v4l2_ycbcr_encoding, Y'CbCr encoding
 * @quantization:	enum v4l2_quantization, colorspace quantization
 * @xfer_func:		enum v4l2_xfer_func, colorspace transfer function
 */
struct v4l2_pix_format_mplane {
	__u32				width;
	__u32				height;
	__u32				pixelformat;
	__u32				field;
	__u32				colorspace;

	struct v4l2_plane_pix_format	plane_fmt[VIDEO_MAX_PLANES];
	__u8				num_planes;
	__u8				flags;
	__u8				ycbcr_enc;
	__u8				quantization;
	__u8				xfer_func;
	__u8				reserved[7];
} __attribute__ ((packed));

/**
 * struct v4l2_sdr_format - SDR format definition
 * @pixelformat:	little endian four character code (fourcc)
 * @buffersize:		maximum size in bytes required for data
 */
struct v4l2_sdr_format {
	__u32				pixelformat;
	__u32				buffersize;
	__u8				reserved[24];
} __attribute__ ((packed));

/**
 * struct v4l2_format - stream data format
 * @type:	enum v4l2_buf_type; type of the data stream
 * @pix:	definition of an image format
 * @pix_mp:	definition of a multiplanar image format
 * @win:	definition of an overlaid image
 * @vbi:	raw VBI capture or output parameters
 * @sliced:	sliced VBI capture or output parameters
 * @raw_data:	placeholder for future extensions and custom formats
 */
struct v4l2_format {
	__u32	 type;
	union {
		struct v4l2_pix_format		pix;     /* V4L2_BUF_TYPE_VIDEO_CAPTURE */
		struct v4l2_pix_format_mplane	pix_mp;  /* V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE */
		struct v4l2_window		win;     /* V4L2_BUF_TYPE_VIDEO_OVERLAY */
		struct v4l2_vbi_format		vbi;     /* V4L2_BUF_TYPE_VBI_CAPTURE */
		struct v4l2_sliced_vbi_format	sliced;  /* V4L2_BUF_TYPE_SLICED_VBI_CAPTURE */
		struct v4l2_sdr_format		sdr;     /* V4L2_BUF_TYPE_SDR_CAPTURE */
		__u8	raw_data[200];                   /* user-defined */
	} fmt;
};
</STRUCT>
<STRUCT>
<NAME>v4l2_streamparm</NAME>
struct v4l2_streamparm {
	__u32	 type;			/* enum v4l2_buf_type */
	union {
		struct v4l2_captureparm	capture;
		struct v4l2_outputparm	output;
		__u8	raw_data[200];  /* user-defined */
	} parm;
};
</STRUCT>
<MACRO>
<NAME>V4L2_EVENT_ALL</NAME>
#define V4L2_EVENT_ALL				0
</MACRO>
<MACRO>
<NAME>V4L2_EVENT_VSYNC</NAME>
#define V4L2_EVENT_VSYNC			1
</MACRO>
<MACRO>
<NAME>V4L2_EVENT_EOS</NAME>
#define V4L2_EVENT_EOS				2
</MACRO>
<MACRO>
<NAME>V4L2_EVENT_CTRL</NAME>
#define V4L2_EVENT_CTRL				3
</MACRO>
<MACRO>
<NAME>V4L2_EVENT_FRAME_SYNC</NAME>
#define V4L2_EVENT_FRAME_SYNC			4
</MACRO>
<MACRO>
<NAME>V4L2_EVENT_SOURCE_CHANGE</NAME>
#define V4L2_EVENT_SOURCE_CHANGE		5
</MACRO>
<MACRO>
<NAME>V4L2_EVENT_MOTION_DET</NAME>
#define V4L2_EVENT_MOTION_DET			6
</MACRO>
<MACRO>
<NAME>V4L2_EVENT_PRIVATE_START</NAME>
#define V4L2_EVENT_PRIVATE_START		0x08000000
</MACRO>
<STRUCT>
<NAME>v4l2_event_vsync</NAME>
struct v4l2_event_vsync {
	/* Can be V4L2_FIELD_ANY, _NONE, _TOP or _BOTTOM */
	__u8 field;
} __attribute__ ((packed));

/* Payload for V4L2_EVENT_CTRL */
#define V4L2_EVENT_CTRL_CH_VALUE		(1 << 0)
#define V4L2_EVENT_CTRL_CH_FLAGS		(1 << 1)
#define V4L2_EVENT_CTRL_CH_RANGE		(1 << 2)

struct v4l2_event_ctrl {
	__u32 changes;
	__u32 type;
	union {
		__s32 value;
		__s64 value64;
	};
	__u32 flags;
	__s32 minimum;
	__s32 maximum;
	__s32 step;
	__s32 default_value;
};
</STRUCT>
<STRUCT>
<NAME>v4l2_event_frame_sync</NAME>
struct v4l2_event_frame_sync {
	__u32 frame_sequence;
};
</STRUCT>
<MACRO>
<NAME>V4L2_EVENT_SRC_CH_RESOLUTION</NAME>
#define V4L2_EVENT_SRC_CH_RESOLUTION		(1 << 0)
</MACRO>
<STRUCT>
<NAME>v4l2_event_src_change</NAME>
struct v4l2_event_src_change {
	__u32 changes;
};
</STRUCT>
<MACRO>
<NAME>V4L2_EVENT_MD_FL_HAVE_FRAME_SEQ</NAME>
#define V4L2_EVENT_MD_FL_HAVE_FRAME_SEQ	(1 << 0)
</MACRO>
<STRUCT>
<NAME>v4l2_event_motion_det</NAME>
struct v4l2_event_motion_det {
	__u32 flags;
	__u32 frame_sequence;
	__u32 region_mask;
};
</STRUCT>
<STRUCT>
<NAME>v4l2_event</NAME>
struct v4l2_event {
	__u32				type;
	union {
		struct v4l2_event_vsync		vsync;
		struct v4l2_event_ctrl		ctrl;
		struct v4l2_event_frame_sync	frame_sync;
		struct v4l2_event_src_change	src_change;
		struct v4l2_event_motion_det	motion_det;
		__u8				data[64];
	} u;
	__u32				pending;
	__u32				sequence;
	struct timespec			timestamp;
	__u32				id;
	__u32				reserved[8];
};
</STRUCT>
<MACRO>
<NAME>V4L2_EVENT_SUB_FL_SEND_INITIAL</NAME>
#define V4L2_EVENT_SUB_FL_SEND_INITIAL		(1 << 0)
</MACRO>
<MACRO>
<NAME>V4L2_EVENT_SUB_FL_ALLOW_FEEDBACK</NAME>
#define V4L2_EVENT_SUB_FL_ALLOW_FEEDBACK	(1 << 1)
</MACRO>
<STRUCT>
<NAME>v4l2_event_subscription</NAME>
struct v4l2_event_subscription {
	__u32				type;
	__u32				id;
	__u32				flags;
	__u32				reserved[5];
};
</STRUCT>
<MACRO>
<NAME>V4L2_CHIP_MATCH_BRIDGE</NAME>
#define V4L2_CHIP_MATCH_BRIDGE      0  /* Match against chip ID on the bridge (0 for the bridge) */
</MACRO>
<MACRO>
<NAME>V4L2_CHIP_MATCH_SUBDEV</NAME>
#define V4L2_CHIP_MATCH_SUBDEV      4  /* Match against subdev index */
</MACRO>
<MACRO>
<NAME>V4L2_CHIP_MATCH_HOST</NAME>
#define V4L2_CHIP_MATCH_HOST V4L2_CHIP_MATCH_BRIDGE
</MACRO>
<MACRO>
<NAME>V4L2_CHIP_MATCH_I2C_DRIVER</NAME>
#define V4L2_CHIP_MATCH_I2C_DRIVER  1  /* Match against I2C driver name */
</MACRO>
<MACRO>
<NAME>V4L2_CHIP_MATCH_I2C_ADDR</NAME>
#define V4L2_CHIP_MATCH_I2C_ADDR    2  /* Match against I2C 7-bit address */
</MACRO>
<MACRO>
<NAME>V4L2_CHIP_MATCH_AC97</NAME>
#define V4L2_CHIP_MATCH_AC97        3  /* Match against ancillary AC97 chip */
</MACRO>
<STRUCT>
<NAME>v4l2_dbg_match</NAME>
struct v4l2_dbg_match {
	__u32 type; /* Match type */
	union {     /* Match this chip, meaning determined by type */
		__u32 addr;
		char name[32];
	};
} __attribute__ ((packed));

struct v4l2_dbg_register {
	struct v4l2_dbg_match match;
	__u32 size;	/* register size in bytes */
	__u64 reg;
	__u64 val;
} __attribute__ ((packed));

#define V4L2_CHIP_FL_READABLE (1 << 0)
#define V4L2_CHIP_FL_WRITABLE (1 << 1)

/* VIDIOC_DBG_G_CHIP_INFO */
struct v4l2_dbg_chip_info {
	struct v4l2_dbg_match match;
	char name[32];
	__u32 flags;
	__u32 reserved[32];
} __attribute__ ((packed));

/**
 * struct v4l2_create_buffers - VIDIOC_CREATE_BUFS argument
 * @index:	on return, index of the first created buffer
 * @count:	entry: number of requested buffers,
 *		return: number of created buffers
 * @memory:	enum v4l2_memory; buffer memory type
 * @format:	frame format, for which buffers are requested
 * @reserved:	future extensions
 */
struct v4l2_create_buffers {
	__u32			index;
	__u32			count;
	__u32			memory;
	struct v4l2_format	format;
	__u32			reserved[8];
};
</STRUCT>
<MACRO>
<NAME>VIDIOC_QUERYCAP</NAME>
#define VIDIOC_QUERYCAP		 _IOR('V',  0, struct v4l2_capability)
</MACRO>
<MACRO>
<NAME>VIDIOC_RESERVED</NAME>
#define VIDIOC_RESERVED		  _IO('V',  1)
</MACRO>
<MACRO>
<NAME>VIDIOC_ENUM_FMT</NAME>
#define VIDIOC_ENUM_FMT         _IOWR('V',  2, struct v4l2_fmtdesc)
</MACRO>
<MACRO>
<NAME>VIDIOC_G_FMT</NAME>
#define VIDIOC_G_FMT		_IOWR('V',  4, struct v4l2_format)
</MACRO>
<MACRO>
<NAME>VIDIOC_S_FMT</NAME>
#define VIDIOC_S_FMT		_IOWR('V',  5, struct v4l2_format)
</MACRO>
<MACRO>
<NAME>VIDIOC_REQBUFS</NAME>
#define VIDIOC_REQBUFS		_IOWR('V',  8, struct v4l2_requestbuffers)
</MACRO>
<MACRO>
<NAME>VIDIOC_QUERYBUF</NAME>
#define VIDIOC_QUERYBUF		_IOWR('V',  9, struct v4l2_buffer)
</MACRO>
<MACRO>
<NAME>VIDIOC_G_FBUF</NAME>
#define VIDIOC_G_FBUF		 _IOR('V', 10, struct v4l2_framebuffer)
</MACRO>
<MACRO>
<NAME>VIDIOC_S_FBUF</NAME>
#define VIDIOC_S_FBUF		 _IOW('V', 11, struct v4l2_framebuffer)
</MACRO>
<MACRO>
<NAME>VIDIOC_OVERLAY</NAME>
#define VIDIOC_OVERLAY		 _IOW('V', 14, int)
</MACRO>
<MACRO>
<NAME>VIDIOC_QBUF</NAME>
#define VIDIOC_QBUF		_IOWR('V', 15, struct v4l2_buffer)
</MACRO>
<MACRO>
<NAME>VIDIOC_EXPBUF</NAME>
#define VIDIOC_EXPBUF		_IOWR('V', 16, struct v4l2_exportbuffer)
</MACRO>
<MACRO>
<NAME>VIDIOC_DQBUF</NAME>
#define VIDIOC_DQBUF		_IOWR('V', 17, struct v4l2_buffer)
</MACRO>
<MACRO>
<NAME>VIDIOC_STREAMON</NAME>
#define VIDIOC_STREAMON		 _IOW('V', 18, int)
</MACRO>
<MACRO>
<NAME>VIDIOC_STREAMOFF</NAME>
#define VIDIOC_STREAMOFF	 _IOW('V', 19, int)
</MACRO>
<MACRO>
<NAME>VIDIOC_G_PARM</NAME>
#define VIDIOC_G_PARM		_IOWR('V', 21, struct v4l2_streamparm)
</MACRO>
<MACRO>
<NAME>VIDIOC_S_PARM</NAME>
#define VIDIOC_S_PARM		_IOWR('V', 22, struct v4l2_streamparm)
</MACRO>
<MACRO>
<NAME>VIDIOC_G_STD</NAME>
#define VIDIOC_G_STD		 _IOR('V', 23, v4l2_std_id)
</MACRO>
<MACRO>
<NAME>VIDIOC_S_STD</NAME>
#define VIDIOC_S_STD		 _IOW('V', 24, v4l2_std_id)
</MACRO>
<MACRO>
<NAME>VIDIOC_ENUMSTD</NAME>
#define VIDIOC_ENUMSTD		_IOWR('V', 25, struct v4l2_standard)
</MACRO>
<MACRO>
<NAME>VIDIOC_ENUMINPUT</NAME>
#define VIDIOC_ENUMINPUT	_IOWR('V', 26, struct v4l2_input)
</MACRO>
<MACRO>
<NAME>VIDIOC_G_CTRL</NAME>
#define VIDIOC_G_CTRL		_IOWR('V', 27, struct v4l2_control)
</MACRO>
<MACRO>
<NAME>VIDIOC_S_CTRL</NAME>
#define VIDIOC_S_CTRL		_IOWR('V', 28, struct v4l2_control)
</MACRO>
<MACRO>
<NAME>VIDIOC_G_TUNER</NAME>
#define VIDIOC_G_TUNER		_IOWR('V', 29, struct v4l2_tuner)
</MACRO>
<MACRO>
<NAME>VIDIOC_S_TUNER</NAME>
#define VIDIOC_S_TUNER		 _IOW('V', 30, struct v4l2_tuner)
</MACRO>
<MACRO>
<NAME>VIDIOC_G_AUDIO</NAME>
#define VIDIOC_G_AUDIO		 _IOR('V', 33, struct v4l2_audio)
</MACRO>
<MACRO>
<NAME>VIDIOC_S_AUDIO</NAME>
#define VIDIOC_S_AUDIO		 _IOW('V', 34, struct v4l2_audio)
</MACRO>
<MACRO>
<NAME>VIDIOC_QUERYCTRL</NAME>
#define VIDIOC_QUERYCTRL	_IOWR('V', 36, struct v4l2_queryctrl)
</MACRO>
<MACRO>
<NAME>VIDIOC_QUERYMENU</NAME>
#define VIDIOC_QUERYMENU	_IOWR('V', 37, struct v4l2_querymenu)
</MACRO>
<MACRO>
<NAME>VIDIOC_G_INPUT</NAME>
#define VIDIOC_G_INPUT		 _IOR('V', 38, int)
</MACRO>
<MACRO>
<NAME>VIDIOC_S_INPUT</NAME>
#define VIDIOC_S_INPUT		_IOWR('V', 39, int)
</MACRO>
<MACRO>
<NAME>VIDIOC_G_EDID</NAME>
#define VIDIOC_G_EDID		_IOWR('V', 40, struct v4l2_edid)
</MACRO>
<MACRO>
<NAME>VIDIOC_S_EDID</NAME>
#define VIDIOC_S_EDID		_IOWR('V', 41, struct v4l2_edid)
</MACRO>
<MACRO>
<NAME>VIDIOC_G_OUTPUT</NAME>
#define VIDIOC_G_OUTPUT		 _IOR('V', 46, int)
</MACRO>
<MACRO>
<NAME>VIDIOC_S_OUTPUT</NAME>
#define VIDIOC_S_OUTPUT		_IOWR('V', 47, int)
</MACRO>
<MACRO>
<NAME>VIDIOC_ENUMOUTPUT</NAME>
#define VIDIOC_ENUMOUTPUT	_IOWR('V', 48, struct v4l2_output)
</MACRO>
<MACRO>
<NAME>VIDIOC_G_AUDOUT</NAME>
#define VIDIOC_G_AUDOUT		 _IOR('V', 49, struct v4l2_audioout)
</MACRO>
<MACRO>
<NAME>VIDIOC_S_AUDOUT</NAME>
#define VIDIOC_S_AUDOUT		 _IOW('V', 50, struct v4l2_audioout)
</MACRO>
<MACRO>
<NAME>VIDIOC_G_MODULATOR</NAME>
#define VIDIOC_G_MODULATOR	_IOWR('V', 54, struct v4l2_modulator)
</MACRO>
<MACRO>
<NAME>VIDIOC_S_MODULATOR</NAME>
#define VIDIOC_S_MODULATOR	 _IOW('V', 55, struct v4l2_modulator)
</MACRO>
<MACRO>
<NAME>VIDIOC_G_FREQUENCY</NAME>
#define VIDIOC_G_FREQUENCY	_IOWR('V', 56, struct v4l2_frequency)
</MACRO>
<MACRO>
<NAME>VIDIOC_S_FREQUENCY</NAME>
#define VIDIOC_S_FREQUENCY	 _IOW('V', 57, struct v4l2_frequency)
</MACRO>
<MACRO>
<NAME>VIDIOC_CROPCAP</NAME>
#define VIDIOC_CROPCAP		_IOWR('V', 58, struct v4l2_cropcap)
</MACRO>
<MACRO>
<NAME>VIDIOC_G_CROP</NAME>
#define VIDIOC_G_CROP		_IOWR('V', 59, struct v4l2_crop)
</MACRO>
<MACRO>
<NAME>VIDIOC_S_CROP</NAME>
#define VIDIOC_S_CROP		 _IOW('V', 60, struct v4l2_crop)
</MACRO>
<MACRO>
<NAME>VIDIOC_G_JPEGCOMP</NAME>
#define VIDIOC_G_JPEGCOMP	 _IOR('V', 61, struct v4l2_jpegcompression)
</MACRO>
<MACRO>
<NAME>VIDIOC_S_JPEGCOMP</NAME>
#define VIDIOC_S_JPEGCOMP	 _IOW('V', 62, struct v4l2_jpegcompression)
</MACRO>
<MACRO>
<NAME>VIDIOC_QUERYSTD</NAME>
#define VIDIOC_QUERYSTD      	 _IOR('V', 63, v4l2_std_id)
</MACRO>
<MACRO>
<NAME>VIDIOC_TRY_FMT</NAME>
#define VIDIOC_TRY_FMT      	_IOWR('V', 64, struct v4l2_format)
</MACRO>
<MACRO>
<NAME>VIDIOC_ENUMAUDIO</NAME>
#define VIDIOC_ENUMAUDIO	_IOWR('V', 65, struct v4l2_audio)
</MACRO>
<MACRO>
<NAME>VIDIOC_ENUMAUDOUT</NAME>
#define VIDIOC_ENUMAUDOUT	_IOWR('V', 66, struct v4l2_audioout)
</MACRO>
<MACRO>
<NAME>VIDIOC_G_PRIORITY</NAME>
#define VIDIOC_G_PRIORITY	 _IOR('V', 67, __u32) /* enum v4l2_priority */
</MACRO>
<MACRO>
<NAME>VIDIOC_S_PRIORITY</NAME>
#define VIDIOC_S_PRIORITY	 _IOW('V', 68, __u32) /* enum v4l2_priority */
</MACRO>
<MACRO>
<NAME>VIDIOC_G_SLICED_VBI_CAP</NAME>
#define VIDIOC_G_SLICED_VBI_CAP _IOWR('V', 69, struct v4l2_sliced_vbi_cap)
</MACRO>
<MACRO>
<NAME>VIDIOC_LOG_STATUS</NAME>
#define VIDIOC_LOG_STATUS         _IO('V', 70)
</MACRO>
<MACRO>
<NAME>VIDIOC_G_EXT_CTRLS</NAME>
#define VIDIOC_G_EXT_CTRLS	_IOWR('V', 71, struct v4l2_ext_controls)
</MACRO>
<MACRO>
<NAME>VIDIOC_S_EXT_CTRLS</NAME>
#define VIDIOC_S_EXT_CTRLS	_IOWR('V', 72, struct v4l2_ext_controls)
</MACRO>
<MACRO>
<NAME>VIDIOC_TRY_EXT_CTRLS</NAME>
#define VIDIOC_TRY_EXT_CTRLS	_IOWR('V', 73, struct v4l2_ext_controls)
</MACRO>
<MACRO>
<NAME>VIDIOC_ENUM_FRAMESIZES</NAME>
#define VIDIOC_ENUM_FRAMESIZES	_IOWR('V', 74, struct v4l2_frmsizeenum)
</MACRO>
<MACRO>
<NAME>VIDIOC_ENUM_FRAMEINTERVALS</NAME>
#define VIDIOC_ENUM_FRAMEINTERVALS _IOWR('V', 75, struct v4l2_frmivalenum)
</MACRO>
<MACRO>
<NAME>VIDIOC_G_ENC_INDEX</NAME>
#define VIDIOC_G_ENC_INDEX       _IOR('V', 76, struct v4l2_enc_idx)
</MACRO>
<MACRO>
<NAME>VIDIOC_ENCODER_CMD</NAME>
#define VIDIOC_ENCODER_CMD      _IOWR('V', 77, struct v4l2_encoder_cmd)
</MACRO>
<MACRO>
<NAME>VIDIOC_TRY_ENCODER_CMD</NAME>
#define VIDIOC_TRY_ENCODER_CMD  _IOWR('V', 78, struct v4l2_encoder_cmd)
</MACRO>
<MACRO>
<NAME>VIDIOC_DBG_S_REGISTER</NAME>
#define	VIDIOC_DBG_S_REGISTER 	 _IOW('V', 79, struct v4l2_dbg_register)
</MACRO>
<MACRO>
<NAME>VIDIOC_DBG_G_REGISTER</NAME>
#define	VIDIOC_DBG_G_REGISTER 	_IOWR('V', 80, struct v4l2_dbg_register)
</MACRO>
<MACRO>
<NAME>VIDIOC_S_HW_FREQ_SEEK</NAME>
#define VIDIOC_S_HW_FREQ_SEEK	 _IOW('V', 82, struct v4l2_hw_freq_seek)
</MACRO>
<MACRO>
<NAME>VIDIOC_S_DV_TIMINGS</NAME>
#define	VIDIOC_S_DV_TIMINGS	_IOWR('V', 87, struct v4l2_dv_timings)
</MACRO>
<MACRO>
<NAME>VIDIOC_G_DV_TIMINGS</NAME>
#define	VIDIOC_G_DV_TIMINGS	_IOWR('V', 88, struct v4l2_dv_timings)
</MACRO>
<MACRO>
<NAME>VIDIOC_DQEVENT</NAME>
#define	VIDIOC_DQEVENT		 _IOR('V', 89, struct v4l2_event)
</MACRO>
<MACRO>
<NAME>VIDIOC_SUBSCRIBE_EVENT</NAME>
#define	VIDIOC_SUBSCRIBE_EVENT	 _IOW('V', 90, struct v4l2_event_subscription)
</MACRO>
<MACRO>
<NAME>VIDIOC_UNSUBSCRIBE_EVENT</NAME>
#define	VIDIOC_UNSUBSCRIBE_EVENT _IOW('V', 91, struct v4l2_event_subscription)
</MACRO>
<MACRO>
<NAME>VIDIOC_CREATE_BUFS</NAME>
#define VIDIOC_CREATE_BUFS	_IOWR('V', 92, struct v4l2_create_buffers)
</MACRO>
<MACRO>
<NAME>VIDIOC_PREPARE_BUF</NAME>
#define VIDIOC_PREPARE_BUF	_IOWR('V', 93, struct v4l2_buffer)
</MACRO>
<MACRO>
<NAME>VIDIOC_G_SELECTION</NAME>
#define VIDIOC_G_SELECTION	_IOWR('V', 94, struct v4l2_selection)
</MACRO>
<MACRO>
<NAME>VIDIOC_S_SELECTION</NAME>
#define VIDIOC_S_SELECTION	_IOWR('V', 95, struct v4l2_selection)
</MACRO>
<MACRO>
<NAME>VIDIOC_DECODER_CMD</NAME>
#define VIDIOC_DECODER_CMD	_IOWR('V', 96, struct v4l2_decoder_cmd)
</MACRO>
<MACRO>
<NAME>VIDIOC_TRY_DECODER_CMD</NAME>
#define VIDIOC_TRY_DECODER_CMD	_IOWR('V', 97, struct v4l2_decoder_cmd)
</MACRO>
<MACRO>
<NAME>VIDIOC_ENUM_DV_TIMINGS</NAME>
#define VIDIOC_ENUM_DV_TIMINGS  _IOWR('V', 98, struct v4l2_enum_dv_timings)
</MACRO>
<MACRO>
<NAME>VIDIOC_QUERY_DV_TIMINGS</NAME>
#define VIDIOC_QUERY_DV_TIMINGS  _IOR('V', 99, struct v4l2_dv_timings)
</MACRO>
<MACRO>
<NAME>VIDIOC_DV_TIMINGS_CAP</NAME>
#define VIDIOC_DV_TIMINGS_CAP   _IOWR('V', 100, struct v4l2_dv_timings_cap)
</MACRO>
<MACRO>
<NAME>VIDIOC_ENUM_FREQ_BANDS</NAME>
#define VIDIOC_ENUM_FREQ_BANDS	_IOWR('V', 101, struct v4l2_frequency_band)
</MACRO>
<MACRO>
<NAME>VIDIOC_DBG_G_CHIP_INFO</NAME>
#define VIDIOC_DBG_G_CHIP_INFO  _IOWR('V', 102, struct v4l2_dbg_chip_info)
</MACRO>
<MACRO>
<NAME>VIDIOC_QUERY_EXT_CTRL</NAME>
#define VIDIOC_QUERY_EXT_CTRL	_IOWR('V', 103, struct v4l2_query_ext_ctrl)
</MACRO>
<MACRO>
<NAME>BASE_VIDIOC_PRIVATE</NAME>
#define BASE_VIDIOC_PRIVATE	192		/* 192-255 are private */
</MACRO>
<MACRO>
<NAME>V4L2_SEL_TGT_CROP</NAME>
#define V4L2_SEL_TGT_CROP		0x0000
</MACRO>
<MACRO>
<NAME>V4L2_SEL_TGT_CROP_DEFAULT</NAME>
#define V4L2_SEL_TGT_CROP_DEFAULT	0x0001
</MACRO>
<MACRO>
<NAME>V4L2_SEL_TGT_CROP_BOUNDS</NAME>
#define V4L2_SEL_TGT_CROP_BOUNDS	0x0002
</MACRO>
<MACRO>
<NAME>V4L2_SEL_TGT_NATIVE_SIZE</NAME>
#define V4L2_SEL_TGT_NATIVE_SIZE	0x0003
</MACRO>
<MACRO>
<NAME>V4L2_SEL_TGT_COMPOSE</NAME>
#define V4L2_SEL_TGT_COMPOSE		0x0100
</MACRO>
<MACRO>
<NAME>V4L2_SEL_TGT_COMPOSE_DEFAULT</NAME>
#define V4L2_SEL_TGT_COMPOSE_DEFAULT	0x0101
</MACRO>
<MACRO>
<NAME>V4L2_SEL_TGT_COMPOSE_BOUNDS</NAME>
#define V4L2_SEL_TGT_COMPOSE_BOUNDS	0x0102
</MACRO>
<MACRO>
<NAME>V4L2_SEL_TGT_COMPOSE_PADDED</NAME>
#define V4L2_SEL_TGT_COMPOSE_PADDED	0x0103
</MACRO>
<MACRO>
<NAME>V4L2_SEL_TGT_CROP_ACTIVE</NAME>
#define V4L2_SEL_TGT_CROP_ACTIVE	V4L2_SEL_TGT_CROP
</MACRO>
<MACRO>
<NAME>V4L2_SEL_TGT_COMPOSE_ACTIVE</NAME>
#define V4L2_SEL_TGT_COMPOSE_ACTIVE	V4L2_SEL_TGT_COMPOSE
</MACRO>
<MACRO>
<NAME>V4L2_SUBDEV_SEL_TGT_CROP_ACTUAL</NAME>
#define V4L2_SUBDEV_SEL_TGT_CROP_ACTUAL	V4L2_SEL_TGT_CROP
</MACRO>
<MACRO>
<NAME>V4L2_SUBDEV_SEL_TGT_COMPOSE_ACTUAL</NAME>
#define V4L2_SUBDEV_SEL_TGT_COMPOSE_ACTUAL V4L2_SEL_TGT_COMPOSE
</MACRO>
<MACRO>
<NAME>V4L2_SUBDEV_SEL_TGT_CROP_BOUNDS</NAME>
#define V4L2_SUBDEV_SEL_TGT_CROP_BOUNDS	V4L2_SEL_TGT_CROP_BOUNDS
</MACRO>
<MACRO>
<NAME>V4L2_SUBDEV_SEL_TGT_COMPOSE_BOUNDS</NAME>
#define V4L2_SUBDEV_SEL_TGT_COMPOSE_BOUNDS V4L2_SEL_TGT_COMPOSE_BOUNDS
</MACRO>
<MACRO>
<NAME>V4L2_SEL_FLAG_GE</NAME>
#define V4L2_SEL_FLAG_GE		(1 << 0)
</MACRO>
<MACRO>
<NAME>V4L2_SEL_FLAG_LE</NAME>
#define V4L2_SEL_FLAG_LE		(1 << 1)
</MACRO>
<MACRO>
<NAME>V4L2_SEL_FLAG_KEEP_CONFIG</NAME>
#define V4L2_SEL_FLAG_KEEP_CONFIG	(1 << 2)
</MACRO>
<MACRO>
<NAME>V4L2_SUBDEV_SEL_FLAG_SIZE_GE</NAME>
#define V4L2_SUBDEV_SEL_FLAG_SIZE_GE	V4L2_SEL_FLAG_GE
</MACRO>
<MACRO>
<NAME>V4L2_SUBDEV_SEL_FLAG_SIZE_LE</NAME>
#define V4L2_SUBDEV_SEL_FLAG_SIZE_LE	V4L2_SEL_FLAG_LE
</MACRO>
<MACRO>
<NAME>V4L2_SUBDEV_SEL_FLAG_KEEP_CONFIG</NAME>
#define V4L2_SUBDEV_SEL_FLAG_KEEP_CONFIG V4L2_SEL_FLAG_KEEP_CONFIG
</MACRO>
<STRUCT>
<NAME>v4l2_edid</NAME>
struct v4l2_edid {
	__u32 pad;
	__u32 start_block;
	__u32 blocks;
	__u32 reserved[5];
	__u8  *edid;
};
</STRUCT>
<MACRO>
<NAME>V4L2_CTRL_CLASS_USER</NAME>
#define V4L2_CTRL_CLASS_USER		0x00980000	/* Old-style 'user' controls */
</MACRO>
<MACRO>
<NAME>V4L2_CTRL_CLASS_MPEG</NAME>
#define V4L2_CTRL_CLASS_MPEG		0x00990000	/* MPEG-compression controls */
</MACRO>
<MACRO>
<NAME>V4L2_CTRL_CLASS_CAMERA</NAME>
#define V4L2_CTRL_CLASS_CAMERA		0x009a0000	/* Camera class controls */
</MACRO>
<MACRO>
<NAME>V4L2_CTRL_CLASS_FM_TX</NAME>
#define V4L2_CTRL_CLASS_FM_TX		0x009b0000	/* FM Modulator controls */
</MACRO>
<MACRO>
<NAME>V4L2_CTRL_CLASS_FLASH</NAME>
#define V4L2_CTRL_CLASS_FLASH		0x009c0000	/* Camera flash controls */
</MACRO>
<MACRO>
<NAME>V4L2_CTRL_CLASS_JPEG</NAME>
#define V4L2_CTRL_CLASS_JPEG		0x009d0000	/* JPEG-compression controls */
</MACRO>
<MACRO>
<NAME>V4L2_CTRL_CLASS_IMAGE_SOURCE</NAME>
#define V4L2_CTRL_CLASS_IMAGE_SOURCE	0x009e0000	/* Image source controls */
</MACRO>
<MACRO>
<NAME>V4L2_CTRL_CLASS_IMAGE_PROC</NAME>
#define V4L2_CTRL_CLASS_IMAGE_PROC	0x009f0000	/* Image processing controls */
</MACRO>
<MACRO>
<NAME>V4L2_CTRL_CLASS_DV</NAME>
#define V4L2_CTRL_CLASS_DV		0x00a00000	/* Digital Video controls */
</MACRO>
<MACRO>
<NAME>V4L2_CTRL_CLASS_FM_RX</NAME>
#define V4L2_CTRL_CLASS_FM_RX		0x00a10000	/* FM Receiver controls */
</MACRO>
<MACRO>
<NAME>V4L2_CTRL_CLASS_RF_TUNER</NAME>
#define V4L2_CTRL_CLASS_RF_TUNER	0x00a20000	/* RF tuner controls */
</MACRO>
<MACRO>
<NAME>V4L2_CTRL_CLASS_DETECT</NAME>
#define V4L2_CTRL_CLASS_DETECT		0x00a30000	/* Detection controls */
</MACRO>
<MACRO>
<NAME>V4L2_CID_BASE</NAME>
#define V4L2_CID_BASE			(V4L2_CTRL_CLASS_USER | 0x900)
</MACRO>
<MACRO>
<NAME>V4L2_CID_USER_BASE</NAME>
#define V4L2_CID_USER_BASE 		V4L2_CID_BASE
</MACRO>
<MACRO>
<NAME>V4L2_CID_USER_CLASS</NAME>
#define V4L2_CID_USER_CLASS 		(V4L2_CTRL_CLASS_USER | 1)
</MACRO>
<MACRO>
<NAME>V4L2_CID_BRIGHTNESS</NAME>
#define V4L2_CID_BRIGHTNESS		(V4L2_CID_BASE+0)
</MACRO>
<MACRO>
<NAME>V4L2_CID_CONTRAST</NAME>
#define V4L2_CID_CONTRAST		(V4L2_CID_BASE+1)
</MACRO>
<MACRO>
<NAME>V4L2_CID_SATURATION</NAME>
#define V4L2_CID_SATURATION		(V4L2_CID_BASE+2)
</MACRO>
<MACRO>
<NAME>V4L2_CID_HUE</NAME>
#define V4L2_CID_HUE			(V4L2_CID_BASE+3)
</MACRO>
<MACRO>
<NAME>V4L2_CID_AUDIO_VOLUME</NAME>
#define V4L2_CID_AUDIO_VOLUME		(V4L2_CID_BASE+5)
</MACRO>
<MACRO>
<NAME>V4L2_CID_AUDIO_BALANCE</NAME>
#define V4L2_CID_AUDIO_BALANCE		(V4L2_CID_BASE+6)
</MACRO>
<MACRO>
<NAME>V4L2_CID_AUDIO_BASS</NAME>
#define V4L2_CID_AUDIO_BASS		(V4L2_CID_BASE+7)
</MACRO>
<MACRO>
<NAME>V4L2_CID_AUDIO_TREBLE</NAME>
#define V4L2_CID_AUDIO_TREBLE		(V4L2_CID_BASE+8)
</MACRO>
<MACRO>
<NAME>V4L2_CID_AUDIO_MUTE</NAME>
#define V4L2_CID_AUDIO_MUTE		(V4L2_CID_BASE+9)
</MACRO>
<MACRO>
<NAME>V4L2_CID_AUDIO_LOUDNESS</NAME>
#define V4L2_CID_AUDIO_LOUDNESS		(V4L2_CID_BASE+10)
</MACRO>
<MACRO>
<NAME>V4L2_CID_BLACK_LEVEL</NAME>
#define V4L2_CID_BLACK_LEVEL		(V4L2_CID_BASE+11) /* Deprecated */
</MACRO>
<MACRO>
<NAME>V4L2_CID_AUTO_WHITE_BALANCE</NAME>
#define V4L2_CID_AUTO_WHITE_BALANCE	(V4L2_CID_BASE+12)
</MACRO>
<MACRO>
<NAME>V4L2_CID_DO_WHITE_BALANCE</NAME>
#define V4L2_CID_DO_WHITE_BALANCE	(V4L2_CID_BASE+13)
</MACRO>
<MACRO>
<NAME>V4L2_CID_RED_BALANCE</NAME>
#define V4L2_CID_RED_BALANCE		(V4L2_CID_BASE+14)
</MACRO>
<MACRO>
<NAME>V4L2_CID_BLUE_BALANCE</NAME>
#define V4L2_CID_BLUE_BALANCE		(V4L2_CID_BASE+15)
</MACRO>
<MACRO>
<NAME>V4L2_CID_GAMMA</NAME>
#define V4L2_CID_GAMMA			(V4L2_CID_BASE+16)
</MACRO>
<MACRO>
<NAME>V4L2_CID_WHITENESS</NAME>
#define V4L2_CID_WHITENESS		(V4L2_CID_GAMMA) /* Deprecated */
</MACRO>
<MACRO>
<NAME>V4L2_CID_EXPOSURE</NAME>
#define V4L2_CID_EXPOSURE		(V4L2_CID_BASE+17)
</MACRO>
<MACRO>
<NAME>V4L2_CID_AUTOGAIN</NAME>
#define V4L2_CID_AUTOGAIN		(V4L2_CID_BASE+18)
</MACRO>
<MACRO>
<NAME>V4L2_CID_GAIN</NAME>
#define V4L2_CID_GAIN			(V4L2_CID_BASE+19)
</MACRO>
<MACRO>
<NAME>V4L2_CID_HFLIP</NAME>
#define V4L2_CID_HFLIP			(V4L2_CID_BASE+20)
</MACRO>
<MACRO>
<NAME>V4L2_CID_VFLIP</NAME>
#define V4L2_CID_VFLIP			(V4L2_CID_BASE+21)
</MACRO>
<MACRO>
<NAME>V4L2_CID_POWER_LINE_FREQUENCY</NAME>
#define V4L2_CID_POWER_LINE_FREQUENCY	(V4L2_CID_BASE+24)
</MACRO>
<ENUM>
<NAME>v4l2_power_line_frequency</NAME>
enum v4l2_power_line_frequency {
	V4L2_CID_POWER_LINE_FREQUENCY_DISABLED	= 0,
	V4L2_CID_POWER_LINE_FREQUENCY_50HZ	= 1,
	V4L2_CID_POWER_LINE_FREQUENCY_60HZ	= 2,
	V4L2_CID_POWER_LINE_FREQUENCY_AUTO	= 3,
};
</ENUM>
<MACRO>
<NAME>V4L2_CID_HUE_AUTO</NAME>
#define V4L2_CID_HUE_AUTO			(V4L2_CID_BASE+25)
</MACRO>
<MACRO>
<NAME>V4L2_CID_WHITE_BALANCE_TEMPERATURE</NAME>
#define V4L2_CID_WHITE_BALANCE_TEMPERATURE	(V4L2_CID_BASE+26)
</MACRO>
<MACRO>
<NAME>V4L2_CID_SHARPNESS</NAME>
#define V4L2_CID_SHARPNESS			(V4L2_CID_BASE+27)
</MACRO>
<MACRO>
<NAME>V4L2_CID_BACKLIGHT_COMPENSATION</NAME>
#define V4L2_CID_BACKLIGHT_COMPENSATION 	(V4L2_CID_BASE+28)
</MACRO>
<MACRO>
<NAME>V4L2_CID_CHROMA_AGC</NAME>
#define V4L2_CID_CHROMA_AGC                     (V4L2_CID_BASE+29)
</MACRO>
<MACRO>
<NAME>V4L2_CID_COLOR_KILLER</NAME>
#define V4L2_CID_COLOR_KILLER                   (V4L2_CID_BASE+30)
</MACRO>
<MACRO>
<NAME>V4L2_CID_COLORFX</NAME>
#define V4L2_CID_COLORFX			(V4L2_CID_BASE+31)
</MACRO>
<ENUM>
<NAME>v4l2_colorfx</NAME>
enum v4l2_colorfx {
	V4L2_COLORFX_NONE			= 0,
	V4L2_COLORFX_BW				= 1,
	V4L2_COLORFX_SEPIA			= 2,
	V4L2_COLORFX_NEGATIVE			= 3,
	V4L2_COLORFX_EMBOSS			= 4,
	V4L2_COLORFX_SKETCH			= 5,
	V4L2_COLORFX_SKY_BLUE			= 6,
	V4L2_COLORFX_GRASS_GREEN		= 7,
	V4L2_COLORFX_SKIN_WHITEN		= 8,
	V4L2_COLORFX_VIVID			= 9,
	V4L2_COLORFX_AQUA			= 10,
	V4L2_COLORFX_ART_FREEZE			= 11,
	V4L2_COLORFX_SILHOUETTE			= 12,
	V4L2_COLORFX_SOLARIZATION		= 13,
	V4L2_COLORFX_ANTIQUE			= 14,
	V4L2_COLORFX_SET_CBCR			= 15,
};
</ENUM>
<MACRO>
<NAME>V4L2_CID_AUTOBRIGHTNESS</NAME>
#define V4L2_CID_AUTOBRIGHTNESS			(V4L2_CID_BASE+32)
</MACRO>
<MACRO>
<NAME>V4L2_CID_BAND_STOP_FILTER</NAME>
#define V4L2_CID_BAND_STOP_FILTER		(V4L2_CID_BASE+33)
</MACRO>
<MACRO>
<NAME>V4L2_CID_ROTATE</NAME>
#define V4L2_CID_ROTATE				(V4L2_CID_BASE+34)
</MACRO>
<MACRO>
<NAME>V4L2_CID_BG_COLOR</NAME>
#define V4L2_CID_BG_COLOR			(V4L2_CID_BASE+35)
</MACRO>
<MACRO>
<NAME>V4L2_CID_CHROMA_GAIN</NAME>
#define V4L2_CID_CHROMA_GAIN                    (V4L2_CID_BASE+36)
</MACRO>
<MACRO>
<NAME>V4L2_CID_ILLUMINATORS_1</NAME>
#define V4L2_CID_ILLUMINATORS_1			(V4L2_CID_BASE+37)
</MACRO>
<MACRO>
<NAME>V4L2_CID_ILLUMINATORS_2</NAME>
#define V4L2_CID_ILLUMINATORS_2			(V4L2_CID_BASE+38)
</MACRO>
<MACRO>
<NAME>V4L2_CID_MIN_BUFFERS_FOR_CAPTURE</NAME>
#define V4L2_CID_MIN_BUFFERS_FOR_CAPTURE	(V4L2_CID_BASE+39)
</MACRO>
<MACRO>
<NAME>V4L2_CID_MIN_BUFFERS_FOR_OUTPUT</NAME>
#define V4L2_CID_MIN_BUFFERS_FOR_OUTPUT		(V4L2_CID_BASE+40)
</MACRO>
<MACRO>
<NAME>V4L2_CID_ALPHA_COMPONENT</NAME>
#define V4L2_CID_ALPHA_COMPONENT		(V4L2_CID_BASE+41)
</MACRO>
<MACRO>
<NAME>V4L2_CID_COLORFX_CBCR</NAME>
#define V4L2_CID_COLORFX_CBCR			(V4L2_CID_BASE+42)
</MACRO>
<MACRO>
<NAME>V4L2_CID_LASTP1</NAME>
#define V4L2_CID_LASTP1                         (V4L2_CID_BASE+43)
</MACRO>
<MACRO>
<NAME>V4L2_CID_USER_MEYE_BASE</NAME>
#define V4L2_CID_USER_MEYE_BASE			(V4L2_CID_USER_BASE + 0x1000)
</MACRO>
<MACRO>
<NAME>V4L2_CID_USER_BTTV_BASE</NAME>
#define V4L2_CID_USER_BTTV_BASE			(V4L2_CID_USER_BASE + 0x1010)
</MACRO>
<MACRO>
<NAME>V4L2_CID_USER_S2255_BASE</NAME>
#define V4L2_CID_USER_S2255_BASE		(V4L2_CID_USER_BASE + 0x1030)
</MACRO>
<MACRO>
<NAME>V4L2_CID_USER_SI476X_BASE</NAME>
#define V4L2_CID_USER_SI476X_BASE		(V4L2_CID_USER_BASE + 0x1040)
</MACRO>
<MACRO>
<NAME>V4L2_CID_USER_TI_VPE_BASE</NAME>
#define V4L2_CID_USER_TI_VPE_BASE		(V4L2_CID_USER_BASE + 0x1050)
</MACRO>
<MACRO>
<NAME>V4L2_CID_USER_SAA7134_BASE</NAME>
#define V4L2_CID_USER_SAA7134_BASE		(V4L2_CID_USER_BASE + 0x1060)
</MACRO>
<MACRO>
<NAME>V4L2_CID_USER_ADV7180_BASE</NAME>
#define V4L2_CID_USER_ADV7180_BASE		(V4L2_CID_USER_BASE + 0x1070)
</MACRO>
<MACRO>
<NAME>V4L2_CID_MPEG_BASE</NAME>
#define V4L2_CID_MPEG_BASE 			(V4L2_CTRL_CLASS_MPEG | 0x900)
</MACRO>
<MACRO>
<NAME>V4L2_CID_MPEG_CLASS</NAME>
#define V4L2_CID_MPEG_CLASS 			(V4L2_CTRL_CLASS_MPEG | 1)
</MACRO>
<MACRO>
<NAME>V4L2_CID_MPEG_STREAM_TYPE</NAME>
#define V4L2_CID_MPEG_STREAM_TYPE 		(V4L2_CID_MPEG_BASE+0)
</MACRO>
<ENUM>
<NAME>v4l2_mpeg_stream_type</NAME>
enum v4l2_mpeg_stream_type {
	V4L2_MPEG_STREAM_TYPE_MPEG2_PS   = 0, /* MPEG-2 program stream */
	V4L2_MPEG_STREAM_TYPE_MPEG2_TS   = 1, /* MPEG-2 transport stream */
	V4L2_MPEG_STREAM_TYPE_MPEG1_SS   = 2, /* MPEG-1 system stream */
	V4L2_MPEG_STREAM_TYPE_MPEG2_DVD  = 3, /* MPEG-2 DVD-compatible stream */
	V4L2_MPEG_STREAM_TYPE_MPEG1_VCD  = 4, /* MPEG-1 VCD-compatible stream */
	V4L2_MPEG_STREAM_TYPE_MPEG2_SVCD = 5, /* MPEG-2 SVCD-compatible stream */
};
</ENUM>
<MACRO>
<NAME>V4L2_CID_MPEG_STREAM_PID_PMT</NAME>
#define V4L2_CID_MPEG_STREAM_PID_PMT 		(V4L2_CID_MPEG_BASE+1)
</MACRO>
<MACRO>
<NAME>V4L2_CID_MPEG_STREAM_PID_AUDIO</NAME>
#define V4L2_CID_MPEG_STREAM_PID_AUDIO 		(V4L2_CID_MPEG_BASE+2)
</MACRO>
<MACRO>
<NAME>V4L2_CID_MPEG_STREAM_PID_VIDEO</NAME>
#define V4L2_CID_MPEG_STREAM_PID_VIDEO 		(V4L2_CID_MPEG_BASE+3)
</MACRO>
<MACRO>
<NAME>V4L2_CID_MPEG_STREAM_PID_PCR</NAME>
#define V4L2_CID_MPEG_STREAM_PID_PCR 		(V4L2_CID_MPEG_BASE+4)
</MACRO>
<MACRO>
<NAME>V4L2_CID_MPEG_STREAM_PES_ID_AUDIO</NAME>
#define V4L2_CID_MPEG_STREAM_PES_ID_AUDIO 	(V4L2_CID_MPEG_BASE+5)
</MACRO>
<MACRO>
<NAME>V4L2_CID_MPEG_STREAM_PES_ID_VIDEO</NAME>
#define V4L2_CID_MPEG_STREAM_PES_ID_VIDEO 	(V4L2_CID_MPEG_BASE+6)
</MACRO>
<MACRO>
<NAME>V4L2_CID_MPEG_STREAM_VBI_FMT</NAME>
#define V4L2_CID_MPEG_STREAM_VBI_FMT 		(V4L2_CID_MPEG_BASE+7)
</MACRO>
<ENUM>
<NAME>v4l2_mpeg_stream_vbi_fmt</NAME>
enum v4l2_mpeg_stream_vbi_fmt {
	V4L2_MPEG_STREAM_VBI_FMT_NONE = 0,  /* No VBI in the MPEG stream */
	V4L2_MPEG_STREAM_VBI_FMT_IVTV = 1,  /* VBI in private packets, IVTV format */
};
</ENUM>
<MACRO>
<NAME>V4L2_CID_MPEG_AUDIO_SAMPLING_FREQ</NAME>
#define V4L2_CID_MPEG_AUDIO_SAMPLING_FREQ 	(V4L2_CID_MPEG_BASE+100)
</MACRO>
<ENUM>
<NAME>v4l2_mpeg_audio_sampling_freq</NAME>
enum v4l2_mpeg_audio_sampling_freq {
	V4L2_MPEG_AUDIO_SAMPLING_FREQ_44100 = 0,
	V4L2_MPEG_AUDIO_SAMPLING_FREQ_48000 = 1,
	V4L2_MPEG_AUDIO_SAMPLING_FREQ_32000 = 2,
};
</ENUM>
<MACRO>
<NAME>V4L2_CID_MPEG_AUDIO_ENCODING</NAME>
#define V4L2_CID_MPEG_AUDIO_ENCODING 		(V4L2_CID_MPEG_BASE+101)
</MACRO>
<ENUM>
<NAME>v4l2_mpeg_audio_encoding</NAME>
enum v4l2_mpeg_audio_encoding {
	V4L2_MPEG_AUDIO_ENCODING_LAYER_1 = 0,
	V4L2_MPEG_AUDIO_ENCODING_LAYER_2 = 1,
	V4L2_MPEG_AUDIO_ENCODING_LAYER_3 = 2,
	V4L2_MPEG_AUDIO_ENCODING_AAC     = 3,
	V4L2_MPEG_AUDIO_ENCODING_AC3     = 4,
};
</ENUM>
<MACRO>
<NAME>V4L2_CID_MPEG_AUDIO_L1_BITRATE</NAME>
#define V4L2_CID_MPEG_AUDIO_L1_BITRATE 		(V4L2_CID_MPEG_BASE+102)
</MACRO>
<ENUM>
<NAME>v4l2_mpeg_audio_l1_bitrate</NAME>
enum v4l2_mpeg_audio_l1_bitrate {
	V4L2_MPEG_AUDIO_L1_BITRATE_32K  = 0,
	V4L2_MPEG_AUDIO_L1_BITRATE_64K  = 1,
	V4L2_MPEG_AUDIO_L1_BITRATE_96K  = 2,
	V4L2_MPEG_AUDIO_L1_BITRATE_128K = 3,
	V4L2_MPEG_AUDIO_L1_BITRATE_160K = 4,
	V4L2_MPEG_AUDIO_L1_BITRATE_192K = 5,
	V4L2_MPEG_AUDIO_L1_BITRATE_224K = 6,
	V4L2_MPEG_AUDIO_L1_BITRATE_256K = 7,
	V4L2_MPEG_AUDIO_L1_BITRATE_288K = 8,
	V4L2_MPEG_AUDIO_L1_BITRATE_320K = 9,
	V4L2_MPEG_AUDIO_L1_BITRATE_352K = 10,
	V4L2_MPEG_AUDIO_L1_BITRATE_384K = 11,
	V4L2_MPEG_AUDIO_L1_BITRATE_416K = 12,
	V4L2_MPEG_AUDIO_L1_BITRATE_448K = 13,
};
</ENUM>
<MACRO>
<NAME>V4L2_CID_MPEG_AUDIO_L2_BITRATE</NAME>
#define V4L2_CID_MPEG_AUDIO_L2_BITRATE 		(V4L2_CID_MPEG_BASE+103)
</MACRO>
<ENUM>
<NAME>v4l2_mpeg_audio_l2_bitrate</NAME>
enum v4l2_mpeg_audio_l2_bitrate {
	V4L2_MPEG_AUDIO_L2_BITRATE_32K  = 0,
	V4L2_MPEG_AUDIO_L2_BITRATE_48K  = 1,
	V4L2_MPEG_AUDIO_L2_BITRATE_56K  = 2,
	V4L2_MPEG_AUDIO_L2_BITRATE_64K  = 3,
	V4L2_MPEG_AUDIO_L2_BITRATE_80K  = 4,
	V4L2_MPEG_AUDIO_L2_BITRATE_96K  = 5,
	V4L2_MPEG_AUDIO_L2_BITRATE_112K = 6,
	V4L2_MPEG_AUDIO_L2_BITRATE_128K = 7,
	V4L2_MPEG_AUDIO_L2_BITRATE_160K = 8,
	V4L2_MPEG_AUDIO_L2_BITRATE_192K = 9,
	V4L2_MPEG_AUDIO_L2_BITRATE_224K = 10,
	V4L2_MPEG_AUDIO_L2_BITRATE_256K = 11,
	V4L2_MPEG_AUDIO_L2_BITRATE_320K = 12,
	V4L2_MPEG_AUDIO_L2_BITRATE_384K = 13,
};
</ENUM>
<MACRO>
<NAME>V4L2_CID_MPEG_AUDIO_L3_BITRATE</NAME>
#define V4L2_CID_MPEG_AUDIO_L3_BITRATE 		(V4L2_CID_MPEG_BASE+104)
</MACRO>
<ENUM>
<NAME>v4l2_mpeg_audio_l3_bitrate</NAME>
enum v4l2_mpeg_audio_l3_bitrate {
	V4L2_MPEG_AUDIO_L3_BITRATE_32K  = 0,
	V4L2_MPEG_AUDIO_L3_BITRATE_40K  = 1,
	V4L2_MPEG_AUDIO_L3_BITRATE_48K  = 2,
	V4L2_MPEG_AUDIO_L3_BITRATE_56K  = 3,
	V4L2_MPEG_AUDIO_L3_BITRATE_64K  = 4,
	V4L2_MPEG_AUDIO_L3_BITRATE_80K  = 5,
	V4L2_MPEG_AUDIO_L3_BITRATE_96K  = 6,
	V4L2_MPEG_AUDIO_L3_BITRATE_112K = 7,
	V4L2_MPEG_AUDIO_L3_BITRATE_128K = 8,
	V4L2_MPEG_AUDIO_L3_BITRATE_160K = 9,
	V4L2_MPEG_AUDIO_L3_BITRATE_192K = 10,
	V4L2_MPEG_AUDIO_L3_BITRATE_224K = 11,
	V4L2_MPEG_AUDIO_L3_BITRATE_256K = 12,
	V4L2_MPEG_AUDIO_L3_BITRATE_320K = 13,
};
</ENUM>
<MACRO>
<NAME>V4L2_CID_MPEG_AUDIO_MODE</NAME>
#define V4L2_CID_MPEG_AUDIO_MODE 		(V4L2_CID_MPEG_BASE+105)
</MACRO>
<ENUM>
<NAME>v4l2_mpeg_audio_mode</NAME>
enum v4l2_mpeg_audio_mode {
	V4L2_MPEG_AUDIO_MODE_STEREO       = 0,
	V4L2_MPEG_AUDIO_MODE_JOINT_STEREO = 1,
	V4L2_MPEG_AUDIO_MODE_DUAL         = 2,
	V4L2_MPEG_AUDIO_MODE_MONO         = 3,
};
</ENUM>
<MACRO>
<NAME>V4L2_CID_MPEG_AUDIO_MODE_EXTENSION</NAME>
#define V4L2_CID_MPEG_AUDIO_MODE_EXTENSION 	(V4L2_CID_MPEG_BASE+106)
</MACRO>
<ENUM>
<NAME>v4l2_mpeg_audio_mode_extension</NAME>
enum v4l2_mpeg_audio_mode_extension {
	V4L2_MPEG_AUDIO_MODE_EXTENSION_BOUND_4  = 0,
	V4L2_MPEG_AUDIO_MODE_EXTENSION_BOUND_8  = 1,
	V4L2_MPEG_AUDIO_MODE_EXTENSION_BOUND_12 = 2,
	V4L2_MPEG_AUDIO_MODE_EXTENSION_BOUND_16 = 3,
};
</ENUM>
<MACRO>
<NAME>V4L2_CID_MPEG_AUDIO_EMPHASIS</NAME>
#define V4L2_CID_MPEG_AUDIO_EMPHASIS 		(V4L2_CID_MPEG_BASE+107)
</MACRO>
<ENUM>
<NAME>v4l2_mpeg_audio_emphasis</NAME>
enum v4l2_mpeg_audio_emphasis {
	V4L2_MPEG_AUDIO_EMPHASIS_NONE         = 0,
	V4L2_MPEG_AUDIO_EMPHASIS_50_DIV_15_uS = 1,
	V4L2_MPEG_AUDIO_EMPHASIS_CCITT_J17    = 2,
};
</ENUM>
<MACRO>
<NAME>V4L2_CID_MPEG_AUDIO_CRC</NAME>
#define V4L2_CID_MPEG_AUDIO_CRC 		(V4L2_CID_MPEG_BASE+108)
</MACRO>
<ENUM>
<NAME>v4l2_mpeg_audio_crc</NAME>
enum v4l2_mpeg_audio_crc {
	V4L2_MPEG_AUDIO_CRC_NONE  = 0,
	V4L2_MPEG_AUDIO_CRC_CRC16 = 1,
};
</ENUM>
<MACRO>
<NAME>V4L2_CID_MPEG_AUDIO_MUTE</NAME>
#define V4L2_CID_MPEG_AUDIO_MUTE 		(V4L2_CID_MPEG_BASE+109)
</MACRO>
<MACRO>
<NAME>V4L2_CID_MPEG_AUDIO_AAC_BITRATE</NAME>
#define V4L2_CID_MPEG_AUDIO_AAC_BITRATE		(V4L2_CID_MPEG_BASE+110)
</MACRO>
<MACRO>
<NAME>V4L2_CID_MPEG_AUDIO_AC3_BITRATE</NAME>
#define V4L2_CID_MPEG_AUDIO_AC3_BITRATE		(V4L2_CID_MPEG_BASE+111)
</MACRO>
<ENUM>
<NAME>v4l2_mpeg_audio_ac3_bitrate</NAME>
enum v4l2_mpeg_audio_ac3_bitrate {
	V4L2_MPEG_AUDIO_AC3_BITRATE_32K  = 0,
	V4L2_MPEG_AUDIO_AC3_BITRATE_40K  = 1,
	V4L2_MPEG_AUDIO_AC3_BITRATE_48K  = 2,
	V4L2_MPEG_AUDIO_AC3_BITRATE_56K  = 3,
	V4L2_MPEG_AUDIO_AC3_BITRATE_64K  = 4,
	V4L2_MPEG_AUDIO_AC3_BITRATE_80K  = 5,
	V4L2_MPEG_AUDIO_AC3_BITRATE_96K  = 6,
	V4L2_MPEG_AUDIO_AC3_BITRATE_112K = 7,
	V4L2_MPEG_AUDIO_AC3_BITRATE_128K = 8,
	V4L2_MPEG_AUDIO_AC3_BITRATE_160K = 9,
	V4L2_MPEG_AUDIO_AC3_BITRATE_192K = 10,
	V4L2_MPEG_AUDIO_AC3_BITRATE_224K = 11,
	V4L2_MPEG_AUDIO_AC3_BITRATE_256K = 12,
	V4L2_MPEG_AUDIO_AC3_BITRATE_320K = 13,
	V4L2_MPEG_AUDIO_AC3_BITRATE_384K = 14,
	V4L2_MPEG_AUDIO_AC3_BITRATE_448K = 15,
	V4L2_MPEG_AUDIO_AC3_BITRATE_512K = 16,
	V4L2_MPEG_AUDIO_AC3_BITRATE_576K = 17,
	V4L2_MPEG_AUDIO_AC3_BITRATE_640K = 18,
};
</ENUM>
<MACRO>
<NAME>V4L2_CID_MPEG_AUDIO_DEC_PLAYBACK</NAME>
#define V4L2_CID_MPEG_AUDIO_DEC_PLAYBACK	(V4L2_CID_MPEG_BASE+112)
</MACRO>
<ENUM>
<NAME>v4l2_mpeg_audio_dec_playback</NAME>
enum v4l2_mpeg_audio_dec_playback {
	V4L2_MPEG_AUDIO_DEC_PLAYBACK_AUTO	    = 0,
	V4L2_MPEG_AUDIO_DEC_PLAYBACK_STEREO	    = 1,
	V4L2_MPEG_AUDIO_DEC_PLAYBACK_LEFT	    = 2,
	V4L2_MPEG_AUDIO_DEC_PLAYBACK_RIGHT	    = 3,
	V4L2_MPEG_AUDIO_DEC_PLAYBACK_MONO	    = 4,
	V4L2_MPEG_AUDIO_DEC_PLAYBACK_SWAPPED_STEREO = 5,
};
</ENUM>
<MACRO>
<NAME>V4L2_CID_MPEG_AUDIO_DEC_MULTILINGUAL_PLAYBACK</NAME>
#define V4L2_CID_MPEG_AUDIO_DEC_MULTILINGUAL_PLAYBACK (V4L2_CID_MPEG_BASE+113)
</MACRO>
<MACRO>
<NAME>V4L2_CID_MPEG_VIDEO_ENCODING</NAME>
#define V4L2_CID_MPEG_VIDEO_ENCODING 		(V4L2_CID_MPEG_BASE+200)
</MACRO>
<ENUM>
<NAME>v4l2_mpeg_video_encoding</NAME>
enum v4l2_mpeg_video_encoding {
	V4L2_MPEG_VIDEO_ENCODING_MPEG_1     = 0,
	V4L2_MPEG_VIDEO_ENCODING_MPEG_2     = 1,
	V4L2_MPEG_VIDEO_ENCODING_MPEG_4_AVC = 2,
};
</ENUM>
<MACRO>
<NAME>V4L2_CID_MPEG_VIDEO_ASPECT</NAME>
#define V4L2_CID_MPEG_VIDEO_ASPECT 		(V4L2_CID_MPEG_BASE+201)
</MACRO>
<ENUM>
<NAME>v4l2_mpeg_video_aspect</NAME>
enum v4l2_mpeg_video_aspect {
	V4L2_MPEG_VIDEO_ASPECT_1x1     = 0,
	V4L2_MPEG_VIDEO_ASPECT_4x3     = 1,
	V4L2_MPEG_VIDEO_ASPECT_16x9    = 2,
	V4L2_MPEG_VIDEO_ASPECT_221x100 = 3,
};
</ENUM>
<MACRO>
<NAME>V4L2_CID_MPEG_VIDEO_B_FRAMES</NAME>
#define V4L2_CID_MPEG_VIDEO_B_FRAMES 		(V4L2_CID_MPEG_BASE+202)
</MACRO>
<MACRO>
<NAME>V4L2_CID_MPEG_VIDEO_GOP_SIZE</NAME>
#define V4L2_CID_MPEG_VIDEO_GOP_SIZE 		(V4L2_CID_MPEG_BASE+203)
</MACRO>
<MACRO>
<NAME>V4L2_CID_MPEG_VIDEO_GOP_CLOSURE</NAME>
#define V4L2_CID_MPEG_VIDEO_GOP_CLOSURE 	(V4L2_CID_MPEG_BASE+204)
</MACRO>
<MACRO>
<NAME>V4L2_CID_MPEG_VIDEO_PULLDOWN</NAME>
#define V4L2_CID_MPEG_VIDEO_PULLDOWN 		(V4L2_CID_MPEG_BASE+205)
</MACRO>
<MACRO>
<NAME>V4L2_CID_MPEG_VIDEO_BITRATE_MODE</NAME>
#define V4L2_CID_MPEG_VIDEO_BITRATE_MODE 	(V4L2_CID_MPEG_BASE+206)
</MACRO>
<ENUM>
<NAME>v4l2_mpeg_video_bitrate_mode</NAME>
enum v4l2_mpeg_video_bitrate_mode {
	V4L2_MPEG_VIDEO_BITRATE_MODE_VBR = 0,
	V4L2_MPEG_VIDEO_BITRATE_MODE_CBR = 1,
};
</ENUM>
<MACRO>
<NAME>V4L2_CID_MPEG_VIDEO_BITRATE</NAME>
#define V4L2_CID_MPEG_VIDEO_BITRATE 		(V4L2_CID_MPEG_BASE+207)
</MACRO>
<MACRO>
<NAME>V4L2_CID_MPEG_VIDEO_BITRATE_PEAK</NAME>
#define V4L2_CID_MPEG_VIDEO_BITRATE_PEAK 	(V4L2_CID_MPEG_BASE+208)
</MACRO>
<MACRO>
<NAME>V4L2_CID_MPEG_VIDEO_TEMPORAL_DECIMATION</NAME>
#define V4L2_CID_MPEG_VIDEO_TEMPORAL_DECIMATION (V4L2_CID_MPEG_BASE+209)
</MACRO>
<MACRO>
<NAME>V4L2_CID_MPEG_VIDEO_MUTE</NAME>
#define V4L2_CID_MPEG_VIDEO_MUTE 		(V4L2_CID_MPEG_BASE+210)
</MACRO>
<MACRO>
<NAME>V4L2_CID_MPEG_VIDEO_MUTE_YUV</NAME>
#define V4L2_CID_MPEG_VIDEO_MUTE_YUV 		(V4L2_CID_MPEG_BASE+211)
</MACRO>
<MACRO>
<NAME>V4L2_CID_MPEG_VIDEO_DECODER_SLICE_INTERFACE</NAME>
#define V4L2_CID_MPEG_VIDEO_DECODER_SLICE_INTERFACE		(V4L2_CID_MPEG_BASE+212)
</MACRO>
<MACRO>
<NAME>V4L2_CID_MPEG_VIDEO_DECODER_MPEG4_DEBLOCK_FILTER</NAME>
#define V4L2_CID_MPEG_VIDEO_DECODER_MPEG4_DEBLOCK_FILTER	(V4L2_CID_MPEG_BASE+213)
</MACRO>
<MACRO>
<NAME>V4L2_CID_MPEG_VIDEO_CYCLIC_INTRA_REFRESH_MB</NAME>
#define V4L2_CID_MPEG_VIDEO_CYCLIC_INTRA_REFRESH_MB		(V4L2_CID_MPEG_BASE+214)
</MACRO>
<MACRO>
<NAME>V4L2_CID_MPEG_VIDEO_FRAME_RC_ENABLE</NAME>
#define V4L2_CID_MPEG_VIDEO_FRAME_RC_ENABLE			(V4L2_CID_MPEG_BASE+215)
</MACRO>
<MACRO>
<NAME>V4L2_CID_MPEG_VIDEO_HEADER_MODE</NAME>
#define V4L2_CID_MPEG_VIDEO_HEADER_MODE				(V4L2_CID_MPEG_BASE+216)
</MACRO>
<ENUM>
<NAME>v4l2_mpeg_video_header_mode</NAME>
enum v4l2_mpeg_video_header_mode {
	V4L2_MPEG_VIDEO_HEADER_MODE_SEPARATE			= 0,
	V4L2_MPEG_VIDEO_HEADER_MODE_JOINED_WITH_1ST_FRAME	= 1,

};
</ENUM>
<MACRO>
<NAME>V4L2_CID_MPEG_VIDEO_MAX_REF_PIC</NAME>
#define V4L2_CID_MPEG_VIDEO_MAX_REF_PIC			(V4L2_CID_MPEG_BASE+217)
</MACRO>
<MACRO>
<NAME>V4L2_CID_MPEG_VIDEO_MB_RC_ENABLE</NAME>
#define V4L2_CID_MPEG_VIDEO_MB_RC_ENABLE		(V4L2_CID_MPEG_BASE+218)
</MACRO>
<MACRO>
<NAME>V4L2_CID_MPEG_VIDEO_MULTI_SLICE_MAX_BYTES</NAME>
#define V4L2_CID_MPEG_VIDEO_MULTI_SLICE_MAX_BYTES	(V4L2_CID_MPEG_BASE+219)
</MACRO>
<MACRO>
<NAME>V4L2_CID_MPEG_VIDEO_MULTI_SLICE_MAX_MB</NAME>
#define V4L2_CID_MPEG_VIDEO_MULTI_SLICE_MAX_MB		(V4L2_CID_MPEG_BASE+220)
</MACRO>
<MACRO>
<NAME>V4L2_CID_MPEG_VIDEO_MULTI_SLICE_MODE</NAME>
#define V4L2_CID_MPEG_VIDEO_MULTI_SLICE_MODE		(V4L2_CID_MPEG_BASE+221)
</MACRO>
<ENUM>
<NAME>v4l2_mpeg_video_multi_slice_mode</NAME>
enum v4l2_mpeg_video_multi_slice_mode {
	V4L2_MPEG_VIDEO_MULTI_SLICE_MODE_SINGLE		= 0,
	V4L2_MPEG_VIDEO_MULTI_SICE_MODE_MAX_MB		= 1,
	V4L2_MPEG_VIDEO_MULTI_SICE_MODE_MAX_BYTES	= 2,
};
</ENUM>
<MACRO>
<NAME>V4L2_CID_MPEG_VIDEO_VBV_SIZE</NAME>
#define V4L2_CID_MPEG_VIDEO_VBV_SIZE			(V4L2_CID_MPEG_BASE+222)
</MACRO>
<MACRO>
<NAME>V4L2_CID_MPEG_VIDEO_DEC_PTS</NAME>
#define V4L2_CID_MPEG_VIDEO_DEC_PTS			(V4L2_CID_MPEG_BASE+223)
</MACRO>
<MACRO>
<NAME>V4L2_CID_MPEG_VIDEO_DEC_FRAME</NAME>
#define V4L2_CID_MPEG_VIDEO_DEC_FRAME			(V4L2_CID_MPEG_BASE+224)
</MACRO>
<MACRO>
<NAME>V4L2_CID_MPEG_VIDEO_VBV_DELAY</NAME>
#define V4L2_CID_MPEG_VIDEO_VBV_DELAY			(V4L2_CID_MPEG_BASE+225)
</MACRO>
<MACRO>
<NAME>V4L2_CID_MPEG_VIDEO_REPEAT_SEQ_HEADER</NAME>
#define V4L2_CID_MPEG_VIDEO_REPEAT_SEQ_HEADER		(V4L2_CID_MPEG_BASE+226)
</MACRO>
<MACRO>
<NAME>V4L2_CID_MPEG_VIDEO_MV_H_SEARCH_RANGE</NAME>
#define V4L2_CID_MPEG_VIDEO_MV_H_SEARCH_RANGE		(V4L2_CID_MPEG_BASE+227)
</MACRO>
<MACRO>
<NAME>V4L2_CID_MPEG_VIDEO_MV_V_SEARCH_RANGE</NAME>
#define V4L2_CID_MPEG_VIDEO_MV_V_SEARCH_RANGE		(V4L2_CID_MPEG_BASE+228)
</MACRO>
<MACRO>
<NAME>V4L2_CID_MPEG_VIDEO_H263_I_FRAME_QP</NAME>
#define V4L2_CID_MPEG_VIDEO_H263_I_FRAME_QP		(V4L2_CID_MPEG_BASE+300)
</MACRO>
<MACRO>
<NAME>V4L2_CID_MPEG_VIDEO_H263_P_FRAME_QP</NAME>
#define V4L2_CID_MPEG_VIDEO_H263_P_FRAME_QP		(V4L2_CID_MPEG_BASE+301)
</MACRO>
<MACRO>
<NAME>V4L2_CID_MPEG_VIDEO_H263_B_FRAME_QP</NAME>
#define V4L2_CID_MPEG_VIDEO_H263_B_FRAME_QP		(V4L2_CID_MPEG_BASE+302)
</MACRO>
<MACRO>
<NAME>V4L2_CID_MPEG_VIDEO_H263_MIN_QP</NAME>
#define V4L2_CID_MPEG_VIDEO_H263_MIN_QP			(V4L2_CID_MPEG_BASE+303)
</MACRO>
<MACRO>
<NAME>V4L2_CID_MPEG_VIDEO_H263_MAX_QP</NAME>
#define V4L2_CID_MPEG_VIDEO_H263_MAX_QP			(V4L2_CID_MPEG_BASE+304)
</MACRO>
<MACRO>
<NAME>V4L2_CID_MPEG_VIDEO_H264_I_FRAME_QP</NAME>
#define V4L2_CID_MPEG_VIDEO_H264_I_FRAME_QP		(V4L2_CID_MPEG_BASE+350)
</MACRO>
<MACRO>
<NAME>V4L2_CID_MPEG_VIDEO_H264_P_FRAME_QP</NAME>
#define V4L2_CID_MPEG_VIDEO_H264_P_FRAME_QP		(V4L2_CID_MPEG_BASE+351)
</MACRO>
<MACRO>
<NAME>V4L2_CID_MPEG_VIDEO_H264_B_FRAME_QP</NAME>
#define V4L2_CID_MPEG_VIDEO_H264_B_FRAME_QP		(V4L2_CID_MPEG_BASE+352)
</MACRO>
<MACRO>
<NAME>V4L2_CID_MPEG_VIDEO_H264_MIN_QP</NAME>
#define V4L2_CID_MPEG_VIDEO_H264_MIN_QP			(V4L2_CID_MPEG_BASE+353)
</MACRO>
<MACRO>
<NAME>V4L2_CID_MPEG_VIDEO_H264_MAX_QP</NAME>
#define V4L2_CID_MPEG_VIDEO_H264_MAX_QP			(V4L2_CID_MPEG_BASE+354)
</MACRO>
<MACRO>
<NAME>V4L2_CID_MPEG_VIDEO_H264_8X8_TRANSFORM</NAME>
#define V4L2_CID_MPEG_VIDEO_H264_8X8_TRANSFORM		(V4L2_CID_MPEG_BASE+355)
</MACRO>
<MACRO>
<NAME>V4L2_CID_MPEG_VIDEO_H264_CPB_SIZE</NAME>
#define V4L2_CID_MPEG_VIDEO_H264_CPB_SIZE		(V4L2_CID_MPEG_BASE+356)
</MACRO>
<MACRO>
<NAME>V4L2_CID_MPEG_VIDEO_H264_ENTROPY_MODE</NAME>
#define V4L2_CID_MPEG_VIDEO_H264_ENTROPY_MODE		(V4L2_CID_MPEG_BASE+357)
</MACRO>
<ENUM>
<NAME>v4l2_mpeg_video_h264_entropy_mode</NAME>
enum v4l2_mpeg_video_h264_entropy_mode {
	V4L2_MPEG_VIDEO_H264_ENTROPY_MODE_CAVLC	= 0,
	V4L2_MPEG_VIDEO_H264_ENTROPY_MODE_CABAC	= 1,
};
</ENUM>
<MACRO>
<NAME>V4L2_CID_MPEG_VIDEO_H264_I_PERIOD</NAME>
#define V4L2_CID_MPEG_VIDEO_H264_I_PERIOD		(V4L2_CID_MPEG_BASE+358)
</MACRO>
<MACRO>
<NAME>V4L2_CID_MPEG_VIDEO_H264_LEVEL</NAME>
#define V4L2_CID_MPEG_VIDEO_H264_LEVEL			(V4L2_CID_MPEG_BASE+359)
</MACRO>
<ENUM>
<NAME>v4l2_mpeg_video_h264_level</NAME>
enum v4l2_mpeg_video_h264_level {
	V4L2_MPEG_VIDEO_H264_LEVEL_1_0	= 0,
	V4L2_MPEG_VIDEO_H264_LEVEL_1B	= 1,
	V4L2_MPEG_VIDEO_H264_LEVEL_1_1	= 2,
	V4L2_MPEG_VIDEO_H264_LEVEL_1_2	= 3,
	V4L2_MPEG_VIDEO_H264_LEVEL_1_3	= 4,
	V4L2_MPEG_VIDEO_H264_LEVEL_2_0	= 5,
	V4L2_MPEG_VIDEO_H264_LEVEL_2_1	= 6,
	V4L2_MPEG_VIDEO_H264_LEVEL_2_2	= 7,
	V4L2_MPEG_VIDEO_H264_LEVEL_3_0	= 8,
	V4L2_MPEG_VIDEO_H264_LEVEL_3_1	= 9,
	V4L2_MPEG_VIDEO_H264_LEVEL_3_2	= 10,
	V4L2_MPEG_VIDEO_H264_LEVEL_4_0	= 11,
	V4L2_MPEG_VIDEO_H264_LEVEL_4_1	= 12,
	V4L2_MPEG_VIDEO_H264_LEVEL_4_2	= 13,
	V4L2_MPEG_VIDEO_H264_LEVEL_5_0	= 14,
	V4L2_MPEG_VIDEO_H264_LEVEL_5_1	= 15,
};
</ENUM>
<MACRO>
<NAME>V4L2_CID_MPEG_VIDEO_H264_LOOP_FILTER_ALPHA</NAME>
#define V4L2_CID_MPEG_VIDEO_H264_LOOP_FILTER_ALPHA	(V4L2_CID_MPEG_BASE+360)
</MACRO>
<MACRO>
<NAME>V4L2_CID_MPEG_VIDEO_H264_LOOP_FILTER_BETA</NAME>
#define V4L2_CID_MPEG_VIDEO_H264_LOOP_FILTER_BETA	(V4L2_CID_MPEG_BASE+361)
</MACRO>
<MACRO>
<NAME>V4L2_CID_MPEG_VIDEO_H264_LOOP_FILTER_MODE</NAME>
#define V4L2_CID_MPEG_VIDEO_H264_LOOP_FILTER_MODE	(V4L2_CID_MPEG_BASE+362)
</MACRO>
<ENUM>
<NAME>v4l2_mpeg_video_h264_loop_filter_mode</NAME>
enum v4l2_mpeg_video_h264_loop_filter_mode {
	V4L2_MPEG_VIDEO_H264_LOOP_FILTER_MODE_ENABLED				= 0,
	V4L2_MPEG_VIDEO_H264_LOOP_FILTER_MODE_DISABLED				= 1,
	V4L2_MPEG_VIDEO_H264_LOOP_FILTER_MODE_DISABLED_AT_SLICE_BOUNDARY	= 2,
};
</ENUM>
<MACRO>
<NAME>V4L2_CID_MPEG_VIDEO_H264_PROFILE</NAME>
#define V4L2_CID_MPEG_VIDEO_H264_PROFILE		(V4L2_CID_MPEG_BASE+363)
</MACRO>
<ENUM>
<NAME>v4l2_mpeg_video_h264_profile</NAME>
enum v4l2_mpeg_video_h264_profile {
	V4L2_MPEG_VIDEO_H264_PROFILE_BASELINE			= 0,
	V4L2_MPEG_VIDEO_H264_PROFILE_CONSTRAINED_BASELINE	= 1,
	V4L2_MPEG_VIDEO_H264_PROFILE_MAIN			= 2,
	V4L2_MPEG_VIDEO_H264_PROFILE_EXTENDED			= 3,
	V4L2_MPEG_VIDEO_H264_PROFILE_HIGH			= 4,
	V4L2_MPEG_VIDEO_H264_PROFILE_HIGH_10			= 5,
	V4L2_MPEG_VIDEO_H264_PROFILE_HIGH_422			= 6,
	V4L2_MPEG_VIDEO_H264_PROFILE_HIGH_444_PREDICTIVE	= 7,
	V4L2_MPEG_VIDEO_H264_PROFILE_HIGH_10_INTRA		= 8,
	V4L2_MPEG_VIDEO_H264_PROFILE_HIGH_422_INTRA		= 9,
	V4L2_MPEG_VIDEO_H264_PROFILE_HIGH_444_INTRA		= 10,
	V4L2_MPEG_VIDEO_H264_PROFILE_CAVLC_444_INTRA		= 11,
	V4L2_MPEG_VIDEO_H264_PROFILE_SCALABLE_BASELINE		= 12,
	V4L2_MPEG_VIDEO_H264_PROFILE_SCALABLE_HIGH		= 13,
	V4L2_MPEG_VIDEO_H264_PROFILE_SCALABLE_HIGH_INTRA	= 14,
	V4L2_MPEG_VIDEO_H264_PROFILE_STEREO_HIGH		= 15,
	V4L2_MPEG_VIDEO_H264_PROFILE_MULTIVIEW_HIGH		= 16,
};
</ENUM>
<MACRO>
<NAME>V4L2_CID_MPEG_VIDEO_H264_VUI_EXT_SAR_HEIGHT</NAME>
#define V4L2_CID_MPEG_VIDEO_H264_VUI_EXT_SAR_HEIGHT	(V4L2_CID_MPEG_BASE+364)
</MACRO>
<MACRO>
<NAME>V4L2_CID_MPEG_VIDEO_H264_VUI_EXT_SAR_WIDTH</NAME>
#define V4L2_CID_MPEG_VIDEO_H264_VUI_EXT_SAR_WIDTH	(V4L2_CID_MPEG_BASE+365)
</MACRO>
<MACRO>
<NAME>V4L2_CID_MPEG_VIDEO_H264_VUI_SAR_ENABLE</NAME>
#define V4L2_CID_MPEG_VIDEO_H264_VUI_SAR_ENABLE		(V4L2_CID_MPEG_BASE+366)
</MACRO>
<MACRO>
<NAME>V4L2_CID_MPEG_VIDEO_H264_VUI_SAR_IDC</NAME>
#define V4L2_CID_MPEG_VIDEO_H264_VUI_SAR_IDC		(V4L2_CID_MPEG_BASE+367)
</MACRO>
<ENUM>
<NAME>v4l2_mpeg_video_h264_vui_sar_idc</NAME>
enum v4l2_mpeg_video_h264_vui_sar_idc {
	V4L2_MPEG_VIDEO_H264_VUI_SAR_IDC_UNSPECIFIED	= 0,
	V4L2_MPEG_VIDEO_H264_VUI_SAR_IDC_1x1		= 1,
	V4L2_MPEG_VIDEO_H264_VUI_SAR_IDC_12x11		= 2,
	V4L2_MPEG_VIDEO_H264_VUI_SAR_IDC_10x11		= 3,
	V4L2_MPEG_VIDEO_H264_VUI_SAR_IDC_16x11		= 4,
	V4L2_MPEG_VIDEO_H264_VUI_SAR_IDC_40x33		= 5,
	V4L2_MPEG_VIDEO_H264_VUI_SAR_IDC_24x11		= 6,
	V4L2_MPEG_VIDEO_H264_VUI_SAR_IDC_20x11		= 7,
	V4L2_MPEG_VIDEO_H264_VUI_SAR_IDC_32x11		= 8,
	V4L2_MPEG_VIDEO_H264_VUI_SAR_IDC_80x33		= 9,
	V4L2_MPEG_VIDEO_H264_VUI_SAR_IDC_18x11		= 10,
	V4L2_MPEG_VIDEO_H264_VUI_SAR_IDC_15x11		= 11,
	V4L2_MPEG_VIDEO_H264_VUI_SAR_IDC_64x33		= 12,
	V4L2_MPEG_VIDEO_H264_VUI_SAR_IDC_160x99		= 13,
	V4L2_MPEG_VIDEO_H264_VUI_SAR_IDC_4x3		= 14,
	V4L2_MPEG_VIDEO_H264_VUI_SAR_IDC_3x2		= 15,
	V4L2_MPEG_VIDEO_H264_VUI_SAR_IDC_2x1		= 16,
	V4L2_MPEG_VIDEO_H264_VUI_SAR_IDC_EXTENDED	= 17,
};
</ENUM>
<MACRO>
<NAME>V4L2_CID_MPEG_VIDEO_H264_SEI_FRAME_PACKING</NAME>
#define V4L2_CID_MPEG_VIDEO_H264_SEI_FRAME_PACKING		(V4L2_CID_MPEG_BASE+368)
</MACRO>
<MACRO>
<NAME>V4L2_CID_MPEG_VIDEO_H264_SEI_FP_CURRENT_FRAME_0</NAME>
#define V4L2_CID_MPEG_VIDEO_H264_SEI_FP_CURRENT_FRAME_0		(V4L2_CID_MPEG_BASE+369)
</MACRO>
<MACRO>
<NAME>V4L2_CID_MPEG_VIDEO_H264_SEI_FP_ARRANGEMENT_TYPE</NAME>
#define V4L2_CID_MPEG_VIDEO_H264_SEI_FP_ARRANGEMENT_TYPE	(V4L2_CID_MPEG_BASE+370)
</MACRO>
<ENUM>
<NAME>v4l2_mpeg_video_h264_sei_fp_arrangement_type</NAME>
enum v4l2_mpeg_video_h264_sei_fp_arrangement_type {
	V4L2_MPEG_VIDEO_H264_SEI_FP_ARRANGEMENT_TYPE_CHECKERBOARD	= 0,
	V4L2_MPEG_VIDEO_H264_SEI_FP_ARRANGEMENT_TYPE_COLUMN		= 1,
	V4L2_MPEG_VIDEO_H264_SEI_FP_ARRANGEMENT_TYPE_ROW		= 2,
	V4L2_MPEG_VIDEO_H264_SEI_FP_ARRANGEMENT_TYPE_SIDE_BY_SIDE	= 3,
	V4L2_MPEG_VIDEO_H264_SEI_FP_ARRANGEMENT_TYPE_TOP_BOTTOM		= 4,
	V4L2_MPEG_VIDEO_H264_SEI_FP_ARRANGEMENT_TYPE_TEMPORAL		= 5,
};
</ENUM>
<MACRO>
<NAME>V4L2_CID_MPEG_VIDEO_H264_FMO</NAME>
#define V4L2_CID_MPEG_VIDEO_H264_FMO			(V4L2_CID_MPEG_BASE+371)
</MACRO>
<MACRO>
<NAME>V4L2_CID_MPEG_VIDEO_H264_FMO_MAP_TYPE</NAME>
#define V4L2_CID_MPEG_VIDEO_H264_FMO_MAP_TYPE		(V4L2_CID_MPEG_BASE+372)
</MACRO>
<ENUM>
<NAME>v4l2_mpeg_video_h264_fmo_map_type</NAME>
enum v4l2_mpeg_video_h264_fmo_map_type {
	V4L2_MPEG_VIDEO_H264_FMO_MAP_TYPE_INTERLEAVED_SLICES		= 0,
	V4L2_MPEG_VIDEO_H264_FMO_MAP_TYPE_SCATTERED_SLICES		= 1,
	V4L2_MPEG_VIDEO_H264_FMO_MAP_TYPE_FOREGROUND_WITH_LEFT_OVER	= 2,
	V4L2_MPEG_VIDEO_H264_FMO_MAP_TYPE_BOX_OUT			= 3,
	V4L2_MPEG_VIDEO_H264_FMO_MAP_TYPE_RASTER_SCAN			= 4,
	V4L2_MPEG_VIDEO_H264_FMO_MAP_TYPE_WIPE_SCAN			= 5,
	V4L2_MPEG_VIDEO_H264_FMO_MAP_TYPE_EXPLICIT			= 6,
};
</ENUM>
<MACRO>
<NAME>V4L2_CID_MPEG_VIDEO_H264_FMO_SLICE_GROUP</NAME>
#define V4L2_CID_MPEG_VIDEO_H264_FMO_SLICE_GROUP	(V4L2_CID_MPEG_BASE+373)
</MACRO>
<MACRO>
<NAME>V4L2_CID_MPEG_VIDEO_H264_FMO_CHANGE_DIRECTION</NAME>
#define V4L2_CID_MPEG_VIDEO_H264_FMO_CHANGE_DIRECTION	(V4L2_CID_MPEG_BASE+374)
</MACRO>
<ENUM>
<NAME>v4l2_mpeg_video_h264_fmo_change_dir</NAME>
enum v4l2_mpeg_video_h264_fmo_change_dir {
	V4L2_MPEG_VIDEO_H264_FMO_CHANGE_DIR_RIGHT	= 0,
	V4L2_MPEG_VIDEO_H264_FMO_CHANGE_DIR_LEFT	= 1,
};
</ENUM>
<MACRO>
<NAME>V4L2_CID_MPEG_VIDEO_H264_FMO_CHANGE_RATE</NAME>
#define V4L2_CID_MPEG_VIDEO_H264_FMO_CHANGE_RATE	(V4L2_CID_MPEG_BASE+375)
</MACRO>
<MACRO>
<NAME>V4L2_CID_MPEG_VIDEO_H264_FMO_RUN_LENGTH</NAME>
#define V4L2_CID_MPEG_VIDEO_H264_FMO_RUN_LENGTH		(V4L2_CID_MPEG_BASE+376)
</MACRO>
<MACRO>
<NAME>V4L2_CID_MPEG_VIDEO_H264_ASO</NAME>
#define V4L2_CID_MPEG_VIDEO_H264_ASO			(V4L2_CID_MPEG_BASE+377)
</MACRO>
<MACRO>
<NAME>V4L2_CID_MPEG_VIDEO_H264_ASO_SLICE_ORDER</NAME>
#define V4L2_CID_MPEG_VIDEO_H264_ASO_SLICE_ORDER	(V4L2_CID_MPEG_BASE+378)
</MACRO>
<MACRO>
<NAME>V4L2_CID_MPEG_VIDEO_H264_HIERARCHICAL_CODING</NAME>
#define V4L2_CID_MPEG_VIDEO_H264_HIERARCHICAL_CODING		(V4L2_CID_MPEG_BASE+379)
</MACRO>
<MACRO>
<NAME>V4L2_CID_MPEG_VIDEO_H264_HIERARCHICAL_CODING_TYPE</NAME>
#define V4L2_CID_MPEG_VIDEO_H264_HIERARCHICAL_CODING_TYPE	(V4L2_CID_MPEG_BASE+380)
</MACRO>
<ENUM>
<NAME>v4l2_mpeg_video_h264_hierarchical_coding_type</NAME>
enum v4l2_mpeg_video_h264_hierarchical_coding_type {
	V4L2_MPEG_VIDEO_H264_HIERARCHICAL_CODING_B	= 0,
	V4L2_MPEG_VIDEO_H264_HIERARCHICAL_CODING_P	= 1,
};
</ENUM>
<MACRO>
<NAME>V4L2_CID_MPEG_VIDEO_H264_HIERARCHICAL_CODING_LAYER</NAME>
#define V4L2_CID_MPEG_VIDEO_H264_HIERARCHICAL_CODING_LAYER	(V4L2_CID_MPEG_BASE+381)
</MACRO>
<MACRO>
<NAME>V4L2_CID_MPEG_VIDEO_H264_HIERARCHICAL_CODING_LAYER_QP</NAME>
#define V4L2_CID_MPEG_VIDEO_H264_HIERARCHICAL_CODING_LAYER_QP	(V4L2_CID_MPEG_BASE+382)
</MACRO>
<MACRO>
<NAME>V4L2_CID_MPEG_VIDEO_MPEG4_I_FRAME_QP</NAME>
#define V4L2_CID_MPEG_VIDEO_MPEG4_I_FRAME_QP	(V4L2_CID_MPEG_BASE+400)
</MACRO>
<MACRO>
<NAME>V4L2_CID_MPEG_VIDEO_MPEG4_P_FRAME_QP</NAME>
#define V4L2_CID_MPEG_VIDEO_MPEG4_P_FRAME_QP	(V4L2_CID_MPEG_BASE+401)
</MACRO>
<MACRO>
<NAME>V4L2_CID_MPEG_VIDEO_MPEG4_B_FRAME_QP</NAME>
#define V4L2_CID_MPEG_VIDEO_MPEG4_B_FRAME_QP	(V4L2_CID_MPEG_BASE+402)
</MACRO>
<MACRO>
<NAME>V4L2_CID_MPEG_VIDEO_MPEG4_MIN_QP</NAME>
#define V4L2_CID_MPEG_VIDEO_MPEG4_MIN_QP	(V4L2_CID_MPEG_BASE+403)
</MACRO>
<MACRO>
<NAME>V4L2_CID_MPEG_VIDEO_MPEG4_MAX_QP</NAME>
#define V4L2_CID_MPEG_VIDEO_MPEG4_MAX_QP	(V4L2_CID_MPEG_BASE+404)
</MACRO>
<MACRO>
<NAME>V4L2_CID_MPEG_VIDEO_MPEG4_LEVEL</NAME>
#define V4L2_CID_MPEG_VIDEO_MPEG4_LEVEL		(V4L2_CID_MPEG_BASE+405)
</MACRO>
<ENUM>
<NAME>v4l2_mpeg_video_mpeg4_level</NAME>
enum v4l2_mpeg_video_mpeg4_level {
	V4L2_MPEG_VIDEO_MPEG4_LEVEL_0	= 0,
	V4L2_MPEG_VIDEO_MPEG4_LEVEL_0B	= 1,
	V4L2_MPEG_VIDEO_MPEG4_LEVEL_1	= 2,
	V4L2_MPEG_VIDEO_MPEG4_LEVEL_2	= 3,
	V4L2_MPEG_VIDEO_MPEG4_LEVEL_3	= 4,
	V4L2_MPEG_VIDEO_MPEG4_LEVEL_3B	= 5,
	V4L2_MPEG_VIDEO_MPEG4_LEVEL_4	= 6,
	V4L2_MPEG_VIDEO_MPEG4_LEVEL_5	= 7,
};
</ENUM>
<MACRO>
<NAME>V4L2_CID_MPEG_VIDEO_MPEG4_PROFILE</NAME>
#define V4L2_CID_MPEG_VIDEO_MPEG4_PROFILE	(V4L2_CID_MPEG_BASE+406)
</MACRO>
<ENUM>
<NAME>v4l2_mpeg_video_mpeg4_profile</NAME>
enum v4l2_mpeg_video_mpeg4_profile {
	V4L2_MPEG_VIDEO_MPEG4_PROFILE_SIMPLE				= 0,
	V4L2_MPEG_VIDEO_MPEG4_PROFILE_ADVANCED_SIMPLE			= 1,
	V4L2_MPEG_VIDEO_MPEG4_PROFILE_CORE				= 2,
	V4L2_MPEG_VIDEO_MPEG4_PROFILE_SIMPLE_SCALABLE			= 3,
	V4L2_MPEG_VIDEO_MPEG4_PROFILE_ADVANCED_CODING_EFFICIENCY	= 4,
};
</ENUM>
<MACRO>
<NAME>V4L2_CID_MPEG_VIDEO_MPEG4_QPEL</NAME>
#define V4L2_CID_MPEG_VIDEO_MPEG4_QPEL		(V4L2_CID_MPEG_BASE+407)
</MACRO>
<MACRO>
<NAME>V4L2_CID_MPEG_VIDEO_VPX_NUM_PARTITIONS</NAME>
#define V4L2_CID_MPEG_VIDEO_VPX_NUM_PARTITIONS		(V4L2_CID_MPEG_BASE+500)
</MACRO>
<ENUM>
<NAME>v4l2_vp8_num_partitions</NAME>
enum v4l2_vp8_num_partitions {
	V4L2_CID_MPEG_VIDEO_VPX_1_PARTITION	= 0,
	V4L2_CID_MPEG_VIDEO_VPX_2_PARTITIONS	= 1,
	V4L2_CID_MPEG_VIDEO_VPX_4_PARTITIONS	= 2,
	V4L2_CID_MPEG_VIDEO_VPX_8_PARTITIONS	= 3,
};
</ENUM>
<MACRO>
<NAME>V4L2_CID_MPEG_VIDEO_VPX_IMD_DISABLE_4X4</NAME>
#define V4L2_CID_MPEG_VIDEO_VPX_IMD_DISABLE_4X4		(V4L2_CID_MPEG_BASE+501)
</MACRO>
<MACRO>
<NAME>V4L2_CID_MPEG_VIDEO_VPX_NUM_REF_FRAMES</NAME>
#define V4L2_CID_MPEG_VIDEO_VPX_NUM_REF_FRAMES		(V4L2_CID_MPEG_BASE+502)
</MACRO>
<ENUM>
<NAME>v4l2_vp8_num_ref_frames</NAME>
enum v4l2_vp8_num_ref_frames {
	V4L2_CID_MPEG_VIDEO_VPX_1_REF_FRAME	= 0,
	V4L2_CID_MPEG_VIDEO_VPX_2_REF_FRAME	= 1,
	V4L2_CID_MPEG_VIDEO_VPX_3_REF_FRAME	= 2,
};
</ENUM>
<MACRO>
<NAME>V4L2_CID_MPEG_VIDEO_VPX_FILTER_LEVEL</NAME>
#define V4L2_CID_MPEG_VIDEO_VPX_FILTER_LEVEL		(V4L2_CID_MPEG_BASE+503)
</MACRO>
<MACRO>
<NAME>V4L2_CID_MPEG_VIDEO_VPX_FILTER_SHARPNESS</NAME>
#define V4L2_CID_MPEG_VIDEO_VPX_FILTER_SHARPNESS	(V4L2_CID_MPEG_BASE+504)
</MACRO>
<MACRO>
<NAME>V4L2_CID_MPEG_VIDEO_VPX_GOLDEN_FRAME_REF_PERIOD</NAME>
#define V4L2_CID_MPEG_VIDEO_VPX_GOLDEN_FRAME_REF_PERIOD	(V4L2_CID_MPEG_BASE+505)
</MACRO>
<MACRO>
<NAME>V4L2_CID_MPEG_VIDEO_VPX_GOLDEN_FRAME_SEL</NAME>
#define V4L2_CID_MPEG_VIDEO_VPX_GOLDEN_FRAME_SEL	(V4L2_CID_MPEG_BASE+506)
</MACRO>
<ENUM>
<NAME>v4l2_vp8_golden_frame_sel</NAME>
enum v4l2_vp8_golden_frame_sel {
	V4L2_CID_MPEG_VIDEO_VPX_GOLDEN_FRAME_USE_PREV		= 0,
	V4L2_CID_MPEG_VIDEO_VPX_GOLDEN_FRAME_USE_REF_PERIOD	= 1,
};
</ENUM>
<MACRO>
<NAME>V4L2_CID_MPEG_VIDEO_VPX_MIN_QP</NAME>
#define V4L2_CID_MPEG_VIDEO_VPX_MIN_QP			(V4L2_CID_MPEG_BASE+507)
</MACRO>
<MACRO>
<NAME>V4L2_CID_MPEG_VIDEO_VPX_MAX_QP</NAME>
#define V4L2_CID_MPEG_VIDEO_VPX_MAX_QP			(V4L2_CID_MPEG_BASE+508)
</MACRO>
<MACRO>
<NAME>V4L2_CID_MPEG_VIDEO_VPX_I_FRAME_QP</NAME>
#define V4L2_CID_MPEG_VIDEO_VPX_I_FRAME_QP		(V4L2_CID_MPEG_BASE+509)
</MACRO>
<MACRO>
<NAME>V4L2_CID_MPEG_VIDEO_VPX_P_FRAME_QP</NAME>
#define V4L2_CID_MPEG_VIDEO_VPX_P_FRAME_QP		(V4L2_CID_MPEG_BASE+510)
</MACRO>
<MACRO>
<NAME>V4L2_CID_MPEG_VIDEO_VPX_PROFILE</NAME>
#define V4L2_CID_MPEG_VIDEO_VPX_PROFILE			(V4L2_CID_MPEG_BASE+511)
</MACRO>
<MACRO>
<NAME>V4L2_CID_MPEG_CX2341X_BASE</NAME>
#define V4L2_CID_MPEG_CX2341X_BASE 				(V4L2_CTRL_CLASS_MPEG | 0x1000)
</MACRO>
<MACRO>
<NAME>V4L2_CID_MPEG_CX2341X_VIDEO_SPATIAL_FILTER_MODE</NAME>
#define V4L2_CID_MPEG_CX2341X_VIDEO_SPATIAL_FILTER_MODE 	(V4L2_CID_MPEG_CX2341X_BASE+0)
</MACRO>
<ENUM>
<NAME>v4l2_mpeg_cx2341x_video_spatial_filter_mode</NAME>
enum v4l2_mpeg_cx2341x_video_spatial_filter_mode {
	V4L2_MPEG_CX2341X_VIDEO_SPATIAL_FILTER_MODE_MANUAL = 0,
	V4L2_MPEG_CX2341X_VIDEO_SPATIAL_FILTER_MODE_AUTO   = 1,
};
</ENUM>
<MACRO>
<NAME>V4L2_CID_MPEG_CX2341X_VIDEO_SPATIAL_FILTER</NAME>
#define V4L2_CID_MPEG_CX2341X_VIDEO_SPATIAL_FILTER 		(V4L2_CID_MPEG_CX2341X_BASE+1)
</MACRO>
<MACRO>
<NAME>V4L2_CID_MPEG_CX2341X_VIDEO_LUMA_SPATIAL_FILTER_TYPE</NAME>
#define V4L2_CID_MPEG_CX2341X_VIDEO_LUMA_SPATIAL_FILTER_TYPE 	(V4L2_CID_MPEG_CX2341X_BASE+2)
</MACRO>
<ENUM>
<NAME>v4l2_mpeg_cx2341x_video_luma_spatial_filter_type</NAME>
enum v4l2_mpeg_cx2341x_video_luma_spatial_filter_type {
	V4L2_MPEG_CX2341X_VIDEO_LUMA_SPATIAL_FILTER_TYPE_OFF                  = 0,
	V4L2_MPEG_CX2341X_VIDEO_LUMA_SPATIAL_FILTER_TYPE_1D_HOR               = 1,
	V4L2_MPEG_CX2341X_VIDEO_LUMA_SPATIAL_FILTER_TYPE_1D_VERT              = 2,
	V4L2_MPEG_CX2341X_VIDEO_LUMA_SPATIAL_FILTER_TYPE_2D_HV_SEPARABLE      = 3,
	V4L2_MPEG_CX2341X_VIDEO_LUMA_SPATIAL_FILTER_TYPE_2D_SYM_NON_SEPARABLE = 4,
};
</ENUM>
<MACRO>
<NAME>V4L2_CID_MPEG_CX2341X_VIDEO_CHROMA_SPATIAL_FILTER_TYPE</NAME>
#define V4L2_CID_MPEG_CX2341X_VIDEO_CHROMA_SPATIAL_FILTER_TYPE 	(V4L2_CID_MPEG_CX2341X_BASE+3)
</MACRO>
<ENUM>
<NAME>v4l2_mpeg_cx2341x_video_chroma_spatial_filter_type</NAME>
enum v4l2_mpeg_cx2341x_video_chroma_spatial_filter_type {
	V4L2_MPEG_CX2341X_VIDEO_CHROMA_SPATIAL_FILTER_TYPE_OFF    = 0,
	V4L2_MPEG_CX2341X_VIDEO_CHROMA_SPATIAL_FILTER_TYPE_1D_HOR = 1,
};
</ENUM>
<MACRO>
<NAME>V4L2_CID_MPEG_CX2341X_VIDEO_TEMPORAL_FILTER_MODE</NAME>
#define V4L2_CID_MPEG_CX2341X_VIDEO_TEMPORAL_FILTER_MODE 	(V4L2_CID_MPEG_CX2341X_BASE+4)
</MACRO>
<ENUM>
<NAME>v4l2_mpeg_cx2341x_video_temporal_filter_mode</NAME>
enum v4l2_mpeg_cx2341x_video_temporal_filter_mode {
	V4L2_MPEG_CX2341X_VIDEO_TEMPORAL_FILTER_MODE_MANUAL = 0,
	V4L2_MPEG_CX2341X_VIDEO_TEMPORAL_FILTER_MODE_AUTO   = 1,
};
</ENUM>
<MACRO>
<NAME>V4L2_CID_MPEG_CX2341X_VIDEO_TEMPORAL_FILTER</NAME>
#define V4L2_CID_MPEG_CX2341X_VIDEO_TEMPORAL_FILTER 		(V4L2_CID_MPEG_CX2341X_BASE+5)
</MACRO>
<MACRO>
<NAME>V4L2_CID_MPEG_CX2341X_VIDEO_MEDIAN_FILTER_TYPE</NAME>
#define V4L2_CID_MPEG_CX2341X_VIDEO_MEDIAN_FILTER_TYPE 		(V4L2_CID_MPEG_CX2341X_BASE+6)
</MACRO>
<ENUM>
<NAME>v4l2_mpeg_cx2341x_video_median_filter_type</NAME>
enum v4l2_mpeg_cx2341x_video_median_filter_type {
	V4L2_MPEG_CX2341X_VIDEO_MEDIAN_FILTER_TYPE_OFF      = 0,
	V4L2_MPEG_CX2341X_VIDEO_MEDIAN_FILTER_TYPE_HOR      = 1,
	V4L2_MPEG_CX2341X_VIDEO_MEDIAN_FILTER_TYPE_VERT     = 2,
	V4L2_MPEG_CX2341X_VIDEO_MEDIAN_FILTER_TYPE_HOR_VERT = 3,
	V4L2_MPEG_CX2341X_VIDEO_MEDIAN_FILTER_TYPE_DIAG     = 4,
};
</ENUM>
<MACRO>
<NAME>V4L2_CID_MPEG_CX2341X_VIDEO_LUMA_MEDIAN_FILTER_BOTTOM</NAME>
#define V4L2_CID_MPEG_CX2341X_VIDEO_LUMA_MEDIAN_FILTER_BOTTOM 	(V4L2_CID_MPEG_CX2341X_BASE+7)
</MACRO>
<MACRO>
<NAME>V4L2_CID_MPEG_CX2341X_VIDEO_LUMA_MEDIAN_FILTER_TOP</NAME>
#define V4L2_CID_MPEG_CX2341X_VIDEO_LUMA_MEDIAN_FILTER_TOP 	(V4L2_CID_MPEG_CX2341X_BASE+8)
</MACRO>
<MACRO>
<NAME>V4L2_CID_MPEG_CX2341X_VIDEO_CHROMA_MEDIAN_FILTER_BOTTOM</NAME>
#define V4L2_CID_MPEG_CX2341X_VIDEO_CHROMA_MEDIAN_FILTER_BOTTOM	(V4L2_CID_MPEG_CX2341X_BASE+9)
</MACRO>
<MACRO>
<NAME>V4L2_CID_MPEG_CX2341X_VIDEO_CHROMA_MEDIAN_FILTER_TOP</NAME>
#define V4L2_CID_MPEG_CX2341X_VIDEO_CHROMA_MEDIAN_FILTER_TOP 	(V4L2_CID_MPEG_CX2341X_BASE+10)
</MACRO>
<MACRO>
<NAME>V4L2_CID_MPEG_CX2341X_STREAM_INSERT_NAV_PACKETS</NAME>
#define V4L2_CID_MPEG_CX2341X_STREAM_INSERT_NAV_PACKETS 	(V4L2_CID_MPEG_CX2341X_BASE+11)
</MACRO>
<MACRO>
<NAME>V4L2_CID_MPEG_MFC51_BASE</NAME>
#define V4L2_CID_MPEG_MFC51_BASE				(V4L2_CTRL_CLASS_MPEG | 0x1100)
</MACRO>
<MACRO>
<NAME>V4L2_CID_MPEG_MFC51_VIDEO_DECODER_H264_DISPLAY_DELAY</NAME>
#define V4L2_CID_MPEG_MFC51_VIDEO_DECODER_H264_DISPLAY_DELAY		(V4L2_CID_MPEG_MFC51_BASE+0)
</MACRO>
<MACRO>
<NAME>V4L2_CID_MPEG_MFC51_VIDEO_DECODER_H264_DISPLAY_DELAY_ENABLE</NAME>
#define V4L2_CID_MPEG_MFC51_VIDEO_DECODER_H264_DISPLAY_DELAY_ENABLE	(V4L2_CID_MPEG_MFC51_BASE+1)
</MACRO>
<MACRO>
<NAME>V4L2_CID_MPEG_MFC51_VIDEO_FRAME_SKIP_MODE</NAME>
#define V4L2_CID_MPEG_MFC51_VIDEO_FRAME_SKIP_MODE			(V4L2_CID_MPEG_MFC51_BASE+2)
</MACRO>
<ENUM>
<NAME>v4l2_mpeg_mfc51_video_frame_skip_mode</NAME>
enum v4l2_mpeg_mfc51_video_frame_skip_mode {
	V4L2_MPEG_MFC51_VIDEO_FRAME_SKIP_MODE_DISABLED		= 0,
	V4L2_MPEG_MFC51_VIDEO_FRAME_SKIP_MODE_LEVEL_LIMIT	= 1,
	V4L2_MPEG_MFC51_VIDEO_FRAME_SKIP_MODE_BUF_LIMIT		= 2,
};
</ENUM>
<MACRO>
<NAME>V4L2_CID_MPEG_MFC51_VIDEO_FORCE_FRAME_TYPE</NAME>
#define V4L2_CID_MPEG_MFC51_VIDEO_FORCE_FRAME_TYPE			(V4L2_CID_MPEG_MFC51_BASE+3)
</MACRO>
<ENUM>
<NAME>v4l2_mpeg_mfc51_video_force_frame_type</NAME>
enum v4l2_mpeg_mfc51_video_force_frame_type {
	V4L2_MPEG_MFC51_VIDEO_FORCE_FRAME_TYPE_DISABLED		= 0,
	V4L2_MPEG_MFC51_VIDEO_FORCE_FRAME_TYPE_I_FRAME		= 1,
	V4L2_MPEG_MFC51_VIDEO_FORCE_FRAME_TYPE_NOT_CODED	= 2,
};
</ENUM>
<MACRO>
<NAME>V4L2_CID_MPEG_MFC51_VIDEO_PADDING</NAME>
#define V4L2_CID_MPEG_MFC51_VIDEO_PADDING				(V4L2_CID_MPEG_MFC51_BASE+4)
</MACRO>
<MACRO>
<NAME>V4L2_CID_MPEG_MFC51_VIDEO_PADDING_YUV</NAME>
#define V4L2_CID_MPEG_MFC51_VIDEO_PADDING_YUV				(V4L2_CID_MPEG_MFC51_BASE+5)
</MACRO>
<MACRO>
<NAME>V4L2_CID_MPEG_MFC51_VIDEO_RC_FIXED_TARGET_BIT</NAME>
#define V4L2_CID_MPEG_MFC51_VIDEO_RC_FIXED_TARGET_BIT			(V4L2_CID_MPEG_MFC51_BASE+6)
</MACRO>
<MACRO>
<NAME>V4L2_CID_MPEG_MFC51_VIDEO_RC_REACTION_COEFF</NAME>
#define V4L2_CID_MPEG_MFC51_VIDEO_RC_REACTION_COEFF			(V4L2_CID_MPEG_MFC51_BASE+7)
</MACRO>
<MACRO>
<NAME>V4L2_CID_MPEG_MFC51_VIDEO_H264_ADAPTIVE_RC_ACTIVITY</NAME>
#define V4L2_CID_MPEG_MFC51_VIDEO_H264_ADAPTIVE_RC_ACTIVITY		(V4L2_CID_MPEG_MFC51_BASE+50)
</MACRO>
<MACRO>
<NAME>V4L2_CID_MPEG_MFC51_VIDEO_H264_ADAPTIVE_RC_DARK</NAME>
#define V4L2_CID_MPEG_MFC51_VIDEO_H264_ADAPTIVE_RC_DARK			(V4L2_CID_MPEG_MFC51_BASE+51)
</MACRO>
<MACRO>
<NAME>V4L2_CID_MPEG_MFC51_VIDEO_H264_ADAPTIVE_RC_SMOOTH</NAME>
#define V4L2_CID_MPEG_MFC51_VIDEO_H264_ADAPTIVE_RC_SMOOTH		(V4L2_CID_MPEG_MFC51_BASE+52)
</MACRO>
<MACRO>
<NAME>V4L2_CID_MPEG_MFC51_VIDEO_H264_ADAPTIVE_RC_STATIC</NAME>
#define V4L2_CID_MPEG_MFC51_VIDEO_H264_ADAPTIVE_RC_STATIC		(V4L2_CID_MPEG_MFC51_BASE+53)
</MACRO>
<MACRO>
<NAME>V4L2_CID_MPEG_MFC51_VIDEO_H264_NUM_REF_PIC_FOR_P</NAME>
#define V4L2_CID_MPEG_MFC51_VIDEO_H264_NUM_REF_PIC_FOR_P		(V4L2_CID_MPEG_MFC51_BASE+54)
</MACRO>
<MACRO>
<NAME>V4L2_CID_CAMERA_CLASS_BASE</NAME>
#define V4L2_CID_CAMERA_CLASS_BASE 	(V4L2_CTRL_CLASS_CAMERA | 0x900)
</MACRO>
<MACRO>
<NAME>V4L2_CID_CAMERA_CLASS</NAME>
#define V4L2_CID_CAMERA_CLASS 		(V4L2_CTRL_CLASS_CAMERA | 1)
</MACRO>
<MACRO>
<NAME>V4L2_CID_EXPOSURE_AUTO</NAME>
#define V4L2_CID_EXPOSURE_AUTO			(V4L2_CID_CAMERA_CLASS_BASE+1)
</MACRO>
<ENUM>
<NAME>v4l2_exposure_auto_type</NAME>
enum v4l2_exposure_auto_type {
	V4L2_EXPOSURE_AUTO = 0,
	V4L2_EXPOSURE_MANUAL = 1,
	V4L2_EXPOSURE_SHUTTER_PRIORITY = 2,
	V4L2_EXPOSURE_APERTURE_PRIORITY = 3
};
</ENUM>
<MACRO>
<NAME>V4L2_CID_EXPOSURE_ABSOLUTE</NAME>
#define V4L2_CID_EXPOSURE_ABSOLUTE		(V4L2_CID_CAMERA_CLASS_BASE+2)
</MACRO>
<MACRO>
<NAME>V4L2_CID_EXPOSURE_AUTO_PRIORITY</NAME>
#define V4L2_CID_EXPOSURE_AUTO_PRIORITY		(V4L2_CID_CAMERA_CLASS_BASE+3)
</MACRO>
<MACRO>
<NAME>V4L2_CID_PAN_RELATIVE</NAME>
#define V4L2_CID_PAN_RELATIVE			(V4L2_CID_CAMERA_CLASS_BASE+4)
</MACRO>
<MACRO>
<NAME>V4L2_CID_TILT_RELATIVE</NAME>
#define V4L2_CID_TILT_RELATIVE			(V4L2_CID_CAMERA_CLASS_BASE+5)
</MACRO>
<MACRO>
<NAME>V4L2_CID_PAN_RESET</NAME>
#define V4L2_CID_PAN_RESET			(V4L2_CID_CAMERA_CLASS_BASE+6)
</MACRO>
<MACRO>
<NAME>V4L2_CID_TILT_RESET</NAME>
#define V4L2_CID_TILT_RESET			(V4L2_CID_CAMERA_CLASS_BASE+7)
</MACRO>
<MACRO>
<NAME>V4L2_CID_PAN_ABSOLUTE</NAME>
#define V4L2_CID_PAN_ABSOLUTE			(V4L2_CID_CAMERA_CLASS_BASE+8)
</MACRO>
<MACRO>
<NAME>V4L2_CID_TILT_ABSOLUTE</NAME>
#define V4L2_CID_TILT_ABSOLUTE			(V4L2_CID_CAMERA_CLASS_BASE+9)
</MACRO>
<MACRO>
<NAME>V4L2_CID_FOCUS_ABSOLUTE</NAME>
#define V4L2_CID_FOCUS_ABSOLUTE			(V4L2_CID_CAMERA_CLASS_BASE+10)
</MACRO>
<MACRO>
<NAME>V4L2_CID_FOCUS_RELATIVE</NAME>
#define V4L2_CID_FOCUS_RELATIVE			(V4L2_CID_CAMERA_CLASS_BASE+11)
</MACRO>
<MACRO>
<NAME>V4L2_CID_FOCUS_AUTO</NAME>
#define V4L2_CID_FOCUS_AUTO			(V4L2_CID_CAMERA_CLASS_BASE+12)
</MACRO>
<MACRO>
<NAME>V4L2_CID_ZOOM_ABSOLUTE</NAME>
#define V4L2_CID_ZOOM_ABSOLUTE			(V4L2_CID_CAMERA_CLASS_BASE+13)
</MACRO>
<MACRO>
<NAME>V4L2_CID_ZOOM_RELATIVE</NAME>
#define V4L2_CID_ZOOM_RELATIVE			(V4L2_CID_CAMERA_CLASS_BASE+14)
</MACRO>
<MACRO>
<NAME>V4L2_CID_ZOOM_CONTINUOUS</NAME>
#define V4L2_CID_ZOOM_CONTINUOUS		(V4L2_CID_CAMERA_CLASS_BASE+15)
</MACRO>
<MACRO>
<NAME>V4L2_CID_PRIVACY</NAME>
#define V4L2_CID_PRIVACY			(V4L2_CID_CAMERA_CLASS_BASE+16)
</MACRO>
<MACRO>
<NAME>V4L2_CID_IRIS_ABSOLUTE</NAME>
#define V4L2_CID_IRIS_ABSOLUTE			(V4L2_CID_CAMERA_CLASS_BASE+17)
</MACRO>
<MACRO>
<NAME>V4L2_CID_IRIS_RELATIVE</NAME>
#define V4L2_CID_IRIS_RELATIVE			(V4L2_CID_CAMERA_CLASS_BASE+18)
</MACRO>
<MACRO>
<NAME>V4L2_CID_AUTO_EXPOSURE_BIAS</NAME>
#define V4L2_CID_AUTO_EXPOSURE_BIAS		(V4L2_CID_CAMERA_CLASS_BASE+19)
</MACRO>
<MACRO>
<NAME>V4L2_CID_AUTO_N_PRESET_WHITE_BALANCE</NAME>
#define V4L2_CID_AUTO_N_PRESET_WHITE_BALANCE	(V4L2_CID_CAMERA_CLASS_BASE+20)
</MACRO>
<ENUM>
<NAME>v4l2_auto_n_preset_white_balance</NAME>
enum v4l2_auto_n_preset_white_balance {
	V4L2_WHITE_BALANCE_MANUAL		= 0,
	V4L2_WHITE_BALANCE_AUTO			= 1,
	V4L2_WHITE_BALANCE_INCANDESCENT		= 2,
	V4L2_WHITE_BALANCE_FLUORESCENT		= 3,
	V4L2_WHITE_BALANCE_FLUORESCENT_H	= 4,
	V4L2_WHITE_BALANCE_HORIZON		= 5,
	V4L2_WHITE_BALANCE_DAYLIGHT		= 6,
	V4L2_WHITE_BALANCE_FLASH		= 7,
	V4L2_WHITE_BALANCE_CLOUDY		= 8,
	V4L2_WHITE_BALANCE_SHADE		= 9,
};
</ENUM>
<MACRO>
<NAME>V4L2_CID_WIDE_DYNAMIC_RANGE</NAME>
#define V4L2_CID_WIDE_DYNAMIC_RANGE		(V4L2_CID_CAMERA_CLASS_BASE+21)
</MACRO>
<MACRO>
<NAME>V4L2_CID_IMAGE_STABILIZATION</NAME>
#define V4L2_CID_IMAGE_STABILIZATION		(V4L2_CID_CAMERA_CLASS_BASE+22)
</MACRO>
<MACRO>
<NAME>V4L2_CID_ISO_SENSITIVITY</NAME>
#define V4L2_CID_ISO_SENSITIVITY		(V4L2_CID_CAMERA_CLASS_BASE+23)
</MACRO>
<MACRO>
<NAME>V4L2_CID_ISO_SENSITIVITY_AUTO</NAME>
#define V4L2_CID_ISO_SENSITIVITY_AUTO		(V4L2_CID_CAMERA_CLASS_BASE+24)
</MACRO>
<ENUM>
<NAME>v4l2_iso_sensitivity_auto_type</NAME>
enum v4l2_iso_sensitivity_auto_type {
	V4L2_ISO_SENSITIVITY_MANUAL		= 0,
	V4L2_ISO_SENSITIVITY_AUTO		= 1,
};
</ENUM>
<MACRO>
<NAME>V4L2_CID_EXPOSURE_METERING</NAME>
#define V4L2_CID_EXPOSURE_METERING		(V4L2_CID_CAMERA_CLASS_BASE+25)
</MACRO>
<ENUM>
<NAME>v4l2_exposure_metering</NAME>
enum v4l2_exposure_metering {
	V4L2_EXPOSURE_METERING_AVERAGE		= 0,
	V4L2_EXPOSURE_METERING_CENTER_WEIGHTED	= 1,
	V4L2_EXPOSURE_METERING_SPOT		= 2,
	V4L2_EXPOSURE_METERING_MATRIX		= 3,
};
</ENUM>
<MACRO>
<NAME>V4L2_CID_SCENE_MODE</NAME>
#define V4L2_CID_SCENE_MODE			(V4L2_CID_CAMERA_CLASS_BASE+26)
</MACRO>
<ENUM>
<NAME>v4l2_scene_mode</NAME>
enum v4l2_scene_mode {
	V4L2_SCENE_MODE_NONE			= 0,
	V4L2_SCENE_MODE_BACKLIGHT		= 1,
	V4L2_SCENE_MODE_BEACH_SNOW		= 2,
	V4L2_SCENE_MODE_CANDLE_LIGHT		= 3,
	V4L2_SCENE_MODE_DAWN_DUSK		= 4,
	V4L2_SCENE_MODE_FALL_COLORS		= 5,
	V4L2_SCENE_MODE_FIREWORKS		= 6,
	V4L2_SCENE_MODE_LANDSCAPE		= 7,
	V4L2_SCENE_MODE_NIGHT			= 8,
	V4L2_SCENE_MODE_PARTY_INDOOR		= 9,
	V4L2_SCENE_MODE_PORTRAIT		= 10,
	V4L2_SCENE_MODE_SPORTS			= 11,
	V4L2_SCENE_MODE_SUNSET			= 12,
	V4L2_SCENE_MODE_TEXT			= 13,
};
</ENUM>
<MACRO>
<NAME>V4L2_CID_3A_LOCK</NAME>
#define V4L2_CID_3A_LOCK			(V4L2_CID_CAMERA_CLASS_BASE+27)
</MACRO>
<MACRO>
<NAME>V4L2_LOCK_EXPOSURE</NAME>
#define V4L2_LOCK_EXPOSURE			(1 << 0)
</MACRO>
<MACRO>
<NAME>V4L2_LOCK_WHITE_BALANCE</NAME>
#define V4L2_LOCK_WHITE_BALANCE			(1 << 1)
</MACRO>
<MACRO>
<NAME>V4L2_LOCK_FOCUS</NAME>
#define V4L2_LOCK_FOCUS				(1 << 2)
</MACRO>
<MACRO>
<NAME>V4L2_CID_AUTO_FOCUS_START</NAME>
#define V4L2_CID_AUTO_FOCUS_START		(V4L2_CID_CAMERA_CLASS_BASE+28)
</MACRO>
<MACRO>
<NAME>V4L2_CID_AUTO_FOCUS_STOP</NAME>
#define V4L2_CID_AUTO_FOCUS_STOP		(V4L2_CID_CAMERA_CLASS_BASE+29)
</MACRO>
<MACRO>
<NAME>V4L2_CID_AUTO_FOCUS_STATUS</NAME>
#define V4L2_CID_AUTO_FOCUS_STATUS		(V4L2_CID_CAMERA_CLASS_BASE+30)
</MACRO>
<MACRO>
<NAME>V4L2_AUTO_FOCUS_STATUS_IDLE</NAME>
#define V4L2_AUTO_FOCUS_STATUS_IDLE		(0 << 0)
</MACRO>
<MACRO>
<NAME>V4L2_AUTO_FOCUS_STATUS_BUSY</NAME>
#define V4L2_AUTO_FOCUS_STATUS_BUSY		(1 << 0)
</MACRO>
<MACRO>
<NAME>V4L2_AUTO_FOCUS_STATUS_REACHED</NAME>
#define V4L2_AUTO_FOCUS_STATUS_REACHED		(1 << 1)
</MACRO>
<MACRO>
<NAME>V4L2_AUTO_FOCUS_STATUS_FAILED</NAME>
#define V4L2_AUTO_FOCUS_STATUS_FAILED		(1 << 2)
</MACRO>
<MACRO>
<NAME>V4L2_CID_AUTO_FOCUS_RANGE</NAME>
#define V4L2_CID_AUTO_FOCUS_RANGE		(V4L2_CID_CAMERA_CLASS_BASE+31)
</MACRO>
<ENUM>
<NAME>v4l2_auto_focus_range</NAME>
enum v4l2_auto_focus_range {
	V4L2_AUTO_FOCUS_RANGE_AUTO		= 0,
	V4L2_AUTO_FOCUS_RANGE_NORMAL		= 1,
	V4L2_AUTO_FOCUS_RANGE_MACRO		= 2,
	V4L2_AUTO_FOCUS_RANGE_INFINITY		= 3,
};
</ENUM>
<MACRO>
<NAME>V4L2_CID_PAN_SPEED</NAME>
#define V4L2_CID_PAN_SPEED			(V4L2_CID_CAMERA_CLASS_BASE+32)
</MACRO>
<MACRO>
<NAME>V4L2_CID_TILT_SPEED</NAME>
#define V4L2_CID_TILT_SPEED			(V4L2_CID_CAMERA_CLASS_BASE+33)
</MACRO>
<MACRO>
<NAME>V4L2_CID_FM_TX_CLASS_BASE</NAME>
#define V4L2_CID_FM_TX_CLASS_BASE		(V4L2_CTRL_CLASS_FM_TX | 0x900)
</MACRO>
<MACRO>
<NAME>V4L2_CID_FM_TX_CLASS</NAME>
#define V4L2_CID_FM_TX_CLASS			(V4L2_CTRL_CLASS_FM_TX | 1)
</MACRO>
<MACRO>
<NAME>V4L2_CID_RDS_TX_DEVIATION</NAME>
#define V4L2_CID_RDS_TX_DEVIATION		(V4L2_CID_FM_TX_CLASS_BASE + 1)
</MACRO>
<MACRO>
<NAME>V4L2_CID_RDS_TX_PI</NAME>
#define V4L2_CID_RDS_TX_PI			(V4L2_CID_FM_TX_CLASS_BASE + 2)
</MACRO>
<MACRO>
<NAME>V4L2_CID_RDS_TX_PTY</NAME>
#define V4L2_CID_RDS_TX_PTY			(V4L2_CID_FM_TX_CLASS_BASE + 3)
</MACRO>
<MACRO>
<NAME>V4L2_CID_RDS_TX_PS_NAME</NAME>
#define V4L2_CID_RDS_TX_PS_NAME			(V4L2_CID_FM_TX_CLASS_BASE + 5)
</MACRO>
<MACRO>
<NAME>V4L2_CID_RDS_TX_RADIO_TEXT</NAME>
#define V4L2_CID_RDS_TX_RADIO_TEXT		(V4L2_CID_FM_TX_CLASS_BASE + 6)
</MACRO>
<MACRO>
<NAME>V4L2_CID_RDS_TX_MONO_STEREO</NAME>
#define V4L2_CID_RDS_TX_MONO_STEREO		(V4L2_CID_FM_TX_CLASS_BASE + 7)
</MACRO>
<MACRO>
<NAME>V4L2_CID_RDS_TX_ARTIFICIAL_HEAD</NAME>
#define V4L2_CID_RDS_TX_ARTIFICIAL_HEAD		(V4L2_CID_FM_TX_CLASS_BASE + 8)
</MACRO>
<MACRO>
<NAME>V4L2_CID_RDS_TX_COMPRESSED</NAME>
#define V4L2_CID_RDS_TX_COMPRESSED		(V4L2_CID_FM_TX_CLASS_BASE + 9)
</MACRO>
<MACRO>
<NAME>V4L2_CID_RDS_TX_DYNAMIC_PTY</NAME>
#define V4L2_CID_RDS_TX_DYNAMIC_PTY		(V4L2_CID_FM_TX_CLASS_BASE + 10)
</MACRO>
<MACRO>
<NAME>V4L2_CID_RDS_TX_TRAFFIC_ANNOUNCEMENT</NAME>
#define V4L2_CID_RDS_TX_TRAFFIC_ANNOUNCEMENT	(V4L2_CID_FM_TX_CLASS_BASE + 11)
</MACRO>
<MACRO>
<NAME>V4L2_CID_RDS_TX_TRAFFIC_PROGRAM</NAME>
#define V4L2_CID_RDS_TX_TRAFFIC_PROGRAM		(V4L2_CID_FM_TX_CLASS_BASE + 12)
</MACRO>
<MACRO>
<NAME>V4L2_CID_RDS_TX_MUSIC_SPEECH</NAME>
#define V4L2_CID_RDS_TX_MUSIC_SPEECH		(V4L2_CID_FM_TX_CLASS_BASE + 13)
</MACRO>
<MACRO>
<NAME>V4L2_CID_RDS_TX_ALT_FREQS_ENABLE</NAME>
#define V4L2_CID_RDS_TX_ALT_FREQS_ENABLE	(V4L2_CID_FM_TX_CLASS_BASE + 14)
</MACRO>
<MACRO>
<NAME>V4L2_CID_RDS_TX_ALT_FREQS</NAME>
#define V4L2_CID_RDS_TX_ALT_FREQS		(V4L2_CID_FM_TX_CLASS_BASE + 15)
</MACRO>
<MACRO>
<NAME>V4L2_CID_AUDIO_LIMITER_ENABLED</NAME>
#define V4L2_CID_AUDIO_LIMITER_ENABLED		(V4L2_CID_FM_TX_CLASS_BASE + 64)
</MACRO>
<MACRO>
<NAME>V4L2_CID_AUDIO_LIMITER_RELEASE_TIME</NAME>
#define V4L2_CID_AUDIO_LIMITER_RELEASE_TIME	(V4L2_CID_FM_TX_CLASS_BASE + 65)
</MACRO>
<MACRO>
<NAME>V4L2_CID_AUDIO_LIMITER_DEVIATION</NAME>
#define V4L2_CID_AUDIO_LIMITER_DEVIATION	(V4L2_CID_FM_TX_CLASS_BASE + 66)
</MACRO>
<MACRO>
<NAME>V4L2_CID_AUDIO_COMPRESSION_ENABLED</NAME>
#define V4L2_CID_AUDIO_COMPRESSION_ENABLED	(V4L2_CID_FM_TX_CLASS_BASE + 80)
</MACRO>
<MACRO>
<NAME>V4L2_CID_AUDIO_COMPRESSION_GAIN</NAME>
#define V4L2_CID_AUDIO_COMPRESSION_GAIN		(V4L2_CID_FM_TX_CLASS_BASE + 81)
</MACRO>
<MACRO>
<NAME>V4L2_CID_AUDIO_COMPRESSION_THRESHOLD</NAME>
#define V4L2_CID_AUDIO_COMPRESSION_THRESHOLD	(V4L2_CID_FM_TX_CLASS_BASE + 82)
</MACRO>
<MACRO>
<NAME>V4L2_CID_AUDIO_COMPRESSION_ATTACK_TIME</NAME>
#define V4L2_CID_AUDIO_COMPRESSION_ATTACK_TIME	(V4L2_CID_FM_TX_CLASS_BASE + 83)
</MACRO>
<MACRO>
<NAME>V4L2_CID_AUDIO_COMPRESSION_RELEASE_TIME</NAME>
#define V4L2_CID_AUDIO_COMPRESSION_RELEASE_TIME	(V4L2_CID_FM_TX_CLASS_BASE + 84)
</MACRO>
<MACRO>
<NAME>V4L2_CID_PILOT_TONE_ENABLED</NAME>
#define V4L2_CID_PILOT_TONE_ENABLED		(V4L2_CID_FM_TX_CLASS_BASE + 96)
</MACRO>
<MACRO>
<NAME>V4L2_CID_PILOT_TONE_DEVIATION</NAME>
#define V4L2_CID_PILOT_TONE_DEVIATION		(V4L2_CID_FM_TX_CLASS_BASE + 97)
</MACRO>
<MACRO>
<NAME>V4L2_CID_PILOT_TONE_FREQUENCY</NAME>
#define V4L2_CID_PILOT_TONE_FREQUENCY		(V4L2_CID_FM_TX_CLASS_BASE + 98)
</MACRO>
<MACRO>
<NAME>V4L2_CID_TUNE_PREEMPHASIS</NAME>
#define V4L2_CID_TUNE_PREEMPHASIS		(V4L2_CID_FM_TX_CLASS_BASE + 112)
</MACRO>
<ENUM>
<NAME>v4l2_preemphasis</NAME>
enum v4l2_preemphasis {
	V4L2_PREEMPHASIS_DISABLED	= 0,
	V4L2_PREEMPHASIS_50_uS		= 1,
	V4L2_PREEMPHASIS_75_uS		= 2,
};
</ENUM>
<MACRO>
<NAME>V4L2_CID_TUNE_POWER_LEVEL</NAME>
#define V4L2_CID_TUNE_POWER_LEVEL		(V4L2_CID_FM_TX_CLASS_BASE + 113)
</MACRO>
<MACRO>
<NAME>V4L2_CID_TUNE_ANTENNA_CAPACITOR</NAME>
#define V4L2_CID_TUNE_ANTENNA_CAPACITOR		(V4L2_CID_FM_TX_CLASS_BASE + 114)
</MACRO>
<MACRO>
<NAME>V4L2_CID_FLASH_CLASS_BASE</NAME>
#define V4L2_CID_FLASH_CLASS_BASE		(V4L2_CTRL_CLASS_FLASH | 0x900)
</MACRO>
<MACRO>
<NAME>V4L2_CID_FLASH_CLASS</NAME>
#define V4L2_CID_FLASH_CLASS			(V4L2_CTRL_CLASS_FLASH | 1)
</MACRO>
<MACRO>
<NAME>V4L2_CID_FLASH_LED_MODE</NAME>
#define V4L2_CID_FLASH_LED_MODE			(V4L2_CID_FLASH_CLASS_BASE + 1)
</MACRO>
<ENUM>
<NAME>v4l2_flash_led_mode</NAME>
enum v4l2_flash_led_mode {
	V4L2_FLASH_LED_MODE_NONE,
	V4L2_FLASH_LED_MODE_FLASH,
	V4L2_FLASH_LED_MODE_TORCH,
};
</ENUM>
<MACRO>
<NAME>V4L2_CID_FLASH_STROBE_SOURCE</NAME>
#define V4L2_CID_FLASH_STROBE_SOURCE		(V4L2_CID_FLASH_CLASS_BASE + 2)
</MACRO>
<ENUM>
<NAME>v4l2_flash_strobe_source</NAME>
enum v4l2_flash_strobe_source {
	V4L2_FLASH_STROBE_SOURCE_SOFTWARE,
	V4L2_FLASH_STROBE_SOURCE_EXTERNAL,
};
</ENUM>
<MACRO>
<NAME>V4L2_CID_FLASH_STROBE</NAME>
#define V4L2_CID_FLASH_STROBE			(V4L2_CID_FLASH_CLASS_BASE + 3)
</MACRO>
<MACRO>
<NAME>V4L2_CID_FLASH_STROBE_STOP</NAME>
#define V4L2_CID_FLASH_STROBE_STOP		(V4L2_CID_FLASH_CLASS_BASE + 4)
</MACRO>
<MACRO>
<NAME>V4L2_CID_FLASH_STROBE_STATUS</NAME>
#define V4L2_CID_FLASH_STROBE_STATUS		(V4L2_CID_FLASH_CLASS_BASE + 5)
</MACRO>
<MACRO>
<NAME>V4L2_CID_FLASH_TIMEOUT</NAME>
#define V4L2_CID_FLASH_TIMEOUT			(V4L2_CID_FLASH_CLASS_BASE + 6)
</MACRO>
<MACRO>
<NAME>V4L2_CID_FLASH_INTENSITY</NAME>
#define V4L2_CID_FLASH_INTENSITY		(V4L2_CID_FLASH_CLASS_BASE + 7)
</MACRO>
<MACRO>
<NAME>V4L2_CID_FLASH_TORCH_INTENSITY</NAME>
#define V4L2_CID_FLASH_TORCH_INTENSITY		(V4L2_CID_FLASH_CLASS_BASE + 8)
</MACRO>
<MACRO>
<NAME>V4L2_CID_FLASH_INDICATOR_INTENSITY</NAME>
#define V4L2_CID_FLASH_INDICATOR_INTENSITY	(V4L2_CID_FLASH_CLASS_BASE + 9)
</MACRO>
<MACRO>
<NAME>V4L2_CID_FLASH_FAULT</NAME>
#define V4L2_CID_FLASH_FAULT			(V4L2_CID_FLASH_CLASS_BASE + 10)
</MACRO>
<MACRO>
<NAME>V4L2_FLASH_FAULT_OVER_VOLTAGE</NAME>
#define V4L2_FLASH_FAULT_OVER_VOLTAGE		(1 << 0)
</MACRO>
<MACRO>
<NAME>V4L2_FLASH_FAULT_TIMEOUT</NAME>
#define V4L2_FLASH_FAULT_TIMEOUT		(1 << 1)
</MACRO>
<MACRO>
<NAME>V4L2_FLASH_FAULT_OVER_TEMPERATURE</NAME>
#define V4L2_FLASH_FAULT_OVER_TEMPERATURE	(1 << 2)
</MACRO>
<MACRO>
<NAME>V4L2_FLASH_FAULT_SHORT_CIRCUIT</NAME>
#define V4L2_FLASH_FAULT_SHORT_CIRCUIT		(1 << 3)
</MACRO>
<MACRO>
<NAME>V4L2_FLASH_FAULT_OVER_CURRENT</NAME>
#define V4L2_FLASH_FAULT_OVER_CURRENT		(1 << 4)
</MACRO>
<MACRO>
<NAME>V4L2_FLASH_FAULT_INDICATOR</NAME>
#define V4L2_FLASH_FAULT_INDICATOR		(1 << 5)
</MACRO>
<MACRO>
<NAME>V4L2_FLASH_FAULT_UNDER_VOLTAGE</NAME>
#define V4L2_FLASH_FAULT_UNDER_VOLTAGE		(1 << 6)
</MACRO>
<MACRO>
<NAME>V4L2_FLASH_FAULT_INPUT_VOLTAGE</NAME>
#define V4L2_FLASH_FAULT_INPUT_VOLTAGE		(1 << 7)
</MACRO>
<MACRO>
<NAME>V4L2_FLASH_FAULT_LED_OVER_TEMPERATURE</NAME>
#define V4L2_FLASH_FAULT_LED_OVER_TEMPERATURE	(1 << 8)
</MACRO>
<MACRO>
<NAME>V4L2_CID_FLASH_CHARGE</NAME>
#define V4L2_CID_FLASH_CHARGE			(V4L2_CID_FLASH_CLASS_BASE + 11)
</MACRO>
<MACRO>
<NAME>V4L2_CID_FLASH_READY</NAME>
#define V4L2_CID_FLASH_READY			(V4L2_CID_FLASH_CLASS_BASE + 12)
</MACRO>
<MACRO>
<NAME>V4L2_CID_JPEG_CLASS_BASE</NAME>
#define V4L2_CID_JPEG_CLASS_BASE		(V4L2_CTRL_CLASS_JPEG | 0x900)
</MACRO>
<MACRO>
<NAME>V4L2_CID_JPEG_CLASS</NAME>
#define V4L2_CID_JPEG_CLASS			(V4L2_CTRL_CLASS_JPEG | 1)
</MACRO>
<MACRO>
<NAME>V4L2_CID_JPEG_CHROMA_SUBSAMPLING</NAME>
#define	V4L2_CID_JPEG_CHROMA_SUBSAMPLING	(V4L2_CID_JPEG_CLASS_BASE + 1)
</MACRO>
<ENUM>
<NAME>v4l2_jpeg_chroma_subsampling</NAME>
enum v4l2_jpeg_chroma_subsampling {
	V4L2_JPEG_CHROMA_SUBSAMPLING_444	= 0,
	V4L2_JPEG_CHROMA_SUBSAMPLING_422	= 1,
	V4L2_JPEG_CHROMA_SUBSAMPLING_420	= 2,
	V4L2_JPEG_CHROMA_SUBSAMPLING_411	= 3,
	V4L2_JPEG_CHROMA_SUBSAMPLING_410	= 4,
	V4L2_JPEG_CHROMA_SUBSAMPLING_GRAY	= 5,
};
</ENUM>
<MACRO>
<NAME>V4L2_CID_JPEG_RESTART_INTERVAL</NAME>
#define	V4L2_CID_JPEG_RESTART_INTERVAL		(V4L2_CID_JPEG_CLASS_BASE + 2)
</MACRO>
<MACRO>
<NAME>V4L2_CID_JPEG_COMPRESSION_QUALITY</NAME>
#define	V4L2_CID_JPEG_COMPRESSION_QUALITY	(V4L2_CID_JPEG_CLASS_BASE + 3)
</MACRO>
<MACRO>
<NAME>V4L2_CID_JPEG_ACTIVE_MARKER</NAME>
#define	V4L2_CID_JPEG_ACTIVE_MARKER		(V4L2_CID_JPEG_CLASS_BASE + 4)
</MACRO>
<MACRO>
<NAME>V4L2_JPEG_ACTIVE_MARKER_APP0</NAME>
#define	V4L2_JPEG_ACTIVE_MARKER_APP0		(1 << 0)
</MACRO>
<MACRO>
<NAME>V4L2_JPEG_ACTIVE_MARKER_APP1</NAME>
#define	V4L2_JPEG_ACTIVE_MARKER_APP1		(1 << 1)
</MACRO>
<MACRO>
<NAME>V4L2_JPEG_ACTIVE_MARKER_COM</NAME>
#define	V4L2_JPEG_ACTIVE_MARKER_COM		(1 << 16)
</MACRO>
<MACRO>
<NAME>V4L2_JPEG_ACTIVE_MARKER_DQT</NAME>
#define	V4L2_JPEG_ACTIVE_MARKER_DQT		(1 << 17)
</MACRO>
<MACRO>
<NAME>V4L2_JPEG_ACTIVE_MARKER_DHT</NAME>
#define	V4L2_JPEG_ACTIVE_MARKER_DHT		(1 << 18)
</MACRO>
<MACRO>
<NAME>V4L2_CID_IMAGE_SOURCE_CLASS_BASE</NAME>
#define V4L2_CID_IMAGE_SOURCE_CLASS_BASE	(V4L2_CTRL_CLASS_IMAGE_SOURCE | 0x900)
</MACRO>
<MACRO>
<NAME>V4L2_CID_IMAGE_SOURCE_CLASS</NAME>
#define V4L2_CID_IMAGE_SOURCE_CLASS		(V4L2_CTRL_CLASS_IMAGE_SOURCE | 1)
</MACRO>
<MACRO>
<NAME>V4L2_CID_VBLANK</NAME>
#define V4L2_CID_VBLANK				(V4L2_CID_IMAGE_SOURCE_CLASS_BASE + 1)
</MACRO>
<MACRO>
<NAME>V4L2_CID_HBLANK</NAME>
#define V4L2_CID_HBLANK				(V4L2_CID_IMAGE_SOURCE_CLASS_BASE + 2)
</MACRO>
<MACRO>
<NAME>V4L2_CID_ANALOGUE_GAIN</NAME>
#define V4L2_CID_ANALOGUE_GAIN			(V4L2_CID_IMAGE_SOURCE_CLASS_BASE + 3)
</MACRO>
<MACRO>
<NAME>V4L2_CID_TEST_PATTERN_RED</NAME>
#define V4L2_CID_TEST_PATTERN_RED		(V4L2_CID_IMAGE_SOURCE_CLASS_BASE + 4)
</MACRO>
<MACRO>
<NAME>V4L2_CID_TEST_PATTERN_GREENR</NAME>
#define V4L2_CID_TEST_PATTERN_GREENR		(V4L2_CID_IMAGE_SOURCE_CLASS_BASE + 5)
</MACRO>
<MACRO>
<NAME>V4L2_CID_TEST_PATTERN_BLUE</NAME>
#define V4L2_CID_TEST_PATTERN_BLUE		(V4L2_CID_IMAGE_SOURCE_CLASS_BASE + 6)
</MACRO>
<MACRO>
<NAME>V4L2_CID_TEST_PATTERN_GREENB</NAME>
#define V4L2_CID_TEST_PATTERN_GREENB		(V4L2_CID_IMAGE_SOURCE_CLASS_BASE + 7)
</MACRO>
<MACRO>
<NAME>V4L2_CID_IMAGE_PROC_CLASS_BASE</NAME>
#define V4L2_CID_IMAGE_PROC_CLASS_BASE		(V4L2_CTRL_CLASS_IMAGE_PROC | 0x900)
</MACRO>
<MACRO>
<NAME>V4L2_CID_IMAGE_PROC_CLASS</NAME>
#define V4L2_CID_IMAGE_PROC_CLASS		(V4L2_CTRL_CLASS_IMAGE_PROC | 1)
</MACRO>
<MACRO>
<NAME>V4L2_CID_LINK_FREQ</NAME>
#define V4L2_CID_LINK_FREQ			(V4L2_CID_IMAGE_PROC_CLASS_BASE + 1)
</MACRO>
<MACRO>
<NAME>V4L2_CID_PIXEL_RATE</NAME>
#define V4L2_CID_PIXEL_RATE			(V4L2_CID_IMAGE_PROC_CLASS_BASE + 2)
</MACRO>
<MACRO>
<NAME>V4L2_CID_TEST_PATTERN</NAME>
#define V4L2_CID_TEST_PATTERN			(V4L2_CID_IMAGE_PROC_CLASS_BASE + 3)
</MACRO>
<MACRO>
<NAME>V4L2_CID_DV_CLASS_BASE</NAME>
#define V4L2_CID_DV_CLASS_BASE			(V4L2_CTRL_CLASS_DV | 0x900)
</MACRO>
<MACRO>
<NAME>V4L2_CID_DV_CLASS</NAME>
#define V4L2_CID_DV_CLASS			(V4L2_CTRL_CLASS_DV | 1)
</MACRO>
<MACRO>
<NAME>V4L2_CID_DV_TX_HOTPLUG</NAME>
#define	V4L2_CID_DV_TX_HOTPLUG			(V4L2_CID_DV_CLASS_BASE + 1)
</MACRO>
<MACRO>
<NAME>V4L2_CID_DV_TX_RXSENSE</NAME>
#define	V4L2_CID_DV_TX_RXSENSE			(V4L2_CID_DV_CLASS_BASE + 2)
</MACRO>
<MACRO>
<NAME>V4L2_CID_DV_TX_EDID_PRESENT</NAME>
#define	V4L2_CID_DV_TX_EDID_PRESENT		(V4L2_CID_DV_CLASS_BASE + 3)
</MACRO>
<MACRO>
<NAME>V4L2_CID_DV_TX_MODE</NAME>
#define	V4L2_CID_DV_TX_MODE			(V4L2_CID_DV_CLASS_BASE + 4)
</MACRO>
<ENUM>
<NAME>v4l2_dv_tx_mode</NAME>
enum v4l2_dv_tx_mode {
	V4L2_DV_TX_MODE_DVI_D	= 0,
	V4L2_DV_TX_MODE_HDMI	= 1,
};
</ENUM>
<MACRO>
<NAME>V4L2_CID_DV_TX_RGB_RANGE</NAME>
#define V4L2_CID_DV_TX_RGB_RANGE		(V4L2_CID_DV_CLASS_BASE + 5)
</MACRO>
<ENUM>
<NAME>v4l2_dv_rgb_range</NAME>
enum v4l2_dv_rgb_range {
	V4L2_DV_RGB_RANGE_AUTO	  = 0,
	V4L2_DV_RGB_RANGE_LIMITED = 1,
	V4L2_DV_RGB_RANGE_FULL	  = 2,
};
</ENUM>
<MACRO>
<NAME>V4L2_CID_DV_RX_POWER_PRESENT</NAME>
#define	V4L2_CID_DV_RX_POWER_PRESENT		(V4L2_CID_DV_CLASS_BASE + 100)
</MACRO>
<MACRO>
<NAME>V4L2_CID_DV_RX_RGB_RANGE</NAME>
#define V4L2_CID_DV_RX_RGB_RANGE		(V4L2_CID_DV_CLASS_BASE + 101)
</MACRO>
<MACRO>
<NAME>V4L2_CID_FM_RX_CLASS_BASE</NAME>
#define V4L2_CID_FM_RX_CLASS_BASE		(V4L2_CTRL_CLASS_FM_RX | 0x900)
</MACRO>
<MACRO>
<NAME>V4L2_CID_FM_RX_CLASS</NAME>
#define V4L2_CID_FM_RX_CLASS			(V4L2_CTRL_CLASS_FM_RX | 1)
</MACRO>
<MACRO>
<NAME>V4L2_CID_TUNE_DEEMPHASIS</NAME>
#define V4L2_CID_TUNE_DEEMPHASIS		(V4L2_CID_FM_RX_CLASS_BASE + 1)
</MACRO>
<ENUM>
<NAME>v4l2_deemphasis</NAME>
enum v4l2_deemphasis {
	V4L2_DEEMPHASIS_DISABLED	= V4L2_PREEMPHASIS_DISABLED,
	V4L2_DEEMPHASIS_50_uS		= V4L2_PREEMPHASIS_50_uS,
	V4L2_DEEMPHASIS_75_uS		= V4L2_PREEMPHASIS_75_uS,
};
</ENUM>
<MACRO>
<NAME>V4L2_CID_RDS_RECEPTION</NAME>
#define V4L2_CID_RDS_RECEPTION			(V4L2_CID_FM_RX_CLASS_BASE + 2)
</MACRO>
<MACRO>
<NAME>V4L2_CID_RDS_RX_PTY</NAME>
#define V4L2_CID_RDS_RX_PTY			(V4L2_CID_FM_RX_CLASS_BASE + 3)
</MACRO>
<MACRO>
<NAME>V4L2_CID_RDS_RX_PS_NAME</NAME>
#define V4L2_CID_RDS_RX_PS_NAME			(V4L2_CID_FM_RX_CLASS_BASE + 4)
</MACRO>
<MACRO>
<NAME>V4L2_CID_RDS_RX_RADIO_TEXT</NAME>
#define V4L2_CID_RDS_RX_RADIO_TEXT		(V4L2_CID_FM_RX_CLASS_BASE + 5)
</MACRO>
<MACRO>
<NAME>V4L2_CID_RDS_RX_TRAFFIC_ANNOUNCEMENT</NAME>
#define V4L2_CID_RDS_RX_TRAFFIC_ANNOUNCEMENT	(V4L2_CID_FM_RX_CLASS_BASE + 6)
</MACRO>
<MACRO>
<NAME>V4L2_CID_RDS_RX_TRAFFIC_PROGRAM</NAME>
#define V4L2_CID_RDS_RX_TRAFFIC_PROGRAM		(V4L2_CID_FM_RX_CLASS_BASE + 7)
</MACRO>
<MACRO>
<NAME>V4L2_CID_RDS_RX_MUSIC_SPEECH</NAME>
#define V4L2_CID_RDS_RX_MUSIC_SPEECH		(V4L2_CID_FM_RX_CLASS_BASE + 8)
</MACRO>
<MACRO>
<NAME>V4L2_CID_RF_TUNER_CLASS_BASE</NAME>
#define V4L2_CID_RF_TUNER_CLASS_BASE		(V4L2_CTRL_CLASS_RF_TUNER | 0x900)
</MACRO>
<MACRO>
<NAME>V4L2_CID_RF_TUNER_CLASS</NAME>
#define V4L2_CID_RF_TUNER_CLASS			(V4L2_CTRL_CLASS_RF_TUNER | 1)
</MACRO>
<MACRO>
<NAME>V4L2_CID_RF_TUNER_BANDWIDTH_AUTO</NAME>
#define V4L2_CID_RF_TUNER_BANDWIDTH_AUTO	(V4L2_CID_RF_TUNER_CLASS_BASE + 11)
</MACRO>
<MACRO>
<NAME>V4L2_CID_RF_TUNER_BANDWIDTH</NAME>
#define V4L2_CID_RF_TUNER_BANDWIDTH		(V4L2_CID_RF_TUNER_CLASS_BASE + 12)
</MACRO>
<MACRO>
<NAME>V4L2_CID_RF_TUNER_LNA_GAIN_AUTO</NAME>
#define V4L2_CID_RF_TUNER_LNA_GAIN_AUTO		(V4L2_CID_RF_TUNER_CLASS_BASE + 41)
</MACRO>
<MACRO>
<NAME>V4L2_CID_RF_TUNER_LNA_GAIN</NAME>
#define V4L2_CID_RF_TUNER_LNA_GAIN		(V4L2_CID_RF_TUNER_CLASS_BASE + 42)
</MACRO>
<MACRO>
<NAME>V4L2_CID_RF_TUNER_MIXER_GAIN_AUTO</NAME>
#define V4L2_CID_RF_TUNER_MIXER_GAIN_AUTO	(V4L2_CID_RF_TUNER_CLASS_BASE + 51)
</MACRO>
<MACRO>
<NAME>V4L2_CID_RF_TUNER_MIXER_GAIN</NAME>
#define V4L2_CID_RF_TUNER_MIXER_GAIN		(V4L2_CID_RF_TUNER_CLASS_BASE + 52)
</MACRO>
<MACRO>
<NAME>V4L2_CID_RF_TUNER_IF_GAIN_AUTO</NAME>
#define V4L2_CID_RF_TUNER_IF_GAIN_AUTO		(V4L2_CID_RF_TUNER_CLASS_BASE + 61)
</MACRO>
<MACRO>
<NAME>V4L2_CID_RF_TUNER_IF_GAIN</NAME>
#define V4L2_CID_RF_TUNER_IF_GAIN		(V4L2_CID_RF_TUNER_CLASS_BASE + 62)
</MACRO>
<MACRO>
<NAME>V4L2_CID_RF_TUNER_PLL_LOCK</NAME>
#define V4L2_CID_RF_TUNER_PLL_LOCK			(V4L2_CID_RF_TUNER_CLASS_BASE + 91)
</MACRO>
<MACRO>
<NAME>V4L2_CID_DETECT_CLASS_BASE</NAME>
#define V4L2_CID_DETECT_CLASS_BASE		(V4L2_CTRL_CLASS_DETECT | 0x900)
</MACRO>
<MACRO>
<NAME>V4L2_CID_DETECT_CLASS</NAME>
#define V4L2_CID_DETECT_CLASS			(V4L2_CTRL_CLASS_DETECT | 1)
</MACRO>
<MACRO>
<NAME>V4L2_CID_DETECT_MD_MODE</NAME>
#define V4L2_CID_DETECT_MD_MODE			(V4L2_CID_DETECT_CLASS_BASE + 1)
</MACRO>
<ENUM>
<NAME>v4l2_detect_md_mode</NAME>
enum v4l2_detect_md_mode {
	V4L2_DETECT_MD_MODE_DISABLED		= 0,
	V4L2_DETECT_MD_MODE_GLOBAL		= 1,
	V4L2_DETECT_MD_MODE_THRESHOLD_GRID	= 2,
	V4L2_DETECT_MD_MODE_REGION_GRID		= 3,
};
</ENUM>
<MACRO>
<NAME>V4L2_CID_DETECT_MD_GLOBAL_THRESHOLD</NAME>
#define V4L2_CID_DETECT_MD_GLOBAL_THRESHOLD	(V4L2_CID_DETECT_CLASS_BASE + 2)
</MACRO>
<MACRO>
<NAME>V4L2_CID_DETECT_MD_THRESHOLD_GRID</NAME>
#define V4L2_CID_DETECT_MD_THRESHOLD_GRID	(V4L2_CID_DETECT_CLASS_BASE + 3)
</MACRO>
<MACRO>
<NAME>V4L2_CID_DETECT_MD_REGION_GRID</NAME>
#define V4L2_CID_DETECT_MD_REGION_GRID		(V4L2_CID_DETECT_CLASS_BASE + 4)
</MACRO>
<MACRO>
<NAME>GST_TYPE_OSSDMABUFFER</NAME>
#define GST_TYPE_OSSDMABUFFER            (gst_ossdmabuffer_get_type())
</MACRO>
<MACRO>
<NAME>GST_OSSDMABUFFER</NAME>
#define GST_OSSDMABUFFER(obj)            (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_OSSDMABUFFER,GstOssDMABuffer))
</MACRO>
<MACRO>
<NAME>GST_OSSDMABUFFER_CLASS</NAME>
#define GST_OSSDMABUFFER_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_OSSDMABUFFER,GstOssDMABufferClass))
</MACRO>
<MACRO>
<NAME>GST_IS_OSSDMABUFFER</NAME>
#define GST_IS_OSSDMABUFFER(obj)         (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_OSSDMABUFFER))
</MACRO>
<MACRO>
<NAME>GST_IS_OSSDMABUFFER_CLASS</NAME>
#define GST_IS_OSSDMABUFFER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_OSSDMABUFFER))
</MACRO>
<MACRO>
<NAME>GST_OSSELEMENT_GET</NAME>
#define GST_OSSELEMENT_GET(obj)  GST_OSSELEMENT (obj->element)
</MACRO>
<ENUM>
<NAME>GstOssDMABufferFlags</NAME>
typedef enum {
  GST_OSSDMABUFFER_OPEN         = (1 << 0),
} GstOssDMABufferFlags;
</ENUM>
<MACRO>
<NAME>GST_OSSDMABUFFER_THREAD</NAME>
#define GST_OSSDMABUFFER_THREAD(buf)   (GST_OSSDMABUFFER(buf)->thread)
</MACRO>
<MACRO>
<NAME>GST_OSSDMABUFFER_LOCK</NAME>
#define GST_OSSDMABUFFER_LOCK          GST_OBJECT_LOCK
</MACRO>
<MACRO>
<NAME>GST_OSSDMABUFFER_UNLOCK</NAME>
#define GST_OSSDMABUFFER_UNLOCK        GST_OBJECT_UNLOCK
</MACRO>
<MACRO>
<NAME>GST_OSSDMABUFFER_COND</NAME>
#define GST_OSSDMABUFFER_COND(buf)     (GST_OSSDMABUFFER(buf)->cond)
</MACRO>
<MACRO>
<NAME>GST_OSSDMABUFFER_SIGNAL</NAME>
#define GST_OSSDMABUFFER_SIGNAL(buf)   (g_cond_signal (GST_OSSDMABUFFER_COND (buf)))
</MACRO>
<MACRO>
<NAME>GST_OSSDMABUFFER_WAIT</NAME>
#define GST_OSSDMABUFFER_WAIT(buf)     (g_cond_wait (GST_OSSDMABUFFER_COND (buf), GST_OBJECT_GET_LOCK (buf)))
</MACRO>
<STRUCT>
<NAME>GstOssDMABuffer</NAME>
struct _GstOssDMABuffer {
  GstRingBuffer  buffer;

  GstOssElement *element;

  int            fd;
  int            caps;
  int            frag;

  GThread       *thread;
  GCond         *cond;
  gboolean       running;
};
</STRUCT>
<STRUCT>
<NAME>GstOssDMABufferClass</NAME>
struct _GstOssDMABufferClass {
  GstRingBufferClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_ossdmabuffer_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_oss_helper_probe_caps</NAME>
<RETURNS>GstCaps * </RETURNS>
gint fd
</FUNCTION>
<FUNCTION>
<NAME>gst_oss_helper_get_card_name</NAME>
<RETURNS>gchar  *</RETURNS>
const gchar * mixer_name
</FUNCTION>
<MACRO>
<NAME>SET_PARAM</NAME>
#define SET_PARAM(_oss, _name, _val, _detail)   \
G_STMT_START {                                  \
  int _tmp = _val;                              \
  if (ioctl(_oss->fd, _name, &_tmp) == -1) {    \
    GST_ELEMENT_ERROR (_oss, RESOURCE, SETTINGS,\
        (NULL),					\
        ("Unable to set param " _detail ": %s", \
                   g_strerror (errno)));        \
    return FALSE;                               \
  }                                             \
  GST_DEBUG_OBJECT(_oss, _detail " %d", _tmp);  \
} G_STMT_END
</MACRO>
<MACRO>
<NAME>GET_PARAM</NAME>
#define GET_PARAM(_oss, _name, _val, _detail)   \
G_STMT_START {                                  \
  if (ioctl(oss->fd, _name, _val) == -1) {      \
    GST_ELEMENT_ERROR (oss, RESOURCE, SETTINGS, \
        (NULL),					\
        ("Unable to get param " _detail ": %s", \
                   g_strerror (errno)));        \
    return FALSE;                               \
  }                                             \
} G_STMT_END
</MACRO>
<MACRO>
<NAME>GST_MIN_OSS4_VERSION</NAME>
#define GST_MIN_OSS4_VERSION  0x040003
</MACRO>
<FUNCTION>
<NAME>gst_oss4_audio_get_version</NAME>
<RETURNS>int        </RETURNS>
GstObject * obj, int fd
</FUNCTION>
<FUNCTION>
<NAME>gst_oss4_audio_check_version</NAME>
<RETURNS>gboolean   </RETURNS>
GstObject * obj, int fd
</FUNCTION>
<FUNCTION>
<NAME>gst_oss4_audio_probe_caps</NAME>
<RETURNS>GstCaps  * </RETURNS>
GstObject * obj, int fd
</FUNCTION>
<FUNCTION>
<NAME>gst_oss4_audio_set_format</NAME>
<RETURNS>gboolean   </RETURNS>
GstObject * obj, int fd, GstAudioRingBufferSpec * spec
</FUNCTION>
<FUNCTION>
<NAME>gst_oss4_audio_get_template_caps</NAME>
<RETURNS>GstCaps  * </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_oss4_audio_find_device</NAME>
<RETURNS>gchar    * </RETURNS>
GstObject * oss
</FUNCTION>
<FUNCTION>
<NAME>gst_oss4_add_property_probe_interface</NAME>
<RETURNS>void       </RETURNS>
GType type
</FUNCTION>
<FUNCTION>
<NAME>gst_oss4_property_probe_find_device_name</NAME>
<RETURNS>gboolean   </RETURNS>
GstObject   * obj, int           fd, const gchar * device_handle, gchar      ** device_name
</FUNCTION>
<FUNCTION>
<NAME>gst_oss4_property_probe_find_device_name_nofd</NAME>
<RETURNS>gboolean   </RETURNS>
GstObject   * obj, const gchar * device_handle, gchar      ** device_name
</FUNCTION>
<FUNCTION>
<NAME>gst_oss4_property_probe_get_values</NAME>
<RETURNS>GValueArray  *</RETURNS>
GstObject * obj, const gchar * pname
</FUNCTION>
<MACRO>
<NAME>COPYING40</NAME>
#define COPYING40 Copyright (C) 4Front Technologies 2000-2006. Released under the BSD license.
</MACRO>
<MACRO>
<NAME>EXTERNC</NAME>
#define EXTERNC extern "C"
</MACRO>
<MACRO>
<NAME>OSS_VERSION</NAME>
#define OSS_VERSION	0x040090 // Pre 4.1
</MACRO>
<MACRO>
<NAME>SOUND_VERSION</NAME>
#define SOUND_VERSION	OSS_VERSION
</MACRO>
<MACRO>
<NAME>OPEN_SOUND_SYSTEM</NAME>
#define OPEN_SOUND_SYSTEM
</MACRO>
<MACRO>
<NAME>SIOCPARM_MASK</NAME>
#define	SIOCPARM_MASK	IOCPARM_MASK
</MACRO>
<MACRO>
<NAME>SIOC_VOID</NAME>
#define	SIOC_VOID	IOC_VOID
</MACRO>
<MACRO>
<NAME>SIOC_OUT</NAME>
#define	SIOC_OUT	IOC_OUT
</MACRO>
<MACRO>
<NAME>SIOC_IN</NAME>
#define	SIOC_IN		IOC_IN
</MACRO>
<MACRO>
<NAME>SIOC_INOUT</NAME>
#define	SIOC_INOUT	IOC_INOUT
</MACRO>
<MACRO>
<NAME>OSS_LONGNAME_SIZE</NAME>
#define OSS_LONGNAME_SIZE	64
</MACRO>
<MACRO>
<NAME>OSS_LABEL_SIZE</NAME>
#define OSS_LABEL_SIZE		16
</MACRO>
<MACRO>
<NAME>OSS_DEVNODE_SIZE</NAME>
#define OSS_DEVNODE_SIZE	32
</MACRO>
<TYPEDEF>
<NAME>oss_longname_t</NAME>
typedef char oss_longname_t[OSS_LONGNAME_SIZE];
</TYPEDEF>
<TYPEDEF>
<NAME>oss_label_t</NAME>
typedef char oss_label_t[OSS_LABEL_SIZE];
</TYPEDEF>
<TYPEDEF>
<NAME>oss_devnode_t</NAME>
typedef char oss_devnode_t[OSS_DEVNODE_SIZE];
</TYPEDEF>
<MACRO>
<NAME>SNDCTL_SEQ_RESET</NAME>
#define SNDCTL_SEQ_RESET		__SIO  ('Q', 0)
</MACRO>
<MACRO>
<NAME>SNDCTL_SEQ_SYNC</NAME>
#define SNDCTL_SEQ_SYNC			__SIO  ('Q', 1)
</MACRO>
<MACRO>
<NAME>SNDCTL_SYNTH_INFO</NAME>
#define SNDCTL_SYNTH_INFO		__SIOWR('Q', 2, struct synth_info)
</MACRO>
<MACRO>
<NAME>SNDCTL_SEQ_CTRLRATE</NAME>
#define SNDCTL_SEQ_CTRLRATE		__SIOWR('Q', 3, int)	/* Set/get timer resolution (HZ) */
</MACRO>
<MACRO>
<NAME>SNDCTL_SEQ_GETOUTCOUNT</NAME>
#define SNDCTL_SEQ_GETOUTCOUNT		__SIOR ('Q', 4, int)
</MACRO>
<MACRO>
<NAME>SNDCTL_SEQ_GETINCOUNT</NAME>
#define SNDCTL_SEQ_GETINCOUNT		__SIOR ('Q', 5, int)
</MACRO>
<MACRO>
<NAME>SNDCTL_SEQ_PERCMODE</NAME>
#define SNDCTL_SEQ_PERCMODE		__SIOW ('Q', 6, int)
</MACRO>
<MACRO>
<NAME>SNDCTL_FM_LOAD_INSTR</NAME>
#define SNDCTL_FM_LOAD_INSTR		__SIOW ('Q', 7, struct sbi_instrument)	/* Obsolete. Don't use!!!!!! */
</MACRO>
<MACRO>
<NAME>SNDCTL_SEQ_TESTMIDI</NAME>
#define SNDCTL_SEQ_TESTMIDI		__SIOW ('Q', 8, int)
</MACRO>
<MACRO>
<NAME>SNDCTL_SEQ_RESETSAMPLES</NAME>
#define SNDCTL_SEQ_RESETSAMPLES		__SIOW ('Q', 9, int)
</MACRO>
<MACRO>
<NAME>SNDCTL_SEQ_NRSYNTHS</NAME>
#define SNDCTL_SEQ_NRSYNTHS		__SIOR ('Q',10, int)
</MACRO>
<MACRO>
<NAME>SNDCTL_SEQ_NRMIDIS</NAME>
#define SNDCTL_SEQ_NRMIDIS		__SIOR ('Q',11, int)
</MACRO>
<MACRO>
<NAME>SNDCTL_MIDI_INFO</NAME>
#define SNDCTL_MIDI_INFO		__SIOWR('Q',12, struct midi_info)	/* OBSOLETE - use SNDCTL_MIDIINFO instead */
</MACRO>
<MACRO>
<NAME>SNDCTL_SEQ_THRESHOLD</NAME>
#define SNDCTL_SEQ_THRESHOLD		__SIOW ('Q',13, int)
</MACRO>
<MACRO>
<NAME>SNDCTL_SYNTH_MEMAVL</NAME>
#define SNDCTL_SYNTH_MEMAVL		__SIOWR('Q',14, int)	/* in=dev#, out=memsize */
</MACRO>
<MACRO>
<NAME>SNDCTL_FM_4OP_ENABLE</NAME>
#define SNDCTL_FM_4OP_ENABLE		__SIOW ('Q',15, int)	/* in=dev# */
</MACRO>
<MACRO>
<NAME>SNDCTL_SEQ_PANIC</NAME>
#define SNDCTL_SEQ_PANIC		__SIO  ('Q',17)
</MACRO>
<MACRO>
<NAME>SNDCTL_SEQ_OUTOFBAND</NAME>
#define SNDCTL_SEQ_OUTOFBAND		__SIOW ('Q',18, struct seq_event_rec)
</MACRO>
<MACRO>
<NAME>SNDCTL_SEQ_GETTIME</NAME>
#define SNDCTL_SEQ_GETTIME		__SIOR ('Q',19, int)
</MACRO>
<MACRO>
<NAME>SNDCTL_SYNTH_ID</NAME>
#define SNDCTL_SYNTH_ID			__SIOWR('Q',20, struct synth_info)
</MACRO>
<MACRO>
<NAME>SNDCTL_SYNTH_CONTROL</NAME>
#define SNDCTL_SYNTH_CONTROL		__SIOWR('Q',21, struct synth_control)
</MACRO>
<MACRO>
<NAME>SNDCTL_SYNTH_REMOVESAMPLE</NAME>
#define SNDCTL_SYNTH_REMOVESAMPLE	__SIOWR('Q',22, struct remove_sample)	/* Reserved for future use */
</MACRO>
<MACRO>
<NAME>SNDCTL_SEQ_TIMING_ENABLE</NAME>
#define SNDCTL_SEQ_TIMING_ENABLE	__SIO  ('Q', 23)	/* Enable incoming MIDI timing messages */
</MACRO>
<MACRO>
<NAME>SNDCTL_SEQ_ACTSENSE_ENABLE</NAME>
#define SNDCTL_SEQ_ACTSENSE_ENABLE	__SIO  ('Q', 24)	/* Enable incoming active sensing messages */
</MACRO>
<MACRO>
<NAME>SNDCTL_SEQ_RT_ENABLE</NAME>
#define SNDCTL_SEQ_RT_ENABLE		__SIO  ('Q', 25)	/* Enable other incoming realtime messages */
</MACRO>
<MACRO>
<NAME>SNDCTL_TMR_TIMEBASE</NAME>
#define SNDCTL_TMR_TIMEBASE		__SIOWR('T', 1, int)
</MACRO>
<MACRO>
<NAME>SNDCTL_TMR_START</NAME>
#define SNDCTL_TMR_START		__SIO  ('T', 2)
</MACRO>
<MACRO>
<NAME>SNDCTL_TMR_STOP</NAME>
#define SNDCTL_TMR_STOP			__SIO  ('T', 3)
</MACRO>
<MACRO>
<NAME>SNDCTL_TMR_CONTINUE</NAME>
#define SNDCTL_TMR_CONTINUE		__SIO  ('T', 4)
</MACRO>
<MACRO>
<NAME>SNDCTL_TMR_TEMPO</NAME>
#define SNDCTL_TMR_TEMPO		__SIOWR('T', 5, int)
</MACRO>
<MACRO>
<NAME>SNDCTL_TMR_SOURCE</NAME>
#define SNDCTL_TMR_SOURCE		__SIOWR('T', 6, int)
</MACRO>
<MACRO>
<NAME>TMR_INTERNAL</NAME>
#	define TMR_INTERNAL		0x00000001
</MACRO>
<MACRO>
<NAME>TMR_EXTERNAL</NAME>
#	define TMR_EXTERNAL		0x00000002
</MACRO>
<MACRO>
<NAME>TMR_MODE_MIDI</NAME>
#		define TMR_MODE_MIDI	0x00000010
</MACRO>
<MACRO>
<NAME>TMR_MODE_FSK</NAME>
#		define TMR_MODE_FSK	0x00000020
</MACRO>
<MACRO>
<NAME>TMR_MODE_CLS</NAME>
#		define TMR_MODE_CLS	0x00000040
</MACRO>
<MACRO>
<NAME>TMR_MODE_SMPTE</NAME>
#		define TMR_MODE_SMPTE	0x00000080
</MACRO>
<MACRO>
<NAME>SNDCTL_TMR_METRONOME</NAME>
#define SNDCTL_TMR_METRONOME		__SIOW ('T', 7, int)
</MACRO>
<MACRO>
<NAME>SNDCTL_TMR_SELECT</NAME>
#define SNDCTL_TMR_SELECT		__SIOW ('T', 8, int)
</MACRO>
<STRUCT>
<NAME>patch_info</NAME>
struct patch_info
{
  unsigned short key;		/* Use WAVE_PATCH here */
#define WAVE_PATCH	_PATCHKEY(0x04)
#define GUS_PATCH	WAVE_PATCH
#define WAVEFRONT_PATCH _PATCHKEY(0x06)

  short device_no;		/* Synthesizer number */
  short instr_no;		/* Midi pgm# */

  unsigned int mode;
/*
 * The least significant byte has the same format than the GUS .PAT
 * files
 */
#define WAVE_16_BITS	0x01	/* bit 0 = 8 or 16 bit wave data. */
#define WAVE_UNSIGNED	0x02	/* bit 1 = Signed - Unsigned data. */
#define WAVE_LOOPING	0x04	/* bit 2 = looping enabled-1. */
#define WAVE_BIDIR_LOOP	0x08	/* bit 3 = Set is bidirectional looping. */
#define WAVE_LOOP_BACK	0x10	/* bit 4 = Set is looping backward. */
#define WAVE_SUSTAIN_ON	0x20	/* bit 5 = Turn sustaining on. (Env. pts. 3) */
#define WAVE_ENVELOPES	0x40	/* bit 6 = Enable envelopes - 1 */
#define WAVE_FAST_RELEASE 0x80	/* bit 7 = Shut off immediately after note off */
  /*  (use the env_rate/env_offs fields). */
/* Linux specific bits */
#define WAVE_VIBRATO	0x00010000	/* The vibrato info is valid */
#define WAVE_TREMOLO	0x00020000	/* The tremolo info is valid */
#define WAVE_SCALE	0x00040000	/* The scaling info is valid */
#define WAVE_FRACTIONS	0x00080000	/* Fraction information is valid */
/* Reserved bits */
#define WAVE_ROM	0x40000000	/* For future use */
#define WAVE_MULAW	0x20000000	/* For future use */
/* Other bits must be zeroed */

  int len;			/* Size of the wave data in bytes */
  int loop_start, loop_end;	/* Byte offsets from the beginning */

/* 
 * The base_freq and base_note fields are used when computing the
 * playback speed for a note. The base_note defines the tone frequency
 * which is heard if the sample is played using the base_freq as the
 * playback speed.
 *
 * The low_note and high_note fields define the minimum and maximum note
 * frequencies for which this sample is valid. It is possible to define
 * more than one samples for an instrument number at the same time. The
 * low_note and high_note fields are used to select the most suitable one.
 *
 * The fields base_note, high_note and low_note should contain
 * the note frequency multiplied by 1000. For example value for the
 * middle A is 440*1000.
 */

  unsigned int base_freq;
  unsigned int base_note;
  unsigned int high_note;
  unsigned int low_note;
  int panning;			/* -128=left, 127=right */
  int detuning;

  /* Envelope. Enabled by mode bit WAVE_ENVELOPES  */
  unsigned char env_rate[6];	/* GUS HW ramping rate */
  unsigned char env_offset[6];	/* 255 == 100% */

  /* 
   * The tremolo, vibrato and scale info are not supported yet.
   * Enable by setting the mode bits WAVE_TREMOLO, WAVE_VIBRATO or
   * WAVE_SCALE
   */

  unsigned char tremolo_sweep;
  unsigned char tremolo_rate;
  unsigned char tremolo_depth;

  unsigned char vibrato_sweep;
  unsigned char vibrato_rate;
  unsigned char vibrato_depth;

  int scale_frequency;
  unsigned int scale_factor;	/* from 0 to 2048 or 0 to 2 */

  int volume;
  int fractions;
  int reserved1;
  int spare[2];
  char data[1];			/* The waveform data starts here */
};
</STRUCT>
<STRUCT>
<NAME>sysex_info</NAME>
struct sysex_info
{
  short key;			/* Use SYSEX_PATCH or MAUI_PATCH here */
#define SYSEX_PATCH	_PATCHKEY(0x05)
#define MAUI_PATCH	_PATCHKEY(0x06)
  short device_no;		/* Synthesizer number */
  int len;			/* Size of the sysex data in bytes */
  unsigned char data[1];	/* Sysex data starts here */
};
</STRUCT>
<MACRO>
<NAME>SEQ_NOTEOFF</NAME>
#define SEQ_NOTEOFF		0
</MACRO>
<MACRO>
<NAME>SEQ_FMNOTEOFF</NAME>
#define SEQ_FMNOTEOFF		SEQ_NOTEOFF	/* Just old name */
</MACRO>
<MACRO>
<NAME>SEQ_NOTEON</NAME>
#define SEQ_NOTEON		1
</MACRO>
<MACRO>
<NAME>SEQ_FMNOTEON</NAME>
#define	SEQ_FMNOTEON		SEQ_NOTEON
</MACRO>
<MACRO>
<NAME>SEQ_WAIT</NAME>
#define SEQ_WAIT		TMR_WAIT_ABS
</MACRO>
<MACRO>
<NAME>SEQ_PGMCHANGE</NAME>
#define SEQ_PGMCHANGE		3
</MACRO>
<MACRO>
<NAME>SEQ_FMPGMCHANGE</NAME>
#define SEQ_FMPGMCHANGE		SEQ_PGMCHANGE
</MACRO>
<MACRO>
<NAME>SEQ_SYNCTIMER</NAME>
#define SEQ_SYNCTIMER		TMR_START
</MACRO>
<MACRO>
<NAME>SEQ_MIDIPUTC</NAME>
#define SEQ_MIDIPUTC		5
</MACRO>
<MACRO>
<NAME>SEQ_DRUMON</NAME>
#define SEQ_DRUMON		6		/*** OBSOLETE ***/
</MACRO>
<MACRO>
<NAME>SEQ_DRUMOFF</NAME>
#define SEQ_DRUMOFF		7		/*** OBSOLETE ***/
</MACRO>
<MACRO>
<NAME>SEQ_ECHO</NAME>
#define SEQ_ECHO		TMR_ECHO	/* For synching programs with output */
</MACRO>
<MACRO>
<NAME>SEQ_AFTERTOUCH</NAME>
#define SEQ_AFTERTOUCH		9
</MACRO>
<MACRO>
<NAME>SEQ_CONTROLLER</NAME>
#define SEQ_CONTROLLER		10
</MACRO>
<MACRO>
<NAME>SEQ_BALANCE</NAME>
#define SEQ_BALANCE		11
</MACRO>
<MACRO>
<NAME>SEQ_VOLMODE</NAME>
#define SEQ_VOLMODE             12
</MACRO>
<MACRO>
<NAME>CTL_BANK_SELECT</NAME>
#define	   CTL_BANK_SELECT		0x00
</MACRO>
<MACRO>
<NAME>CTL_MODWHEEL</NAME>
#define	   CTL_MODWHEEL			0x01
</MACRO>
<MACRO>
<NAME>CTL_BREATH</NAME>
#define    CTL_BREATH			0x02
</MACRO>
<MACRO>
<NAME>CTL_FOOT</NAME>
#define    CTL_FOOT			0x04
</MACRO>
<MACRO>
<NAME>CTL_PORTAMENTO_TIME</NAME>
#define    CTL_PORTAMENTO_TIME		0x05
</MACRO>
<MACRO>
<NAME>CTL_DATA_ENTRY</NAME>
#define    CTL_DATA_ENTRY		0x06
</MACRO>
<MACRO>
<NAME>CTL_MAIN_VOLUME</NAME>
#define    CTL_MAIN_VOLUME		0x07
</MACRO>
<MACRO>
<NAME>CTL_BALANCE</NAME>
#define    CTL_BALANCE			0x08
</MACRO>
<MACRO>
<NAME>CTL_PAN</NAME>
#define    CTL_PAN			0x0a
</MACRO>
<MACRO>
<NAME>CTL_EXPRESSION</NAME>
#define    CTL_EXPRESSION		0x0b
</MACRO>
<MACRO>
<NAME>CTL_GENERAL_PURPOSE1</NAME>
#define    CTL_GENERAL_PURPOSE1		0x10
</MACRO>
<MACRO>
<NAME>CTL_GENERAL_PURPOSE2</NAME>
#define    CTL_GENERAL_PURPOSE2		0x11
</MACRO>
<MACRO>
<NAME>CTL_GENERAL_PURPOSE3</NAME>
#define    CTL_GENERAL_PURPOSE3		0x12
</MACRO>
<MACRO>
<NAME>CTL_GENERAL_PURPOSE4</NAME>
#define    CTL_GENERAL_PURPOSE4		0x13
</MACRO>
<MACRO>
<NAME>CTL_DAMPER_PEDAL</NAME>
#define    CTL_DAMPER_PEDAL		0x40
</MACRO>
<MACRO>
<NAME>CTL_SUSTAIN</NAME>
#define    CTL_SUSTAIN			0x40	/* Alias */
</MACRO>
<MACRO>
<NAME>CTL_HOLD</NAME>
#define    CTL_HOLD			0x40	/* Alias */
</MACRO>
<MACRO>
<NAME>CTL_PORTAMENTO</NAME>
#define    CTL_PORTAMENTO		0x41
</MACRO>
<MACRO>
<NAME>CTL_SOSTENUTO</NAME>
#define    CTL_SOSTENUTO		0x42
</MACRO>
<MACRO>
<NAME>CTL_SOFT_PEDAL</NAME>
#define    CTL_SOFT_PEDAL		0x43
</MACRO>
<MACRO>
<NAME>CTL_HOLD2</NAME>
#define    CTL_HOLD2			0x45
</MACRO>
<MACRO>
<NAME>CTL_GENERAL_PURPOSE5</NAME>
#define    CTL_GENERAL_PURPOSE5		0x50
</MACRO>
<MACRO>
<NAME>CTL_GENERAL_PURPOSE6</NAME>
#define    CTL_GENERAL_PURPOSE6		0x51
</MACRO>
<MACRO>
<NAME>CTL_GENERAL_PURPOSE7</NAME>
#define    CTL_GENERAL_PURPOSE7		0x52
</MACRO>
<MACRO>
<NAME>CTL_GENERAL_PURPOSE8</NAME>
#define    CTL_GENERAL_PURPOSE8		0x53
</MACRO>
<MACRO>
<NAME>CTL_EXT_EFF_DEPTH</NAME>
#define    CTL_EXT_EFF_DEPTH		0x5b
</MACRO>
<MACRO>
<NAME>CTL_TREMOLO_DEPTH</NAME>
#define    CTL_TREMOLO_DEPTH		0x5c
</MACRO>
<MACRO>
<NAME>CTL_CHORUS_DEPTH</NAME>
#define    CTL_CHORUS_DEPTH		0x5d
</MACRO>
<MACRO>
<NAME>CTL_DETUNE_DEPTH</NAME>
#define    CTL_DETUNE_DEPTH		0x5e
</MACRO>
<MACRO>
<NAME>CTL_CELESTE_DEPTH</NAME>
#define    CTL_CELESTE_DEPTH		0x5e	/* Alias for the above one */
</MACRO>
<MACRO>
<NAME>CTL_PHASER_DEPTH</NAME>
#define    CTL_PHASER_DEPTH		0x5f
</MACRO>
<MACRO>
<NAME>CTL_DATA_INCREMENT</NAME>
#define    CTL_DATA_INCREMENT		0x60
</MACRO>
<MACRO>
<NAME>CTL_DATA_DECREMENT</NAME>
#define    CTL_DATA_DECREMENT		0x61
</MACRO>
<MACRO>
<NAME>CTL_NONREG_PARM_NUM_LSB</NAME>
#define    CTL_NONREG_PARM_NUM_LSB	0x62
</MACRO>
<MACRO>
<NAME>CTL_NONREG_PARM_NUM_MSB</NAME>
#define    CTL_NONREG_PARM_NUM_MSB	0x63
</MACRO>
<MACRO>
<NAME>CTL_REGIST_PARM_NUM_LSB</NAME>
#define    CTL_REGIST_PARM_NUM_LSB	0x64
</MACRO>
<MACRO>
<NAME>CTL_REGIST_PARM_NUM_MSB</NAME>
#define    CTL_REGIST_PARM_NUM_MSB	0x65
</MACRO>
<MACRO>
<NAME>CTRL_PITCH_BENDER</NAME>
#define    CTRL_PITCH_BENDER		255
</MACRO>
<MACRO>
<NAME>CTRL_PITCH_BENDER_RANGE</NAME>
#define    CTRL_PITCH_BENDER_RANGE	254
</MACRO>
<MACRO>
<NAME>CTRL_EXPRESSION</NAME>
#define    CTRL_EXPRESSION		253	/* Obsolete */
</MACRO>
<MACRO>
<NAME>CTRL_MAIN_VOLUME</NAME>
#define    CTRL_MAIN_VOLUME		252	/* Obsolete */
</MACRO>
<MACRO>
<NAME>VOL_METHOD_ADAGIO</NAME>
#define VOL_METHOD_ADAGIO	1
</MACRO>
<MACRO>
<NAME>VOL_METHOD_LINEAR</NAME>
#define VOL_METHOD_LINEAR	2
</MACRO>
<MACRO>
<NAME>SEQ_FULLSIZE</NAME>
#define SEQ_FULLSIZE		0xfd	/* Long events */
</MACRO>
<MACRO>
<NAME>SEQ_PRIVATE</NAME>
#define SEQ_PRIVATE		0xfe	/* Low level HW dependent events (8 bytes) */
</MACRO>
<MACRO>
<NAME>SEQ_EXTENDED</NAME>
#define SEQ_EXTENDED		0xff	/* Extended events (8 bytes) OBSOLETE */
</MACRO>
<TYPEDEF>
<NAME>sbi_instr_data</NAME>
typedef unsigned char sbi_instr_data[32];
</TYPEDEF>
<STRUCT>
<NAME>sbi_instrument</NAME>
struct sbi_instrument
{
  unsigned short key;		/* FM_PATCH or OPL3_PATCH */
#define FM_PATCH	_PATCHKEY(0x01)
#define OPL3_PATCH	_PATCHKEY(0x03)
  short device;			/*  Synth# (0-4)    */
  int channel;			/*  Program# to be initialized  */
  sbi_instr_data operators;	/*  Register settings for operator cells (.SBI format)  */
};
</STRUCT>
<STRUCT>
<NAME>synth_info</NAME>
struct synth_info
{				/* Read only */
  char name[30];
  int device;			/* 0-N. INITIALIZE BEFORE CALLING */
  int synth_type;
#define SYNTH_TYPE_FM			0
#define SYNTH_TYPE_SAMPLE		1
#define SYNTH_TYPE_MIDI			2	/* Midi interface */

  int synth_subtype;
#define FM_TYPE_ADLIB			0x00
#define FM_TYPE_OPL3			0x01
#define MIDI_TYPE_MPU401		0x401

#define SAMPLE_TYPE_BASIC		0x10
#define SAMPLE_TYPE_GUS			SAMPLE_TYPE_BASIC
#define SAMPLE_TYPE_WAVEFRONT   	0x11

  int perc_mode;		/* No longer supported */
  int nr_voices;
  int nr_drums;			/* Obsolete field */
  int instr_bank_size;
  unsigned int capabilities;
#define SYNTH_CAP_PERCMODE	0x00000001	/* No longer used */
#define SYNTH_CAP_OPL3		0x00000002	/* Set if OPL3 supported */
#define SYNTH_CAP_INPUT		0x00000004	/* Input (MIDI) device */
  int dummies[19];		/* Reserve space */
};
</STRUCT>
<STRUCT>
<NAME>sound_timer_info</NAME>
struct sound_timer_info
{
  char name[32];
  int caps;
};
</STRUCT>
<STRUCT>
<NAME>midi_info</NAME>
struct midi_info		/* OBSOLETE */
{
  char name[30];
  int device;			/* 0-N. INITIALIZE BEFORE CALLING */
  unsigned int capabilities;	/* To be defined later */
  int dev_type;
  int dummies[18];		/* Reserve space */
};
</STRUCT>
<MACRO>
<NAME>EV_SEQ_LOCAL</NAME>
#define EV_SEQ_LOCAL		0x80
</MACRO>
<MACRO>
<NAME>EV_TIMING</NAME>
#define EV_TIMING		0x81
</MACRO>
<MACRO>
<NAME>EV_CHN_COMMON</NAME>
#define EV_CHN_COMMON		0x92
</MACRO>
<MACRO>
<NAME>EV_CHN_VOICE</NAME>
#define EV_CHN_VOICE		0x93
</MACRO>
<MACRO>
<NAME>EV_SYSEX</NAME>
#define EV_SYSEX		0x94
</MACRO>
<MACRO>
<NAME>EV_SYSTEM</NAME>
#define EV_SYSTEM		0x95	/* MIDI system and real time messages (input only) */
</MACRO>
<MACRO>
<NAME>MIDI_NOTEOFF</NAME>
#define MIDI_NOTEOFF		0x80
</MACRO>
<MACRO>
<NAME>MIDI_NOTEON</NAME>
#define MIDI_NOTEON		0x90
</MACRO>
<MACRO>
<NAME>MIDI_KEY_PRESSURE</NAME>
#define MIDI_KEY_PRESSURE	0xA0
</MACRO>
<MACRO>
<NAME>MIDI_CTL_CHANGE</NAME>
#define MIDI_CTL_CHANGE		0xB0
</MACRO>
<MACRO>
<NAME>MIDI_PGM_CHANGE</NAME>
#define MIDI_PGM_CHANGE		0xC0
</MACRO>
<MACRO>
<NAME>MIDI_CHN_PRESSURE</NAME>
#define MIDI_CHN_PRESSURE	0xD0
</MACRO>
<MACRO>
<NAME>MIDI_PITCH_BEND</NAME>
#define MIDI_PITCH_BEND		0xE0
</MACRO>
<MACRO>
<NAME>MIDI_SYSTEM_PREFIX</NAME>
#define MIDI_SYSTEM_PREFIX	0xF0
</MACRO>
<MACRO>
<NAME>TMR_WAIT_REL</NAME>
#define TMR_WAIT_REL		1	/* Time relative to the prev time */
</MACRO>
<MACRO>
<NAME>TMR_WAIT_ABS</NAME>
#define TMR_WAIT_ABS		2	/* Absolute time since TMR_START */
</MACRO>
<MACRO>
<NAME>TMR_STOP</NAME>
#define TMR_STOP		3
</MACRO>
<MACRO>
<NAME>TMR_START</NAME>
#define TMR_START		4
</MACRO>
<MACRO>
<NAME>TMR_CONTINUE</NAME>
#define TMR_CONTINUE		5
</MACRO>
<MACRO>
<NAME>TMR_TEMPO</NAME>
#define TMR_TEMPO		6
</MACRO>
<MACRO>
<NAME>TMR_ECHO</NAME>
#define TMR_ECHO		8
</MACRO>
<MACRO>
<NAME>TMR_CLOCK</NAME>
#define TMR_CLOCK		9	/* MIDI clock */
</MACRO>
<MACRO>
<NAME>TMR_SPP</NAME>
#define TMR_SPP			10	/* Song position pointer */
</MACRO>
<MACRO>
<NAME>TMR_TIMESIG</NAME>
#define TMR_TIMESIG		11	/* Time signature */
</MACRO>
<MACRO>
<NAME>LOCL_STARTAUDIO</NAME>
#define LOCL_STARTAUDIO		1
</MACRO>
<MACRO>
<NAME>LOCL_STARTAUDIO2</NAME>
#define LOCL_STARTAUDIO2	2
</MACRO>
<MACRO>
<NAME>LOCL_STARTAUDIO3</NAME>
#define LOCL_STARTAUDIO3	3
</MACRO>
<MACRO>
<NAME>LOCL_STARTAUDIO4</NAME>
#define LOCL_STARTAUDIO4	4
</MACRO>
<MACRO>
<NAME>SEQ_DECLAREBUF</NAME>
#define SEQ_DECLAREBUF()		SEQ_USE_EXTBUF()
</MACRO>
<FUNCTION>
<NAME>seqbuf_dump</NAME>
<RETURNS>void  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>SEQ_PM_DEFINES</NAME>
#define SEQ_PM_DEFINES int __foo_bar___
</MACRO>
<MACRO>
<NAME>SEQ_USE_EXTBUF</NAME>
#  define SEQ_USE_EXTBUF() \
		EXTERNC unsigned char *_seqbuf; \
		EXTERNC int _seqbuflen;EXTERNC int _seqbufptr
</MACRO>
<MACRO>
<NAME>SEQ_DEFINEBUF</NAME>
#  define SEQ_DEFINEBUF(len) SEQ_USE_EXTBUF();static int _requested_seqbuflen=len
</MACRO>
<MACRO>
<NAME>SEQ_DUMPBUF</NAME>
#  define SEQ_DUMPBUF() OSS_seqbuf_dump(seqfd, _seqbuf, _seqbuflen)
</MACRO>
<MACRO>
<NAME>SEQ_LOAD_GMINSTR</NAME>
#  define SEQ_LOAD_GMINSTR(dev, instr) \
		OSS_patch_caching(dev, -1, instr, seqfd, _seqbuf, _seqbuflen)
</MACRO>
<MACRO>
<NAME>SEQ_LOAD_GMDRUM</NAME>
#  define SEQ_LOAD_GMDRUM(dev, drum) \
		OSS_drum_caching(dev, -1, drum, seqfd, _seqbuf, _seqbuflen)
</MACRO>
<MACRO>
<NAME>SEQ_VOLUME_MODE</NAME>
#define SEQ_VOLUME_MODE(dev, mode) \
				{_SEQ_NEEDBUF(8);\
				_seqbuf[_seqbufptr] = SEQ_EXTENDED;\
				_seqbuf[_seqbufptr+1] = SEQ_VOLMODE;\
				_seqbuf[_seqbufptr+2] = (dev);\
				_seqbuf[_seqbufptr+3] = (mode);\
				_seqbuf[_seqbufptr+4] = 0;\
				_seqbuf[_seqbufptr+5] = 0;\
				_seqbuf[_seqbufptr+6] = 0;\
				_seqbuf[_seqbufptr+7] = 0;\
				_SEQ_ADVBUF(8);}
</MACRO>
<MACRO>
<NAME>SEQ_START_NOTE</NAME>
#define SEQ_START_NOTE(dev, chn, note, vol) \
			_CHN_VOICE(dev, MIDI_NOTEON, chn, note, vol)
</MACRO>
<MACRO>
<NAME>SEQ_STOP_NOTE</NAME>
#define SEQ_STOP_NOTE(dev, chn, note, vol) \
			_CHN_VOICE(dev, MIDI_NOTEOFF, chn, note, vol)
</MACRO>
<MACRO>
<NAME>SEQ_KEY_PRESSURE</NAME>
#define SEQ_KEY_PRESSURE(dev, chn, note, pressure) \
			_CHN_VOICE(dev, MIDI_KEY_PRESSURE, chn, note, pressure)
</MACRO>
<MACRO>
<NAME>SEQ_SYSEX</NAME>
#define SEQ_SYSEX(dev, buf, len) \
				{int ii, ll=(len); \
				 unsigned char *bufp=buf;\
				 if (ll>6)ll=6;\
				_SEQ_NEEDBUF(8);\
				_seqbuf[_seqbufptr] = EV_SYSEX;\
				_seqbuf[_seqbufptr+1] = (dev);\
				for(ii=0;ii<ll;ii++)\
				   _seqbuf[_seqbufptr+ii+2] = bufp[ii];\
				for(ii=ll;ii<6;ii++)\
				   _seqbuf[_seqbufptr+ii+2] = 0xff;\
				_SEQ_ADVBUF(8);}
</MACRO>
<MACRO>
<NAME>SEQ_CHN_PRESSURE</NAME>
#define SEQ_CHN_PRESSURE(dev, chn, pressure) \
		_CHN_COMMON(dev, MIDI_CHN_PRESSURE, chn, pressure, 0, 0)
</MACRO>
<MACRO>
<NAME>SEQ_SET_PATCH</NAME>
#define SEQ_SET_PATCH SEQ_PGM_CHANGE
</MACRO>
<MACRO>
<NAME>SEQ_PGM_CHANGE</NAME>
#   define SEQ_PGM_CHANGE(dev, chn, patch) \
		{OSS_patch_caching(dev, chn, patch, seqfd, _seqbuf, _seqbuflen); \
		 _CHN_COMMON(dev, MIDI_PGM_CHANGE, chn, patch, 0, 0);}
</MACRO>
<MACRO>
<NAME>SEQ_CONTROL</NAME>
#define SEQ_CONTROL(dev, chn, controller, value) \
		_CHN_COMMON(dev, MIDI_CTL_CHANGE, chn, controller, 0, value)
</MACRO>
<MACRO>
<NAME>SEQ_BENDER</NAME>
#define SEQ_BENDER(dev, chn, value) \
		_CHN_COMMON(dev, MIDI_PITCH_BEND, chn, 0, 0, value)
</MACRO>
<MACRO>
<NAME>SEQ_V2_X_CONTROL</NAME>
#define SEQ_V2_X_CONTROL(dev, voice, controller, value)	\
				{_SEQ_NEEDBUF(8);\
				_seqbuf[_seqbufptr] = SEQ_EXTENDED;\
				_seqbuf[_seqbufptr+1] = SEQ_CONTROLLER;\
				_seqbuf[_seqbufptr+2] = (dev);\
				_seqbuf[_seqbufptr+3] = (voice);\
				_seqbuf[_seqbufptr+4] = (controller);\
				_seqbuf[_seqbufptr+5] = ((value)&0xff);\
				_seqbuf[_seqbufptr+6] = ((value>>8)&0xff);\
				_seqbuf[_seqbufptr+7] = 0;\
				_SEQ_ADVBUF(8);}
</MACRO>
<MACRO>
<NAME>SEQ_PITCHBEND</NAME>
#define SEQ_PITCHBEND(dev, voice, value) \
	SEQ_V2_X_CONTROL(dev, voice, CTRL_PITCH_BENDER, value)
</MACRO>
<MACRO>
<NAME>SEQ_BENDER_RANGE</NAME>
#define SEQ_BENDER_RANGE(dev, voice, value) \
	SEQ_V2_X_CONTROL(dev, voice, CTRL_PITCH_BENDER_RANGE, value)
</MACRO>
<MACRO>
<NAME>SEQ_EXPRESSION</NAME>
#define SEQ_EXPRESSION(dev, voice, value) \
	SEQ_CONTROL(dev, voice, CTL_EXPRESSION, value*128)
</MACRO>
<MACRO>
<NAME>SEQ_MAIN_VOLUME</NAME>
#define SEQ_MAIN_VOLUME(dev, voice, value) \
	SEQ_CONTROL(dev, voice, CTL_MAIN_VOLUME, (value*16383)/100)
</MACRO>
<MACRO>
<NAME>SEQ_PANNING</NAME>
#define SEQ_PANNING(dev, voice, pos) \
	SEQ_CONTROL(dev, voice, CTL_PAN, (pos+128) / 2)
</MACRO>
<MACRO>
<NAME>SEQ_START_TIMER</NAME>
#define SEQ_START_TIMER()		_TIMER_EVENT(TMR_START, 0)
</MACRO>
<MACRO>
<NAME>SEQ_STOP_TIMER</NAME>
#define SEQ_STOP_TIMER()		_TIMER_EVENT(TMR_STOP, 0)
</MACRO>
<MACRO>
<NAME>SEQ_CONTINUE_TIMER</NAME>
#define SEQ_CONTINUE_TIMER()		_TIMER_EVENT(TMR_CONTINUE, 0)
</MACRO>
<MACRO>
<NAME>SEQ_WAIT_TIME</NAME>
#define SEQ_WAIT_TIME(ticks)		_TIMER_EVENT(TMR_WAIT_ABS, ticks)
</MACRO>
<MACRO>
<NAME>SEQ_DELTA_TIME</NAME>
#define SEQ_DELTA_TIME(ticks)		_TIMER_EVENT(TMR_WAIT_REL, ticks)
</MACRO>
<MACRO>
<NAME>SEQ_ECHO_BACK</NAME>
#define SEQ_ECHO_BACK(key)		_TIMER_EVENT(TMR_ECHO, key)
</MACRO>
<MACRO>
<NAME>SEQ_SET_TEMPO</NAME>
#define SEQ_SET_TEMPO(value)		_TIMER_EVENT(TMR_TEMPO, value)
</MACRO>
<MACRO>
<NAME>SEQ_SONGPOS</NAME>
#define SEQ_SONGPOS(pos)		_TIMER_EVENT(TMR_SPP, pos)
</MACRO>
<MACRO>
<NAME>SEQ_TIME_SIGNATURE</NAME>
#define SEQ_TIME_SIGNATURE(sig)		_TIMER_EVENT(TMR_TIMESIG, sig)
</MACRO>
<MACRO>
<NAME>SEQ_PLAYAUDIO</NAME>
#define SEQ_PLAYAUDIO(devmask)		_LOCAL_EVENT(LOCL_STARTAUDIO, devmask)
</MACRO>
<MACRO>
<NAME>SEQ_PLAYAUDIO2</NAME>
#define SEQ_PLAYAUDIO2(devmask)		_LOCAL_EVENT(LOCL_STARTAUDIO2, devmask)
</MACRO>
<MACRO>
<NAME>SEQ_PLAYAUDIO3</NAME>
#define SEQ_PLAYAUDIO3(devmask)		_LOCAL_EVENT(LOCL_STARTAUDIO3, devmask)
</MACRO>
<MACRO>
<NAME>SEQ_PLAYAUDIO4</NAME>
#define SEQ_PLAYAUDIO4(devmask)		_LOCAL_EVENT(LOCL_STARTAUDIO4, devmask)
</MACRO>
<MACRO>
<NAME>SEQ_MIDIOUT</NAME>
#define SEQ_MIDIOUT(device, byte)	{_SEQ_NEEDBUF(4);\
					_seqbuf[_seqbufptr] = SEQ_MIDIPUTC;\
					_seqbuf[_seqbufptr+1] = (byte);\
					_seqbuf[_seqbufptr+2] = (device);\
					_seqbuf[_seqbufptr+3] = 0;\
					_SEQ_ADVBUF(4);}
</MACRO>
<MACRO>
<NAME>SEQ_WRPATCH</NAME>
#   define SEQ_WRPATCH(patchx, len) \
		OSS_write_patch(seqfd, (char*)(patchx), len)
</MACRO>
<MACRO>
<NAME>SEQ_WRPATCH2</NAME>
#   define SEQ_WRPATCH2(patchx, len) \
		OSS_write_patch2(seqfd, (char*)(patchx), len)
</MACRO>
<MACRO>
<NAME>SNDCTL_MIDI_PRETIME</NAME>
#define SNDCTL_MIDI_PRETIME	__SIOWR('m', 0, int)
</MACRO>
<MACRO>
<NAME>SNDCTL_MIDI_MPUMODE</NAME>
#define SNDCTL_MIDI_MPUMODE	__SIOWR('m', 1, int)
</MACRO>
<MACRO>
<NAME>SNDCTL_MIDI_MPUCMD</NAME>
#define SNDCTL_MIDI_MPUCMD	__SIOWR('m', 2, mpu_command_rec)
</MACRO>
<MACRO>
<NAME>SNDCTL_MIDI_MTCINPUT</NAME>
#define SNDCTL_MIDI_MTCINPUT	__SIOWR('m', 3, int)
</MACRO>
<MACRO>
<NAME>MTC_DIR_STOPPED</NAME>
#define MTC_DIR_STOPPED		 0
</MACRO>
<MACRO>
<NAME>MTC_DIR_FORWARD</NAME>
#define MTC_DIR_FORWARD		 1
</MACRO>
<MACRO>
<NAME>MTC_DIR_BACKWARD</NAME>
#define MTC_DIR_BACKWARD	-1
</MACRO>
<MACRO>
<NAME>SNDCTL_MIDI_SETMODE</NAME>
#define SNDCTL_MIDI_SETMODE	__SIOWR('m', 6, int)
</MACRO>
<MACRO>
<NAME>MIDI_MODE_TRADITIONAL</NAME>
#	define MIDI_MODE_TRADITIONAL	0
</MACRO>
<MACRO>
<NAME>MIDI_MODE_TIMED</NAME>
#	define MIDI_MODE_TIMED		1	/* Input times are in MIDI ticks */
</MACRO>
<MACRO>
<NAME>MIDI_MODE_TIMED_ABS</NAME>
#	define MIDI_MODE_TIMED_ABS  	2	/* Input times are absolute (usecs) */
</MACRO>
<TYPEDEF>
<NAME>oss_midi_time_t</NAME>
typedef unsigned long long oss_midi_time_t;	/* Variable type for MIDI time (clock ticks) */
</TYPEDEF>
<MACRO>
<NAME>MIDI_HDR_MAGIC</NAME>
#define MIDI_HDR_MAGIC	-1
</MACRO>
<MACRO>
<NAME>MIDI_EV_WRITE</NAME>
#define MIDI_EV_WRITE			0	/* Write or read (with payload) */
</MACRO>
<MACRO>
<NAME>MIDI_EV_TEMPO</NAME>
#define MIDI_EV_TEMPO			1
</MACRO>
<MACRO>
<NAME>MIDI_EV_ECHO</NAME>
#define MIDI_EV_ECHO			2
</MACRO>
<MACRO>
<NAME>MIDI_EV_START</NAME>
#define MIDI_EV_START			3
</MACRO>
<MACRO>
<NAME>MIDI_EV_STOP</NAME>
#define MIDI_EV_STOP			4
</MACRO>
<MACRO>
<NAME>MIDI_EV_CONTINUE</NAME>
#define MIDI_EV_CONTINUE		5
</MACRO>
<MACRO>
<NAME>MIDI_EV_XPRESSWRITE</NAME>
#define MIDI_EV_XPRESSWRITE		6
</MACRO>
<MACRO>
<NAME>MIDI_EV_TIMEBASE</NAME>
#define MIDI_EV_TIMEBASE		7
</MACRO>
<MACRO>
<NAME>MIDI_EV_DEVCTL</NAME>
#define MIDI_EV_DEVCTL			8	/* Device control read/write */
</MACRO>
<MACRO>
<NAME>MIDI_OPT_NONE</NAME>
#define MIDI_OPT_NONE			0x0000
</MACRO>
<MACRO>
<NAME>MIDI_OPT_TIMED</NAME>
#define MIDI_OPT_TIMED			0x0001
</MACRO>
<MACRO>
<NAME>MIDI_OPT_CONTINUATION</NAME>
#define MIDI_OPT_CONTINUATION		0x0002
</MACRO>
<MACRO>
<NAME>MIDI_OPT_USECTIME</NAME>
#define MIDI_OPT_USECTIME		0x0004	/* Time is absolute (in usecs) */
</MACRO>
<MACRO>
<NAME>MIDI_OPT_BUSY</NAME>
#define MIDI_OPT_BUSY			0x0008	/* Reserved for internal use */
</MACRO>
<MACRO>
<NAME>MIDI_PAYLOAD_SIZE</NAME>
#define MIDI_PAYLOAD_SIZE		1000
</MACRO>
<MACRO>
<NAME>SNDCTL_MIDI_TIMEBASE</NAME>
#define SNDCTL_MIDI_TIMEBASE		__SIOWR('m', 7, int)
</MACRO>
<MACRO>
<NAME>SNDCTL_MIDI_TEMPO</NAME>
#define SNDCTL_MIDI_TEMPO		__SIOWR('m', 8, int)
</MACRO>
<MACRO>
<NAME>SNDCTL_MIDI_SET_LATENCY</NAME>
#define SNDCTL_MIDI_SET_LATENCY		__SIOW ('m', 9, int)
</MACRO>
<MACRO>
<NAME>SNDCTL_DSP_HALT</NAME>
#define SNDCTL_DSP_HALT			__SIO  ('P', 0)
</MACRO>
<MACRO>
<NAME>SNDCTL_DSP_RESET</NAME>
#define SNDCTL_DSP_RESET		SNDCTL_DSP_HALT	/* Old name */
</MACRO>
<MACRO>
<NAME>SNDCTL_DSP_SYNC</NAME>
#define SNDCTL_DSP_SYNC			__SIO  ('P', 1)
</MACRO>
<MACRO>
<NAME>SNDCTL_DSP_SPEED</NAME>
#define SNDCTL_DSP_SPEED		__SIOWR('P', 2, int)
</MACRO>
<MACRO>
<NAME>SNDCTL_DSP_STEREO</NAME>
#define SNDCTL_DSP_STEREO		__SIOWR('P', 3, int)
</MACRO>
<MACRO>
<NAME>SNDCTL_DSP_GETBLKSIZE</NAME>
#define SNDCTL_DSP_GETBLKSIZE		__SIOWR('P', 4, int)
</MACRO>
<MACRO>
<NAME>SNDCTL_DSP_SAMPLESIZE</NAME>
#define SNDCTL_DSP_SAMPLESIZE		SNDCTL_DSP_SETFMT
</MACRO>
<MACRO>
<NAME>SNDCTL_DSP_CHANNELS</NAME>
#define SNDCTL_DSP_CHANNELS		__SIOWR('P', 6, int)
</MACRO>
<MACRO>
<NAME>SNDCTL_DSP_POST</NAME>
#define SNDCTL_DSP_POST			__SIO  ('P', 8)
</MACRO>
<MACRO>
<NAME>SNDCTL_DSP_SUBDIVIDE</NAME>
#define SNDCTL_DSP_SUBDIVIDE		__SIOWR('P', 9, int)
</MACRO>
<MACRO>
<NAME>SNDCTL_DSP_SETFRAGMENT</NAME>
#define SNDCTL_DSP_SETFRAGMENT		__SIOWR('P',10, int)
</MACRO>
<MACRO>
<NAME>SNDCTL_DSP_GETFMTS</NAME>
#define SNDCTL_DSP_GETFMTS		__SIOR ('P',11, int)	/* Returns a mask */
</MACRO>
<MACRO>
<NAME>SNDCTL_DSP_SETFMT</NAME>
#define SNDCTL_DSP_SETFMT		__SIOWR('P',5, int)	/* Selects ONE fmt */
</MACRO>
<MACRO>
<NAME>AFMT_QUERY</NAME>
#	define AFMT_QUERY	0x00000000	/* Return current fmt */
</MACRO>
<MACRO>
<NAME>AFMT_MU_LAW</NAME>
#	define AFMT_MU_LAW	0x00000001
</MACRO>
<MACRO>
<NAME>AFMT_A_LAW</NAME>
#	define AFMT_A_LAW	0x00000002
</MACRO>
<MACRO>
<NAME>AFMT_IMA_ADPCM</NAME>
#	define AFMT_IMA_ADPCM	0x00000004
</MACRO>
<MACRO>
<NAME>AFMT_U8</NAME>
#	define AFMT_U8		0x00000008
</MACRO>
<MACRO>
<NAME>AFMT_S16_LE</NAME>
#	define AFMT_S16_LE	0x00000010	/* Little endian signed 16 */
</MACRO>
<MACRO>
<NAME>AFMT_S16_BE</NAME>
#	define AFMT_S16_BE	0x00000020	/* Big endian signed 16 */
</MACRO>
<MACRO>
<NAME>AFMT_S8</NAME>
#	define AFMT_S8		0x00000040
</MACRO>
<MACRO>
<NAME>AFMT_U16_LE</NAME>
#	define AFMT_U16_LE	0x00000080	/* Little endian U16 */
</MACRO>
<MACRO>
<NAME>AFMT_U16_BE</NAME>
#	define AFMT_U16_BE	0x00000100	/* Big endian U16 */
</MACRO>
<MACRO>
<NAME>AFMT_MPEG</NAME>
#	define AFMT_MPEG	0x00000200	/* MPEG (2) audio */
</MACRO>
<MACRO>
<NAME>AFMT_AC3</NAME>
#	define AFMT_AC3		0x00000400
</MACRO>
<MACRO>
<NAME>AFMT_VORBIS</NAME>
#	define AFMT_VORBIS	0x00000800
</MACRO>
<MACRO>
<NAME>AFMT_S32_LE</NAME>
#	define AFMT_S32_LE	0x00001000
</MACRO>
<MACRO>
<NAME>AFMT_S32_BE</NAME>
#	define AFMT_S32_BE	0x00002000
</MACRO>
<MACRO>
<NAME>AFMT_FLOAT</NAME>
#	define AFMT_FLOAT	0x00004000
</MACRO>
<MACRO>
<NAME>AFMT_S24_LE</NAME>
#	define AFMT_S24_LE	0x00008000
</MACRO>
<MACRO>
<NAME>AFMT_S24_BE</NAME>
#	define AFMT_S24_BE	0x00010000
</MACRO>
<MACRO>
<NAME>AFMT_SPDIF_RAW</NAME>
#	define AFMT_SPDIF_RAW	0x00020000
</MACRO>
<MACRO>
<NAME>AFMT_S24_PACKED</NAME>
#	define AFMT_S24_PACKED	0x00040000
</MACRO>
<MACRO>
<NAME>AFMT_S16_NE</NAME>
#  define AFMT_S16_NE AFMT_S16_BE
</MACRO>
<MACRO>
<NAME>AFMT_U16_NE</NAME>
#  define AFMT_U16_NE AFMT_U16_BE
</MACRO>
<MACRO>
<NAME>AFMT_S32_NE</NAME>
#  define AFMT_S32_NE AFMT_S32_BE
</MACRO>
<MACRO>
<NAME>AFMT_S24_NE</NAME>
#  define AFMT_S24_NE AFMT_S24_BE
</MACRO>
<MACRO>
<NAME>AFMT_S16_OE</NAME>
#  define AFMT_S16_OE AFMT_S16_LE
</MACRO>
<MACRO>
<NAME>AFMT_S32_OE</NAME>
#  define AFMT_S32_OE AFMT_S32_LE
</MACRO>
<MACRO>
<NAME>AFMT_S24_OE</NAME>
#  define AFMT_S24_OE AFMT_S24_LE
</MACRO>
<MACRO>
<NAME>SNDCTL_DSP_GETOSPACE</NAME>
#define SNDCTL_DSP_GETOSPACE		__SIOR ('P',12, audio_buf_info)
</MACRO>
<MACRO>
<NAME>SNDCTL_DSP_GETISPACE</NAME>
#define SNDCTL_DSP_GETISPACE		__SIOR ('P',13, audio_buf_info)
</MACRO>
<MACRO>
<NAME>SNDCTL_DSP_GETCAPS</NAME>
#define SNDCTL_DSP_GETCAPS		__SIOR ('P',15, int)
</MACRO>
<MACRO>
<NAME>PCM_CAP_REVISION</NAME>
#	define PCM_CAP_REVISION		0x000000ff	/* Bits for revision level (0 to 255) */
</MACRO>
<MACRO>
<NAME>PCM_CAP_DUPLEX</NAME>
#	define PCM_CAP_DUPLEX		0x00000100	/* Full duplex record/playback */
</MACRO>
<MACRO>
<NAME>PCM_CAP_REALTIME</NAME>
#	define PCM_CAP_REALTIME		0x00000200	/* Not in use */
</MACRO>
<MACRO>
<NAME>PCM_CAP_BATCH</NAME>
#	define PCM_CAP_BATCH		0x00000400	/* Device has some kind of */
</MACRO>
<MACRO>
<NAME>PCM_CAP_COPROC</NAME>
#	define PCM_CAP_COPROC		0x00000800	/* Has a coprocessor */
</MACRO>
<MACRO>
<NAME>PCM_CAP_TRIGGER</NAME>
#	define PCM_CAP_TRIGGER		0x00001000	/* Supports SETTRIGGER */
</MACRO>
<MACRO>
<NAME>PCM_CAP_MMAP</NAME>
#	define PCM_CAP_MMAP		0x00002000	/* Supports mmap() */
</MACRO>
<MACRO>
<NAME>PCM_CAP_MULTI</NAME>
#	define PCM_CAP_MULTI		0x00004000	/* Supports multiple open */
</MACRO>
<MACRO>
<NAME>PCM_CAP_BIND</NAME>
#	define PCM_CAP_BIND		0x00008000	/* Supports binding to front/rear/center/lfe */
</MACRO>
<MACRO>
<NAME>PCM_CAP_INPUT</NAME>
#   	define PCM_CAP_INPUT		0x00010000	/* Supports recording */
</MACRO>
<MACRO>
<NAME>PCM_CAP_OUTPUT</NAME>
#   	define PCM_CAP_OUTPUT		0x00020000	/* Supports playback */
</MACRO>
<MACRO>
<NAME>PCM_CAP_VIRTUAL</NAME>
#	define PCM_CAP_VIRTUAL		0x00040000	/* Virtual device */
</MACRO>
<MACRO>
<NAME>PCM_CAP_ANALOGOUT</NAME>
#	define PCM_CAP_ANALOGOUT	0x00100000
</MACRO>
<MACRO>
<NAME>PCM_CAP_ANALOGIN</NAME>
#	define PCM_CAP_ANALOGIN		0x00200000
</MACRO>
<MACRO>
<NAME>PCM_CAP_DIGITALOUT</NAME>
#	define PCM_CAP_DIGITALOUT	0x00400000
</MACRO>
<MACRO>
<NAME>PCM_CAP_DIGITALIN</NAME>
#	define PCM_CAP_DIGITALIN	0x00800000
</MACRO>
<MACRO>
<NAME>PCM_CAP_ADMASK</NAME>
#	define PCM_CAP_ADMASK		0x00f00000
</MACRO>
<MACRO>
<NAME>PCM_CAP_SHADOW</NAME>
#	define PCM_CAP_SHADOW		0x01000000	/* "Shadow" device */
</MACRO>
<MACRO>
<NAME>DSP_CH_MASK</NAME>
#	define DSP_CH_MASK		0x06000000	/* Mask */
</MACRO>
<MACRO>
<NAME>DSP_CH_ANY</NAME>
#	define DSP_CH_ANY		0x00000000	/* No preferred mode */
</MACRO>
<MACRO>
<NAME>DSP_CH_MONO</NAME>
#	define DSP_CH_MONO		0x02000000
</MACRO>
<MACRO>
<NAME>DSP_CH_STEREO</NAME>
#	define DSP_CH_STEREO		0x04000000
</MACRO>
<MACRO>
<NAME>DSP_CH_MULTI</NAME>
#	define DSP_CH_MULTI		0x06000000	/* More than two channels */
</MACRO>
<MACRO>
<NAME>PCM_CAP_HIDDEN</NAME>
#	define PCM_CAP_HIDDEN		0x08000000	/* Hidden device */
</MACRO>
<MACRO>
<NAME>PCM_CAP_FREERATE</NAME>
#	define PCM_CAP_FREERATE		0x10000000
</MACRO>
<MACRO>
<NAME>PCM_CAP_MODEM</NAME>
#	define PCM_CAP_MODEM		0x20000000	/* Modem device */
</MACRO>
<MACRO>
<NAME>PCM_CAP_DEFAULT</NAME>
#	define PCM_CAP_DEFAULT		0x40000000	/* "Default" device */
</MACRO>
<MACRO>
<NAME>DSP_CAP_ADMASK</NAME>
#define DSP_CAP_ADMASK		PCM_CAP_ADMASK
</MACRO>
<MACRO>
<NAME>DSP_CAP_ANALOGIN</NAME>
#define DSP_CAP_ANALOGIN	PCM_CAP_ANALOGIN
</MACRO>
<MACRO>
<NAME>DSP_CAP_ANALOGOUT</NAME>
#define DSP_CAP_ANALOGOUT	PCM_CAP_ANALOGOUT
</MACRO>
<MACRO>
<NAME>DSP_CAP_BATCH</NAME>
#define DSP_CAP_BATCH		PCM_CAP_BATCH
</MACRO>
<MACRO>
<NAME>DSP_CAP_BIND</NAME>
#define DSP_CAP_BIND		PCM_CAP_BIND
</MACRO>
<MACRO>
<NAME>DSP_CAP_COPROC</NAME>
#define DSP_CAP_COPROC		PCM_CAP_COPROC
</MACRO>
<MACRO>
<NAME>DSP_CAP_DEFAULT</NAME>
#define DSP_CAP_DEFAULT		PCM_CAP_DEFAULT
</MACRO>
<MACRO>
<NAME>DSP_CAP_DIGITALIN</NAME>
#define DSP_CAP_DIGITALIN	PCM_CAP_DIGITALIN
</MACRO>
<MACRO>
<NAME>DSP_CAP_DIGITALOUT</NAME>
#define DSP_CAP_DIGITALOUT	PCM_CAP_DIGITALOUT
</MACRO>
<MACRO>
<NAME>DSP_CAP_DUPLEX</NAME>
#define DSP_CAP_DUPLEX		PCM_CAP_DUPLEX
</MACRO>
<MACRO>
<NAME>DSP_CAP_FREERATE</NAME>
#define DSP_CAP_FREERATE	PCM_CAP_FREERATE
</MACRO>
<MACRO>
<NAME>DSP_CAP_HIDDEN</NAME>
#define DSP_CAP_HIDDEN		PCM_CAP_HIDDEN
</MACRO>
<MACRO>
<NAME>DSP_CAP_INPUT</NAME>
#define DSP_CAP_INPUT		PCM_CAP_INPUT
</MACRO>
<MACRO>
<NAME>DSP_CAP_MMAP</NAME>
#define DSP_CAP_MMAP		PCM_CAP_MMAP
</MACRO>
<MACRO>
<NAME>DSP_CAP_MODEM</NAME>
#define DSP_CAP_MODEM		PCM_CAP_MODEM
</MACRO>
<MACRO>
<NAME>DSP_CAP_MULTI</NAME>
#define DSP_CAP_MULTI		PCM_CAP_MULTI
</MACRO>
<MACRO>
<NAME>DSP_CAP_OUTPUT</NAME>
#define DSP_CAP_OUTPUT		PCM_CAP_OUTPUT
</MACRO>
<MACRO>
<NAME>DSP_CAP_REALTIME</NAME>
#define DSP_CAP_REALTIME	PCM_CAP_REALTIME
</MACRO>
<MACRO>
<NAME>DSP_CAP_REVISION</NAME>
#define DSP_CAP_REVISION	PCM_CAP_REVISION
</MACRO>
<MACRO>
<NAME>DSP_CAP_SHADOW</NAME>
#define DSP_CAP_SHADOW		PCM_CAP_SHADOW
</MACRO>
<MACRO>
<NAME>DSP_CAP_TRIGGER</NAME>
#define DSP_CAP_TRIGGER		PCM_CAP_TRIGGER
</MACRO>
<MACRO>
<NAME>DSP_CAP_VIRTUAL</NAME>
#define DSP_CAP_VIRTUAL		PCM_CAP_VIRTUAL
</MACRO>
<MACRO>
<NAME>SNDCTL_DSP_GETTRIGGER</NAME>
#define SNDCTL_DSP_GETTRIGGER		__SIOR ('P',16, int)
</MACRO>
<MACRO>
<NAME>SNDCTL_DSP_SETTRIGGER</NAME>
#define SNDCTL_DSP_SETTRIGGER		__SIOW ('P',16, int)
</MACRO>
<MACRO>
<NAME>PCM_ENABLE_INPUT</NAME>
#	define PCM_ENABLE_INPUT		0x00000001
</MACRO>
<MACRO>
<NAME>PCM_ENABLE_OUTPUT</NAME>
#	define PCM_ENABLE_OUTPUT	0x00000002
</MACRO>
<MACRO>
<NAME>SNDCTL_DSP_GETIPTR</NAME>
#define SNDCTL_DSP_GETIPTR		__SIOR ('P',17, count_info)
</MACRO>
<MACRO>
<NAME>SNDCTL_DSP_GETOPTR</NAME>
#define SNDCTL_DSP_GETOPTR		__SIOR ('P',18, count_info)
</MACRO>
<MACRO>
<NAME>SNDCTL_DSP_SETSYNCRO</NAME>
#define SNDCTL_DSP_SETSYNCRO		__SIO  ('P', 21)
</MACRO>
<MACRO>
<NAME>SNDCTL_DSP_SETDUPLEX</NAME>
#define SNDCTL_DSP_SETDUPLEX		__SIO  ('P', 22)
</MACRO>
<MACRO>
<NAME>SNDCTL_DSP_PROFILE</NAME>
#define SNDCTL_DSP_PROFILE		__SIOW ('P', 23, int)	/* OBSOLETE */
</MACRO>
<MACRO>
<NAME>APF_NORMAL</NAME>
#define	  APF_NORMAL	0	/* Normal applications */
</MACRO>
<MACRO>
<NAME>APF_NETWORK</NAME>
#define	  APF_NETWORK	1	/* Underruns probably caused by an "external" delay */
</MACRO>
<MACRO>
<NAME>APF_CPUINTENS</NAME>
#define   APF_CPUINTENS 2	/* Underruns probably caused by "overheating" the CPU */
</MACRO>
<MACRO>
<NAME>SNDCTL_DSP_GETODELAY</NAME>
#define SNDCTL_DSP_GETODELAY		__SIOR ('P', 23, int)
</MACRO>
<MACRO>
<NAME>SNDCTL_DSP_GETPLAYVOL</NAME>
#define SNDCTL_DSP_GETPLAYVOL		__SIOR ('P', 24, int)
</MACRO>
<MACRO>
<NAME>SNDCTL_DSP_SETPLAYVOL</NAME>
#define SNDCTL_DSP_SETPLAYVOL		__SIOWR('P', 24, int)
</MACRO>
<MACRO>
<NAME>SNDCTL_DSP_GETERROR</NAME>
#define SNDCTL_DSP_GETERROR		__SIOR ('P', 25, audio_errinfo)
</MACRO>
<MACRO>
<NAME>DIG_CBITIN_NONE</NAME>
#define DIG_CBITIN_NONE			0x00000000
</MACRO>
<MACRO>
<NAME>DIG_CBITIN_LIMITED</NAME>
#define DIG_CBITIN_LIMITED		0x00000001
</MACRO>
<MACRO>
<NAME>DIG_CBITIN_DATA</NAME>
#define DIG_CBITIN_DATA 		0x00000002
</MACRO>
<MACRO>
<NAME>DIG_CBITIN_BYTE0</NAME>
#define DIG_CBITIN_BYTE0		0x00000004
</MACRO>
<MACRO>
<NAME>DIG_CBITIN_FULL</NAME>
#define DIG_CBITIN_FULL 		0x00000008
</MACRO>
<MACRO>
<NAME>DIG_CBITIN_MASK</NAME>
#define DIG_CBITIN_MASK 		0x0000000f
</MACRO>
<MACRO>
<NAME>DIG_CBITOUT_NONE</NAME>
#define DIG_CBITOUT_NONE		0x00000000
</MACRO>
<MACRO>
<NAME>DIG_CBITOUT_LIMITED</NAME>
#define DIG_CBITOUT_LIMITED		0x00000010
</MACRO>
<MACRO>
<NAME>DIG_CBITOUT_BYTE0</NAME>
#define DIG_CBITOUT_BYTE0		0x00000020
</MACRO>
<MACRO>
<NAME>DIG_CBITOUT_FULL</NAME>
#define DIG_CBITOUT_FULL 		0x00000040
</MACRO>
<MACRO>
<NAME>DIG_CBITOUT_DATA</NAME>
#define DIG_CBITOUT_DATA 		0x00000080
</MACRO>
<MACRO>
<NAME>DIG_CBITOUT_MASK</NAME>
#define DIG_CBITOUT_MASK 		0x000000f0
</MACRO>
<MACRO>
<NAME>DIG_UBITIN</NAME>
#define DIG_UBITIN			0x00000100
</MACRO>
<MACRO>
<NAME>DIG_UBITOUT</NAME>
#define DIG_UBITOUT			0x00000200
</MACRO>
<MACRO>
<NAME>DIG_VBITOUT</NAME>
#define DIG_VBITOUT			0x00000400
</MACRO>
<MACRO>
<NAME>DIG_OUTRATE</NAME>
#define DIG_OUTRATE			0x00000800
</MACRO>
<MACRO>
<NAME>DIG_INRATE</NAME>
#define DIG_INRATE			0x00001000
</MACRO>
<MACRO>
<NAME>DIG_INBITS</NAME>
#define DIG_INBITS			0x00002000
</MACRO>
<MACRO>
<NAME>DIG_OUTBITS</NAME>
#define DIG_OUTBITS			0x00004000
</MACRO>
<MACRO>
<NAME>DIG_EXACT</NAME>
#define DIG_EXACT			0x00010000
</MACRO>
<MACRO>
<NAME>DIG_PRO</NAME>
#define DIG_PRO				0x00020000
</MACRO>
<MACRO>
<NAME>DIG_CONSUMER</NAME>
#define DIG_CONSUMER			0x00040000
</MACRO>
<MACRO>
<NAME>DIG_PASSTHROUGH</NAME>
#define DIG_PASSTHROUGH			0x00080000
</MACRO>
<MACRO>
<NAME>DIG_OUTSEL</NAME>
#define DIG_OUTSEL			0x00100000
</MACRO>
<MACRO>
<NAME>VAL_CBITIN</NAME>
#define VAL_CBITIN			0x00000001
</MACRO>
<MACRO>
<NAME>VAL_UBITIN</NAME>
#define VAL_UBITIN			0x00000002
</MACRO>
<MACRO>
<NAME>VAL_CBITOUT</NAME>
#define VAL_CBITOUT			0x00000004
</MACRO>
<MACRO>
<NAME>VAL_UBITOUT</NAME>
#define VAL_UBITOUT			0x00000008
</MACRO>
<MACRO>
<NAME>VAL_ISTATUS</NAME>
#define VAL_ISTATUS			0x00000010
</MACRO>
<MACRO>
<NAME>VAL_IRATE</NAME>
#define VAL_IRATE			0x00000020
</MACRO>
<MACRO>
<NAME>VAL_ORATE</NAME>
#define VAL_ORATE			0x00000040
</MACRO>
<MACRO>
<NAME>VAL_INBITS</NAME>
#define VAL_INBITS			0x00000080
</MACRO>
<MACRO>
<NAME>VAL_OUTBITS</NAME>
#define VAL_OUTBITS			0x00000100
</MACRO>
<MACRO>
<NAME>VAL_REQUEST</NAME>
#define VAL_REQUEST			0x00000200
</MACRO>
<MACRO>
<NAME>VAL_OUTSEL</NAME>
#define VAL_OUTSEL			0x00000400
</MACRO>
<MACRO>
<NAME>VAL_OUTMASK</NAME>
#define VAL_OUTMASK (VAL_CBITOUT|VAL_UBITOUT|VAL_ORATE|VAL_OUTBITS|VAL_OUTSEL)
</MACRO>
<MACRO>
<NAME>SPD_RQ_PASSTHROUGH</NAME>
#define SPD_RQ_PASSTHROUGH				1
</MACRO>
<MACRO>
<NAME>OUTSEL_DIGITAL</NAME>
#define OUTSEL_DIGITAL		1
</MACRO>
<MACRO>
<NAME>OUTSEL_ANALOG</NAME>
#define OUTSEL_ANALOG		2
</MACRO>
<MACRO>
<NAME>OUTSEL_BOTH</NAME>
#define OUTSEL_BOTH		(OUTSEL_DIGITAL|OUTSEL_ANALOG)
</MACRO>
<MACRO>
<NAME>IND_UNKNOWN</NAME>
#define IND_UNKNOWN		0
</MACRO>
<MACRO>
<NAME>IND_AUDIO</NAME>
#define IND_AUDIO		1
</MACRO>
<MACRO>
<NAME>IND_DATA</NAME>
#define IND_DATA		2
</MACRO>
<MACRO>
<NAME>LOCK_NOT_INDICATED</NAME>
#define LOCK_NOT_INDICATED	0
</MACRO>
<MACRO>
<NAME>LOCK_UNLOCKED</NAME>
#define LOCK_UNLOCKED		1
</MACRO>
<MACRO>
<NAME>LOCK_LOCKED</NAME>
#define LOCK_LOCKED		2
</MACRO>
<MACRO>
<NAME>IN_QUAL_NOT_INDICATED</NAME>
#define IN_QUAL_NOT_INDICATED	0
</MACRO>
<MACRO>
<NAME>IN_QUAL_POOR</NAME>
#define IN_QUAL_POOR		1
</MACRO>
<MACRO>
<NAME>IN_QUAL_GOOD</NAME>
#define IN_QUAL_GOOD		2
</MACRO>
<MACRO>
<NAME>VBIT_NOT_INDICATED</NAME>
#define VBIT_NOT_INDICATED	0
</MACRO>
<MACRO>
<NAME>VBIT_OFF</NAME>
#define VBIT_OFF		1
</MACRO>
<MACRO>
<NAME>VBIT_ON</NAME>
#define VBIT_ON			2
</MACRO>
<MACRO>
<NAME>INERR_CRC</NAME>
#define INERR_CRC		0x0001
</MACRO>
<MACRO>
<NAME>INERR_QCODE_CRC</NAME>
#define INERR_QCODE_CRC		0x0002
</MACRO>
<MACRO>
<NAME>INERR_PARITY</NAME>
#define INERR_PARITY		0x0004
</MACRO>
<MACRO>
<NAME>INERR_BIPHASE</NAME>
#define INERR_BIPHASE		0x0008
</MACRO>
<MACRO>
<NAME>SNDCTL_DSP_READCTL</NAME>
#define SNDCTL_DSP_READCTL		__SIOWR('P', 26, oss_digital_control)
</MACRO>
<MACRO>
<NAME>SNDCTL_DSP_WRITECTL</NAME>
#define SNDCTL_DSP_WRITECTL		__SIOWR('P', 27, oss_digital_control)
</MACRO>
<MACRO>
<NAME>SNDCTL_DSP_SYNCGROUP</NAME>
#define SNDCTL_DSP_SYNCGROUP		__SIOWR('P', 28, oss_syncgroup)
</MACRO>
<MACRO>
<NAME>SNDCTL_DSP_SYNCSTART</NAME>
#define SNDCTL_DSP_SYNCSTART		__SIOW ('P', 29, int)
</MACRO>
<MACRO>
<NAME>SNDCTL_DSP_COOKEDMODE</NAME>
#define SNDCTL_DSP_COOKEDMODE		__SIOW ('P', 30, int)
</MACRO>
<MACRO>
<NAME>SNDCTL_DSP_SILENCE</NAME>
#define SNDCTL_DSP_SILENCE		__SIO  ('P', 31)
</MACRO>
<MACRO>
<NAME>SNDCTL_DSP_SKIP</NAME>
#define SNDCTL_DSP_SKIP			__SIO  ('P', 32)
</MACRO>
<MACRO>
<NAME>SNDCTL_DSP_HALT_INPUT</NAME>
#define SNDCTL_DSP_HALT_INPUT		__SIO  ('P', 33)
</MACRO>
<MACRO>
<NAME>SNDCTL_DSP_RESET_INPUT</NAME>
#define SNDCTL_DSP_RESET_INPUT	SNDCTL_DSP_HALT_INPUT	/* Old name */
</MACRO>
<MACRO>
<NAME>SNDCTL_DSP_HALT_OUTPUT</NAME>
#define SNDCTL_DSP_HALT_OUTPUT		__SIO  ('P', 34)
</MACRO>
<MACRO>
<NAME>SNDCTL_DSP_RESET_OUTPUT</NAME>
#define SNDCTL_DSP_RESET_OUTPUT	SNDCTL_DSP_HALT_OUTPUT	/* Old name */
</MACRO>
<MACRO>
<NAME>SNDCTL_DSP_LOW_WATER</NAME>
#define SNDCTL_DSP_LOW_WATER		__SIOW ('P', 34, int)
</MACRO>
<MACRO>
<NAME>SNDCTL_DSP_CURRENT_IPTR</NAME>
#define SNDCTL_DSP_CURRENT_IPTR		__SIOR ('P', 35, oss_count_t)
</MACRO>
<MACRO>
<NAME>SNDCTL_DSP_CURRENT_OPTR</NAME>
#define SNDCTL_DSP_CURRENT_OPTR		__SIOR ('P', 36, oss_count_t)
</MACRO>
<MACRO>
<NAME>SNDCTL_DSP_GET_RECSRC_NAMES</NAME>
#define SNDCTL_DSP_GET_RECSRC_NAMES	__SIOR ('P', 37, oss_mixer_enuminfo)
</MACRO>
<MACRO>
<NAME>SNDCTL_DSP_GET_RECSRC</NAME>
#define SNDCTL_DSP_GET_RECSRC		__SIOR ('P', 38, int)
</MACRO>
<MACRO>
<NAME>SNDCTL_DSP_SET_RECSRC</NAME>
#define SNDCTL_DSP_SET_RECSRC		__SIOWR('P', 38, int)
</MACRO>
<MACRO>
<NAME>SNDCTL_DSP_GET_PLAYTGT_NAMES</NAME>
#define SNDCTL_DSP_GET_PLAYTGT_NAMES	__SIOR ('P', 39, oss_mixer_enuminfo)
</MACRO>
<MACRO>
<NAME>SNDCTL_DSP_GET_PLAYTGT</NAME>
#define SNDCTL_DSP_GET_PLAYTGT		__SIOR ('P', 40, int)
</MACRO>
<MACRO>
<NAME>SNDCTL_DSP_SET_PLAYTGT</NAME>
#define SNDCTL_DSP_SET_PLAYTGT		__SIOWR('P', 40, int)
</MACRO>
<MACRO>
<NAME>SNDCTL_DSP_GETRECVOL</NAME>
#define SNDCTL_DSP_GETRECVOL		__SIOR ('P', 41, int)
</MACRO>
<MACRO>
<NAME>SNDCTL_DSP_SETRECVOL</NAME>
#define SNDCTL_DSP_SETRECVOL		__SIOWR('P', 41, int)
</MACRO>
<MACRO>
<NAME>SNDCTL_DSP_GET_CHNORDER</NAME>
#define SNDCTL_DSP_GET_CHNORDER		__SIOR ('P', 42, unsigned long long)
</MACRO>
<MACRO>
<NAME>SNDCTL_DSP_SET_CHNORDER</NAME>
#define SNDCTL_DSP_SET_CHNORDER		__SIOWR('P', 42, unsigned long long)
</MACRO>
<MACRO>
<NAME>CHID_UNDEF</NAME>
#	define CHID_UNDEF	0
</MACRO>
<MACRO>
<NAME>CHID_L</NAME>
#	define CHID_L		1
</MACRO>
<MACRO>
<NAME>CHID_R</NAME>
#	define CHID_R		2
</MACRO>
<MACRO>
<NAME>CHID_C</NAME>
#	define CHID_C		3
</MACRO>
<MACRO>
<NAME>CHID_LFE</NAME>
#	define CHID_LFE		4
</MACRO>
<MACRO>
<NAME>CHID_LS</NAME>
#	define CHID_LS		5
</MACRO>
<MACRO>
<NAME>CHID_RS</NAME>
#	define CHID_RS		6
</MACRO>
<MACRO>
<NAME>CHID_LR</NAME>
#	define CHID_LR		7
</MACRO>
<MACRO>
<NAME>CHID_RR</NAME>
#	define CHID_RR		8
</MACRO>
<MACRO>
<NAME>CHNORDER_UNDEF</NAME>
#define CHNORDER_UNDEF		0x0000000000000000ULL
</MACRO>
<MACRO>
<NAME>CHNORDER_NORMAL</NAME>
#define CHNORDER_NORMAL		0x0000000087654321ULL
</MACRO>
<MACRO>
<NAME>MAX_PEAK_CHANNELS</NAME>
#define MAX_PEAK_CHANNELS	128
</MACRO>
<TYPEDEF>
<NAME>oss_peaks_t</NAME>
typedef unsigned short oss_peaks_t[MAX_PEAK_CHANNELS];
</TYPEDEF>
<MACRO>
<NAME>SNDCTL_DSP_GETIPEAKS</NAME>
#define SNDCTL_DSP_GETIPEAKS		__SIOR('P', 43, oss_peaks_t)
</MACRO>
<MACRO>
<NAME>SNDCTL_DSP_GETOPEAKS</NAME>
#define SNDCTL_DSP_GETOPEAKS		__SIOR('P', 44, oss_peaks_t)
</MACRO>
<MACRO>
<NAME>SNDCTL_DSP_POLICY</NAME>
#define SNDCTL_DSP_POLICY		__SIOW('P', 45, int)	/* See the manual */
</MACRO>
<MACRO>
<NAME>SNDCTL_DSP_GETCHANNELMASK</NAME>
#define SNDCTL_DSP_GETCHANNELMASK	__SIOWR('P', 64, int)
</MACRO>
<MACRO>
<NAME>SNDCTL_DSP_BIND_CHANNEL</NAME>
#define SNDCTL_DSP_BIND_CHANNEL		__SIOWR('P', 65, int)
</MACRO>
<MACRO>
<NAME>DSP_BIND_QUERY</NAME>
#     define DSP_BIND_QUERY           0x00000000
</MACRO>
<MACRO>
<NAME>DSP_BIND_FRONT</NAME>
#     define DSP_BIND_FRONT           0x00000001
</MACRO>
<MACRO>
<NAME>DSP_BIND_SURR</NAME>
#     define DSP_BIND_SURR            0x00000002
</MACRO>
<MACRO>
<NAME>DSP_BIND_CENTER_LFE</NAME>
#     define DSP_BIND_CENTER_LFE      0x00000004
</MACRO>
<MACRO>
<NAME>DSP_BIND_HANDSET</NAME>
#     define DSP_BIND_HANDSET         0x00000008
</MACRO>
<MACRO>
<NAME>DSP_BIND_MIC</NAME>
#     define DSP_BIND_MIC             0x00000010
</MACRO>
<MACRO>
<NAME>DSP_BIND_MODEM1</NAME>
#     define DSP_BIND_MODEM1          0x00000020
</MACRO>
<MACRO>
<NAME>DSP_BIND_MODEM2</NAME>
#     define DSP_BIND_MODEM2          0x00000040
</MACRO>
<MACRO>
<NAME>DSP_BIND_I2S</NAME>
#     define DSP_BIND_I2S             0x00000080
</MACRO>
<MACRO>
<NAME>DSP_BIND_SPDIF</NAME>
#     define DSP_BIND_SPDIF           0x00000100
</MACRO>
<MACRO>
<NAME>DSP_BIND_REAR</NAME>
#     define DSP_BIND_REAR            0x00000200
</MACRO>
<MACRO>
<NAME>X_SADA_GET_PLAYTGT_MASK</NAME>
#define X_SADA_GET_PLAYTGT_MASK	__SIOR ('P', 66, int)
</MACRO>
<MACRO>
<NAME>X_SADA_GET_PLAYTGT</NAME>
#define X_SADA_GET_PLAYTGT	__SIOR ('P', 67, int)
</MACRO>
<MACRO>
<NAME>X_SADA_SET_PLAYTGT</NAME>
#define X_SADA_SET_PLAYTGT	__SIOWR('P', 68, int)
</MACRO>
<MACRO>
<NAME>SOUND_MIXER_NRDEVICES</NAME>
#define SOUND_MIXER_NRDEVICES	28
</MACRO>
<MACRO>
<NAME>SOUND_MIXER_VOLUME</NAME>
#define SOUND_MIXER_VOLUME	0
</MACRO>
<MACRO>
<NAME>SOUND_MIXER_BASS</NAME>
#define SOUND_MIXER_BASS	1
</MACRO>
<MACRO>
<NAME>SOUND_MIXER_TREBLE</NAME>
#define SOUND_MIXER_TREBLE	2
</MACRO>
<MACRO>
<NAME>SOUND_MIXER_SYNTH</NAME>
#define SOUND_MIXER_SYNTH	3
</MACRO>
<MACRO>
<NAME>SOUND_MIXER_PCM</NAME>
#define SOUND_MIXER_PCM		4
</MACRO>
<MACRO>
<NAME>SOUND_MIXER_SPEAKER</NAME>
#define SOUND_MIXER_SPEAKER	5
</MACRO>
<MACRO>
<NAME>SOUND_MIXER_LINE</NAME>
#define SOUND_MIXER_LINE	6
</MACRO>
<MACRO>
<NAME>SOUND_MIXER_MIC</NAME>
#define SOUND_MIXER_MIC		7
</MACRO>
<MACRO>
<NAME>SOUND_MIXER_CD</NAME>
#define SOUND_MIXER_CD		8
</MACRO>
<MACRO>
<NAME>SOUND_MIXER_IMIX</NAME>
#define SOUND_MIXER_IMIX	9	/*  Recording monitor  */
</MACRO>
<MACRO>
<NAME>SOUND_MIXER_ALTPCM</NAME>
#define SOUND_MIXER_ALTPCM	10
</MACRO>
<MACRO>
<NAME>SOUND_MIXER_RECLEV</NAME>
#define SOUND_MIXER_RECLEV	11	/* Recording level */
</MACRO>
<MACRO>
<NAME>SOUND_MIXER_IGAIN</NAME>
#define SOUND_MIXER_IGAIN	12	/* Input gain */
</MACRO>
<MACRO>
<NAME>SOUND_MIXER_OGAIN</NAME>
#define SOUND_MIXER_OGAIN	13	/* Output gain */
</MACRO>
<MACRO>
<NAME>SOUND_MIXER_LINE1</NAME>
#define SOUND_MIXER_LINE1	14	/* Input source 1  (aux1) */
</MACRO>
<MACRO>
<NAME>SOUND_MIXER_LINE2</NAME>
#define SOUND_MIXER_LINE2	15	/* Input source 2  (aux2) */
</MACRO>
<MACRO>
<NAME>SOUND_MIXER_LINE3</NAME>
#define SOUND_MIXER_LINE3	16	/* Input source 3  (line) */
</MACRO>
<MACRO>
<NAME>SOUND_MIXER_DIGITAL1</NAME>
#define SOUND_MIXER_DIGITAL1	17	/* Digital I/O 1 */
</MACRO>
<MACRO>
<NAME>SOUND_MIXER_DIGITAL2</NAME>
#define SOUND_MIXER_DIGITAL2	18	/* Digital I/O 2 */
</MACRO>
<MACRO>
<NAME>SOUND_MIXER_DIGITAL3</NAME>
#define SOUND_MIXER_DIGITAL3	19	/* Digital I/O 3 */
</MACRO>
<MACRO>
<NAME>SOUND_MIXER_PHONE</NAME>
#define SOUND_MIXER_PHONE	20	/* Phone */
</MACRO>
<MACRO>
<NAME>SOUND_MIXER_MONO</NAME>
#define SOUND_MIXER_MONO	21	/* Mono Output */
</MACRO>
<MACRO>
<NAME>SOUND_MIXER_VIDEO</NAME>
#define SOUND_MIXER_VIDEO	22	/* Video/TV (audio) in */
</MACRO>
<MACRO>
<NAME>SOUND_MIXER_RADIO</NAME>
#define SOUND_MIXER_RADIO	23	/* Radio in */
</MACRO>
<MACRO>
<NAME>SOUND_MIXER_DEPTH</NAME>
#define SOUND_MIXER_DEPTH	24	/* Surround depth */
</MACRO>
<MACRO>
<NAME>SOUND_MIXER_REARVOL</NAME>
#define SOUND_MIXER_REARVOL	25	/* Rear/Surround speaker vol */
</MACRO>
<MACRO>
<NAME>SOUND_MIXER_CENTERVOL</NAME>
#define SOUND_MIXER_CENTERVOL	26	/* Center/LFE speaker vol */
</MACRO>
<MACRO>
<NAME>SOUND_MIXER_SIDEVOL</NAME>
#define SOUND_MIXER_SIDEVOL	27	/* Side-Surround (8speaker) vol */
</MACRO>
<MACRO>
<NAME>SOUND_MIXER_SURRVOL</NAME>
#define SOUND_MIXER_SURRVOL	SOUND_MIXER_SIDEVOL
</MACRO>
<MACRO>
<NAME>SOUND_ONOFF_MIN</NAME>
#define SOUND_ONOFF_MIN		28
</MACRO>
<MACRO>
<NAME>SOUND_ONOFF_MAX</NAME>
#define SOUND_ONOFF_MAX		30
</MACRO>
<MACRO>
<NAME>SOUND_MIXER_NONE</NAME>
#define SOUND_MIXER_NONE	31
</MACRO>
<MACRO>
<NAME>SOUND_MIXER_ENHANCE</NAME>
#define SOUND_MIXER_ENHANCE	SOUND_MIXER_NONE
</MACRO>
<MACRO>
<NAME>SOUND_MIXER_MUTE</NAME>
#define SOUND_MIXER_MUTE	SOUND_MIXER_NONE
</MACRO>
<MACRO>
<NAME>SOUND_MIXER_LOUD</NAME>
#define SOUND_MIXER_LOUD	SOUND_MIXER_NONE
</MACRO>
<MACRO>
<NAME>SOUND_DEVICE_LABELS</NAME>
#define SOUND_DEVICE_LABELS \
	{"Vol  ", "Bass ", "Treble", "Synth", "Pcm  ", "Speaker ", "Line ", \
	 "Mic  ", "CD   ", "Mix  ", "Pcm2 ", "Rec  ", "IGain", "OGain", \
	 "Aux1", "Aux2", "Aux3", "Digital1", "Digital2", "Digital3", \
	 "Phone", "Mono", "Video", "Radio", "Depth", \
	 "Rear", "Center", "Side"}
</MACRO>
<MACRO>
<NAME>SOUND_DEVICE_NAMES</NAME>
#define SOUND_DEVICE_NAMES \
	{"vol", "bass", "treble", "synth", "pcm", "speaker", "line", \
	 "mic", "cd", "mix", "pcm2", "rec", "igain", "ogain", \
	 "aux1", "aux2", "aux3", "dig1", "dig2", "dig3", \
	 "phone", "mono", "video", "radio", "depth", \
	 "rear", "center", "side"}
</MACRO>
<MACRO>
<NAME>SOUND_MIXER_RECSRC</NAME>
#define SOUND_MIXER_RECSRC	0xff	/* Arg contains a bit for each recording source */
</MACRO>
<MACRO>
<NAME>SOUND_MIXER_DEVMASK</NAME>
#define SOUND_MIXER_DEVMASK	0xfe	/* Arg contains a bit for each supported device */
</MACRO>
<MACRO>
<NAME>SOUND_MIXER_RECMASK</NAME>
#define SOUND_MIXER_RECMASK	0xfd	/* Arg contains a bit for each supported recording source */
</MACRO>
<MACRO>
<NAME>SOUND_MIXER_CAPS</NAME>
#define SOUND_MIXER_CAPS	0xfc
</MACRO>
<MACRO>
<NAME>SOUND_CAP_EXCL_INPUT</NAME>
#	define SOUND_CAP_EXCL_INPUT	0x00000001	/* Only one recording source at a time */
</MACRO>
<MACRO>
<NAME>SOUND_CAP_NOLEGACY</NAME>
#	define SOUND_CAP_NOLEGACY	0x00000004	/* For internal use only */
</MACRO>
<MACRO>
<NAME>SOUND_CAP_NORECSRC</NAME>
#	define SOUND_CAP_NORECSRC	0x00000008
</MACRO>
<MACRO>
<NAME>SOUND_MIXER_STEREODEVS</NAME>
#define SOUND_MIXER_STEREODEVS	0xfb	/* Mixer channels supporting stereo */
</MACRO>
<MACRO>
<NAME>SOUND_MIXER_OUTSRC</NAME>
#define SOUND_MIXER_OUTSRC    0xfa	/* Arg contains a bit for each input source to output */
</MACRO>
<MACRO>
<NAME>SOUND_MIXER_OUTMASK</NAME>
#define SOUND_MIXER_OUTMASK   0xf9	/* Arg contains a bit for each supported input source to output */
</MACRO>
<MACRO>
<NAME>SOUND_MASK_VOLUME</NAME>
#define SOUND_MASK_VOLUME	(1 << SOUND_MIXER_VOLUME)
</MACRO>
<MACRO>
<NAME>SOUND_MASK_BASS</NAME>
#define SOUND_MASK_BASS		(1 << SOUND_MIXER_BASS)
</MACRO>
<MACRO>
<NAME>SOUND_MASK_TREBLE</NAME>
#define SOUND_MASK_TREBLE	(1 << SOUND_MIXER_TREBLE)
</MACRO>
<MACRO>
<NAME>SOUND_MASK_SYNTH</NAME>
#define SOUND_MASK_SYNTH	(1 << SOUND_MIXER_SYNTH)
</MACRO>
<MACRO>
<NAME>SOUND_MASK_PCM</NAME>
#define SOUND_MASK_PCM		(1 << SOUND_MIXER_PCM)
</MACRO>
<MACRO>
<NAME>SOUND_MASK_SPEAKER</NAME>
#define SOUND_MASK_SPEAKER	(1 << SOUND_MIXER_SPEAKER)
</MACRO>
<MACRO>
<NAME>SOUND_MASK_LINE</NAME>
#define SOUND_MASK_LINE		(1 << SOUND_MIXER_LINE)
</MACRO>
<MACRO>
<NAME>SOUND_MASK_MIC</NAME>
#define SOUND_MASK_MIC		(1 << SOUND_MIXER_MIC)
</MACRO>
<MACRO>
<NAME>SOUND_MASK_CD</NAME>
#define SOUND_MASK_CD		(1 << SOUND_MIXER_CD)
</MACRO>
<MACRO>
<NAME>SOUND_MASK_IMIX</NAME>
#define SOUND_MASK_IMIX		(1 << SOUND_MIXER_IMIX)
</MACRO>
<MACRO>
<NAME>SOUND_MASK_ALTPCM</NAME>
#define SOUND_MASK_ALTPCM	(1 << SOUND_MIXER_ALTPCM)
</MACRO>
<MACRO>
<NAME>SOUND_MASK_RECLEV</NAME>
#define SOUND_MASK_RECLEV	(1 << SOUND_MIXER_RECLEV)
</MACRO>
<MACRO>
<NAME>SOUND_MASK_IGAIN</NAME>
#define SOUND_MASK_IGAIN	(1 << SOUND_MIXER_IGAIN)
</MACRO>
<MACRO>
<NAME>SOUND_MASK_OGAIN</NAME>
#define SOUND_MASK_OGAIN	(1 << SOUND_MIXER_OGAIN)
</MACRO>
<MACRO>
<NAME>SOUND_MASK_LINE1</NAME>
#define SOUND_MASK_LINE1	(1 << SOUND_MIXER_LINE1)
</MACRO>
<MACRO>
<NAME>SOUND_MASK_LINE2</NAME>
#define SOUND_MASK_LINE2	(1 << SOUND_MIXER_LINE2)
</MACRO>
<MACRO>
<NAME>SOUND_MASK_LINE3</NAME>
#define SOUND_MASK_LINE3	(1 << SOUND_MIXER_LINE3)
</MACRO>
<MACRO>
<NAME>SOUND_MASK_DIGITAL1</NAME>
#define SOUND_MASK_DIGITAL1	(1 << SOUND_MIXER_DIGITAL1)
</MACRO>
<MACRO>
<NAME>SOUND_MASK_DIGITAL2</NAME>
#define SOUND_MASK_DIGITAL2	(1 << SOUND_MIXER_DIGITAL2)
</MACRO>
<MACRO>
<NAME>SOUND_MASK_DIGITAL3</NAME>
#define SOUND_MASK_DIGITAL3	(1 << SOUND_MIXER_DIGITAL3)
</MACRO>
<MACRO>
<NAME>SOUND_MASK_MONO</NAME>
#define SOUND_MASK_MONO		(1 << SOUND_MIXER_MONO)
</MACRO>
<MACRO>
<NAME>SOUND_MASK_PHONE</NAME>
#define SOUND_MASK_PHONE	(1 << SOUND_MIXER_PHONE)
</MACRO>
<MACRO>
<NAME>SOUND_MASK_RADIO</NAME>
#define SOUND_MASK_RADIO	(1 << SOUND_MIXER_RADIO)
</MACRO>
<MACRO>
<NAME>SOUND_MASK_VIDEO</NAME>
#define SOUND_MASK_VIDEO	(1 << SOUND_MIXER_VIDEO)
</MACRO>
<MACRO>
<NAME>SOUND_MASK_DEPTH</NAME>
#define SOUND_MASK_DEPTH	(1 << SOUND_MIXER_DEPTH)
</MACRO>
<MACRO>
<NAME>SOUND_MASK_REARVOL</NAME>
#define SOUND_MASK_REARVOL	(1 << SOUND_MIXER_REARVOL)
</MACRO>
<MACRO>
<NAME>SOUND_MASK_CENTERVOL</NAME>
#define SOUND_MASK_CENTERVOL	(1 << SOUND_MIXER_CENTERVOL)
</MACRO>
<MACRO>
<NAME>SOUND_MASK_SIDEVOL</NAME>
#define SOUND_MASK_SIDEVOL	(1 << SOUND_MIXER_SIDEVOL)
</MACRO>
<MACRO>
<NAME>SOUND_MASK_SURRVOL</NAME>
#define SOUND_MASK_SURRVOL	(1 << SOUND_MIXER_SIDEVOL)
</MACRO>
<MACRO>
<NAME>SOUND_MASK_MUTE</NAME>
#define SOUND_MASK_MUTE		(1 << SOUND_MIXER_MUTE)
</MACRO>
<MACRO>
<NAME>SOUND_MASK_ENHANCE</NAME>
#define SOUND_MASK_ENHANCE	(1 << SOUND_MIXER_ENHANCE)
</MACRO>
<MACRO>
<NAME>SOUND_MASK_LOUD</NAME>
#define SOUND_MASK_LOUD		(1 << SOUND_MIXER_LOUD)
</MACRO>
<MACRO>
<NAME>MIXER_READ</NAME>
#define MIXER_READ(dev)			__SIOR('M', dev, int)
</MACRO>
<MACRO>
<NAME>SOUND_MIXER_READ_VOLUME</NAME>
#define SOUND_MIXER_READ_VOLUME		MIXER_READ(SOUND_MIXER_VOLUME)
</MACRO>
<MACRO>
<NAME>SOUND_MIXER_READ_BASS</NAME>
#define SOUND_MIXER_READ_BASS		MIXER_READ(SOUND_MIXER_BASS)
</MACRO>
<MACRO>
<NAME>SOUND_MIXER_READ_TREBLE</NAME>
#define SOUND_MIXER_READ_TREBLE		MIXER_READ(SOUND_MIXER_TREBLE)
</MACRO>
<MACRO>
<NAME>SOUND_MIXER_READ_SYNTH</NAME>
#define SOUND_MIXER_READ_SYNTH		MIXER_READ(SOUND_MIXER_SYNTH)
</MACRO>
<MACRO>
<NAME>SOUND_MIXER_READ_PCM</NAME>
#define SOUND_MIXER_READ_PCM		MIXER_READ(SOUND_MIXER_PCM)
</MACRO>
<MACRO>
<NAME>SOUND_MIXER_READ_SPEAKER</NAME>
#define SOUND_MIXER_READ_SPEAKER	MIXER_READ(SOUND_MIXER_SPEAKER)
</MACRO>
<MACRO>
<NAME>SOUND_MIXER_READ_LINE</NAME>
#define SOUND_MIXER_READ_LINE		MIXER_READ(SOUND_MIXER_LINE)
</MACRO>
<MACRO>
<NAME>SOUND_MIXER_READ_MIC</NAME>
#define SOUND_MIXER_READ_MIC		MIXER_READ(SOUND_MIXER_MIC)
</MACRO>
<MACRO>
<NAME>SOUND_MIXER_READ_CD</NAME>
#define SOUND_MIXER_READ_CD		MIXER_READ(SOUND_MIXER_CD)
</MACRO>
<MACRO>
<NAME>SOUND_MIXER_READ_IMIX</NAME>
#define SOUND_MIXER_READ_IMIX		MIXER_READ(SOUND_MIXER_IMIX)
</MACRO>
<MACRO>
<NAME>SOUND_MIXER_READ_ALTPCM</NAME>
#define SOUND_MIXER_READ_ALTPCM		MIXER_READ(SOUND_MIXER_ALTPCM)
</MACRO>
<MACRO>
<NAME>SOUND_MIXER_READ_RECLEV</NAME>
#define SOUND_MIXER_READ_RECLEV		MIXER_READ(SOUND_MIXER_RECLEV)
</MACRO>
<MACRO>
<NAME>SOUND_MIXER_READ_IGAIN</NAME>
#define SOUND_MIXER_READ_IGAIN		MIXER_READ(SOUND_MIXER_IGAIN)
</MACRO>
<MACRO>
<NAME>SOUND_MIXER_READ_OGAIN</NAME>
#define SOUND_MIXER_READ_OGAIN		MIXER_READ(SOUND_MIXER_OGAIN)
</MACRO>
<MACRO>
<NAME>SOUND_MIXER_READ_LINE1</NAME>
#define SOUND_MIXER_READ_LINE1		MIXER_READ(SOUND_MIXER_LINE1)
</MACRO>
<MACRO>
<NAME>SOUND_MIXER_READ_LINE2</NAME>
#define SOUND_MIXER_READ_LINE2		MIXER_READ(SOUND_MIXER_LINE2)
</MACRO>
<MACRO>
<NAME>SOUND_MIXER_READ_LINE3</NAME>
#define SOUND_MIXER_READ_LINE3		MIXER_READ(SOUND_MIXER_LINE3)
</MACRO>
<MACRO>
<NAME>SOUND_MIXER_READ_MUTE</NAME>
#define SOUND_MIXER_READ_MUTE		MIXER_READ(SOUND_MIXER_MUTE)
</MACRO>
<MACRO>
<NAME>SOUND_MIXER_READ_ENHANCE</NAME>
#define SOUND_MIXER_READ_ENHANCE	MIXER_READ(SOUND_MIXER_ENHANCE)
</MACRO>
<MACRO>
<NAME>SOUND_MIXER_READ_LOUD</NAME>
#define SOUND_MIXER_READ_LOUD		MIXER_READ(SOUND_MIXER_LOUD)
</MACRO>
<MACRO>
<NAME>SOUND_MIXER_READ_RECSRC</NAME>
#define SOUND_MIXER_READ_RECSRC		MIXER_READ(SOUND_MIXER_RECSRC)
</MACRO>
<MACRO>
<NAME>SOUND_MIXER_READ_DEVMASK</NAME>
#define SOUND_MIXER_READ_DEVMASK	MIXER_READ(SOUND_MIXER_DEVMASK)
</MACRO>
<MACRO>
<NAME>SOUND_MIXER_READ_RECMASK</NAME>
#define SOUND_MIXER_READ_RECMASK	MIXER_READ(SOUND_MIXER_RECMASK)
</MACRO>
<MACRO>
<NAME>SOUND_MIXER_READ_STEREODEVS</NAME>
#define SOUND_MIXER_READ_STEREODEVS	MIXER_READ(SOUND_MIXER_STEREODEVS)
</MACRO>
<MACRO>
<NAME>SOUND_MIXER_READ_CAPS</NAME>
#define SOUND_MIXER_READ_CAPS		MIXER_READ(SOUND_MIXER_CAPS)
</MACRO>
<MACRO>
<NAME>MIXER_WRITE</NAME>
#define MIXER_WRITE(dev)		__SIOWR('M', dev, int)
</MACRO>
<MACRO>
<NAME>SOUND_MIXER_WRITE_VOLUME</NAME>
#define SOUND_MIXER_WRITE_VOLUME	MIXER_WRITE(SOUND_MIXER_VOLUME)
</MACRO>
<MACRO>
<NAME>SOUND_MIXER_WRITE_BASS</NAME>
#define SOUND_MIXER_WRITE_BASS		MIXER_WRITE(SOUND_MIXER_BASS)
</MACRO>
<MACRO>
<NAME>SOUND_MIXER_WRITE_TREBLE</NAME>
#define SOUND_MIXER_WRITE_TREBLE	MIXER_WRITE(SOUND_MIXER_TREBLE)
</MACRO>
<MACRO>
<NAME>SOUND_MIXER_WRITE_SYNTH</NAME>
#define SOUND_MIXER_WRITE_SYNTH		MIXER_WRITE(SOUND_MIXER_SYNTH)
</MACRO>
<MACRO>
<NAME>SOUND_MIXER_WRITE_PCM</NAME>
#define SOUND_MIXER_WRITE_PCM		MIXER_WRITE(SOUND_MIXER_PCM)
</MACRO>
<MACRO>
<NAME>SOUND_MIXER_WRITE_SPEAKER</NAME>
#define SOUND_MIXER_WRITE_SPEAKER	MIXER_WRITE(SOUND_MIXER_SPEAKER)
</MACRO>
<MACRO>
<NAME>SOUND_MIXER_WRITE_LINE</NAME>
#define SOUND_MIXER_WRITE_LINE		MIXER_WRITE(SOUND_MIXER_LINE)
</MACRO>
<MACRO>
<NAME>SOUND_MIXER_WRITE_MIC</NAME>
#define SOUND_MIXER_WRITE_MIC		MIXER_WRITE(SOUND_MIXER_MIC)
</MACRO>
<MACRO>
<NAME>SOUND_MIXER_WRITE_CD</NAME>
#define SOUND_MIXER_WRITE_CD		MIXER_WRITE(SOUND_MIXER_CD)
</MACRO>
<MACRO>
<NAME>SOUND_MIXER_WRITE_IMIX</NAME>
#define SOUND_MIXER_WRITE_IMIX		MIXER_WRITE(SOUND_MIXER_IMIX)
</MACRO>
<MACRO>
<NAME>SOUND_MIXER_WRITE_ALTPCM</NAME>
#define SOUND_MIXER_WRITE_ALTPCM	MIXER_WRITE(SOUND_MIXER_ALTPCM)
</MACRO>
<MACRO>
<NAME>SOUND_MIXER_WRITE_RECLEV</NAME>
#define SOUND_MIXER_WRITE_RECLEV	MIXER_WRITE(SOUND_MIXER_RECLEV)
</MACRO>
<MACRO>
<NAME>SOUND_MIXER_WRITE_IGAIN</NAME>
#define SOUND_MIXER_WRITE_IGAIN		MIXER_WRITE(SOUND_MIXER_IGAIN)
</MACRO>
<MACRO>
<NAME>SOUND_MIXER_WRITE_OGAIN</NAME>
#define SOUND_MIXER_WRITE_OGAIN		MIXER_WRITE(SOUND_MIXER_OGAIN)
</MACRO>
<MACRO>
<NAME>SOUND_MIXER_WRITE_LINE1</NAME>
#define SOUND_MIXER_WRITE_LINE1		MIXER_WRITE(SOUND_MIXER_LINE1)
</MACRO>
<MACRO>
<NAME>SOUND_MIXER_WRITE_LINE2</NAME>
#define SOUND_MIXER_WRITE_LINE2		MIXER_WRITE(SOUND_MIXER_LINE2)
</MACRO>
<MACRO>
<NAME>SOUND_MIXER_WRITE_LINE3</NAME>
#define SOUND_MIXER_WRITE_LINE3		MIXER_WRITE(SOUND_MIXER_LINE3)
</MACRO>
<MACRO>
<NAME>SOUND_MIXER_WRITE_MUTE</NAME>
#define SOUND_MIXER_WRITE_MUTE		MIXER_WRITE(SOUND_MIXER_MUTE)
</MACRO>
<MACRO>
<NAME>SOUND_MIXER_WRITE_ENHANCE</NAME>
#define SOUND_MIXER_WRITE_ENHANCE	MIXER_WRITE(SOUND_MIXER_ENHANCE)
</MACRO>
<MACRO>
<NAME>SOUND_MIXER_WRITE_LOUD</NAME>
#define SOUND_MIXER_WRITE_LOUD		MIXER_WRITE(SOUND_MIXER_LOUD)
</MACRO>
<MACRO>
<NAME>SOUND_MIXER_WRITE_RECSRC</NAME>
#define SOUND_MIXER_WRITE_RECSRC	MIXER_WRITE(SOUND_MIXER_RECSRC)
</MACRO>
<MACRO>
<NAME>SOUND_MIXER_INFO</NAME>
#define SOUND_MIXER_INFO		__SIOR ('M', 101, mixer_info)
</MACRO>
<MACRO>
<NAME>SOUND_MIXER_AGC</NAME>
#define SOUND_MIXER_AGC  _SIOWR('M', 103, int)
</MACRO>
<MACRO>
<NAME>SOUND_MIXER_3DSE</NAME>
#define SOUND_MIXER_3DSE  _SIOWR('M', 104, int)
</MACRO>
<MACRO>
<NAME>SOUND_MIXER_PRIVATE1</NAME>
#define SOUND_MIXER_PRIVATE1		__SIOWR('M', 111, int)
</MACRO>
<MACRO>
<NAME>SOUND_MIXER_PRIVATE2</NAME>
#define SOUND_MIXER_PRIVATE2		__SIOWR('M', 112, int)
</MACRO>
<MACRO>
<NAME>SOUND_MIXER_PRIVATE3</NAME>
#define SOUND_MIXER_PRIVATE3		__SIOWR('M', 113, int)
</MACRO>
<MACRO>
<NAME>SOUND_MIXER_PRIVATE4</NAME>
#define SOUND_MIXER_PRIVATE4		__SIOWR('M', 114, int)
</MACRO>
<MACRO>
<NAME>SOUND_MIXER_PRIVATE5</NAME>
#define SOUND_MIXER_PRIVATE5		__SIOWR('M', 115, int)
</MACRO>
<MACRO>
<NAME>SOUND_MIXER_READ_MAINVOL</NAME>
#define SOUND_MIXER_READ_MAINVOL		__SIOR ('M', 116, int)
</MACRO>
<MACRO>
<NAME>SOUND_MIXER_WRITE_MAINVOL</NAME>
#define SOUND_MIXER_WRITE_MAINVOL		__SIOWR('M', 116, int)
</MACRO>
<MACRO>
<NAME>SOUND_MIXER_GETLEVELS</NAME>
#define SOUND_MIXER_GETLEVELS		__SIOWR('M', 116, mixer_vol_table)
</MACRO>
<MACRO>
<NAME>SOUND_MIXER_SETLEVELS</NAME>
#define SOUND_MIXER_SETLEVELS		__SIOWR('M', 117, mixer_vol_table)
</MACRO>
<MACRO>
<NAME>OSS_GETVERSION</NAME>
#define OSS_GETVERSION			__SIOR ('M', 118, int)
</MACRO>
<MACRO>
<NAME>SOUND_MIXER_READ_RECGAIN</NAME>
#define SOUND_MIXER_READ_RECGAIN	__SIOR ('M', 119, int)
</MACRO>
<MACRO>
<NAME>SOUND_MIXER_WRITE_RECGAIN</NAME>
#define SOUND_MIXER_WRITE_RECGAIN	__SIOWR('M', 119, int)
</MACRO>
<MACRO>
<NAME>SOUND_MIXER_READ_MONGAIN</NAME>
#define SOUND_MIXER_READ_MONGAIN	__SIOR ('M', 120, int)
</MACRO>
<MACRO>
<NAME>SOUND_MIXER_WRITE_MONGAIN</NAME>
#define SOUND_MIXER_WRITE_MONGAIN	__SIOWR('M', 120, int)
</MACRO>
<TYPEDEF>
<NAME>oss_reserved_t</NAME>
typedef unsigned char oss_reserved_t[512];
</TYPEDEF>
<MACRO>
<NAME>SOUND_MIXER_RESERVED</NAME>
#define SOUND_MIXER_RESERVED		__SIOWR('M', 121, oss_reserved_t)
</MACRO>
<MACRO>
<NAME>MIXT_DEVROOT</NAME>
#	define MIXT_DEVROOT	 0	/* Device root entry */
</MACRO>
<MACRO>
<NAME>MIXT_GROUP</NAME>
#	define MIXT_GROUP	 1	/* Controller group */
</MACRO>
<MACRO>
<NAME>MIXT_ONOFF</NAME>
#	define MIXT_ONOFF	 2	/* OFF (0) or ON (1) */
</MACRO>
<MACRO>
<NAME>MIXT_ENUM</NAME>
#	define MIXT_ENUM	 3	/* Enumerated (0 to maxvalue) */
</MACRO>
<MACRO>
<NAME>MIXT_MONOSLIDER</NAME>
#	define MIXT_MONOSLIDER	 4	/* Mono slider (0 to 255) */
</MACRO>
<MACRO>
<NAME>MIXT_STEREOSLIDER</NAME>
#	define MIXT_STEREOSLIDER 5	/* Stereo slider (dual 0 to 255) */
</MACRO>
<MACRO>
<NAME>MIXT_MESSAGE</NAME>
#	define MIXT_MESSAGE	 6	/* (Readable) textual message */
</MACRO>
<MACRO>
<NAME>MIXT_MONOVU</NAME>
#	define MIXT_MONOVU	 7	/* VU meter value (mono) */
</MACRO>
<MACRO>
<NAME>MIXT_STEREOVU</NAME>
#	define MIXT_STEREOVU	 8	/* VU meter value (stereo) */
</MACRO>
<MACRO>
<NAME>MIXT_MONOPEAK</NAME>
#	define MIXT_MONOPEAK	 9	/* VU meter peak value (mono) */
</MACRO>
<MACRO>
<NAME>MIXT_STEREOPEAK</NAME>
#	define MIXT_STEREOPEAK	10	/* VU meter peak value (stereo) */
</MACRO>
<MACRO>
<NAME>MIXT_RADIOGROUP</NAME>
#	define MIXT_RADIOGROUP	11	/* Radio button group */
</MACRO>
<MACRO>
<NAME>MIXT_MARKER</NAME>
#	define MIXT_MARKER	12	/* Separator between normal and extension entries */
</MACRO>
<MACRO>
<NAME>MIXT_VALUE</NAME>
#	define MIXT_VALUE	13	/* Decimal value entry */
</MACRO>
<MACRO>
<NAME>MIXT_HEXVALUE</NAME>
#	define MIXT_HEXVALUE	14	/* Hexadecimal value entry */
</MACRO>
<MACRO>
<NAME>MIXT_MONODB</NAME>
#	define MIXT_MONODB	15	/* OBSOLETE */
</MACRO>
<MACRO>
<NAME>MIXT_STEREODB</NAME>
#	define MIXT_STEREODB	16	/* OBSOLETE */
</MACRO>
<MACRO>
<NAME>MIXT_SLIDER</NAME>
#	define MIXT_SLIDER	17	/* Slider (mono) with full (31 bit) postitive integer range */
</MACRO>
<MACRO>
<NAME>MIXT_3D</NAME>
#	define MIXT_3D		18
</MACRO>
<MACRO>
<NAME>MIXT_MONOSLIDER16</NAME>
#	define MIXT_MONOSLIDER16	19
</MACRO>
<MACRO>
<NAME>MIXT_STEREOSLIDER16</NAME>
#	define MIXT_STEREOSLIDER16	20
</MACRO>
<MACRO>
<NAME>MIXT_MUTE</NAME>
#	define MIXT_MUTE	21	/* Mute=1, unmute=0 */
</MACRO>
<MACRO>
<NAME>MIXF_READABLE</NAME>
#	define MIXF_READABLE	0x00000001	/* Has readable value */
</MACRO>
<MACRO>
<NAME>MIXF_WRITEABLE</NAME>
#	define MIXF_WRITEABLE	0x00000002	/* Has writeable value */
</MACRO>
<MACRO>
<NAME>MIXF_POLL</NAME>
#	define MIXF_POLL	0x00000004	/* May change itself */
</MACRO>
<MACRO>
<NAME>MIXF_HZ</NAME>
#	define MIXF_HZ		0x00000008	/* Herz scale */
</MACRO>
<MACRO>
<NAME>MIXF_STRING</NAME>
#	define MIXF_STRING	0x00000010	/* Use dynamic extensions for value */
</MACRO>
<MACRO>
<NAME>MIXF_DYNAMIC</NAME>
#	define MIXF_DYNAMIC	0x00000010	/* Supports dynamic extensions */
</MACRO>
<MACRO>
<NAME>MIXF_OKFAIL</NAME>
#	define MIXF_OKFAIL	0x00000020	/* Interpret value as 1=OK, 0=FAIL */
</MACRO>
<MACRO>
<NAME>MIXF_FLAT</NAME>
#	define MIXF_FLAT	0x00000040	/* Flat vertical space requirements */
</MACRO>
<MACRO>
<NAME>MIXF_LEGACY</NAME>
#	define MIXF_LEGACY	0x00000080	/* Legacy mixer control group */
</MACRO>
<MACRO>
<NAME>MIXF_CENTIBEL</NAME>
#	define MIXF_CENTIBEL	0x00000100	/* Centibel (0.1 dB) step size */
</MACRO>
<MACRO>
<NAME>MIXF_DECIBEL</NAME>
#	define MIXF_DECIBEL	0x00000200	/* Step size of 1 dB */
</MACRO>
<MACRO>
<NAME>MIXF_MAINVOL</NAME>
#	define MIXF_MAINVOL	0x00000400	/* Main volume control */
</MACRO>
<MACRO>
<NAME>MIXF_PCMVOL</NAME>
#	define MIXF_PCMVOL	0x00000800	/* PCM output volume control */
</MACRO>
<MACRO>
<NAME>MIXF_RECVOL</NAME>
#	define MIXF_RECVOL	0x00001000	/* PCM recording volume control */
</MACRO>
<MACRO>
<NAME>MIXF_MONVOL</NAME>
#	define MIXF_MONVOL	0x00002000	/* Input->output monitor volume */
</MACRO>
<MACRO>
<NAME>MIXF_WIDE</NAME>
#	define MIXF_WIDE	0x00004000	/* Enum control has wide labels */
</MACRO>
<MACRO>
<NAME>MIXF_DESCR</NAME>
#	define MIXF_DESCR	0x00008000	/* Description (tooltip) available */
</MACRO>
<MACRO>
<NAME>MIXEXT_SCOPE_MASK</NAME>
#define MIXEXT_SCOPE_MASK			0x0000003f
</MACRO>
<MACRO>
<NAME>MIXEXT_SCOPE_OTHER</NAME>
#define MIXEXT_SCOPE_OTHER			0x00000000
</MACRO>
<MACRO>
<NAME>MIXEXT_SCOPE_INPUT</NAME>
#define MIXEXT_SCOPE_INPUT			0x00000001
</MACRO>
<MACRO>
<NAME>MIXEXT_SCOPE_OUTPUT</NAME>
#define MIXEXT_SCOPE_OUTPUT			0x00000002
</MACRO>
<MACRO>
<NAME>MIXEXT_SCOPE_MONITOR</NAME>
#define MIXEXT_SCOPE_MONITOR			0x00000003
</MACRO>
<MACRO>
<NAME>MIXEXT_SCOPE_RECSWITCH</NAME>
#define MIXEXT_SCOPE_RECSWITCH			0x00000004
</MACRO>
<MACRO>
<NAME>OSS_RGB_BLUE</NAME>
#define OSS_RGB_BLUE	0x7aabde		// Light blue
</MACRO>
<MACRO>
<NAME>OSS_RGB_GREEN</NAME>
#define OSS_RGB_GREEN	0xb3c98c		// Lime green
</MACRO>
<MACRO>
<NAME>OSS_RGB_PINK</NAME>
#define OSS_RGB_PINK	0xe88c99
</MACRO>
<MACRO>
<NAME>OSS_RGB_GRAY</NAME>
#define OSS_RGB_GRAY	0xd1ccc4
</MACRO>
<MACRO>
<NAME>OSS_RGB_BLACK</NAME>
#define OSS_RGB_BLACK	0x2b2926		// Light black
</MACRO>
<MACRO>
<NAME>OSS_RGB_ORANGE</NAME>
#define OSS_RGB_ORANGE	0xe89e47
</MACRO>
<MACRO>
<NAME>OSS_RGB_RED</NAME>
#define OSS_RGB_RED	0xff0000
</MACRO>
<MACRO>
<NAME>OSS_RGB_YELLOW</NAME>
#define OSS_RGB_YELLOW	0xffff00
</MACRO>
<MACRO>
<NAME>OSS_RGB_PURPLE</NAME>
#define OSS_RGB_PURPLE	0x800080
</MACRO>
<MACRO>
<NAME>OSS_RGB_WHITE</NAME>
#define OSS_RGB_WHITE	0xf8f8ff
</MACRO>
<MACRO>
<NAME>OSS_ENUM_MAXVALUE</NAME>
#define OSS_ENUM_MAXVALUE	255
</MACRO>
<MACRO>
<NAME>OSS_ENUM_STRINGSIZE</NAME>
#define OSS_ENUM_STRINGSIZE	3000
</MACRO>
<MACRO>
<NAME>OPEN_READ</NAME>
#define OPEN_READ	PCM_ENABLE_INPUT
</MACRO>
<MACRO>
<NAME>OPEN_WRITE</NAME>
#define OPEN_WRITE	PCM_ENABLE_OUTPUT
</MACRO>
<MACRO>
<NAME>OPEN_READWRITE</NAME>
#define OPEN_READWRITE	(OPEN_READ|OPEN_WRITE)
</MACRO>
<MACRO>
<NAME>OSS_MAX_SAMPLE_RATES</NAME>
#define OSS_MAX_SAMPLE_RATES	20	/* Cannot be changed  */
</MACRO>
<MACRO>
<NAME>MIXER_CAP_VIRTUAL</NAME>
#define MIXER_CAP_VIRTUAL	0x00000001
</MACRO>
<MACRO>
<NAME>MIXER_CAP_LAYOUT_B</NAME>
#define MIXER_CAP_LAYOUT_B	0x00000002	/* For internal use only */
</MACRO>
<MACRO>
<NAME>MIXER_CAP_NARROW</NAME>
#define MIXER_CAP_NARROW	0x00000004	/* Conserve horiz space */
</MACRO>
<MACRO>
<NAME>MIDI_CAP_MPU401</NAME>
#define MIDI_CAP_MPU401		0x00000001	/**** OBSOLETE ****/
</MACRO>
<MACRO>
<NAME>MIDI_CAP_INPUT</NAME>
#define MIDI_CAP_INPUT		0x00000002
</MACRO>
<MACRO>
<NAME>MIDI_CAP_OUTPUT</NAME>
#define MIDI_CAP_OUTPUT		0x00000004
</MACRO>
<MACRO>
<NAME>MIDI_CAP_INOUT</NAME>
#define MIDI_CAP_INOUT		(MIDI_CAP_INPUT|MIDI_CAP_OUTPUT)
</MACRO>
<MACRO>
<NAME>MIDI_CAP_VIRTUAL</NAME>
#define MIDI_CAP_VIRTUAL	0x00000008	/* Pseudo device */
</MACRO>
<MACRO>
<NAME>MIDI_CAP_MTCINPUT</NAME>
#define MIDI_CAP_MTCINPUT	0x00000010	/* Supports SNDCTL_MIDI_MTCINPUT */
</MACRO>
<MACRO>
<NAME>MIDI_CAP_CLIENT</NAME>
#define MIDI_CAP_CLIENT		0x00000020	/* Virtual client side device */
</MACRO>
<MACRO>
<NAME>MIDI_CAP_SERVER</NAME>
#define MIDI_CAP_SERVER		0x00000040	/* Virtual server side device */
</MACRO>
<MACRO>
<NAME>MIDI_CAP_INTERNAL</NAME>
#define MIDI_CAP_INTERNAL	0x00000080	/* Internal (synth) device */
</MACRO>
<MACRO>
<NAME>MIDI_CAP_EXTERNAL</NAME>
#define MIDI_CAP_EXTERNAL	0x00000100	/* external (MIDI port) device */
</MACRO>
<MACRO>
<NAME>MIDI_CAP_PTOP</NAME>
#define MIDI_CAP_PTOP		0x00000200	/* Point to point link to one device */
</MACRO>
<MACRO>
<NAME>MIDI_CAP_MTC</NAME>
#define MIDI_CAP_MTC		0x00000400	/* MTC/SMPTE (control) device */
</MACRO>
<MACRO>
<NAME>SNDCTL_SYSINFO</NAME>
#define SNDCTL_SYSINFO		__SIOR ('X', 1, oss_sysinfo)
</MACRO>
<MACRO>
<NAME>OSS_SYSINFO</NAME>
#define OSS_SYSINFO		SNDCTL_SYSINFO	/* Old name */
</MACRO>
<MACRO>
<NAME>SNDCTL_MIX_NRMIX</NAME>
#define SNDCTL_MIX_NRMIX	__SIOR ('X', 2, int)
</MACRO>
<MACRO>
<NAME>SNDCTL_MIX_NREXT</NAME>
#define SNDCTL_MIX_NREXT	__SIOWR('X', 3, int)
</MACRO>
<MACRO>
<NAME>SNDCTL_MIX_EXTINFO</NAME>
#define SNDCTL_MIX_EXTINFO	__SIOWR('X', 4, oss_mixext)
</MACRO>
<MACRO>
<NAME>SNDCTL_MIX_READ</NAME>
#define SNDCTL_MIX_READ		__SIOWR('X', 5, oss_mixer_value)
</MACRO>
<MACRO>
<NAME>SNDCTL_MIX_WRITE</NAME>
#define SNDCTL_MIX_WRITE	__SIOWR('X', 6, oss_mixer_value)
</MACRO>
<MACRO>
<NAME>SNDCTL_AUDIOINFO</NAME>
#define SNDCTL_AUDIOINFO	__SIOWR('X', 7, oss_audioinfo)
</MACRO>
<MACRO>
<NAME>SNDCTL_MIX_ENUMINFO</NAME>
#define SNDCTL_MIX_ENUMINFO	__SIOWR('X', 8, oss_mixer_enuminfo)
</MACRO>
<MACRO>
<NAME>SNDCTL_MIDIINFO</NAME>
#define SNDCTL_MIDIINFO		__SIOWR('X', 9, oss_midi_info)
</MACRO>
<MACRO>
<NAME>SNDCTL_MIXERINFO</NAME>
#define SNDCTL_MIXERINFO	__SIOWR('X',10, oss_mixerinfo)
</MACRO>
<MACRO>
<NAME>SNDCTL_CARDINFO</NAME>
#define SNDCTL_CARDINFO		__SIOWR('X',11, oss_card_info)
</MACRO>
<MACRO>
<NAME>SNDCTL_ENGINEINFO</NAME>
#define SNDCTL_ENGINEINFO	__SIOWR('X',12, oss_audioinfo)
</MACRO>
<MACRO>
<NAME>SNDCTL_AUDIOINFO_EX</NAME>
#define SNDCTL_AUDIOINFO_EX	__SIOWR('X',13, oss_audioinfo)
</MACRO>
<MACRO>
<NAME>SNDCTL_MIX_DESCRIPTION</NAME>
#define SNDCTL_MIX_DESCRIPTION	__SIOWR('X',14, oss_mixer_enuminfo)
</MACRO>
<MACRO>
<NAME>SNDCTL_SETSONG</NAME>
#define SNDCTL_SETSONG		__SIOW ('Y', 2, oss_longname_t)
</MACRO>
<MACRO>
<NAME>SNDCTL_GETSONG</NAME>
#define SNDCTL_GETSONG		__SIOR ('Y', 2, oss_longname_t)
</MACRO>
<MACRO>
<NAME>SNDCTL_SETNAME</NAME>
#define SNDCTL_SETNAME		__SIOW ('Y', 3, oss_longname_t)
</MACRO>
<MACRO>
<NAME>SNDCTL_SETLABEL</NAME>
#define SNDCTL_SETLABEL		__SIOW ('Y', 4, oss_label_t)
</MACRO>
<MACRO>
<NAME>SNDCTL_GETLABEL</NAME>
#define SNDCTL_GETLABEL		__SIOR ('Y', 4, oss_label_t)
</MACRO>
<FUNCTION>
<NAME>osslib_open</NAME>
<RETURNS>int  </RETURNS>
const char *path, int flags, int dummy
</FUNCTION>
<FUNCTION>
<NAME>osslib_close</NAME>
<RETURNS>void  </RETURNS>
int fd
</FUNCTION>
<FUNCTION>
<NAME>osslib_write</NAME>
<RETURNS>int  </RETURNS>
int fd, const void *buf, int count
</FUNCTION>
<FUNCTION>
<NAME>osslib_read</NAME>
<RETURNS>int  </RETURNS>
int fd, void *buf, int count
</FUNCTION>
<FUNCTION>
<NAME>osslib_ioctl</NAME>
<RETURNS>int  </RETURNS>
int fd, unsigned int request, void *arg
</FUNCTION>
<MACRO>
<NAME>SNDCTL_DSP_NONBLOCK</NAME>
#define SNDCTL_DSP_NONBLOCK		__SIO  ('P',14)	/* Obsolete. Not supported any more */
</MACRO>
<MACRO>
<NAME>SOUND_PCM_READ_RATE</NAME>
#define SOUND_PCM_READ_RATE             SOUND_PCM_READ_RATE_is_obsolete
</MACRO>
<MACRO>
<NAME>SOUND_PCM_READ_BITS</NAME>
#define SOUND_PCM_READ_BITS             SOUND_PCM_READ_BITS_is_obsolete
</MACRO>
<MACRO>
<NAME>SOUND_PCM_READ_CHANNELS</NAME>
#define SOUND_PCM_READ_CHANNELS         SOUND_PCM_READ_CHANNELS_is_obsolete
</MACRO>
<MACRO>
<NAME>SOUND_PCM_WRITE_RATE</NAME>
#define SOUND_PCM_WRITE_RATE            SOUND_PCM_WRITE_RATE_is_obsolet_use_SNDCTL_DSP_SPEED_instead
</MACRO>
<MACRO>
<NAME>SOUND_PCM_WRITE_CHANNELS</NAME>
#define SOUND_PCM_WRITE_CHANNELS        SOUND_PCM_WRITE_CHANNELS_is_obsolete_use_SNDCTL_DSP_CHANNELS_instead
</MACRO>
<MACRO>
<NAME>SOUND_PCM_WRITE_BITS</NAME>
#define SOUND_PCM_WRITE_BITS            SOUND_PCM_WRITE_BITS_is_obsolete_use_SNDCTL_DSP_SETFMT_instead
</MACRO>
<MACRO>
<NAME>SOUND_PCM_POST</NAME>
#define SOUND_PCM_POST                  SOUND_PCM_POST_is_obsolete_use_SNDCTL_DSP_POST_instead
</MACRO>
<MACRO>
<NAME>SOUND_PCM_RESET</NAME>
#define SOUND_PCM_RESET                 SOUND_PCM_RESET_is_obsolete_use_SNDCTL_DSP_HALT_instead
</MACRO>
<MACRO>
<NAME>SOUND_PCM_SYNC</NAME>
#define SOUND_PCM_SYNC                  SOUND_PCM_SYNC_is_obsolete_use_SNDCTL_DSP_SYNC_instead
</MACRO>
<MACRO>
<NAME>SOUND_PCM_SUBDIVIDE</NAME>
#define SOUND_PCM_SUBDIVIDE             SOUND_PCM_SUBDIVIDE_is_obsolete_use_SNDCTL_DSP_SUBDIVIDE_instead
</MACRO>
<MACRO>
<NAME>SOUND_PCM_SETFRAGMENT</NAME>
#define SOUND_PCM_SETFRAGMENT           SOUND_PCM_SETFRAGMENT_is_obsolete_use_SNDCTL_DSP_SETFRAGMENT_instead
</MACRO>
<MACRO>
<NAME>SOUND_PCM_GETFMTS</NAME>
#define SOUND_PCM_GETFMTS               SOUND_PCM_GETFMTS_is_obsolete_use_SNDCTL_DSP_GETFMTS_instead
</MACRO>
<MACRO>
<NAME>SOUND_PCM_SETFMT</NAME>
#define SOUND_PCM_SETFMT                SOUND_PCM_SETFMT_is_obsolete_use_SNDCTL_DSP_SETFMT_instead
</MACRO>
<MACRO>
<NAME>SOUND_PCM_GETOSPACE</NAME>
#define SOUND_PCM_GETOSPACE             SOUND_PCM_GETOSPACE_is_obsolete_use_SNDCTL_DSP_GETOSPACE_instead
</MACRO>
<MACRO>
<NAME>SOUND_PCM_GETISPACE</NAME>
#define SOUND_PCM_GETISPACE             SOUND_PCM_GETISPACE_is_obsolete_use_SNDCTL_DSP_GETISPACE_instead
</MACRO>
<MACRO>
<NAME>SOUND_PCM_NONBLOCK</NAME>
#define SOUND_PCM_NONBLOCK              SOUND_PCM_NONBLOCK_is_obsolete_use_SNDCTL_DSP_NONBLOCK_instead
</MACRO>
<MACRO>
<NAME>SOUND_PCM_GETCAPS</NAME>
#define SOUND_PCM_GETCAPS               SOUND_PCM_GETCAPS_is_obsolete_use_SNDCTL_DSP_GETCAPS_instead
</MACRO>
<MACRO>
<NAME>SOUND_PCM_GETTRIGGER</NAME>
#define SOUND_PCM_GETTRIGGER            SOUND_PCM_GETTRIGGER_is_obsolete_use_SNDCTL_DSP_GETTRIGGER_instead
</MACRO>
<MACRO>
<NAME>SOUND_PCM_SETTRIGGER</NAME>
#define SOUND_PCM_SETTRIGGER            SOUND_PCM_SETTRIGGER_is_obsolete_use_SNDCTL_DSP_SETTRIGGER_instead
</MACRO>
<MACRO>
<NAME>SOUND_PCM_SETSYNCRO</NAME>
#define SOUND_PCM_SETSYNCRO             SOUND_PCM_SETSYNCRO_is_obsolete_use_SNDCTL_DSP_SETSYNCRO_instead
</MACRO>
<MACRO>
<NAME>SOUND_PCM_GETIPTR</NAME>
#define SOUND_PCM_GETIPTR               SOUND_PCM_GETIPTR_is_obsolete_use_SNDCTL_DSP_GETIPTR_instead
</MACRO>
<MACRO>
<NAME>SOUND_PCM_GETOPTR</NAME>
#define SOUND_PCM_GETOPTR               SOUND_PCM_GETOPTR_is_obsolete_use_SNDCTL_DSP_GETOPTR_instead
</MACRO>
<MACRO>
<NAME>SOUND_PCM_MAPINBUF</NAME>
#define SOUND_PCM_MAPINBUF              SOUND_PCM_MAPINBUF_is_obsolete_use_SNDCTL_DSP_MAPINBUF_instead
</MACRO>
<MACRO>
<NAME>SOUND_PCM_MAPOUTBUF</NAME>
#define SOUND_PCM_MAPOUTBUF             SOUND_PCM_MAPOUTBUF_is_obsolete_use_SNDCTL_DSP_MAPOUTBUF_instead
</MACRO>
